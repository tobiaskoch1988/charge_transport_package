#!/usr/bin/python
# @author Jim Bachmann
# this script gets all the resid's within a cutoff radius around each molecule
# using a .gro file and a .xyz file generated by COM_per_mol 

import os,sys,numpy as np, re

if 1==1:																									#check the input
	SCRIPT=sys.argv[0].split('/')
	NARGS=len(sys.argv)-1
	THELP=['-h','-help']

	if NARGS<3 or (NARGS>0 and sys.argv[1] in THELP):
		print""
		print"parameterexpected:",SCRIPT[len(SCRIPT)-1],
		print"[input.xyz] [input.gro] [cutoff [Angstr]]"
		print""
		sys.exit(0)

	if (sys.argv[1][-4:] != ".xyz"):
		print""
		print" wrong input format"
		print" expected: [input.xyz] [input.gro] [cutoff [Angstr]]"
		print""
		sys.exit(0)
	
	
	if (sys.argv[2][-4:] != ".gro"):
		print""
		print" wrong input format"
		print" expected: [input.xyz] [input.gro] [cutoff [Angstr]]"
		print""
		sys.exit(0)


##### input & output files
coords=open(sys.argv[1])
gro_coords=open(sys.argv[2])
neighbour_list=open("lambda_neighbours.ngh",'w')#erases data



##### variables
xyz_list=[] #stores the coordinates for fast access
grid_box=[] #stores the index and x,y,z coordinates per grid box as a list of lists
number_of_points=0 #contains the number of discretization points
xedge=0 #checks if the edge of the box in the grid search is reached
yedge=0 #
zedge=0 #
atom_list=[[]] #atom_list[i] contains a list (gro format) of all atoms in mol i
mol_count=0
boxx=0
boxy=0
boxz=0
number_of_atoms=0



#### parameters

cutoff = float(sys.argv[3]) #cutoff in angstrom

##### counts which line is read
iline=0

##### define your functional forms here


######## functional_form
#### functional form is the evalution of the marcus rate, based on distance & molecule types
#### the parameter lambda und the energy shift are expected to be constant, because
#### the transfer integral varies in several orders of magnitude compared to 
#### lambda or energy shift which vary just by factors of ~2
def functional_form(list_of_distance, mol_type_list):
	#list_of_distance[1:]=1/list_of_distance[1:]
	#list_of_distance[1:]=list_of_distance[1:]/sum(list_of_distance[1:])
	#list_of_distance[0]=1-sum(list_of_distance[1:])
	#print mol_type_list
	return list_of_distance
########

#####

###########################
## use selection sort to sort elements in alist, elements are changed in b_list simultaniously 
## make sure a_list and b_list have the same length.
def selectionSort(a_list,b_list):
	if (len(a_list) == len(b_list) ):
   		for fillslot in range(len(a_list)-1,0,-1):
			positionOfMax=0
       			for location in range(1,fillslot+1):
           			if a_list[location]>a_list[positionOfMax]:
               				positionOfMax = location

       			temp = a_list[fillslot]
       			a_list[fillslot] = a_list[positionOfMax]
       			a_list[positionOfMax] = temp

       			temp_b = b_list[fillslot]
       			b_list[fillslot] = b_list[positionOfMax]
       			b_list[positionOfMax] = temp_b
	else:
		print 'Error in : selectionSort'
		print 'Lists do not have the same size, EXIT'
		print a_list
		print b_list
		sys.exit(1)
##########################


######## read coords from .gro file
iline=0
while 1:
	line1 = gro_coords.readline()
	if not line1:
		break
		
	##### get the number of atoms	
	if iline==1:	number_of_atoms = int(line1)	
	elif iline==2:	last_mol_number = int(line1[0:5])
	####
	elif iline>=2 and iline<number_of_atoms+2:
		##### split the line
		line=[int(line1[0:5]),str(line1[5:10]),str(line1[10:15]),int(line1[15:20]),float(line1[20:28]),float(line1[28:36]),float(line1[36:44])]
		#account for periodic boundary conditions
		#move coordinates back into the box
  		if line[4]>boxx/10 : line[4]=line[4]-boxx/10
		elif line[4]<0 : line[4]=line[4]+boxx/10
  		if line[5]>boxy/10 : line[5]=line[5]-boxy/10
		elif line[5]<0 : line[5]=line[5]+boxy/10
  		if line[6]>boxz/10 : line[6]=line[6]-boxz/10
		elif line[6]<0 : line[6]=line[6]+boxz/10
		##### check if a new molecule is present or not
		mol_number = line[0]
		if mol_number!=last_mol_number:
			mol_count = mol_count + 1
			atom_list.append([])
		atom_list[mol_count].append(line)	
		##### store the mol_number to check if the next line contains the same molecule
		last_mol_number = mol_number
	elif iline==number_of_atoms+2: 
		##### read the box vectors
		line=line1.split()
		boxx=float(line[0])*10
		boxy=float(line[1])*10
		boxz=float(line[2])*10
		print('Box size found: '+str(boxx)+'	'+str(boxy)+'	'+str(boxz)+'	')
	iline=iline+1
iline=0
########


######## calc the number of subboxes
minBox = min(boxx,boxy,boxz)

subboxes=int(minBox/cutoff) #number of boxes the box is split up to in the grid search algorithm
print 'cutoff: ' +str(cutoff)+' minimal boxlength: '+str(minBox)
if cutoff == 0:
	print 'cutoff too large, use a smaller one!'
print '=> '+str(subboxes)+' subboxes are used'
########

######## In this part the COM are read and a grid search is applied
####initialize the grid list
for x in range(subboxes):
	grid_box.append([])
	for y in range(subboxes):
		grid_box[x].append([])
		for z in range(subboxes):
			grid_box[x][y].append([])

#### first build a list for each grid cell, containing index and coordinates
#### each grid cell gets their own list
print('... reading data ...')
while 1:
	line1 = coords.readline()
	if not line1:
		break
	splitted_line=line1.split()
	if iline>=2: 
		#append all coords for fast access
		xyz_list.append([float(splitted_line[1]),float(splitted_line[2]),float(splitted_line[3])])
		#account for periodic boundary conditions
		#move too big coordinates back into the box
  		xyz_list[iline-2][0] = xyz_list[iline-2][0] - int(xyz_list[iline-2][0]/boxx)*boxx
  		xyz_list[iline-2][1] = xyz_list[iline-2][1] - int(xyz_list[iline-2][1]/boxy)*boxy
  		xyz_list[iline-2][2] = xyz_list[iline-2][2] - int(xyz_list[iline-2][2]/boxz)*boxz
		#move negative coords back into the box
		if xyz_list[iline-2][0]<0: xyz_list[iline-2][0]=xyz_list[iline-2][0]+boxx
		if xyz_list[iline-2][1]<0: xyz_list[iline-2][1]=xyz_list[iline-2][1]+boxy
		if xyz_list[iline-2][2]<0: xyz_list[iline-2][2]=xyz_list[iline-2][2]+boxz
		#print error if negative grid boxes are assigned
		if int(xyz_list[iline-2][0]/boxx*subboxes)<0: print('x error at index' + str(iline))
		if int(xyz_list[iline-2][1]/boxx*subboxes)<0: print('y error at index' + str(iline))
		if int(xyz_list[iline-2][2]/boxx*subboxes)<0: print('z error at index' + str(iline))
		#divide your box up into sub boxes and assign each COM to one of them
		#grid_box[x][y][z] will then contain a list of COM where
		#grid_box[x][y][z][i] contains index and coordinates of point i [index, x, y, z]
		grid_box[int(xyz_list[iline-2][0]/boxx*subboxes)][int(xyz_list[iline-2][1]/boxy*subboxes)][int(xyz_list[iline-2][2]/boxz*subboxes)].append([iline-2,np.asarray([xyz_list[iline-2][0],xyz_list[iline-2][1],xyz_list[iline-2][2]])])
	iline=iline+1
print('... grid list generated with ' + str(iline-2)+ ' points ...')
#number_of_points = iline-2

######## starting to generate the neighbour list
#dist_list=[]
dist_list = np.asarray([])
index_list=[]
#### search in all boxes
for x in range(len(grid_box)):
	for y in range(len(grid_box[x])):
		for z in range(len(grid_box[x][y])):
			#### search the list of box x,y,z
			for i in range(len(grid_box[x][y][z])):
				#### account for neighbouring boxes
				for helpx in [-1,0,1]:
					for helpy in [-1,0,1]:
						for helpz in [-1,0,1]:
							xi = x+helpx
							yi = y+helpy
							zi = z+helpz
							##account for pbd
							if xi==-1: 
								xi=subboxes-1
								xedge=-1
							elif xi==subboxes: 
								xi=0
								xedge=1
							if yi==-1: 
								yi=subboxes-1
								yedge=-1
							elif yi==subboxes: 
								yi=0
								yedge=1
							if zi==-1: 
								zi=subboxes-1
								zedge=-1
							elif zi==subboxes: 
								zi=0
								zedge=1
							correctedge=np.array([xedge*boxx,yedge*boxy,zedge*boxz])
							#### build the distance list. dist_list[n] contains [distance of indices, i, j]
							for j in range(len(grid_box[xi][yi][zi])):
								if i!=j:
									#dist_list.append(np.linalg.norm(grid_box[x][y][z][i][1]-grid_box[xi][yi][zi][j][1]))
									dist_list=np.append(dist_list,np.linalg.norm(grid_box[x][y][z][i][1]-grid_box[xi][yi][zi][j][1]-correctedge))
									index_list.append([grid_box[x][y][z][i][0],grid_box[xi][yi][zi][j][0]])
							xedge=yedge=zedge=0 #reset the edge variables
				ind = []
				#### get all molecules within a cutoff radius
				for i in range(len(dist_list))[2:]:
					if dist_list[i]<cutoff:
						ind.append(i)
				

				dist_list=dist_list[ind]

				########
				#### in this part the molecule types of the neighbouring molecules are stored as strings
				#### to be passed to the rate evalutation routine, because the transfer-integrals depend
				#### on mol_types. then the calculated distances and mol types are passed to the
				#### evaluation routine "functional_form" defined above
				mol_types=[]
				list_temp_dist=[]
				for p in range(len(dist_list)):
					mol_types.append(str(atom_list[index_list[ind[p]][1]][0][1]))
					#list_temp_dist.append(atom_list[index_list[ind[p]][1]][0][1])
				#list_temp = functional_form(dist_list,mol_types)
				list_temp_dist= functional_form(dist_list,mol_types)
				##print ind[0],str(index_list[ind[0]][0])
				#neighbour_list.write(str(index_list[ind[0]][0])+'	'+str(0)+'	'+str('	'.join(map(str, list_temp)))+ '\n')
				########

				########
				#### in this part the molecule indices of the neighbouring molecules are stored 
				#### and then printed into the neighbours.ngh file 
				list_temp_resid=[]
				printhelp=[]
				for p in range(len(dist_list)):
					printhelp.append(str(index_list[ind[p]][1]))
					list_temp_resid.append(index_list[ind[p]][1])
				#neighbour_list.write(str(index_list[ind[0]][0])+'	'+str(index_list[ind[0]][0])+'	'+('	'.join(printhelp))+ '\n')

				selectionSort(list_temp_dist,list_temp_resid)
				if (len(dist_list) == 0 ):
					print 'Error: No_element_in_the_neighbourlist_found._Increase_r_cut!'			
					print 'list_temp_dist:',list_temp_dist
					print 'list_temp_dist:',list_temp_resid
					exit()
				else: ##print sorted output to neighbour_list
					neighbour_list.write(str(index_list[ind[0]][0])+'	'+str(0)+'	'+str('	'.join(map(str, list_temp_dist)))+ '\n')
					neighbour_list.write(str(index_list[ind[0]][0])+'	'+str(index_list[ind[0]][0])+'	'+('	'.join(map(str, list_temp_resid)))+ '\n')
				########
				#print(ind[0])
				index_list=[]		
				dist_list = np.asarray([])
	print(str(x) + ' out of '+str(subboxes)+' x boxes done ~ ' + str(x/float(subboxes) * 100)+ '%')
	
###### output description ######
### the output file has the format:
### index(residuum number)	stay prob.	jump to ind. prob.	jump to ind. prob.			
### index(residuum number)	index		index where to jump	index where to jump
### ...
###### output description ######			
	
######## close files
coords.close()
neighbour_list.close()
########


##### input & output files
neighbour_list=open("lambda_neighbours.ngh",'r')#erases data

def sortkey_natural(s):
    return tuple(int(part) if re.match(r'[0-9]+$', part) else part
                for part in re.split(r'([0-9]+)', s))

### sort the list
sorted_list=open("sorted_lambda_neighbours.ngh",'w')
#lines = neighbour_list.readlines()
#lines.sort()
#sorted_list.write(print str(lines))

with neighbour_list as r:
    for line in sorted(r, key=sortkey_natural):
        sorted_list.write(line)


######## close files
sorted_list.close()
neighbour_list.close()
########



