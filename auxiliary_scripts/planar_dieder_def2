#!/usr/bin/python
## modified version of jim's planar_dieder programm to a critical angle: crit_angle for thiophene rings between two subunits into account 
## crit_angle can only be chosen between 0 and 90 degrees!!!
## crit_angle =0 => every thiophene ring gets one resid
## crit_angle =90 => no cuts 
## the new definition def2 for SCCS dihedral angle theta:
##			   theta < crit_angle         and theta > 0:
##			   theta > (180 - crit_angle) and theta > 0
##                         theta < 0 and |theta| < crit_angle:
## 			   theta < 0 and |theta| > (180 - crit_angle):
## => otherwise the chain is cut into two resids!
import os,sys,numpy as np, math

if 1==1:																									#check the input
	SCRIPT=sys.argv[0].split('/')
	NARGS=len(sys.argv)-1
	THELP=['-h','-help']

	if NARGS<2 or (NARGS>0 and sys.argv[1] in THELP):
		print""
		print"parameterexpected:",SCRIPT[len(SCRIPT)-1],
		print"[input.gro]  [theta_cutoff [in degree]]"
		print""
		sys.exit(0)

	if (sys.argv[1][-4:] != ".gro"):
		print""
		print" wrong input format"
		print" expected: [input.gro] [theta_cutoff [in degree]]"
		print""
		sys.exit(0)


#### parameters
if (NARGS>1):
    crit_angle= float(sys.argv[2]) #cutoff in angstrom
    print 'use critical cutoff angle theta=',crit_angle
else:
    crit_angle=75.0
    print 'use critical cutoff angle theta=',crit_angle

##### input & output files
coords=open(sys.argv[1])
gro_out=open("indexed.gro",'w')#erases data

### create a file to define the mapping from resids in the input.gro file to the output resids in the indexed.gro file // in order to take cuts in the P3HT-chain into account.
resid_cut0_to_resid_r_cut_file='resid_cut0_to_resid_r_cut_'+str(crit_angle)+'.dat'
resid_cut0_to_resid_r_cut_file=open(resid_cut0_to_resid_r_cut_file,'w') #erases data
resid_cut0_to_resid_r_cut_file.write( '# resid_cut0_to_resid_r_cut  gro: '+str(sys.argv[1])+' crit_angle: '+str(crit_angle) + '\n')

##### variables
last_moltype=''
DIPBI_count=0
THP_count=0
mol_count=0
THP_firstlast_count=0
number_of_atoms=0
dipbi_atoms=118
thp_atoms=12
thp_firstlast_atoms=13
cut_DIPBI=118
cut_THP=12
cut_firstlast_THP=13
cut_Alq3=52
i_int=0
## variables with PPDI / PBDT-TS1
PPDI_count=0
PBDT_TS1_count=0
PBDT_first_count=0
PPDI_atoms=98
cut_PPDI=98
Alq3_count=0

### lists
atom_store=[]
last_atoms=[]
exception = 0
###crit_angle=75.0
theta=0.0
store_coords=[]

##### vectors
middle = np.asarray([0.0,0.0,0.0])
new_middle = np.asarray([0.0,0.0,0.0])


##### counts which line is read
iline=0

print "use critical angle to cut p3ht theta_SCCS="+str(crit_angle) 
######## In this part the data is read and the COM are calculated
while 1:
	line1 = coords.readline()
	if not line1:
		break
		
	##### get the number of atoms
	#if iline==0:	gro_out.write(line1)
	if iline==1:	
	#	gro_out.write(line1)
		number_of_atoms = int(line1)
	if iline==2:	last_mol_number = int(line1[0:5])
	if iline>=2 and iline<number_of_atoms+2:
		##### split the line
		line=[int(line1[0:5]),str(line1[5:10]),str(line1[10:15]),int(line1[15:20]),float(line1[20:28]),float(line1[28:36]),float(line1[36:44])]
		##### check if a new molecule is present or not
		mol_number = line[0]
		mol_type = line[1]

##################### handle next molecule
		# atom_store is a list of atom coordinates of the current thyophene ring
		# last_atoms is a list of atom coordinates of the last thyophene ring
		if mol_number!=last_mol_number:
			if last_moltype=='PPDI_': 
				print 'PPDI'				
				mol_count = mol_count +1
				PPDI_count = PPDI_count +1
				for i in range(len(store_coords)):
					gro_out.write('%5s'%str(mol_count-1) + store_coords[i])
				store_coords=[]
				resid_cut0_to_resid_r_cut_file.write(str(last_mol_number)+'  '+str(mol_count-1)+ '\n')	
				print str(last_mol_number)+'  '+str(mol_count-1)
			elif last_moltype=='DIPBI': 
				print 'DIPBI'				
				mol_count = mol_count +1
				DIPBI_count = DIPBI_count +1
				for i in range(len(store_coords)):
					gro_out.write('%5s'%str(mol_count-1) + store_coords[i])
				store_coords=[]
				resid_cut0_to_resid_r_cut_file.write(str(last_mol_number)+'  '+str(mol_count-1)+ '\n')	
				print str(last_mol_number)+'  '+str(mol_count-1)
			elif (last_moltype[0:5]=='Alq  '):
				mol_count = mol_count +1
				Alq3_count = Alq3_count +1
				for i in range(len(store_coords)):
					gro_out.write('%5s'%str(mol_count-1) + store_coords[i])
				store_coords=[]
				resid_cut0_to_resid_r_cut_file.write(str(last_mol_number)+'  '+str(mol_count-1)+ '\n')	
				print str(last_mol_number)+'  '+str(mol_count-1)
			elif (last_moltype[:5]=='8poly'):
				print 'Error: Can_not_handle_PBDT-TS1'
				exit()
			elif (last_moltype[:5]=='THP1A'):	
				mol_count = mol_count + 1
				THP_firstlast_count = THP_firstlast_count+1
				print 'THP1A ',mol_count
				for i in range(len(store_coords)):
					gro_out.write('%5s'%str(mol_count-1) + store_coords[i])
				store_coords=[]
				resid_cut0_to_resid_r_cut_file.write(str(last_mol_number)+'  '+str(mol_count-1)+ '\n')	
				print str(last_mol_number)+'  '+str(mol_count-1)
			elif (last_moltype[:5]=='THP2A'): 
				print 'THP2A'
				##### here the atoms of the pi system are adressed and the middle is calculated
				##### indices: 12456
				if 1==1:
			#	if THP_firstlast_count!=0:
					atoms_from = last_atoms
					atoms_where = atom_store
					#atom indices for 1st to 2nd ring
					atom_a_ind_1=6
					atom_a_ind_2=5
					atom_b_ind_1=0
					atom_b_ind_2=5

			#		a = np.asarray(np.asarray(atoms_from[atom_a_ind_2])-np.asarray(atoms_from[atom_a_ind_1]))
			#		b = np.asarray(np.asarray(atoms_where[atom_b_ind_1])-np.asarray(atoms_from[atom_a_ind_2]))
			#		c = np.asarray(np.asarray(atoms_where[atom_b_ind_2])-np.asarray(atoms_where[atom_b_ind_1]))
	
					a = np.asarray(np.asarray(atoms_from[atom_a_ind_2])-np.asarray(atoms_from[atom_a_ind_1]))
					b = np.asarray(np.asarray(atoms_where[atom_b_ind_1])-np.asarray(atoms_from[atom_a_ind_2]))
					c = np.asarray(np.asarray(atoms_where[atom_b_ind_2])-np.asarray(atoms_where[atom_b_ind_1]))
	

					#get the normal vectors of the surfaces
					n_1 = np.cross(a,b)
					n_1 = n_1 / np.linalg.norm(n_1)
					n_2 = np.cross(b,c)
					n_2 = n_2 / np.linalg.norm(n_2)

					#calculate angle
					#thetaA=-1.0*np.arccos(np.dot(n_1,n_2))*180.0/np.pi
					theta = np.arctan2(np.vdot(np.cross(n_1,n_2),b/np.linalg.norm(b)),np.vdot(n_1,n_2))
					theta = theta/(2.0*np.pi)*360.0

					print 'Winkel:'+str(theta)         ###' '+str(thetaA)
					#print 'a, b, c',a, b, c, theta
				
				#	if theta>180.0: theta = 360.0-theta
					
					if theta < crit_angle and theta > 0:
						print('theta= '+str(theta)+' < '+str(crit_angle)+' found at first ring at index: '+str(mol_count-1))
					elif theta > (180 - crit_angle) and theta > 0:
						print('theta= '+str(theta)+' < '+str(crit_angle)+' found at first ring at index: '+str(mol_count-1))
					elif theta < 0 and np.abs(theta)<crit_angle:
						print('theta= '+str(theta)+' < '+str(crit_angle)+' found at first ring at index: '+str(mol_count-1))
					elif theta < 0 and np.abs(theta) > (180 - crit_angle):
						print('theta= '+str(theta)+' < '+str(crit_angle)+' found at first ring at index: '+str(mol_count-1))
					# if all false, cut the chain
					else:
						mol_count = mol_count + 1
						print('theta= '+str(theta)+' > '+str(crit_angle)+' found at first ring at index: '+str(mol_count-1))
						exception = exception + 1						
			#		if(theta>crit_angle): 
			#			mol_count = mol_count + 1
			#			print('theta= '+str(theta)+' > '+str(crit_angle)+' found at first ring at index: '+str(mol_count))
			#			exception = exception + 1
			#		else:
			#			print('theta= '+str(theta)+' < '+str(crit_angle)+' found at first ring at index: '+str(mol_count))
			#			print(atom_store)
			#			print(last_atoms)
						
					for i in range(len(store_coords)):
						gro_out.write('%5s'%str(mol_count-1) + store_coords[i])
					store_coords=[]
					THP_count=THP_count + 1
					resid_cut0_to_resid_r_cut_file.write(str(last_mol_number)+'  '+str(mol_count-1)+ '\n')	
					print str(last_mol_number)+'  '+str(mol_count-1)	
				#last_atoms=atom_store
				#atom_store=[]
		#	elif (last_moltype[:5]=='THP32'):
		#		##### here the atoms of the pi system are adressed and the middle is calculated
		#		##### indices: 01346
		#		mol_count = mol_count + 1
		#		THP_firstlast_count = THP_firstlast_count+1
		#		for i in range(len(store_coords)):
		#			gro_out.write('%5s'%str(mol_count) + store_coords[i])
		#		store_coords=[]
				#last_atoms=atom_store
				#atom_store=[]	
			elif last_moltype[:3]=='THP': 
				##### here the atoms of the pi system are adressed and the middle is calculated
				##### indices: 01345
				atoms_from = last_atoms
				atoms_where = atom_store
				
				#atom indices for 1st to 2nd ring
				if last_moltype[:5]=='THP32':
					atom_a_ind_1=5
					atom_a_ind_2=4
					atom_b_ind_1=0
					atom_b_ind_2=6
				else:
					atom_a_ind_1=5
					atom_a_ind_2=4
					atom_b_ind_1=0
					atom_b_ind_2=5

			#	a = np.asarray(np.asarray(atoms_from[atom_a_ind_2])-np.asarray(atoms_from[atom_a_ind_1]))
			#	b = np.asarray(np.asarray(atoms_where[atom_b_ind_1])-np.asarray(atoms_from[atom_a_ind_2]))
			#	c = np.asarray(np.asarray(atoms_where[atom_b_ind_2])-np.asarray(atoms_where[atom_b_ind_1]))

				a = np.asarray(np.asarray(atoms_from[atom_a_ind_2])-np.asarray(atoms_from[atom_a_ind_1]))
				b = np.asarray(np.asarray(atoms_where[atom_b_ind_1])-np.asarray(atoms_from[atom_a_ind_2]))
				c = np.asarray(np.asarray(atoms_where[atom_b_ind_2])-np.asarray(atoms_where[atom_b_ind_1]))
	

				#get the normal vectors of the surfaces
				n_1 = np.cross(a,b)
				n_1 = n_1 / np.linalg.norm(n_1)
				n_2 = np.cross(b,c)
				n_2 = n_2 / np.linalg.norm(n_2)

				#calculate angle
				#thetaA=-1.0*np.arccos(np.dot(n_1,n_2))*180.0/np.pi
				theta = np.arctan2(np.vdot(np.cross(n_1,n_2),b/np.linalg.norm(b)),np.vdot(n_1,n_2))
				theta = theta/(2.0*np.pi)*360.0
				
				print 'Winkel:'+str(theta) #+' '+str(thetaA)				
				
				#if theta<0: print theta
				#if theta>180.0: theta = 360.0-theta
				
				if   theta > 0 and ( theta < crit_angle):
					print('theta= '+str(theta)+' < '+str(crit_angle)+' found at first ring at index: '+str(mol_count-1))
				elif theta > 0 and theta > (180 - crit_angle):
					print('theta= '+str(theta)+' < '+str(crit_angle)+' found at first ring at index: '+str(mol_count-1))
				elif theta < 0 and np.abs(theta)<crit_angle:
					print('theta= '+str(theta)+' < '+str(crit_angle)+' found at first ring at index: '+str(mol_count-1))
				elif theta < 0 and np.abs(theta) > (180 - crit_angle):
					print('theta= '+str(theta)+' < '+str(crit_angle)+' found at first ring at index: '+str(mol_count-1))
					# if all false, cut the chain
				else:
					mol_count = mol_count + 1
					
					print('theta= '+str(theta)+' > '+str(crit_angle)+' found at first ring at index: '+str(mol_count-1)+' and cut')
					exception = exception + 1
			#	if(theta>crit_angle): 
			#		mol_count = mol_count + 1
			#		print('theta= '+str(theta)+' > '+str(crit_angle)+' found in the middle at index: '+str(mol_count))
			#		exception = exception + 1
		#		else:
		#			if (last_moltype[:5]=='THP32'):
		#				print('theta= '+str(theta)+' < '+str(crit_angle)+' found at last index: '+str(mol_count-1))
		#			else:
		#				print('theta= '+str(theta)+' < '+str(crit_angle)+' found at middle index: '+str(mol_count-1))
						
				for i in range(len(store_coords)):
					gro_out.write('%5s'%str(mol_count-1) + store_coords[i])
				store_coords=[]
				resid_cut0_to_resid_r_cut_file.write(str(last_mol_number)+'  '+str(mol_count-1)+ '\n')	
				print str(last_mol_number)+'  '+str(mol_count-1)
				if (last_moltype[:5]=='THP32'):
					THP_firstlast_count = THP_firstlast_count+1
				else:
					THP_count=THP_count + 1	
			last_atoms=atom_store
			atom_store=[]
		
			
#####################

		
		##### store the mol_number to check if the next line contains the same molecule
		##### store the coordinates for use above if a new mol is found
		atom_store.append([line[4],line[5],line[6]])
		last_mol_number = mol_number
		last_moltype = line[1]
	if iline==(number_of_atoms+2): ### end of the gro-file
		print str(last_mol_number)+'  '+str(mol_count-1)
		if last_moltype=='PPDI_':
			mol_count = mol_count + 1 
			PPDI_count = PPDI_count + 1
			for i in range(len(store_coords)):
				gro_out.write('%5s'%str(mol_count-1) + store_coords[i])
			atom_store=[]
		elif last_moltype=='DIPBI':
			mol_count = mol_count + 1 
			DIPBI_count = DIPBI_count + 1
			for i in range(len(store_coords)):
				gro_out.write('%5s'%str(mol_count-1) + store_coords[i])
			atom_store=[]
		elif last_moltype=='Alq  ':
			mol_count = mol_count + 1 
			Alq3_count = Alq3_count + 1
			for i in range(len(store_coords)):
				gro_out.write('%5s'%str(mol_count-1) + store_coords[i])
			atom_store=[]
		elif (last_moltype[:5]=='THP1A'):
			mol_count = mol_count + 1 
			THP_firstlast_count = THP_firstlast_count+1
			for i in range(len(store_coords)):
				gro_out.write('%5s'%str(mol_count-1) + store_coords[i])
		#	if mol_count!=1:
		#		for i_1 in range(len(last_atoms)):
		#			print(last_atoms[i_1])
			last_atoms=atom_store
			atom_store=[]
		elif (last_moltype[:5]=='THP32'):
				THP_firstlast_count = THP_firstlast_count+1
				atoms_from = last_atoms
				atoms_where = atom_store

				atom_a_ind_1=5
				atom_a_ind_2=4
				atom_b_ind_1=0
				atom_b_ind_2=6

				a = np.asarray(np.asarray(atoms_from[atom_a_ind_2])-np.asarray(atoms_from[atom_a_ind_1]))
				b = np.asarray(np.asarray(atoms_where[atom_b_ind_1])-np.asarray(atoms_from[atom_a_ind_2]))
				c = np.asarray(np.asarray(atoms_where[atom_b_ind_2])-np.asarray(atoms_where[atom_b_ind_1]))
				#get the normal vectors of the surfaces
				n_1 = np.cross(a,b)
				n_1 = n_1 / np.linalg.norm(n_1)
				n_2 = np.cross(b,c)
				n_2 = n_2 / np.linalg.norm(n_2)
				#calculate angle
				theta = np.arctan2(np.vdot(np.cross(n_1,n_2),b/np.linalg.norm(b)),np.vdot(n_1,n_2))
				theta = theta/(2.0*np.pi)*360.0
				print 'Winkel:'+str(theta) #+' '+str(thetaA)				
				if   theta > 0 and ( theta < crit_angle):
					print('theta= '+str(theta)+' < '+str(crit_angle)+' found at first ring at index: '+str(mol_count-1))
				elif theta > 0 and theta > (180 - crit_angle):
					print('theta= '+str(theta)+' < '+str(crit_angle)+' found at first ring at index: '+str(mol_count-1))
				elif theta < 0 and np.abs(theta)<crit_angle:
					print('theta= '+str(theta)+' < '+str(crit_angle)+' found at first ring at index: '+str(mol_count-1))
				elif theta < 0 and np.abs(theta) > (180 - crit_angle):
					print('theta= '+str(theta)+' < '+str(crit_angle)+' found at first ring at index: '+str(mol_count-1))
					# if all false, cut the chain
				else:
					mol_count = mol_count + 1
					
					print('theta= '+str(theta)+' > '+str(crit_angle)+' found at first ring at index: '+str(mol_count-1)+' and cut')
					exception = exception + 1
				for i in range(len(store_coords)):
					gro_out.write('%5s'%str(mol_count-1) + store_coords[i])
				last_atoms=atom_store
				atom_store=[]		
		elif last_moltype[:3]=='THP':
			mol_count = mol_count + 1  
			THP_count=THP_count + 1	
			for i in range(len(store_coords)):
				gro_out.write('%5s'%str(mol_count-1) + store_coords[i])
			last_atoms=atom_store
			atom_store=[]
		gro_out.write(line1)

		#if last_moltype=='DIPBI': DIPBI_count = DIPBI_count + 1
		#elif (last_moltype[:5]=='THP1A' or last_moltype[:5]=='THP32'): THP_firstlast_count = THP_firstlast_count+1
		#elif last_moltype[:3]=='THP': THP_count=THP_count + 1
	elif iline >= 2:
		store_coords.append(line1[5:])
	iline = iline + 1

## add last resids to list
resid_cut0_to_resid_r_cut_file.write(str(last_mol_number)+'  '+str(mol_count-1)+ '\n') 
resid_cut0_to_resid_r_cut_file.close()
print "N_DIPBI: ", DIPBI_count
print "N_THP: ",THP_count
print "N_PPDI: ",PPDI_count
print "N_PBDT-TS1: ",PBDT_TS1_count
print "Alq3_count: ",Alq3_count
print "N_new_molecules: ",mol_count
##### put number of mols at the top of file for VMD
print(str(number_of_atoms - (cut_DIPBI*DIPBI_count+cut_THP*THP_count+cut_firstlast_THP*THP_firstlast_count+cut_PPDI*PPDI_count))+' out of '+str(number_of_atoms)+' atoms removed')
print(str(cut_DIPBI*DIPBI_count+cut_THP*THP_count+cut_firstlast_THP*THP_firstlast_count+cut_PPDI*PPDI_count)+' atoms remaining')
gro_out=open("indexed.gro",'r+')
data=gro_out.read()
gro_out.seek(0)
gro_out.truncate()
gro_out.write('cuttedSystem'+'\n')	
#gro_out.write(str(dipbi_atoms*DIPBI_count+thp_atoms*THP_count)'\n')
gro_out.write(str(cut_DIPBI*DIPBI_count+cut_THP*THP_count+cut_firstlast_THP*THP_firstlast_count+Alq3_count*cut_Alq3)+'\n')
gro_out.write(data)
print(str(exception) + ' angles > '+str(crit_angle)+' deg found')
coords.close()
gro_out.close()
########



