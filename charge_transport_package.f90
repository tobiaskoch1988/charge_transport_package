!!! ------------------------------------------------------------------------------------------------------------------- !!!
!! charge_transport_package
!!
!! 
!! Compile with LAPACK and BLAS package:
!! clear ; gfortran charge_transport_package.f90  -o charge_transport_package /usr/lib/lapack/liblapack.so.3  /usr/lib/libblas/libblas.so.3 &> error ; head error  
!! sonst auskommentiert: !CALL DSYEV  
!!
!! contains the modules:
!! module small_functions
!! module KMC_class
!! module gro_to_DIPRO
!! module DIPRO_nMO
!! module Molecule_class
!! module gro_to_votca
!! module rates_to_votca_sqlfile
!! module calc_current_I_from_kmc_data
!! module mod_dijkstra
!! module charge_transfer_rate_calculator
!!
!!
!! charge_transport_package starts in PROGRAM main
!! Start with command line arguments or with the option.xml file
!! options are set to type KMC_setup_t
!!! ------------------------------------------------------------------------------------------------------------------- !!!


!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!!      small functions module
!!! ------------------------------------------------------------------------------------------------------------------- !!!
module small_functions
	
	CONTAINS 
	
	!!! Start Usefull functions

	!! norm for real*4 vector
	Real Function norm(vector)
		IMPLICIT NONE
		Real, Dimension(3), Intent(IN) :: vector
		norm = SQRT(vector(1)**2 + vector(2)**2 + vector(3)**2)
	END Function norm
	
	!! norm for real*8 vector
	Real*8 Function norm8(vector)
		IMPLICIT NONE
		Real*8, Dimension(3), Intent(IN) :: vector
			norm8 = SQRT(vector(1)**2 + vector(2)**2 + vector(3)**2)
	END Function norm8
	
	Subroutine kreuzprodukt(vektor1,vektor2,kreuzprod) !berechnet vektor1 x vektor2 in kreuzprod
		IMPLICIT NONE
		Real, Dimension(3) :: vektor1, vektor2,kreuzprod

		kreuzprod(1) = vektor1(2)*vektor2(3)-vektor1(3)*vektor2(2)
		kreuzprod(2) = vektor1(3)*vektor2(1)-vektor1(1)*vektor2(3)
		kreuzprod(3) = vektor1(1)*vektor2(2)-vektor1(2)*vektor2(1)

	end Subroutine kreuzprodukt

	integer function Read_rows_file(filename,lio) ! Angabe mit Endung ; lio Parameter zur Vermeidung von Verwechslungen, falls mehrere Rechnungen gleichzeitig ablaufen.
			IMPLICIT NONE
			Character(10000), INTENT(IN) :: filename,lio
			Character(22000) :: bashline
			Character(50) :: tmp_filename
			INTEGER::linenumber
			LOGICAL::tmp_file_exists
			
				if(file_exists(filename))then
					tmp_filename='wc_'//TRIM(lio)//'.txt'
					write(bashline,*) 'wc -l '//TRIM(filename)//' >  '//TRIM(tmp_filename)
					Write(*,*) trim(bashline)
					CALL execute_command_line(TRIM(bashline))
					if(file_exists(tmp_filename))then
						OPEN(unit=122,file=TRIM(tmp_filename)) 
						READ(122,*) linenumber
						CLOSE(122)
						if(file_exists(tmp_filename))then
							bashline=' rm  '//TRIM(tmp_filename)
							CALL execute_command_line(bashline) 
							!! check if tmp_file was removed successfully
							inquire(file=TRIM(tmp_filename),exist=tmp_file_exists)
							IF( tmp_file_exists) THEN
								WRITE(*,*) 'Error while reading the file '//TRIM(filename)
								WRITE(*,*) 'Could not delete temporary file: '//TRIM(tmp_filename)
								CALL EXIT(1)
							END IF
						endif
					endif ! tmp_filename exists?
				endif ! filename exists?
			Read_rows_file=linenumber
	END function Read_rows_file
	
	integer function Read_rows_file2(filename) ! Angabe mit Endung
			IMPLICIT NONE
			Character(500), INTENT(IN) :: filename
			Character(500)::tmp_filename
			Character(2024) :: bashline
			INTEGER::linenumber
			Character(10)::lio
			logical::tmp_file_exists
				
				lio=TRIM(make_lio())
					
				if(file_exists(filename))then
					!write(*,*) 'lio: ',TRIM(lio)
					tmp_filename='wc_'//TRIM(lio)//'.txt'
					write(bashline,*) 'wc -l '//TRIM(filename)//' >  '//TRIM(tmp_filename)
					Write(*,*) trim(bashline)
					CALL execute_command_line(TRIM(bashline))
					if(file_exists(tmp_filename))then
						OPEN(unit=122,file=TRIM(tmp_filename)) 
						READ(122,*) linenumber
						CLOSE(122)
						if(file_exists(tmp_filename))then
							bashline=' rm  '//TRIM(tmp_filename)
							CALL execute_command_line(bashline) 
							!! check if tmp_file was removed successfully
							inquire(file=TRIM(tmp_filename),exist=tmp_file_exists)
							IF( tmp_file_exists) THEN
								WRITE(*,*) 'Error while reading the file '//TRIM(filename)
								WRITE(*,*) 'Could not delete temporary file: '//TRIM(tmp_filename)
								CALL EXIT(1)
							END IF
						endif
					endif ! tmp_filename exists?
				endif ! filename exists?
					
			Read_rows_file2=linenumber
	END function Read_rows_file2

	!! make_lio create an string with RANDOM_NUMBER, in order_to_create_unique string:  lio=chaos in espanol !
	CHARACTER(len=5) function make_lio() 
		   ! Creates a random string unsing clock-time 
		   IMPLICIT NONE
		   !   "Convert an real to string."
		   character(len=10) :: k
		   INTEGER::i
		   REAL::HARVEST
		   !integer, allocatable :: seed(:)
		   !integer:: size2
		   LOGICAL::first_call=.true.
		   integer:: values(1:8)
			
			IF (first_call) THEN
				CALL init_random_seed()
				call date_and_time(values=values)
				first_call=.false.
			END IF


		   !call random_seed(size=size2)
		   !allocate(seed(1:size2))
		   !seed(:)=values(8)
		   ! set seed(:) somehow
		   !call random_seed(put=seed)
		   call system_clock(i)
		   CALL RANDOM_NUMBER(HARVEST)
		   !WRITE(*,*) HARVEST,abs(mod(HARVEST,REAL(i)))*1.E5
		   write (k,'(I5)') INT((abs(mod(HARVEST,REAL(i))))*1.E5)
		   !WRITE(*,*) k
		   make_lio=adjustl(TRIM(k))
	end function make_lio

	!! Function, which creates a unique temporary file name. 
	!! Intent in a key: nodes, a seed and a filename.
	!! Usage e.g.:  tmp_readfile=TRIM(make_tmp_readfilename('nodes',votca_sql_name,KMC_setup%set_seed))
	CHARACTER(LEN=500) FUNCTION make_tmp_readfilename(key,filename2,seed)
		IMPLICIT NONE
		CHARACTER (LEN=*)  , INTENT(IN)    :: key
		CHARACTER (LEN=500), INTENT(IN)    :: filename2
		CHARACTER(LEN=500)  :: filename
		INTEGER, INTENT(IN) :: seed
		CHARACTER(LEN=10)   :: lio
		
		lio=TRIM(make_lio())//'_'//TRIM(str(seed))
		filename=TRIM(filename2)
		
		IF( INDEX(filename, '.', .true. ) > LEN_TRIM(filename)-4 ) then
			filename=TRIM(filename(:(INDEX(filename, '.', .true. )-1)))
		ENDIF
		
		IF( INDEX(filename, '/', .true. ) > 0 ) then
			filename=TRIM(filename(INDEX(filename, '/', .true. )+1:)) !!! Look for index with / from the back =.true.
		ELSE
			filename=TRIM(filename)
		ENDIF
		
		make_tmp_readfilename='tmp_readfile_'//TRIM(key)//'_'//TRIM(filename)//'_'//TRIM(lio)//'.dat'
	END FUNCTION make_tmp_readfilename

	!! Random seed 
	subroutine init_random_seed()
	  implicit none
	  integer :: i, n, clock
	  integer, dimension(:), allocatable :: seed
	  call random_seed(size = n)
	  allocate(seed(n))
	  call system_clock(count=clock)
	  seed = clock + 37 * (/ (i - 1, i = 1, n) /)
	  call random_seed(put = seed)
	  deallocate(seed)
	end

	!! Integer to string conversion with WRITE statement
	character(len=30) function str(k) ! Integer_to_String
				IMPLICIT NONE
			!   "Convert an integer to string."
				integer, intent(in) :: k
				write (str, *) k
				str = adjustl(str)
	end function str

	!! Integer to string conversion with WRITE statement
	character(len=30) function int2str(k) ! Integer_to_String
				IMPLICIT NONE
			!   "Convert an integer to string."
				integer, intent(in) :: k
				write (int2str, *) k
				int2str = adjustl(int2str)
	end function int2str

	character(len=30) function Real2str(k) ! Real_to_String
		IMPLICIT NONE
		!   "Convert an real to string."
		REAL, intent(in) :: k
		CHARACTER(Len=30):: strReal_local
		write (strReal_local,'(E18.8)') k
		Real2str = adjustl(strReal_local)
	end function Real2str

	character(len=30) function Real8str(k) ! Real*8_to_String
			IMPLICIT NONE
			!   "Convert an real to string."
			REAL*8, intent(in) :: k
			CHARACTER(Len=30):: strReal_local
			write (strReal_local,'(E18.8)') k
			Real8str = adjustl(strReal_local)
	end function Real8str

	real function str2real(string)
		!! A function which converts a string to a real*8 number.
		!! e.g. avoids a wrong conversion in READ(string,*) real, if string contains only integer digits.
		IMPLICIT NONE
		CHARACTER(LEN=*)::string
		REAL::real_number
		INTEGER::ierror
		INTEGER::integer
		LOGICAL::debug=.false.
		
		IF( (INDEX(string,"E") /= 0) .OR. (INDEX(string,"e") /= 0) .OR. &
		 &  (INDEX(string,"D") /= 0) .OR. (INDEX(string,"d") /= 0) ) THEN
			READ (string, '(E20.16)',IOSTAT=ierror) real_number
		ELSE IF (INDEX(string,".") /= 0) THEN
			READ (string, '(F20.16)',IOSTAT=ierror) real_number
		ELSE 
			READ (string,*,IOSTAT=ierror) integer
			real_number=REAL(integer,4)
		END IF

		IF(ierror > 0) THEN
			WRITE(*,*) 'Error in str2real4 conversion: ',TRIM(string),real_number
			CALL EXIT(1)
		END IF
						
		IF(debug) WRITE(*,*) 'str2real4 Convert String ',TRIM(string),' to real:',real_number
		str2real=real_number
	end function str2real

	real*8 function str2real8(string)
		!! A function which converts a string to a real*8 number.
		!! e.g. avoids a wrong conversion in READ(string,*) real, if string contains only integer digits.
		IMPLICIT NONE
		CHARACTER(LEN=*)::string
		REAL*8::real_number
		INTEGER::ierror
		INTEGER::integer
		LOGICAL::debug=.false.
		
		IF( (INDEX(string,"E") /= 0) .OR. (INDEX(string,"e") /= 0) .OR. &
		 &  (INDEX(string,"D") /= 0) .OR. (INDEX(string,"d") /= 0) ) THEN
			READ (string, '(E20.16)',IOSTAT=ierror) real_number
		ELSE IF (INDEX(string,".") /= 0) THEN
			READ (string, '(F20.16)',IOSTAT=ierror) real_number
		ELSE 
			READ (string,*,IOSTAT=ierror) integer
			real_number=REAL(integer,8)
		END IF

		IF(ierror > 0) THEN
			WRITE(*,*) 'Error in str2real conversion: ',TRIM(string),real_number
			CALL EXIT(1)
		END IF
						
		IF(debug) WRITE(*,*) 'str2real Convert String ',TRIM(string),' to real:',real_number
		str2real8=real_number
	end function str2real8

	integer function str2int(value)
		!! str2int converts the input "value" as a string into an integer value. 
		implicit none
		character(len=*), intent(in) :: value
		integer :: i_value,ierror
		
		read (value, '(I12)',IOSTAT=ierror) i_value
		if( ierror > 0 ) then
			write(*,*) 'Error: Conversion of string '//trim(value)//' to integer failed. ',i_value
			call exit(1)
		endif
		str2int=i_value
	end function str2int
	
	integer*8 function str2int8(value)
		!! str2int converts the input "value" as a string into an integer value. 
		implicit none
		character(len=*), intent(in) :: value
		integer*8 :: i_value,ierror
		
		read (value, '(I12)',IOSTAT=ierror) i_value
		if( ierror > 0 ) then
			write(*,*) 'Error: Conversion of string '//trim(value)//' to integer failed. ',i_value
			call exit(1)
		endif
		str2int8=i_value
	end function str2int8	
	
	CHARACTER(LEN=500) FUNCTION delete_characters_from_string(inputstring)
		!! Function which detects all Character variables from an inputstring and returns the string without any Characters.
		!! Use IACHAR as a filer.
		IMPLICIT NONE
		CHARACTER(LEN=*)         :: inputstring
		CHARACTER(LEN=50000)     :: tmp_string
		INTEGER ::i,i_max
		tmp_string=""
		i_max=LEN_TRIM(inputstring)
		if( i_max > 0 ) then
			DO i=1,i_max
				!write(*,*) inputstring(i:i),'  IACHAR: ',IACHAR(inputstring(i:i))
				IF( (IACHAR(inputstring(i:i)) >= 48) .and. (IACHAR(inputstring(i:i)) <= 57) ) THEN
					tmp_string=TRIM(tmp_string)//inputstring(i:i)
					!write(*,*) TRIM(tmp_string)
				END IF
			ENDDO
		endif
		delete_characters_from_string = trim(adjustl(tmp_string))
	END FUNCTION delete_characters_from_string
	
	CHARACTER(LEN=500) FUNCTION delete_numbers_from_string(inputstring)
		!! Function which detects all numbers variables from an inputstring and returns the string without any numbers [0,9].
		!! Use IACHAR as a filer.
		IMPLICIT NONE
		CHARACTER(LEN=*)     :: inputstring
		CHARACTER(LEN=50000)   :: tmp_string
		INTEGER ::i,i_max
		tmp_string=""
		i_max=LEN_TRIM(inputstring)
		if( i_max > 0 ) then
			DO i=1,i_max
				!write(*,*) inputstring(i:i),'  IACHAR: ',IACHAR(inputstring(i:i))
				IF( (IACHAR(inputstring(i:i)) < 48) .or. (IACHAR(inputstring(i:i)) > 57) ) THEN
					tmp_string=TRIM(tmp_string)//inputstring(i:i)
					!write(*,*) TRIM(tmp_string)
				END IF
			ENDDO
		endif
		delete_numbers_from_string = trim(adjustl(tmp_string))
	END FUNCTION delete_numbers_from_string

	!! check if the input string is numeric 
	LOGICAL FUNCTION is_numeric(string)
	  IMPLICIT NONE
	  CHARACTER(len=*), INTENT(IN) :: string
	  REAL :: x
	  INTEGER :: e
	  READ(string,*,IOSTAT=e) x
	  is_numeric = e == 0
	END FUNCTION is_numeric

	!! Checks if a file exists and terminates the program if it is not available. else => EXIT
	logical function file_exists(filename) 
				implicit none
				CHARACTER(LEN=*)::filename
				LOGICAL::Datei_vorhanden
				
				Datei_vorhanden=.false.
				inquire(file=TRIM(filename),exist=Datei_vorhanden)
				IF( .NOT. Datei_vorhanden) THEN
						WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(filename)
						WRITE(*,*) ' ENDE'
						CALL EXIT (1)
				ELSE 
						Datei_vorhanden=.true.
				END IF  
				
				file_exists=Datei_vorhanden
	end function file_exists
	
	!! Checks if a file exists. => returns .true. or .false.
	logical function file_exists_and_continue(filename) 
				implicit none
				CHARACTER(LEN=*)::filename
				LOGICAL::Datei_vorhanden
				
				Datei_vorhanden=.false.
				inquire(file=TRIM(filename),exist=Datei_vorhanden)
				IF( .NOT. Datei_vorhanden) THEN
						Datei_vorhanden=.false.
				ELSE 
						Datei_vorhanden=.true.
				END IF  
				
				file_exists_and_continue=Datei_vorhanden
	end function file_exists_and_continue

	!! Checks if the user selected filename has got a usefull termination, else => programm termintates with an error
	LOGICAL FUNCTION check_filetermination(filename,termination)
		IMPLICIT NONE
		! Checks if the filename has got the correct termination
		! filename=my_molecule.xyz  and termination=.xyz => CALL EXIT (1) program with an error.
		CHARACTER (LEN=*), INTENT(IN) :: filename,termination
		LOGICAL :: termination_ok
		termination_ok=.false.
		IF( index(filename((LEN_TRIM(filename)-LEN_TRIM(termination)+1):),TRIM(termination)) == 0 ) THEN
			WRITE(*,*) 'Fehler: Eine falsche Endung der Datei '//TRIM(filename)//' ist nicht: '//TRIM(termination)
			CALL EXIT (1)
		ELSE
			termination_ok=.true.
		END IF
		check_filetermination=termination_ok
	END FUNCTION check_filetermination

	!! Checks if the user selected filename has got a usefull termination, else => returns false
	LOGICAL FUNCTION check_filetermination_and_continue(filename,termination)
		IMPLICIT NONE
		! Checks if the filename has got the correct termination
		! filename=my_molecule.xyz  and termination=.xyz => CALL EXIT (1) program with an error.
		CHARACTER (LEN=*), INTENT(IN) :: filename,termination
		LOGICAL :: termination_ok
		termination_ok=.false.
		IF( index(filename((LEN_TRIM(filename)-LEN_TRIM(termination)+1):),TRIM(termination)) == 0 ) THEN
			termination_ok=.false.
		ELSE
			termination_ok=.true.
		END IF
		check_filetermination_and_continue=termination_ok
	END FUNCTION check_filetermination_and_continue

	!! separate a string into substings, with delimiters=(/' ',';',tab/),  
	subroutine split_string_to_array( line, fields, n_fields, max_fields )
		!! splits a string input "line" into the array "fields" and returns the number of fields as "n_fields".
		!! max_fields, is the maximum number of expected fields.
		!! Uses delimites / seperators  delimiters=(/' ',';',tab/)
		implicit none
		character(len=50000) ::line
		integer :: n_fields,max_fields 
		character(len=500), dimension(max_fields) :: fields
		character(1) :: tab
		integer, parameter ::n_delimiters=3
		character(len=1), dimension(n_delimiters) ::delimiters
		integer::i,j,e
		logical :: d_found,old_d
		
		tab = ACHAR(9)
		delimiters=(/' ',';',tab/)
		e=LEN_TRIM(line)
		line=TRIM(line)
		n_fields=0
		fields=""
		old_d=.true.
		do i=1,e
			d_found=.false.
			do j=1,n_delimiters
				if(delimiters(j) == line(i:i)) then
					d_found=.true.
				endif
			enddo !j
			
			if( .not. d_found) then
				if(old_d)then
					n_fields=n_fields+1
					old_d=.false.
				endif
				fields(n_fields)=TRIM(fields(n_fields))//line(i:i)
			endif
			old_d=d_found
		enddo
	end subroutine split_string_to_array

	CHARACTER(LEN=7) FUNCTION percent(real_number)
			IMPLICIT NONE
			REAL*8::real_number
			CHARACTER(LEN=7) ::str
			WRITE(str,'(F6.2)') real_number*100
			percent=" "//TRIM(str)//'%'
	END FUNCTION percent

	!!! read the boxsize (x_box,y_box,z_box) from sql_filname.  Output in Angstroem!
	SUBROUTINE Read_boxsize_from_sql(sql_filename,x_box,y_box,z_box) !!! Output in Angstroem
			!!! Output in Angstroem
			IMPLICIT NONE
			REAL, INTENT(OUT)::x_box,y_box,z_box
			REAL:: nm_2_ang=10.0
			CHARACTER(LEN=*)    :: sql_filename
			CHARACTER(LEN=5000) :: bashline
			CHARACTER(LEN=500)  :: tmp_box_filename
			LOGICAL::Datei_vorhanden
			INTEGER::ierror
			CHARACTER(LEN=10)::lio
			
			lio=TRIM(make_lio())
			tmp_box_filename='my_tmp_box_'//TRIM(lio)//'.dat'
			
			inquire(file=TRIM(sql_filename),exist=Datei_vorhanden) 
			IF (.NOT. Datei_vorhanden) THEN
				WRITE(*,*) 'Sql file is not available: '//TRIM(sql_filename)
				CALL EXIT(1)
			END IF
		

			bashline=' sqlite3 '//TRIM(sql_filename)//' " SELECT box11,box22,box33 FROM frames " '//&
			 &"  | sed 's&|&  &g' >   "//TRIM(tmp_box_filename)
			WRITE(*,*) TRIM(bashline)
			CALL execute_command_line(TRIM(bashline)) 
			
			inquire(file=TRIM(tmp_box_filename),exist=Datei_vorhanden) 
			IF (.NOT. Datei_vorhanden) THEN
					WRITE(*,*) 'Tmp boxfilename is not available: '//TRIM(tmp_box_filename)
					CALL EXIT(1)
			ELSE
						OPEN(UNIT=77,FILE=TRIM(tmp_box_filename),STATUS='unknown',ACTION='READ',IOSTAT=ierror)
						READ(77,*) x_box,y_box,z_box
						CLOSE(77)
						!! nm2Ang
						x_box=x_box*nm_2_ang
						y_box=y_box*nm_2_ang
						z_box=z_box*nm_2_ang
						
						CALL delete_file_and_check(tmp_box_filename)
						inquire(file=TRIM(tmp_box_filename),exist=Datei_vorhanden)
						if(Datei_vorhanden)then
							write(*,*) 'Error: temporary file still exists: '//TRIM(tmp_box_filename)
							call exit(1)
						else
							WRITE(*,*) 'Boxsize in ',TRIM(sql_filename),': ',x_box,y_box,z_box,' [Ang]'
						end if
			END IF	
					
	END SUBROUTINE Read_boxsize_from_sql

	!!! read the boxsize (x_box,y_box,z_box) => returns the box dimensions in Angstroem!!
	SUBROUTINE Read_boxsize_from_gro(filename,x_box,y_box,z_box,lio) ! Angabe mit Endung
		IMPLICIT NONE
		Character(500), INTENT(IN) :: filename,lio
		REAL,INTENT(OUT)::x_box,y_box,z_box
		Character(5024) :: bashline
		INTEGER::ierror1
		LOGICAL::Datei_vorhanden
				
				inquire(file=TRIM(filename),exist=Datei_vorhanden) ! Abfrage ob gro-Datei vorhanden ist.
				IF( .NOT. Datei_vorhanden) THEN 
					WRITE(*,*) 'Fehler: Einlesen_der_boxsize_nicht_moeglich:_Die_gro_Datei_ist_nicht_vorhanden. '//TRIM(filename)
					WRITE(*,*) ' ENDE'
					STOP
				END IF ! gro-file vorhanden  
				
				write(bashline,*) 'tail -1 '//TRIM(filename)//' > boxsize_read_'//TRIM(lio)//'.txt'
				CALL execute_command_line(TRIM(bashline)) 
				
				inquire(file='boxsize_read_'//TRIM(lio)//'.txt',exist=Datei_vorhanden) ! Abfrage ob gro-Datei vorhanden ist.
				IF( Datei_vorhanden) THEN
					OPEN(unit=123,file='boxsize_read_'//TRIM(lio)//'.txt',IOSTAT=ierror1) 
					READ(123,*,IOSTAT=ierror1) x_box,y_box,z_box
					CLOSE(123)
					IF(ierror1 > 0) THEN
						WRITE(*,*) 'Fehler: Es ist eine Fehler beim Einlesen von ',TRIM(filename),' aufgetreten.'
						WRITE(*,*) 'Beende Einlesen !'
						STOP
					END IF
					! Umwandlung von nm in Ang
					x_box=10.0*x_box
					y_box=10.0*y_box
					z_box=10.0*z_box        
					CALL execute_command_line('rm boxsize_read_'//TRIM(lio)//'.txt') 
					WRITE(*,*) 'use boxsize (Ang):',x_box,y_box,z_box
				ELSE
					WRITE(*,*) 'Fehler: boxsize_wurde_nicht_richtig_eingelesen'
					STOP
				END IF
	END SUBROUTINE Read_boxsize_from_gro

	SUBROUTINE position_PBC_correction(pos_vec,x_box,y_box,z_box)
			!! PBC Correction of position vector, promotes vector to positix pos_vec_x,pos_vec_y,pos_vec_z make sure the input vector and the box vector is in the same length units.
			IMPLICIT NONE
			REAL, INTENT(IN)::x_box,y_box,z_box
			REAL, DIMENSION (3),INTENT(INOUT)::pos_vec
			REAL, DIMENSION (3)::box_size
			INTEGER::i
				box_size(1)=x_box
				box_size(2)=y_box
				box_size(3)=z_box

				DO i=1,3
					IF( pos_vec(i) > box_size(i) ) THEN
							pos_vec(i) = pos_vec(i)-box_size(i)
					ELSE IF ( pos_vec(i) < 0.0 ) THEN
							pos_vec(i) = pos_vec(i)+box_size(i)
					ELSE
							CYCLE
					END IF
			END DO

	END SUBROUTINE position_PBC_correction

	SUBROUTINE distance_PBC_correction(dist,x_box,y_box,z_box)
		!! PBC Correction of distance vector, make sure the input vector and the box vector is in the same length units.
		IMPLICIT NONE
		REAL, INTENT(IN)::x_box,y_box,z_box
		REAL, DIMENSION (3),INTENT(INOUT)::dist
		REAL, DIMENSION (3)::box_size
		INTEGER::i
			box_size(1)=x_box
			box_size(2)=y_box
			box_size(3)=z_box

			DO i=1,3
				IF( dist(i) > 0.5*box_size(i) ) THEN
						dist(i) = dist(i)-box_size(i)
				ELSE IF ( dist(i) < -0.5*box_size(i) ) THEN
						dist(i) = dist(i)+box_size(i)
				ELSE
						CYCLE
				END IF
		END DO

	END SUBROUTINE distance_PBC_correction

	!!! Unite the molecule with NAtoms to a singel molecule and unwrap the periodic boundary conditions.
	!!! Takes the position of the first atom in the Koords array as a reference point.
	SUBROUTINE PBC_center_molecule(NAtoms,Koords,x_box,y_box,z_box)
			!! PBC Correction of position vector, promotes vector to positix pos_vec_x,pos_vec_y,pos_vec_z make sure the input vector and the box vector is in the same length units.
			IMPLICIT NONE
			INTEGER, INTENT(IN) :: NAtoms
			REAL, INTENT(IN)::x_box,y_box,z_box
			REAL, DIMENSION (NAtoms,3),INTENT(INOUT)::Koords
			REAL, DIMENSION (3) :: box_size
			REAL, DIMENSION (3) :: pos_ref, pos_vec
			INTEGER::i,n
			logical:: debug
			
			debug=.false.
			box_size(1)=x_box
			box_size(2)=y_box
			box_size(3)=z_box
			!! Referece Position, where the molecule is united
			pos_ref=Koords(1,1:3)
			
			if(debug) write (*,*) 'Positions Reference: ',pos_ref(1:3)
			if(debug) write(*,*) 'box: ',box_size(:)
			DO n=1, NAtoms
				pos_vec(1:3)=Koords(n,1:3)
				DO i=1,3
					IF( (pos_ref(i) - pos_vec(i) ) > box_size(i)/2.0 ) THEN
							pos_vec(i) = pos_vec(i) + box_size(i)
							if(debug) write(*,*) 'Case 1'
					ELSE IF ( ( -1.0*( pos_ref(i) -  pos_vec(i) )) > box_size(i)/2.0 ) THEN
							pos_vec(i) = pos_vec(i) - box_size(i)
							if(debug) write(*,*) 'Case 2'
					ELSE
							if(debug) write(*,*) 'Case 3'
							CYCLE
					END IF
				END DO
				Koords(n,1:3) = pos_vec(1:3)
			END DO
	END SUBROUTINE PBC_center_molecule
	
	!!! delete a file and check if it was successful
	subroutine delete_file_and_check(tmp_filename)
		implicit none
		character(len=500), intent(in)::tmp_filename
		logical::Datei_vorhanden
		character(len=1000)::Bashline
						inquire(file=TRIM(tmp_filename),exist=Datei_vorhanden)
						if(Datei_vorhanden)then
								bashline=' rm '//TRIM(tmp_filename)
								WRITE(*,*) TRIM(bashline)
								CALL execute_command_line(TRIM(bashline)) 
							
						else
							WRITE(*,*) 'Error: Temporary file does not exist:  ',TRIM(tmp_filename)
							call exit(1)
						end if
	 
						inquire(file=TRIM(tmp_filename),exist=Datei_vorhanden)
						if(Datei_vorhanden)then
							write(*,*) 'Error: temporary file still exists: '//TRIM(tmp_filename)
							call exit(1)
						else
							WRITE(*,*) 'Temporary file deleted:  ',TRIM(tmp_filename)
							return
						end if
	 end subroutine delete_file_and_check
 
 !!! End Usefull functions


	Subroutine SortArray(Array1,n_max)
	!! Subroutine um eine Real Array aufsteigend zu ordnen
	!! Array1 liest den Array ein
	!! n_max gibt die Anzahl der sortierten Elemente an
			IMPLICIT NONE
			INTEGER::i,j,i_min,n_max
			Real, Dimension(:), INTENT (INOUT)::Array1 
			REAL::dummy

			! Selection Sort
			!n_max=size(Array1)
			do j=1,n_max-1 ! Durchgehen der Atome in Molekuel     
				i_min=j
					DO i=j+1,n_max ! Durchgehen von B          
					   IF( Array1(i) < Array1(i_min) ) THEN
						   i_min=i
					   END IF
					END DO    
					IF( i_min /= j ) THEN ! tauschen
						   dummy=Array1(j)
						   Array1(j)=Array1(i_min)
						   Array1(i_min)=dummy
					END IF           
			END DO

	end subroutine SortArray

	Subroutine SortArray8(Array1,n_max)
		!! Subroutine um eine Real Array aufsteigend zu ordnen
		!! Array1 liest den Array ein
		!! n_max gibt die Anzahl der sortierten Elemente an
		IMPLICIT NONE
		INTEGER::i,j,i_min,n_max
		Real*8, Dimension(:), INTENT (INOUT)::Array1 
		REAL*8::dummy

		! Selection Sort
		!n_max=size(Array1)
		do j=1,n_max-1 ! Durchgehen der Atome in Molekuel     
			i_min=j
				DO i=j+1,n_max ! Durchgehen von B          
				   IF( Array1(i) < Array1(i_min) ) THEN
					   i_min=i
				   END IF
				END DO    
				IF( i_min /= j ) THEN ! tauschen
					   dummy=Array1(j)
					   Array1(j)=Array1(i_min)
					   Array1(i_min)=dummy
				END IF           
		END DO

	end Subroutine SortArray8

	Real function angle(pointA,pointB,pointC)
			!! calculates the angle beween 3 Points in A,B,C ( A-to-B-to-C)
			IMPLICIT NONE
			Real, Dimension(3), INTENT (IN)::pointA,pointB,pointC
			REAL, DIMENSION(3)::V1,V2
			REAL, PARAMETER::PI=4.0*atan(1.0)
			V1=pointA-pointB
			V2=pointC-pointB
			angle=acos( DOT_PRODUCT(V1,V2)/(norm(V1)*norm(V2)) )*180.0/PI
	end function angle

	Subroutine setAngle(Atom1,Atom2,Atom3,SetAtom4,winkel)
	!! Atom1: Zentrum der Drehung!!!
	!! Atom2 und Atom3 sind Punkte, die die Ebene n1 mit Atom1 aufspannen.
	!! winkel: Rotationswinkel um Normalenvektor der Ebene n1
	!! SetAtom4 wird gedreht
	!! n1= Normalenvekotor der Ebene 
	!! RotAtom=dummyvektor
		IMPLICIT NONE
		Real, Dimension(3), INTENT(IN)  ::Atom1,Atom2,Atom3
		Real, Dimension(3), INTENT(OUT) ::SetAtom4
		Real, INTENT(IN) :: winkel
		Real, Dimension(3) :: n1,RotAtom

		CALL kreuzprodukt(Atom2(:)-Atom1(:),Atom3-Atom1(:),n1)

		RotAtom=SetAtom4(:)-Atom1(:)
		CALL Rotationsmatrix_alpha(RotAtom,winkel,n1,.true.)
		SetAtom4(:)=RotAtom(:)+Atom1(:)

	END Subroutine 

	Real Function getDistance(atom1,atom2)
		IMPLICIT NONE
		Real, Dimension(3), Intent(IN) :: atom1,atom2
		getDistance = SQRT((atom1(1) - atom2(1))**2 + (atom1(2) - atom2(2))**2 + (atom1(3) - atom2(3))**2)
	END Function getDistance

	Subroutine setDistance(festesAtom,varAtom,newDistance) !! varAtom verschieben Richtung beibehalten
			IMPLICIT NONE
			Real, Dimension(3) :: festesAtom,varAtom
			Real :: newDistance,oldDistance
			Integer :: j

			oldDistance = getDistance(festesAtom,varAtom)
			DO j=1,3,1
				varAtom(j) = newDistance/oldDistance *(varAtom(j)-festesAtom(j)) + festesAtom(j)
			END DO

			RETURN
	END Subroutine setDistance

	Subroutine rotate(achse1,achse2,varAtom,winkel) !rotiert varAtom um winkel Grad um Achse
		IMPLICIT NONE
		Real, Dimension(3) :: achse1,achse2,varAtom,achsvektor,rotiervektor,kreuzprod
		Real :: winkel,bogen,skalar,achsLaenge,cosinus,sinus
		Integer :: i

		bogen=winkel/180. *ACOS(-1.)  !Winkel in bogenmass umrechnen
		cosinus = COS(bogen)
		sinus = SIN(bogen)

		!achsvektor, rotiervektor und skalarprodukt berechnen
		skalar =0.
		achsLaenge = getDistance(achse1,achse2)
		DO i=1,3,1
			achsvektor(i) = (achse2(i) - achse1(i))/achsLaenge !normierter AchsVektor
			rotiervektor(i) = varAtom(i) - achse2(i)
			skalar = skalar + achsvektor(i)*rotiervektor(i)
		END DO

		!kreuzprodukt berechnen
		 CALL kreuzprodukt(achsvektor,rotiervektor,kreuzprod)

		!neue Koordinaten
		DO i=1,3,1
			varAtom(i) = (1-cosinus)*achsvektor(i)*skalar + cosinus*rotiervektor(i) +sinus*kreuzprod(i) + achse2(i)
		END DO


	END Subroutine rotate

	Subroutine Rotationsmatrix_alpha(x,winkel,Achsenvektor,beliebigeachse) 
			!!Rotation von Vektor x um winkel um eine Ursprungsgerade um die Achse mit dem Einheistvekotor n=(n_1,n_2,n_3)
			!!winkel in Grad
			!! .true. fuer Rotation um beliebige Achse n
			!! .false. fuer Ursprungsrotation um Richtung n 
			IMPLICIT NONE
			Real, INTENT(IN)::winkel
			Real, Dimension(3), INTENT(INOUT) ::x
			Real, Dimension(3), INTENT(IN) ::Achsenvektor
			Real, Dimension(3,3) ::Rotmat
			REAL, PARAMETER::Pi=4.0*atan(1.0)
			Real, Dimension(3)::n,cross1,cross2
			REAL::alpha
			LOGICAL, INTENT(IN)::beliebigeachse  ! .true. sonst Ursprungsrotation
			alpha=Pi/180.0*winkel
			n(:)=Achsenvektor(:)
			n(:)=n(:)/norm(n(:))  !Erzeuge Einheitsvekor

			IF ( beliebigeachse .EQV. .false.) THEN ! Berechnung der Rotation um Ursprungsgerade       
					RotMat(1,1)=n(1)**2*(1-cos(alpha))+cos(alpha)
					RotMat(1,2)=n(1)*n(2)*(1-cos(alpha))-n(3)*sin(alpha)
					RotMat(1,3)=n(1)*n(3)*(1-cos(alpha))+n(2)*sin(alpha)

					RotMat(2,1)=n(1)*n(2)*(1-cos(alpha))+n(3)*sin(alpha)
					RotMat(2,2)=n(2)**2*(1-cos(alpha))+cos(alpha)
					RotMat(2,3)=n(2)*n(3)*(1-cos(alpha))-n(1)*sin(alpha)


					RotMat(3,1)=n(1)*n(3)*(1-cos(alpha))-n(2)*sin(alpha)
					RotMat(3,2)=n(2)*n(3)*(1-cos(alpha))+n(1)*sin(alpha)
					RotMat(3,3)=n(3)**2*(1-cos(alpha))+cos(alpha)
			
					!write(*,*) 'Determinante der Rotationsmatrix',Det_3x3(RotMat)        
					!write(*,*) x
					!DO i=1,3
					!        write(*,*) (RotMat(i,j) j=1,3)
					!END DO
					IF ( (1.0-Det_3x3(Rotmat)) > 1.0E-4 ) THEN
						write(*,*) 'Fehler bei der Berechnung der Rotationsmatrix: Det(RotMat) /= 1.0 '
						Write(*,*) 'Beende Programm'
						CALL EXIT (1)
					END IF        
					x=MATMUL(RotMat,x)
					RETURN
			END IF
			
			! Drehung um eine beliebige Achse n
			! R_{\hat{n}}(\alpha)\vec{x}=\hat{n}(\hat{n}\cdot\vec{x})
			! +\cos\left(\alpha\right)(\hat{n}\times\vec{x})\times\hat{n}
			! +\sin\left(\alpha\right)(\hat{n}\times\vec{x})       
			IF ( beliebigeachse .EQV. .true. ) THEN  ! Drehung um Beliebige Achse
					call kreuzprodukt(n,x,cross1)
					call kreuzprodukt(cross1,n,cross2)
					x(:)=n(:)*DOT_PRODUCT(n,x)+cos(alpha)*cross2(:)+sin(alpha)*cross1(:)
					RETURN
			END IF

	end subroutine Rotationsmatrix_alpha

	real function Det_3x3(Mat)
	!! Berechnen Determinante der 3x3 Matrix mit der Regel von Sarrus
		   IMPLICIT NONE
		   REAL, DIMENSION(3,3), INTENT(IN)::Mat
	 Det_3x3=MAT(1,1)*MAT(2,2)*MAT(3,3)-MAT(3,1)*MAT(2,2)*MAT(1,3)+&
			 MAT(1,2)*MAT(2,3)*MAT(3,1)-MAT(3,2)*MAT(2,3)*MAT(1,1)+&
			 MAT(1,3)*MAT(2,1)*MAT(3,2)-MAT(3,3)*MAT(2,1)*MAT(1,2)
	end function 

	Subroutine calc_dihedral(A1,A2,A3,A4,diederwinkel)
		!! Berechnet den Diederwinkel zwischen 4 Atomen
		!! A1,A2,A3,A4 Eingangsvektoren
		!! B1,B2,B3    Verbindungsvektoren
		!! N1,N2       Ebenen-Normalenvektoren
		!! M           Orthogonalvektor, fuer lok. cart. Koordinatensystem
		IMPLICIT NONE
		REAL, DIMENSION (3), INTENT(IN) ::A1,A2,A3,A4
		REAL, INTENT (OUT)  :: diederwinkel
		REAL, DIMENSION (3) :: B1,B2,B3,N1,N2,M
		REAL::PI=4.0*atan(1.0)
		! Verbindungsvekotren festlegen
		B1(:)=A2(:)-A1(:)
		B2(:)=A3(:)-A2(:)
		B3(:)=A4(:)-A3(:)
		! Vektoren Normieren
		B1=B1/norm(B1)
		B2=B2/norm(B2)
		B3=B3/norm(B3)
		! Ebenen Vektoren
		call kreuzprodukt(B1,B2,N1)
		call kreuzprodukt(B2,B3,N2)
		call kreuzprodukt(B2,N1,M)

		diederwinkel=180.0/PI*atan2(DOT_PRODUCT(M,N2),DOT_PRODUCT(N1,N2))

	end subroutine calc_dihedral        

	subroutine set_dih_by_rotation_around_axis(atom1,atom2,atom3,atom4,dih_ziel,Rotwinkel)
		 !! Rotiert ein Atom1 (H) um die Achse Atom2-Atom3 bis der diederwinkel 
		 !! zu Atom 4 dem gewuenschten Diederwinkel:dih_ziel (Grand) A1-A2-A3-A4 entspricht.
		 IMPLICIT NONE
		 REAL, Dimension(3), INTENT(INOUT):: atom1
		 REAL, Dimension(3), INTENT(IN):: atom2,atom3,atom4
		 Real, INTENT(IN) ::dih_ziel
		 Real, INTENT(OUT)::Rotwinkel
		 Real::dih_best,dih,alpha
		 Real, Dimension(3)::X,C
		 Integer :: i

		! Bestimmung des besten Rotwinkels

		 call calc_dihedral(atom4,atom3,atom2,atom1,dih_best)
		 !write(*,*) "dih start",dih_best
		 Rotwinkel=0.0
		 C(:)=atom2(:)
		 do i=1,720,1    ! Durchlaufen der Rotationen in 1-Schritten um besten Rotationswinkel zu finden.
				alpha=0.5*i
				X=atom1(:)-C(:)
				call Rotationsmatrix_alpha(X,alpha,atom3(:)-C(:),.true.)
				call calc_dihedral(atom4,atom3,atom2,X(:)+C(:),dih)
				IF ( abs(abs(dih)-abs(dih_ziel)) < abs(abs(dih_best)-abs(dih_ziel)) ) THEN ! Abweichung von dih_ziel soll gering sein. 
						dih_best=dih
						Rotwinkel=alpha    
				END IF
		end do

		! write(*,*) 'dih=',dih,'dih_ziel=',dih_ziel,'Rotationswinkel=',Rotwinkel
		! write(*,*) 'dih_best=',dih_best
		 !Rotation von atom1 um Rotwinkel um Achse (Atom2-Atom3)

		 X=atom1(:)-C(:)
		 call Rotationsmatrix_alpha(X,Rotwinkel,atom3(:)-C(:),.true.)
		 atom1(:)=X(:)+C(:)

		  return
	end subroutine set_dih_by_rotation_around_axis 


	CHARACTER FUNCTION get_max_angular_momentum(atomsorte)
			!! holt den groessten Drehimpuls fuer dftb+ SKF-files (SlaterKosterFiles)
			IMPLICIT NONE
			Character(5), Dimension(1), INTENT(IN) :: atomsorte
			CHARACTER(1) :: l_max
			Character(5) :: element
			
			l_max=""
			element=TRIM(adjustl(delete_numbers_from_string(atomsorte(1))))
			if (TRIM(adjustl(element))=='C') THEN 
				l_max="p" 
			ELSE if (TRIM(adjustl(element))=='Ca') THEN
				l_max= "p"
			ELSE if (TRIM(adjustl(element))=='Cl') THEN
				l_max= "d"
			ELSE if (TRIM(adjustl(element))=='Br') THEN
				l_max= "d"
			ELSE if (TRIM(adjustl(element))=='F') THEN 
				l_max= "p"
			ELSE if (TRIM(adjustl(element))=='H') THEN 
				l_max= "s"
			ELSE if (TRIM(adjustl(element))=='I') THEN
				l_max= "d"
			ELSE if (TRIM(adjustl(element))=='K') THEN
				l_max= "p"
			ELSE if (TRIM(adjustl(element))=='Mg') THEN
				l_max= "p"
			ELSE if (TRIM(adjustl(element))=='N') THEN
				l_max= "p"
			ELSE if (TRIM(adjustl(element))=='Na') THEN 
				l_max= "p"
			ELSE if (TRIM(adjustl(element))=='O') THEN 
				l_max= "p"
			ELSE if (TRIM(adjustl(element))=='P') THEN 
				l_max= "d"
			ELSE if (TRIM(adjustl(element))=='S') THEN
				l_max= "d"
			ELSE if (TRIM(adjustl(element))=='Zn') THEN
				l_max= "d"
			ELSE
				WRITE(*,*) 'Error: The_selected_element_is_not_available_in_DFTB3-3OB_parameter_list: '//TRIM(element)
				WRITE(*,*) 'STOP'
				STOP
			END IF
			
			IF( LEN_TRIM(l_max) == 0)THEN
				WRITE(*,*) 'Error: The maximum angular momentum per atom was not determined correctly for "'//TRIM(element)//'".'
				WRITE(*,*) 'STOP'
				CALL EXIT(1)
			ENDIF
			get_max_angular_momentum=TRIM(l_max)
	END FUNCTION get_max_angular_momentum

	SUBROUTINE Massenschwerpunkt(atomsorte,koord,NAtoms,schwerpunkt,Kette) ! 
			!! subroutine berechnet den Massenschwerpunkt mit Ausgabe in schwerpunkt        
			!! Wenn Kette=false, dann wird die Masse fuer CH1,CH2,CH3 in gro format =0 gesetzte
			IMPLICIT NONE
			Integer, INTENT(IN)                         :: NAtoms
			Real, Dimension(NAtoms,3), INTENT(IN)       :: koord
			Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
			logical, INTENT(IN)::Kette
			Character(5)      :: element
			Real, Dimension(3)::schwerpunkt
			integer::i
			Real::m_i,m_ges

			!write(*,*) 'Start der Berechnung des Schwerpunktes'        
			schwerpunkt(:)=0
			m_ges=0
			m_i=0
			do i=1,NAtoms
			   m_i=0
			   ! GRO Ausgaben
			   if (TRIM(adjustl(atomsorte(i)))=='HC')  m_i=1.0079  ! fuer H
			   if (Kette) then
					   if (TRIM(adjustl(atomsorte(i)))=='CH1') m_i=13.0186 !  fuer 1H und 1C 
					   if (TRIM(adjustl(atomsorte(i)))=='CH2') m_i=14.0265 ! fuer 2H und 1C  
					   if (TRIM(adjustl(atomsorte(i)))=='CH3') m_i=15.0344 ! fuer 3H und 1C  
			   else
					   if (TRIM(adjustl(atomsorte(i)))=='CH1') m_i=0.0 !  fuer 1H und 1C
					   if (TRIM(adjustl(atomsorte(i)))=='CH2') m_i=0.0 ! fuer 2H und 1C
					   if (TRIM(adjustl(atomsorte(i)))=='CH3') m_i=0.0 ! fuer 3H und 1C
			   end if
			   element=TRIM(adjustl(delete_numbers_from_string(atomsorte(i))))
			   if (TRIM(adjustl(element))=='CA')  m_i=12.0107 ! fuer CA = C 
			   if (TRIM(adjustl(element))=='NR')  m_i=14.0067 ! fuer NR = N 
			   if (TRIM(adjustl(element))=='NT')  m_i=14.0067 ! fuer NT = N 
			   !richtige Elemente
			   if (TRIM(adjustl(element))=='H')  m_i=1.0079   !Wasserstoff     H       1
			   if (TRIM(adjustl(element))=='He')  m_i=4.0026  !Helium          He      2
			   if (TRIM(adjustl(element))=='Li')  m_i=6.941   !Lithium         Li      3
			   if (TRIM(adjustl(element))=='Be')  m_i=9.0122  !Beryllium       Be      4
			   if (TRIM(adjustl(element))=='B')  m_i=10.811   !Bor     B       5
			   if (TRIM(adjustl(element))=='C')  m_i=12.0107  !Kohlenstoff     C       6
			   if (TRIM(adjustl(element))=='N')  m_i=14.0067  !        Stickstoff      N       7
			   if (TRIM(adjustl(element))=='O')  m_i=15.9994  !        Sauerstoff      O       8
			   if (TRIM(adjustl(element))=='F')  m_i=18.9984  !        Fluor   F       9
			   if (TRIM(adjustl(element))=='Ne')  m_i=20.1797 !        Neon    Ne      10
			   if (TRIM(adjustl(element))=='Na')  m_i=22.9897 !        Natrium         Na      11
			   if (TRIM(adjustl(element))=='Mg')  m_i=24.305  !Magnesium       Mg      12
			   if (TRIM(adjustl(element))=='Al')  m_i=26.9815 !        Aluminum        Al      13
			   if (TRIM(adjustl(element))=='Si')  m_i=28.0855 !        Silizium        Si      14
			   if (TRIM(adjustl(element))=='P')  m_i=30.9738  !        Phosphor        P       15
			   if (TRIM(adjustl(element))=='S')  m_i=32.065   !Schwefel        S       16
			   if (TRIM(adjustl(element))=='Cl')  m_i=35.453  !Chlor   Cl      17
			   if (TRIM(adjustl(element))=='K')  m_i=39.0983  !        Kalium  K       19
			   if (TRIM(adjustl(element))=='Ar')  m_i=39.948  !Argon   Ar      18
			   if (TRIM(adjustl(element))=='Ca')  m_i=40.078  !Kalzium         Ca      20
			   if (TRIM(adjustl(element))=='Sc')  m_i=44.9559 !        Scandium        Sc      21
			   if (TRIM(adjustl(element))=='Ti')  m_i=47.867  !Titan   Ti      22
			   if (TRIM(adjustl(element))=='V')  m_i=50.9415  !        Vanadium        V       23
			   if (TRIM(adjustl(element))=='Cr')  m_i=51.9961 !        Chrom   Cr      24
			   if (TRIM(adjustl(element))=='Mn')  m_i=54.938  !Mangan  Mn      25
			   if (TRIM(adjustl(element))=='Fe')  m_i=55.845  !Eisen   Fe      26
			   if (TRIM(adjustl(element))=='Ni')  m_i=58.6934 !        Nickel  Ni      28
			   if (TRIM(adjustl(element))=='Co')  m_i=58.9332  !        Kobalt  Co      27
			   if (TRIM(adjustl(element))=='Cu')  m_i=63.546   !Kupfer  Cu      29
			   if (TRIM(adjustl(element))=='Zn')  m_i=65.39    !Zink    Zn      30
			   if (TRIM(adjustl(element))=='Ga')  m_i=69.723   !Gallium         Ga      31
			   if (TRIM(adjustl(element))=='Ge')  m_i=72.64    !Germanium       Ge      32
			   if (TRIM(adjustl(element))=='As')  m_i=74.9216  !        Arsen   As      33
			   if (TRIM(adjustl(element))=='Se')  m_i=78.96    !Selen   Se      34
			   if (TRIM(adjustl(element))=='Br')  m_i=79.904   !Brom    Br      35
			   if (TRIM(adjustl(element))=='Kr')  m_i=83.8     !Krypton         Kr      36
			   if (TRIM(adjustl(element))=='Rb')  m_i=85.4678  !        Rubidium        Rb      37
			   if (TRIM(adjustl(element))=='Sr')  m_i=87.62    !Strontium       Sr      38
			   if (TRIM(adjustl(element))=='Y')  m_i=88.9059   !        Yttrium         Y       39
			   if (TRIM(adjustl(element))=='Zr')  m_i=91.224   !Zirkonium       Zr      40
			   if (TRIM(adjustl(element))=='Nb')  m_i=92.9064  !        Nobium  Nb      41
			   if (TRIM(adjustl(element))=='Mo')  m_i=95.94   !Molybdaen        Mo      42
			   if (TRIM(adjustl(element))=='Tc')  m_i=98      !Technetium      Tc      43
			   if (TRIM(adjustl(element))=='Ru')  m_i=101.07  !Ruthenium       Ru      44
			   if (TRIM(adjustl(element))=='Rh')  m_i=102.9055!        Rhodium         Rh      45
			   if (TRIM(adjustl(element))=='Pd')  m_i=106.42  !Palladium       Pd      46
			   if (TRIM(adjustl(element))=='Ag')  m_i=107.8682!        Silber  Ag      47
			   if (TRIM(adjustl(element))=='Cd')  m_i=112.411 !        Kadmium         Cd      48
			   if (TRIM(adjustl(element))=='In')  m_i=114.818 !        Indium  In      49
			   if (TRIM(adjustl(element))=='Sn')  m_i=118.71  !Zinn    Sn      50
			   if (TRIM(adjustl(element))=='Sb')  m_i=121.76  !Antimon         Sb      51
			   if (TRIM(adjustl(element))=='I')  m_i=126.9045!        Jod     I       53
			   if (TRIM(adjustl(element))=='Te')  m_i=127.6   !Tellur  Te      52
			   if (TRIM(adjustl(element))=='Xe')  m_i=131.293 !        Xenon   Xe      54
			   if (TRIM(adjustl(element))=='Re')  m_i=186.207 !        Rhenium         Re      75
			   if (TRIM(adjustl(element))=='Os')  m_i=190.23  !Osmium  Os      76
			   if (TRIM(adjustl(element))=='Ir')  m_i=192.217 !        Iridium         Ir      77
			   if (TRIM(adjustl(element))=='Pt')  m_i=195.078 !        Platin  Pt      78
			   if (TRIM(adjustl(element))=='Au')  m_i=196.9665!        Gold    Au      79
			   if (TRIM(adjustl(element))=='Hg')  m_i=200.59  !Quecksilber     Hg      80
			   if (TRIM(adjustl(element))=='Tl')  m_i=204.3833!        Thallium        Tl      81
			   if (TRIM(adjustl(element))=='Pb')  m_i=207.2   !Blei    Pb      82
			   if (TRIM(adjustl(element))=='Bi')  m_i=208.9804!        Wismut  Bi      83
			   if (TRIM(adjustl(element))=='Po')  m_i=209     !Polonium        Po      84
			   if (TRIM(adjustl(element))=='At')  m_i=210 !Astat   At      85
			   if (TRIM(adjustl(element))=='Rn')  m_i=222 !    Radon
			   
			   schwerpunkt(:)=schwerpunkt(:)+m_i*koord(i,:)     
			   m_ges=m_ges+m_i     
			   !write(*,*) m_i,schwerpunkt/real(m_ges)
			end do 
			schwerpunkt=schwerpunkt/real(m_ges)
	 
			!WRITE(*,*) 'Die Anzahl der Elekronen im neutralen Molekuel ist',z_ges
			!write(*,*) 'Der Schwerpunkt liegt bei ', schwerpunkt
	END SUBROUTINE Massenschwerpunkt
	
	REAL FUNCTION element_to_mass(atomsorte,Kette)
	   !! gets the Element symbol and returns the atomic mass in a.u.
	   !! Default Kette= .false.
	   IMPLICIT NONE
	   Character(LEN=*) , INTENT(IN):: atomsorte
	   LOGICAL, INTENT(IN) :: Kette
	   REAL::mass
	   mass=0.0
	   if (Kette) then
		  if (TRIM(adjustl(atomsorte))=='CH1') THEN
						 element_to_mass=13.0186 !  fuer 1H und 1C 
						 return 
		  ELSE if (TRIM(adjustl(atomsorte))=='CH2') THEN
						 element_to_mass=14.0265 ! fuer 2H und 1C  
						  return 
		  ELSE if (TRIM(adjustl(atomsorte))=='CH3') THEN
						 element_to_mass=15.0344 ! fuer 3H und 1C  
						  Return 
		  END IF
	   END IF ! Kette = .true.
	   
	   SELECT CASE (TRIM(adjustl(atomsorte)))
			 CASE('HC')  
				mass=1.0079  ! fuer H
			 CASE('CH1') 
						 mass=0.0 !  fuer 1H und 1C
			 CASE('CH2') 
						 mass=0.0 ! fuer 2H und 1C
			 CASE('CH3') 
						 mass=0.0 ! fuer 3H und 1C
			   CASE('CA')  
				mass=12.0107 ! fuer CA = C 
			   CASE('NR')  
				mass=14.0067 ! fuer NR = N 
			   CASE('NT')  
				mass=14.0067 ! fuer NT = N 
			   !richtige Elemente
			   CASE('H')  
				mass=1.0079   !Wasserstoff     H       1
			   CASE('He')  
				mass=4.0026  !Helium          He      2
			   CASE('Li')  
				mass=6.941   !Lithium         Li      3
			   CASE('Be')  
				mass=9.0122  !Beryllium       Be      4
			   CASE('B')  
				mass=10.811   !Bor     B       5
			   CASE('C')  
				mass=12.0107  !Kohlenstoff     C       6
			   CASE('N')  
				mass=14.0067  !        Stickstoff      N       7
			   CASE('O')  
				mass=15.9994  !        Sauerstoff      O       8
			   CASE('F')  
				mass=18.9984  !        Fluor   F       9
			   CASE('Ne')  
				mass=20.1797 !        Neon    Ne      10
			   CASE('Na')  
				mass=22.9897 !        Natrium         Na      11
			   CASE('Mg')  
				mass=24.305  !Magnesium       Mg      12
			   CASE('Al')  
				mass=26.9815 !        Aluminum        Al      13
			   CASE('Si')  
				mass=28.0855 !        Silizium        Si      14
			   CASE('P')  
				mass=30.9738  !        Phosphor        P       15
			   CASE('S')  
				mass=32.065   !Schwefel        S       16
			   CASE('Cl')  
				mass=35.453  !Chlor   Cl      17
			   CASE('K')  
				mass=39.0983  !        Kalium  K       19
			   CASE('Ar')  
				mass=39.948  !Argon   Ar      18
			   CASE('Ca')  
				mass=40.078  !Kalzium         Ca      20
			   CASE('Sc')  
				mass=44.9559 !        Scandium        Sc      21
			   CASE('Ti')  
				mass=47.867  !Titan   Ti      22
			   CASE('V')  
				mass=50.9415  !        Vanadium        V       23
			   CASE('Cr')  
				mass=51.9961 !        Chrom   Cr      24
			   CASE('Mn')  
				mass=54.938  !Mangan  Mn      25
			   CASE('Fe')  
				mass=55.845  !Eisen   Fe      26
			   CASE('Ni')  
				mass=58.6934 !        Nickel  Ni      28
			   CASE('Co')  
				mass=58.9332  !        Kobalt  Co      27
			   CASE('Cu')  
				mass=63.546   !Kupfer  Cu      29
			   CASE('Zn')  
				mass=65.39    !Zink    Zn      30
			   CASE('Ga')  
				mass=69.723   !Gallium         Ga      31
			   CASE('Ge')  
				mass=72.64    !Germanium       Ge      32
			   CASE('As')  
				mass=74.9216  !        Arsen   As      33
			   CASE('Se')  
				mass=78.96    !Selen   Se      34
			   CASE('Br')  
				mass=79.904   !Brom    Br      35
			   CASE('Kr')  
				mass=83.8     !Krypton         Kr      36
			   CASE('Rb')  
				mass=85.4678  !        Rubidium        Rb      37
			   CASE('Sr')  
				mass=87.62    !Strontium       Sr      38
			   CASE('Y')  
				mass=88.9059   !        Yttrium         Y       39
			   CASE('Zr')  
				mass=91.224   !Zirkonium       Zr      40
			   CASE('Nb')  
				mass=92.9064  !        Nobium  Nb      41
			   CASE('Mo')  
				mass=95.94   !Molybdaen        Mo      42
			   CASE('Tc')  
				mass=98      !Technetium      Tc      43
			   CASE('Ru')  
				mass=101.07  !Ruthenium       Ru      44
			   CASE('Rh')  
				mass=102.9055!        Rhodium         Rh      45
			   CASE('Pd')  
				mass=106.42  !Palladium       Pd      46
			   CASE('Ag')  
				mass=107.8682!        Silber  Ag      47
			   CASE('Cd')  
				mass=112.411 !        Kadmium         Cd      48
			   CASE('In')  
				mass=114.818 !        Indium  In      49
			   CASE('Sn')  
				mass=118.71  !Zinn    Sn      50
			   CASE('Sb')  
				mass=121.76  !Antimon         Sb      51
			   CASE('I')  
				mass=126.9045!        Jod     I       53
			   CASE('Te')  
				mass=127.6   !Tellur  Te      52
			   CASE('Xe')  
				mass=131.293 !        Xenon   Xe      54
			   CASE('Re')  
				mass=186.207 !        Rhenium         Re      75
			   CASE('Os')  
				mass=190.23  !Osmium  Os      76
			   CASE('Ir')  
				mass=192.217 !        Iridium         Ir      77
			   CASE('Pt')  
				mass=195.078 !        Platin  Pt      78
			   CASE('Au')  
				mass=196.9665!        Gold    Au      79
			   CASE('Hg')  
				mass=200.59  !Quecksilber     Hg      80
			   CASE('Tl')  
				mass=204.3833!        Thallium        Tl      81
			   CASE('Pb')  
				mass=207.2   !Blei    Pb      82
			   CASE('Bi')  
				mass=208.9804!        Wismut  Bi      83
			   CASE('Po')  
				mass=209     !Polonium        Po      84
			   CASE('At')  
				mass=210 !Astat   At      85
			   CASE('Rn')  
				mass=222 !    Radon
			 CASE DEFAULT
				mass=0.0
				WRITE(*,*) 'WARNING! Element symbol was not recognized. Mass is set to zero for: '//TRIM(adjustl(atomsorte))
			 END SELECT    
		  element_to_mass=mass
	END FUNCTION element_to_mass

	INTEGER FUNCTION Calc_N_electrons_in(atomsorte,N_Atoms,Kette)  
			!! Berechnet der Anzahl der Elektronen        
			!! Wenn Kette=false, dann wird die Ladung fuer CH1,CH2,CH3 in gro format =0 gesetzte
			IMPLICIT NONE
			Integer, INTENT(IN)  :: N_Atoms
			Character(5), Dimension(N_Atoms), INTENT(IN) :: atomsorte
			Character(5)  ::element
			LOGICAL, INTENT(IN)::Kette 
			integer   ::i
			integer   ::z_ges,z_i

		   ! Berechnung der Anzahl der Elektronen im neutralen Molekuel z_ges 
			z_ges=0
			DO i=1,N_Atoms
			   z_i=0
			   ! .gro Gruppen
			   
			   if (KETTE) THEN 
					if (TRIM(adjustl(atomsorte(i)))=='CH1') z_i=12   ! fuer 1H und 1C 
					if (TRIM(adjustl(atomsorte(i)))=='CH2') z_i=14   ! fuer 2H und 1C  
					if (TRIM(adjustl(atomsorte(i)))=='CH3') z_i=15   ! fuer 3H und 1C  
			   else 
					if (TRIM(adjustl(atomsorte(i)))=='CH1') z_i=0   ! fuer 1H und 1C 
					if (TRIM(adjustl(atomsorte(i)))=='CH2') z_i=0   ! fuer 2H und 1C  
					if (TRIM(adjustl(atomsorte(i)))=='CH3') z_i=0   ! fuer 3H und 1C  
			   end if
			   element=TRIM(adjustl(delete_numbers_from_string(atomsorte(i))))
			   if (TRIM(adjustl(element))=='HC')  z_i=1    ! fuer H
			   if (TRIM(adjustl(element))=='CA')  z_i=12   ! fuer CA = C  
			   if (TRIM(adjustl(element))=='NR')  z_i=7   ! fuer NR = N 
			   if (TRIM(adjustl(element))=='NT')  z_i=7   ! fuer NT = N 
			   ! normale Atome
			   if (TRIM(adjustl(element))=='H')  z_i=1!Wasserstoff     H       1
			   if (TRIM(adjustl(element))=='He') z_i=2!Helium          He      2
			   if (TRIM(adjustl(element))=='Li') z_i=3!Lithium         Li      3
			   if (TRIM(adjustl(element))=='Be') z_i=4!Beryllium       Be      4
			   if (TRIM(adjustl(element))=='B')  z_i=5!Bor     B       5
			   if (TRIM(adjustl(element))=='C')  z_i=6!Kohlenstoff     C       6
			   if (TRIM(adjustl(element))=='N')  z_i=7!        Stickstoff      N       7
			   if (TRIM(adjustl(element))=='O')  z_i=8!        Sauerstoff      O       8
			   if (TRIM(adjustl(element))=='F')  z_i=9!        Fluor   F       9
			   if (TRIM(adjustl(element))=='Ne') z_i=10!        Neon    Ne      10
			   if (TRIM(adjustl(element))=='Na') z_i=11!        Natrium         Na      11
			   if (TRIM(adjustl(element))=='Mg') z_i=12!Magnesium       Mg      12
			   if (TRIM(adjustl(element))=='Al') z_i=13!        Aluminum        Al      13
			   if (TRIM(adjustl(element))=='Si') z_i=14!        Silizium        Si      14
			   if (TRIM(adjustl(element))=='P')  z_i=15!        Phosphor        P       15
			   if (TRIM(adjustl(element))=='S')  z_i=16!Schwefel        S       16
			   if (TRIM(adjustl(element))=='Cl') z_i=17!Chlor   Cl      17
			   if (TRIM(adjustl(element))=='K')  z_i=19!        Kalium  K       19
			   if (TRIM(adjustl(element))=='Ar') z_i=17!Argon   Ar      18
			   if (TRIM(adjustl(element))=='Ca') z_i=20!Kalzium         Ca      20
			   if (TRIM(adjustl(element))=='Sc') z_i=21!        Scandium        Sc      21
			   if (TRIM(adjustl(element))=='Ti') z_i=22!Titan   Ti      22
			   if (TRIM(adjustl(element))=='V')  z_i=23 !        Vanadium        V       23
			   if (TRIM(adjustl(element))=='Cr') z_i=24!        Chrom   Cr      24
			   if (TRIM(adjustl(element))=='Mn') z_i=25!Mangan  Mn      25
			   if (TRIM(adjustl(element))=='Fe') z_i=26!Eisen   Fe      26
			   if (TRIM(adjustl(element))=='Ni') z_i=28!        Nickel  Ni      28
			   if (TRIM(adjustl(element))=='Co') z_i=27!        Kobalt  Co      27
			   if (TRIM(adjustl(element))=='Cu') z_i=29!Kupfer  Cu      29
			   if (TRIM(adjustl(element))=='Zn') z_i=30!Zink    Zn      30
			   if (TRIM(adjustl(element))=='Ga') z_i=31!Gallium         Ga      31
			   if (TRIM(adjustl(element))=='Ge') z_i=32!Germanium       Ge      32
			   if (TRIM(adjustl(element))=='As') z_i=33!        Arsen   As      33
			   if (TRIM(adjustl(element))=='Se') z_i=34!Selen   Se      34
			   if (TRIM(adjustl(element))=='Br') z_i=35!Brom    Br      35
			   if (TRIM(adjustl(element))=='Kr') z_i=36!Krypton         Kr      36
			   if (TRIM(adjustl(element))=='Rb') z_i=37!        Rubidium        Rb      37
			   if (TRIM(adjustl(element))=='Sr') z_i=38!Strontium       Sr      38
			   if (TRIM(adjustl(element))=='Y')  z_i=39!        Yttrium         Y       39
			   if (TRIM(adjustl(element))=='Zr') z_i=40!Zirkonium       Zr      40
			   if (TRIM(adjustl(element))=='Nb') z_i=41!        Nobium  Nb      41
			   if (TRIM(adjustl(element))=='Mo') z_i=42!Molybdaen        Mo      42
			   if (TRIM(adjustl(element))=='Tc') z_i=43!Technetium      Tc      43
			   if (TRIM(adjustl(element))=='Ru') z_i=44!Ruthenium       Ru      44
			   if (TRIM(adjustl(element))=='Rh') z_i=45!        Rhodium         Rh      45
			   if (TRIM(adjustl(element))=='Pd') z_i=46!Palladium       Pd      46
			   if (TRIM(adjustl(element))=='Ag') z_i=47!        Silber  Ag      47
			   if (TRIM(adjustl(element))=='Cd') z_i=48!        Kadmium         Cd      48
			   if (TRIM(adjustl(element))=='In') z_i=49!        Indium  In      49
			   if (TRIM(adjustl(element))=='Sn') z_i=50!Zinn    Sn      50
			   if (TRIM(adjustl(element))=='Sb') z_i=51!Antimon         Sb      51
			   if (TRIM(adjustl(element))=='I')  z_i=53!        Jod     I       53
			   if (TRIM(adjustl(element))=='Te') z_i=52!Tellur  Te      52
			   if (TRIM(adjustl(element))=='Xe') z_i=54!        Xenon   Xe      54
			   if (TRIM(adjustl(element))=='Re') z_i=75!        Rhenium         Re      75
			   if (TRIM(adjustl(element))=='Os') z_i=76!Osmium  Os      76
			   if (TRIM(adjustl(element))=='Ir') z_i=77!        Iridium         Ir      77
			   if (TRIM(adjustl(element))=='Pt') z_i=78!        Platin  Pt      78
			   if (TRIM(adjustl(element))=='Au') z_i=79!        Gold    Au      79
			   if (TRIM(adjustl(element))=='Hg') z_i=80!Quecksilber     Hg      80
			   if (TRIM(adjustl(element))=='Tl') z_i=81!        Thallium        Tl      81
			   if (TRIM(adjustl(element))=='Pb') z_i=82!Blei    Pb      82
			   if (TRIM(adjustl(element))=='Bi') z_i=83!        Wismut  Bi      83
			   if (TRIM(adjustl(element))=='Po') z_i=84    !Polonium        Po      84
			   if (TRIM(adjustl(element))=='At') z_i=85     !Astat   At      85
			   if (TRIM(adjustl(element))=='Rn') z_i=86      !    Radon
			   
				IF (z_i==0 .and. KETTE) THEN
					WRITE(*,*) 'Es ist ein Fehler bei der Berechnung der Elektronenanzahl z_ges aufgetreten!'
				END IF
				z_ges=z_ges+z_i
			END DO
		Calc_N_electrons_in=z_ges
	END FUNCTION Calc_N_electrons_in

	SUBROUTINE Read_coord_from_xyz(atomsorteA,koordA,xyz_inputfile)
		!! SUBROUTINE zum Einlesen von Molekuelkoordinaten aus einer xyz-Datei.
		!! Dateiname ist xyz_inputfile mit oder ohne .xyz Endung.
		IMPLICIT NONE
		Real, ALLOCATABLE, Dimension(:,:), INTENT(OUT)       :: koordA
		Character(5), ALLOCATABLE, Dimension(:), INTENT(OUT) :: atomsorteA
		Character(500), INTENT (IN) :: xyz_inputfile
		Character(500)              :: xyzfilename
		INTEGER::i,ierror,NAtoms
			
			if(check_filetermination_and_continue(xyz_inputfile,'.xyz')) then
				xyzfilename=TRIM(xyz_inputfile)
			else
				xyzfilename=TRIM(xyz_inputfile)//'.xyz'
			endif
			
			IF(file_exists(xyzfilename))THEN
				OPEN(UNIT=78,FILE=TRIM(xyzfilename),STATUS='OLD',IOSTAT=ierror)
				WRITE(*,*) TRIM(xyzfilename)
				READ(78,*,IOSTAT=ierror) NAtoms
				IF(ierror>0) THEN
							WRITE(*,*) 'Fehler beim Einlesen: '//TRIM(xyzfilename)
							STOP
				END IF
				READ(78,*,IOSTAT=ierror) 
				ALLOCATE(atomsorteA(NAtoms))
				ALLOCATE(koordA(NAtoms,3))
				DO i=1,NAtoms
					READ(78,*,IOSTAT=ierror) atomsorteA(i),koordA(i,1),koordA(i,2),koordA(i,3)
					!WRITE(*,*) atomsorteA(i),koordA(i,1),koordA(i,2),koordA(i,3)
					IF(ierror < 0) EXIT
					IF(ierror > 0) THEN
						WRITE(*,*) 'Es ist eine Fehler beim Einlesen von ',TRIM(xyzfilename),' aufgetreten.'
						WRITE(*,*) 'Beende Einlesen !'
						STOP
					END IF
				END DO
				CLOSE(78)
			ENDIF
	END SUBROUTINE Read_coord_from_xyz

	SUBROUTINE make_coord_to_xyz(atomsorte,koord,NAtoms,ziel)
		!! Subroutine um aus den Inputkoordinaten eine xyz-Datei zu erstellen.
		IMPLICIT NONE
		Integer, INTENT (IN):: NAtoms
		Real, Dimension(NAtoms,3), INTENT (IN) :: koord
		Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
		Character(500), INTENT (IN) :: ziel
		Character(500)              :: xyzfilename
		Character(5) :: element
		Integer :: i,ierror
		
		if(check_filetermination_and_continue(ziel,'.xyz')) then
			xyzfilename=TRIM(ziel)
		else
			xyzfilename=TRIM(ziel)//'.xyz'
		endif
		
		OPEN(UNIT=77,FILE=TRIM(xyzfilename),STATUS='REPLACE',IOSTAT=ierror)
		Write(77,*) NAtoms
		Write(77,*) TRIM(ziel)
		DO i= 1, NAtoms, 1
			element=TRIM(adjustl(delete_numbers_from_string(atomsorte(i))))
			write(77,'(2X,A3,1X,3F16.6)') TRIM(adjustl(element)),koord(i,1),koord(i,2),koord(i,3)
		END DO
		ClOSE(77)
		WRITE(*,*) 'Koordinaten in ',TRIM(xyzfilename),' geschrieben.'

	END SUBROUTINE make_coord_to_xyz

	SUBROUTINE make_coord_to_xyz_in_dir(atomsorte,koord,NAtoms,ziel,foldername)
		!! Subroutine um aus den Inputkoordinaten eine xyz-Datei in einem Unterordner "foldername" zu erstellen.
		IMPLICIT NONE
		Integer, INTENT (IN):: NAtoms
		Real, Dimension(NAtoms,3), INTENT (IN)      :: koord
		Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
		Character(500), INTENT (IN) :: ziel
		Character(100)  :: foldername
		Character(5000) :: bashline
		Character(500)  :: xyzfilename
		Character(5)    :: element
		Integer :: i,ierror
		LOGICAL::folder_vorhanden
		
		inquire(file=TRIM(foldername),exist=folder_vorhanden) ! Erstelle Ordner, wenn er noch nicht existiert
		if (.NOT. folder_vorhanden) THEN
				write(bashline,*) 'mkdir '//TRIM(foldername)
				CALL execute_command_line(TRIM(bashline)) 
				WRITE(*,*) TRIM(bashline)
		END IF
		
		if(check_filetermination_and_continue(ziel,'.xyz')) then
			xyzfilename=TRIM(ziel)
		else
			xyzfilename=TRIM(ziel)//'.xyz'
		endif
		
		OPEN(UNIT=77,FILE=TRIM(foldername)//'/'//TRIM(xyzfilename),STATUS='REPLACE',IOSTAT=ierror)
		Write(77,*) NAtoms
		Write(77,*) TRIM(ziel)
		DO i= 1, NAtoms, 1
			element=TRIM(adjustl(delete_numbers_from_string(atomsorte(i))))
			write(77,'(2X,A3,1X,3F16.6)') TRIM(adjustl(element)),koord(i,1),koord(i,2),koord(i,3)
		END DO
		ClOSE(77)
		WRITE(*,*) 'Koordinaten in ',TRIM(foldername)//'/'//TRIM(xyzfilename)//' geschrieben.'

	END SUBROUTINE make_coord_to_xyz_in_dir


	!! Calculate RCOM und d_RCOM
	SUBROUTINE calc_COM_S_MA(atomsorteA,koordA,NAtomsA,atomsorteB,koordB,NAtomsB,COM_S_MA,d_RCOM)
		!! Subroutine um den COM_Abstand_der Ringe mit S-Atomen als Minimalen Abstand der einzelnen Ringe (COM_S_MA) zweier Molekuele A und B zu berechnen.
		!! d_RCOM ist der Verbinungsvektor.
		!! Es werden erst in N_COM_1,N_COM_2 jeweils die Schwerpunkte der Ringe bestimmt und dann wird der kleinste Abstand zwischen zwei COMs aus A und B als COM_S_MA verwendet. 
		!! Ausgabe in Ang, wenn .xyz als Eingabeformat verwendet wird. 
			IMPLICIT NONE
			Integer, INTENT(IN) :: NAtomsA
			Real, Dimension(NAtomsA,3), INTENT(IN) :: koordA
			Character(5), Dimension(NAtomsA), INTENT(IN) :: atomsorteA
			Integer, INTENT(IN) :: NAtomsB
			Real, Dimension(NAtomsB,3), INTENT(IN)       :: koordB
			Character(5), Dimension(NAtomsB), INTENT(IN) :: atomsorteB
			REAL, INTENT(OUT)                :: COM_S_MA
			REAL, DIMENSION(3) , INTENT(OUT) :: d_RCOM
			LOGICAL::KETTE=.false.
			Real, Dimension(6,3) ::Ringe_atome
			Character(5), Dimension(6) :: Ringe_atomsorte
			Real, Allocatable, Dimension(:,:)::N_COM_1,N_COM_2
			INTEGER:: N_Schwefel_1,N_Schwefel_2
			REAL, Dimension(3)::COM_1,COM_2
			INTEGER::i,j,ind,i_COM_1,i_COM_2
			REAL::dist_COM
			
			COM_S_MA=0.0
			N_Schwefel_1=0
			DO j=1,NAtomsA
				   if (TRIM(adjustl(atomsorteA(j)))=='S') N_Schwefel_1=N_Schwefel_1+1
				   if (TRIM(adjustl(atomsorteA(j)))=='S-S_R') N_Schwefel_1=N_Schwefel_1+1
			END DO
			N_Schwefel_2=0
			DO j=1,NAtomsB
				  if (TRIM(adjustl(atomsorteB(j)))=='S') N_Schwefel_2=N_Schwefel_2+1
				  if (TRIM(adjustl(atomsorteB(j)))=='S-S_R') N_Schwefel_2=N_Schwefel_2+1
			END DO

			ind=0 ! index fur die Atome in den Ringen von Mol A
			i_COM_1=0 ! index fuer die Anzahl der Schwerpunkt von A
			IF (N_Schwefel_1==0) THEN
					ALLOCATE(N_COM_1(1,3))
					i_COM_1=1
					call Massenschwerpunkt(atomsorteA,koordA,NAtomsA,N_COM_1(1,:),KETTE)
			ELSE
					ALLOCATE(N_COM_1(N_Schwefel_1,3))
					DO i=1,NAtomsA
							IF( (TRIM(adjustl(atomsorteA(i)))=='S') .OR. (TRIM(adjustl(atomsorteA(i)))=='S-S_R') )THEN
									DO j=(i-5),i,1
											ind=ind+1
											Ringe_atomsorte(ind)=atomsorteA(j)
											Ringe_atome(ind,:)=koordA(j,:)
											!WRITE(*,*) ind,Ringe_atomsorte(ind),Ringe_atome(ind,:)
									END DO
									! Abspeichern des COM des Ringes
									IF (ind == 6) THEN
											! Korrektur, wenn das Ende der THP Kette erreicht ist, da hier die Reihung geaendert ist,
											! ersetze End HC durch CA in der Liste 
											IF( (TRIM(adjustl(atomsorteA(i-1)))=='H') .OR. (TRIM(adjustl(atomsorteA(i-1)))=='HC') .OR.&
													& (TRIM(adjustl(atomsorteA(i-1)))=='H-H_') ) THEN
													Ringe_atomsorte(5)=atomsorteA(j-7)
													Ringe_atome(5,:)=koordA(j-7,:)
													!WRITE(*,*) 'Ersetzt CA:', Ringe_atomsorte(5),Ringe_atome(5,:)
											END IF

											ind=0
											i_COM_1=i_COM_1+1
											call Massenschwerpunkt(Ringe_atomsorte,Ringe_atome,6,COM_1,.false.)
											N_COM_1(i_COM_1,:)=COM_1(:)
											!WRITE(*,*) 'COM_1',COM_1(:)
									END IF ! calc COM_1
							END IF ! S = ?                        
							!WRITE(*,*) atomsorteA(i),koordA(i,:)
					END DO ! i=,1,NAtomsA
			END IF ! N_Schwefel_1==0

			ind=0 ! index fur die Atome in den Ringen von Mol B
			i_COM_2=0 ! index fuer die Anzahl der Schwerpunkt von B
			IF (N_Schwefel_2==0) THEN
					ALLOCATE(N_COM_2(1,3))
					i_COM_2=1
					call Massenschwerpunkt(atomsorteB,koordB,NAtomsB,N_COM_2(1,:),KETTE)
			ELSE
					ALLOCATE(N_COM_2(N_Schwefel_2,3))
					DO i=1,NAtomsB
							IF( (TRIM(adjustl(atomsorteB(i)))=='S') .OR. (TRIM(adjustl(atomsorteB(i)))=='S-S_R') )THEN
									DO j=(i-5),i,1
											ind=ind+1
											Ringe_atomsorte(ind)=atomsorteB(j)
											Ringe_atome(ind,:)=koordB(j,:)
											!WRITE(*,*) ind,Ringe_atomsorte(ind),Ringe_atome(ind,:)
									END DO
									! Abspeichern des COM des Ringes
									IF (ind == 6) THEN ! calc COM_2
											! Korrektur, wenn das Ende der THP Kette erreicht ist, da hier die Reihung geaendert ist,
											! ersetze End HC durch CA in der Liste 
											IF( (TRIM(adjustl(atomsorteB(i-1)))=='H') .OR. (TRIM(adjustl(atomsorteB(i-1)))=='HC') .OR.&
													& (TRIM(adjustl(atomsorteB(i-1)))=='H-H_') ) THEN
													Ringe_atomsorte(5)=atomsorteB(j-7)
													Ringe_atome(5,:)=koordB(j-7,:)
													!WRITE(*,*) 'Ersetzt CA:', Ringe_atomsorte(5),Ringe_atome(5,:)
											END IF

											ind=0
											i_COM_2=i_COM_2+1
											call Massenschwerpunkt(Ringe_atomsorte,Ringe_atome,6,COM_2,.false.)
											N_COM_2(i_COM_2,:)=COM_2(:)
											!WRITE(*,*) 'COM_2',COM_2(:)
									END IF ! calc COM_2
							END IF ! S = ?               
							! WRITE(*,*) atomsorteB(i),koordB(i,:)
					END DO ! i=,1,NAtomsB
			END IF ! N_Schwefel_2==0
		  
			!! Berechne minimalen Abstand der COM
			COM_S_MA=norm(N_COM_1(1,:)-N_COM_2(1,:)) 
			d_RCOM(:)=N_COM_2(1,:)-N_COM_1(1,:)
			IF( (N_Schwefel_1 /= 0) .OR. (N_Schwefel_2 /= 0) ) THEN 
					DO i=1,i_COM_1
							DO j=1,i_COM_2
									dist_COM=norm(N_COM_1(i,:)-N_COM_2(j,:))
									IF( dist_COM < COM_S_MA) THEN
											d_RCOM(:)=N_COM_2(j,:)-N_COM_1(i,:)
											COM_S_MA=dist_COM
											!WRITE(*,*) i,j,COM_S_MA
									END IF
							END DO !j
					END DO !i
			END IF
			
			WRITE(*,*) 'COM_S_MA: ', COM_S_MA 

			! WRITE(*,*) 'COM_1'
			!DO i=1,i_COM_1
			!        WRITE(*,*) N_COM_1(i,:)
			!END DO 
		   
			!WRITE(*,*) 'COM_2'
			!DO i=1,i_COM_2
			!        WRITE(*,*) N_COM_2(i,:)
			!END DO 

	END SUBROUTINE calc_COM_S_MA
	!! Calculate   MA und d_MA
	SUBROUTINE calc_min_dist_MA_dimer(atomsorteA,koordA,NAtomsA,atomsorteB,koordB,NAtomsB,Abstand_min,d_MA)
	!! Subroutine um den Minimalen Abstand (MA) zweier Molekuele A und B zu berechnen.
	!! d_MA ist der Vektor mit minimalem Abstand von A nach B     d_MA =  min( R_B - R_A )
	!! Also den kleinen moeglichen Abstand zweier Atome
	IMPLICIT NONE
	INTEGER, INTENT(IN) :: NAtomsA
	REAL, Dimension(NAtomsA,3), INTENT(IN) :: koordA
	Character(5), Dimension(NAtomsA), INTENT(IN) :: atomsorteA
	INTEGER, INTENT(IN) :: NAtomsB
	REAL, Dimension(NAtomsB,3), INTENT(IN)       :: koordB
	Character(5), Dimension(NAtomsB), INTENT(IN) :: atomsorteB
	REAL, INTENT(OUT)::Abstand_min
	REAL, Dimension(3) ::Atom1, d_MA
	REAL:: Abstand
	INTEGER::i,j,i_min,j_min
	LOGICAL :: debug=.false.
	
	Abstand_min=getDistance(koordA(1,:),koordB(1,:))
	d_MA=0

	DO i=1,NAtomsA ! Durchgehen der Atome in Molekuel    
		i_min=i
		j_min=1
		Atom1=koordA(i,:)
		DO j=1,NAtomsB ! Durchgehen von B
			Abstand=getDistance(Atom1,koordB(j,:))
			IF( Abstand <= Abstand_min) THEN
				Abstand_min=Abstand
				i_min=i
				j_min=j
			END IF
		END DO
	END DO

	d_MA(:)=koordB(j_min,:) - koordA(i_min,:)
	
	if(debug) then
		WRITE(*,*) 'Der Minimalabstand (MA) zwischen dem Atom ',i_min,atomsorteA(i_min),' aus mol A'
		WRITE(*,*) 'und dem Atom ',j_min,atomsorteB(j_min),' aus mol B ist [Ang]', Abstand_min
		WRITE(*,*) atomsorteA(i_min),koordA(i_min,1),koordA(i_min,2),koordA(i_min,3)
		WRITE(*,*) atomsorteB(j_min),koordB(j_min,1),koordB(j_min,2),koordB(j_min,3)
	endif
	
	
	END SUBROUTINE calc_min_dist_MA_dimer
	!! Calculate   MMA und d_MMA
	SUBROUTINE calc_mittlerer_minimal_Abstand_MMA_dimer(koordA,NAtomsA,koordB,NAtomsB,MMA,d_MMA)
	!! Subroutine um den mittlere Minimalabstand (MMA) und den gemittelten Vektor  zweier  Molekuele A und B zu berechnen.
	!! Also den fuer jedes Atom in Molekuel A wird der Abstand zu allen anderen Atomen in Molekuel B bestimmt und der Abstaende werden gemittelt.
		IMPLICIT NONE
		INTEGER, INTENT(IN) :: NAtomsA
		REAL, Dimension(NAtomsA,3), INTENT(IN) :: koordA
		!Character(5), Dimension(NAtomsA), INTENT(IN) :: atomsorteA
		Integer, INTENT(IN) :: NAtomsB
		REAL, Dimension(NAtomsB,3), INTENT(IN)       :: koordB
		!Character(5), Dimension(NAtomsB), INTENT(IN) :: atomsorteB
		REAL, INTENT(OUT)  :: MMA
		REAL, Dimension(3), INTENT(OUT)  :: d_MMA
		REAL, Dimension(3) ::Atom1
		REAL:: Abstand,Abstand_min
		INTEGER::i,j,i_min,j_min
		LOGICAL :: debug=.false.
		
		MMA=0           !Mittlerer Minimalabstand
		d_MMA=0

		do i=1,NAtomsA ! Durchgehen der Atome in Molekuel    
			i_min=i
			j_min=1
			Atom1=koordA(i,:)
			Abstand_min=getDistance(Atom1,koordB(1,:))
			DO j=1,NAtomsB ! Durchgehen von B
				Abstand=getDistance(Atom1,koordB(j,:))
				IF( Abstand <= Abstand_min) THEN
					Abstand_min=Abstand
					i_min=i
					j_min=j
				END IF
			END DO
			d_MMA= d_MMA + koordB(j_min,:)-koordA(i_min,:)
			MMA=MMA+Abstand_min
		END DO
		MMA=MMA/real(NAtomsA)
		IF(debug)  WRITE(*,*) 'Der mittlere Minimalabstand (MMA)[Ang] betraegt', MMA
		d_MMA = d_MMA /real(NAtomsA)
		MMA=MMA/real(NAtomsA)

		IF(debug)  WRITE(*,*) 'Der mittlere Minimalabstand (MMA)[Ang] betraegt', MMA, &
			& ' mit dem d_MMA Vektor ',d_MMA
END SUBROUTINE calc_mittlerer_minimal_Abstand_MMA_dimer




 
!!!---------------------------------------------------------------------------------------------------------------!!!!
!!!    Functions to manipulate the H-Atoms in molecular coordinates                                               !!!!
!!!---------------------------------------------------------------------------------------------------------------!!!!
!! atomsorte: contains a list of elements 
!! koord(:,3): contains the nuclear coordinates koord(i,1) = x,  koord(i,2) = y ,koord(i,3)=z
!! NAtoms: Number of atoms.
!! Add H atoms to the chain or cuts the chain if needed.
!! KETTE = .true. selects the full side chain representation.
	SUBROUTINE add_h_atoms_to_mol(atomsorte,koord,NAtoms,residue_name,KETTE,atomsorte1H,koord1H,NAtoms1H,Molname) 
			IMPLICIT NONE
			Character(5), Dimension(NAtoms), INTENT(INOUT) :: atomsorte  ! , ALLOCATABLE ??
			Real, Dimension(NAtoms,3), INTENT(IN)       :: koord
			Character(5), INTENT(IN) :: residue_name
			INTEGER, INTENT(IN)::NAtoms
			LOGICAL, INTENT(IN)::KETTE
			Character(5), ALLOCATABLE, Dimension(:), INTENT(OUT) :: atomsorte1H
			Real, ALLOCATABLE, Dimension(:,:), INTENT(OUT) :: koord1H
			INTEGER, INTENT(OUT) ::NAtoms1H
			!! 
			INTEGER::i
			LOGICAL::DEBUG=.false.
			LOGICAL::  DIPBI,DIPBI_KETTE,P3HT,P3MT,P3HT_KETTE,PPDI,PPDI_KETTE,PBDT_TS1,HDI_KETTE,PPDI_Propyl
			Character(500), INTENT(OUT)::Molname
			DIPBI=.false.
			DIPBI_KETTE=.true.
			P3HT=.false. 
			P3MT=.false.
			P3HT_KETTE=.false.
			PPDI=.false.
			PPDI_Propyl=.false.
			PPDI_KETTE=.false.
			PBDT_TS1=.false.
			HDI_KETTE=.false. 

			IF(DEBUG) THEN
			DO i=1,NAtoms
				WRITE(*,*) i,atomsorte(i),koord(i,1),koord(i,2),koord(i,3)
			END DO
			 END IF

		IF ('THP'==TRIM(residue_name(1:3))) THEN        
			P3HT=.TRUE.
			Molname="P3MT"
			P3MT=.TRUE.
			IF(KETTE) THEN
				Molname="P3HT"
				P3MT=.false.
			P3HT_KETTE=.true.
			END IF    	
		ELSE IF( TRIM(residue_name)=='DIPBI' ) THEN
			DIPBI=.TRUE.
			Molname="DIPBI"
			IF(KETTE) THEN
				Molname="DIPBI_KETTE"
				DIPBI_KETTE=.true.
			END IF
		ELSE IF ( 'HDI__'==TRIM(residue_name(1:5)) ) THEN
			Molname='HDI'          
		ELSE IF ( 'HDI_K'==TRIM(residue_name(1:5)) ) THEN
			Molname='HDI_K' 
			IF(KETTE) THEN
				HDI_KETTE=.true.
				Molname="HDI_KETTE"
			END IF
		ELSE IF ( 'TDI__'==TRIM(residue_name(1:5)) ) THEN
			Molname='TDI'
		ELSE IF ( 'K1K__'==TRIM(residue_name(1:5)) .OR. 'PtK1K'==TRIM(residue_name(1:5)) ) THEN
			Molname='PtK1K'                     
		ELSE IF ( 'K2K__'==TRIM(residue_name(1:5)) .OR. 'PtK2K'==TRIM(residue_name(1:5)) ) THEN
			Molname='PtK2K'                   
		ELSE IF ( 'K3K__'==TRIM(residue_name(1:5)) .OR. 'PtK3K'==TRIM(residue_name(1:5)) ) THEN
			Molname='PtK3K'
		ELSE IF ( 'K4K__'==TRIM(residue_name(1:5)) .OR. 'PtK4K'==TRIM(residue_name(1:5)) ) THEN
			Molname='PtK4K'                     
		ELSE IF ( 'mCP__'==TRIM(residue_name(1:5)) ) THEN
			Molname='mCP'        
		ELSE IF ( 'NPB__'==TRIM(residue_name(1:5)) ) THEN
			Molname='NPB'
		ELSE IF ( 'PPDI_'==TRIM(residue_name(1:5)) ) THEN
			Molname='PPDI'   
			PPDI=.true.
			IF (KETTE) THEN
				PPDI_KETTE=.true.
			END IF
		ELSE IF ( '8poly'==TRIM(residue_name(1:5)) ) THEN
			Molname='PBDT_TS1'
			PBDT_TS1=.true.
		ELSE
			Molname=TRIM(residue_name)
		END IF 



		IF(DIPBI) THEN
			IF(DIPBI_KETTE) THEN
				call h_diPBI_kette(atomsorte,koord,atomsorte1H,koord1H,NAtoms,Molname)
			ELSE
				call h_diPBI(atomsorte,koord,atomsorte1H,koord1H,NAtoms,Molname)
			END IF
		ELSE IF (P3HT) THEN
			IF(P3MT) THEN
				CALL h_P3MT(atomsorte,koord,atomsorte1H,koord1H,NAtoms,Molname)
			ELSE IF (P3HT_KETTE) THEN	

				CALL h_P3HT(atomsorte,koord,atomsorte1H,koord1H,NAtoms,Molname)  
			!DO i=1,size(atomsorte1H)
			!	WRITE(*,*) atomsorte1H(i),koord1H(i,1),koord1H(i,2),koord1H(i,3)
			!END DO
			!CALL EXIT (1)	
			END IF
		ELSE IF (PPDI) THEN
			IF(PPDI_KETTE) THEN
				CALL h_PPDI_kette(atomsorte,koord,atomsorte1H,koord1H,NAtoms,Molname)
			ELSE IF (PPDI_Propyl) THEN    
				CALL h_PPDI_propyl(atomsorte,koord,atomsorte1H,koord1H,NAtoms,Molname)
			ELSE
				!DO i=1,NAtoms
				!    WRITE(*,*) atomsorte(i),koord(i,:)
				!END DO
				CALL h_PPDI(atomsorte,koord,atomsorte1H,koord1H,NAtoms,Molname)   
			END IF
		ELSE IF (PBDT_TS1) THEN
			!DO i=1,NAtoms
			!    WRITE(*,*) atomsorte(i),koord(i,:)
			!END DO
			CALL h_PBDT_TS1(atomsorte,koord,atomsorte1H,koord1H,NAtoms,Molname)    
		ELSE IF( (.NOT. HDI_KETTE) .AND. (TRIM(Molname) =='HDI' .OR. TRIM(Molname) =='HDI_K' .OR. TRIM(Molname) =='HDI_KETTE')) THEN
			!DO i=1,NAtoms
				!WRITE(*,*) atomsorte(i),koord(i,:)
			!END DO
			CALL h_cut_chain_HDI(atomsorte,koord,NAtoms,atomsorte1H,koord1H,Molname)
		ELSE IF (index(TRIM(Molname),'Alq') .ne. 0) THEN ! H-Atoms are not changed
			CALL alq3_rename_elements(atomsorte,koord,NAtoms,atomsorte1H,koord1H,Molname)
		ELSE
			
			! Uebergabe ohne Bearbeitung der H-Atome
			ALLOCATE(koord1H(NAtoms,3))
			ALLOCATE(atomsorte1H(NAtoms))
			DO i=1,NAtoms
				koord1H(i,:)=koord(i,:)
				atomsorte1H(i)=atomsorte(i)
			END DO    
			if(debug) write(*,*) ' Keine Bearbeitung der H-Atome'
		END IF

		NAtoms1H=size(atomsorte1H)
		IF (DEBUG) THEN
			!WRITE(*,*) 'Koordinaten molA: atomsorte1H, koord1H(i,:)'
			!DO i=1,NAtoms1H
			!    WRITE(*,*) atomsorte1H(i),koord1H(i,:)
			!END DO
			WRITE(*,*) 'molA: '//TRIM(Molname)//'  ,PBDT_TS1:',PBDT_TS1,' PPDI:',PPDI,' DIPBI:',DIPBI,' P3HT:',P3HT
		END IF


	END SUBROUTINE add_h_atoms_to_mol

	!! Add H Atoms to a P3HT molecule
	SUBROUTINE h_P3HT(atomsorte,koord,atomsorteH,koordH,NAtoms,ziel)
		IMPLICIT NONE
		Integer, INTENT (IN):: NAtoms
		Real, Dimension(NAtoms,3), INTENT (IN) :: koord
		Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
		REAL, ALLOCATABLE, DIMENSION(:,:), INTENT (OUT) ::koordH
		Character(5), ALLOCATABLE, Dimension(:), INTENT (OUT) :: atomsorteH
		Character(5), ALLOCATABLE, Dimension(:)::atomsortedummy
		Character(500), INTENT (IN) :: ziel
		Integer ::i,j,k,ind,anzahl,anzahlneu,anzahlringe,ind5RingEnde,cAtomRingInd,sAtomInd,zaehler
		Character(3) :: dummy
		Real, Dimension(3) :: cAtom,hAtom1,hAtom2,hAtom3
		Real, Dimension(3) :: vorigesC,naechstesC,kreuzprod,c1Atom,c2Atom,sAtom
		Integer, Dimension(NAtoms) :: ind5Ring
		LOGICAL::HStart,HEnde,DEBUG=.false.

		IF(DEBUG) THEN
			WRITE(*,*) 'Koordinaten vor h_P3HT ' 
			DO i=1,NAtoms,1
					write(*,*)  atomsorte(i),(koord(i,j),j=1,3)
			END DO
		END IF



		HStart=.false.
		HEnde=.false.

		! Bestimmung ob erstes und letztes H-Atom existiert

		IF( TRIM(adjustl(atomsorte(1))) == 'HC' .AND. TRIM(adjustl(atomsorte(2))) == 'CA' ) HStart=.true.
		IF( TRIM(adjustl(atomsorte(NAtoms-7))) == 'HC' ) HEnde=.true.

		!Indexarray fur 5Ringe und Wasserstoffe erzeugen
		anzahl=NAtoms
		i =1
		ind=1
		ind5Ring =0
		DO WHILE(ind <= anzahl)
			ind5Ring(i) = ind
			IF(index(atomsorte(ind),'S') >0) THEN !Hexylgruppe Ueberspringen
				ind = ind +6 !jetzt: ind letztes Atom der Hexylgruppe
			END IF
			i=i+1
			ind=ind+1
		END DO
		ind5RingEnde = i-1 !letzter belegter Platz

		!Write(*,*) 'HStart',HStart,'HEnde',HEnde

		IF( HStart .AND. HEnde ) THEN
			anzahlringe = (ind5RingEnde -2)/6                   !anzahlringe = (ind5RingEnde -2)/6 !fuer ganze Kette 
			anzahlneu = anzahl + anzahlringe*13                 !Gesamtanzahl Atome in neuer Datei
		else
			IF(HStart .OR. HEnde) THEN
				anzahlringe = (ind5RingEnde -1)/6  
				anzahlneu = anzahl + anzahlringe*13 + 1 !Gesamtanzahl Atome in neuer Datei +1 fuer Anfangs/Abschluss H-Atom
			ELSE 
				anzahlringe = (ind5RingEnde)/6 
				anzahlneu = anzahl + anzahlringe*13 + 2 !Gesamtanzahl Atome in neuer Datei +2 fuer Anfangs+Abschluss H-Atom
			END IF
		END IF
		IF(DEBUG) THEN
			WRITE(*,*) "NAtoms",NAtoms
			WRITE(*,*) "anzahlringe",anzahlringe
			WRITE(*,*) "anzahlneu",anzahlneu
			WRITE(*,*) "ind5RingEnde",ind5RingEnde
		END IF !DEBUG
		ALLOCATE(koordH(anzahlneu,3))
		ALLOCATE(atomsorteH(anzahlneu))
		ALLocate(atomsortedummy(anzahlneu))
		atomsortedummy=' '
		ind =1
		i=1
		DO WHILE(i <= NAtoms )
			 dummy = adjustl(atomsorte(i))
			 atomsorteH(ind) = dummy(1:1)//'  '
			 atomsortedummy(i) = dummy(1:1)//'  '    !Schneidet hintere von CH das H ab / laesst nur noch ersten Buchstaben durch
			 IF(index(atomsorte(i),'S') >0) THEN
				ind = ind+19                ! Ueberspringen um 19 Atome =6*C+13*H
				i=i+6
			 END IF
			ind=ind+1
			i=i+1
		END DO 

		k=1       ! Index fuer das Speichern der Koordinaten in KoordH
		!neue Koordinaten schreiben
		DO i=1,ind5RingEnde,1
			!Write(23,'(2X,A2,1X,3F16.6)') atomsortedummy(ind5Ring(i)),koord(ind5Ring(i),1),koord(ind5Ring(i),2),koord(ind5Ring(i),3)    
			koordH(k,:)=koord(ind5Ring(i),:) !Uebergabe der Koordinaten an koordH
			k=k+1

			IF(index(atomsortedummy(ind5Ring(i)),'S') >0) THEN !H-Atome an Hexylgruppe anfangen
				cAtomRingInd = ind5Ring(i) -2 !Indizes zwischenspeichern
				sAtomInd = ind5Ring(i)
				
				!1. C-Atom mit H bestuecken
				DO ind=1,3,1 !Koordinaten merken
					cAtom(ind) = koord(sAtomInd+1,ind)
					vorigesC(ind) = koord(cAtomRingInd,ind)
					naechstesC(ind) = koord(sAtomInd+2,ind)
				END DO
						
				CALL kreuzprodukt(cAtom - vorigesC, cAtom -naechstesC,kreuzprod)
				hAtom1 = cAtom + kreuzprod
				hAtom2 = cAtom - kreuzprod

				CALL rotate(naechstesC,vorigesC,hAtom1,32.) !Winkel anpassen
				CALL rotate(naechstesC,vorigesC,hAtom2,-32.)

				CALL setDistance(cAtom,hAtom1,1.095) !Abstand anpassen
				CALL setDistance(cAtom,hAtom2,1.095) !Abstand anpassen
				
				!Write(23,'(2X,A2,1X,3F16.6)') 'C ',cAtom(1),cAtom(2),cAtom(3)
				koordH(k,:)=cAtom(:) !Uebergabe der Koordinaten an koordH
				atomsorteH(k)='C ' 
				k=k+1
				!Write(23,'(2X,A2,1X,3F16.6)') 'H ',hAtom1(1),hAtom1(2),hAtom1(3)
				koordH(k,:)=hAtom1(:) !Uebergabe der Koordinaten an koordH
				atomsorteH(k)='H ' 
				k=k+1
				!Write(23,'(2X,A2,1X,3F16.6)') 'H ',hAtom2(1),hAtom2(2),hAtom2(3)
				koordH(k,:)=hAtom2(:) !Uebergabe der Koordinaten an koordH
				atomsorteH(k)='H ' 
				k=k+1
				!C-Atome 2 - 5 bestuecken
				DO zaehler=2,5,1
					DO ind=1,3,1 !Koordinaten merken
						cAtom(ind) = koord(sAtomInd+zaehler,ind)
						vorigesC(ind) = koord(sAtomInd+zaehler-1,ind)
						naechstesC(ind) = koord(sAtomInd+zaehler+1,ind)
					END DO
							
					CALL kreuzprodukt(cAtom - vorigesC, cAtom -naechstesC,kreuzprod)
					hAtom1 = cAtom + kreuzprod
					hAtom2 = cAtom - kreuzprod
					
					CALL rotate(naechstesC,vorigesC,hAtom1,32.) !Winkel anpassen
					CALL rotate(naechstesC,vorigesC,hAtom2,-32.)
			
					CALL setDistance(cAtom,hAtom1,1.095) !Abstand anpassen
					CALL setDistance(cAtom,hAtom2,1.095) !Abstand anpassen

					!Write(23,'(2X,A2,1X,3F16.6)') 'C ',cAtom(1),cAtom(2),cAtom(3)
					koordH(k,:)=cAtom(:) !Uebergabe der Koordinaten an koordH
					atomsorteH(k)='C ' 
					k=k+1           
					!Write(23,'(2X,A2,1X,3F16.6)') 'H ',hAtom1(1),hAtom1(2),hAtom1(3)
					koordH(k,:)=hAtom1(:) !Uebergabe der Koordinaten an koordH
					atomsorteH(k)='H ' 
					k=k+1           
					!Write(23,'(2X,A2,1X,3F16.6)') 'H ',hAtom2(1),hAtom2(2),hAtom2(3)
					koordH(k,:)=hAtom2(:) !Uebergabe der Koordinaten an koordH
					atomsorteH(k)='H ' 
					k=k+1  
				END DO

				!letztes C-Atom mit 3 H-Atomen bestuecken
				DO ind=1,3,1 !Koordinaten merken
					cAtom(ind) = koord(sAtomInd+6,ind)
					vorigesC(ind) = koord(sAtomInd+5,ind)
					naechstesC(ind) = koord(sAtomInd+4,ind) !vorvoriges C-atom
				END DO		
				
				CALL kreuzprodukt(cAtom - vorigesC, cAtom -naechstesC,kreuzprod)

				hAtom1 = vorigesC
				CALL setDistance(cAtom,hAtom1,1.095)
				CALL rotate(cAtom,cAtom+kreuzprod,hAtom1,112.)
					hAtom2 = hAtom1  !schon mal die ungefaehre Position
				hAtom3 = hAtom1

				CALL rotate(vorigesC,cAtom,hAtom2,120.) !in korrekte Position bringen
				CALL rotate(vorigesC,cAtom,hAtom3,240.)
				
				!Rotation um C-C Achse sodass der Diederwinkel H-C-C-H ~60° wird
				! (Korrektur zur passenden Newman-Projektion)
				   hAtom1=hAtom1-cAtom(:)
				   call Rotationsmatrix_alpha(hAtom1,60.,vorigesC(:)-cAtom(:),.true.)
				   hAtom1(:)=hAtom1(:)+cAtom(:)

				   hAtom2=hAtom2-cAtom(:)
				   call Rotationsmatrix_alpha(hAtom2,60.,vorigesC(:)-cAtom(:),.true.)
				   hAtom2(:)=hAtom2(:)+cAtom(:)

				   hAtom3=hAtom3-cAtom(:)
				   call Rotationsmatrix_alpha(hAtom3,60.,vorigesC(:)-cAtom(:),.true.)
				   hAtom3(:)=hAtom3(:)+cAtom(:)

				!letztes C-Atom ausgeben
				!Write(23,'(2X,A2,1X,3F16.6)') 'C ',cAtom(1),cAtom(2),cAtom(3)
				koordH(k,:)=cAtom(:) !Uebergabe der Koordinaten an koordH
				atomsorteH(k)='C ' 
				k=k+1       
				!Write(23,'(2X,A2,1X,3F16.6)') 'H ',hAtom1(1),hAtom1(2),hAtom1(3)
				! Rotation 
				
				koordH(k,:)=hAtom1(:) !Uebergabe der Koordinaten an koordH
				atomsorteH(k)='H ' 
				k=k+1           
				!Write(23,'(2X,A2,1X,3F16.6)') 'H ',hAtom2(1),hAtom2(2),hAtom2(3)
				koordH(k,:)=hAtom2(:) !Uebergabe der Koordinaten an koordH
				atomsorteH(k)='H ' 
				k=k+1     
				!Write(23,'(2X,A2,1X,3F16.6)') 'H ',hAtom3(1),hAtom3(2),hAtom3(3)
				koordH(k,:)=hAtom3(:) !Uebergabe der Koordinaten an koordH
				atomsorteH(k)='H ' 
				k=k+1 
			END IF
		END DO

		IF(.NOT. HEnde) THEN  ! Anfuegen des Letzten H-Atoms zum Absaettigen
			c1Atom=koord(NAtoms-7,:)   ! C1-Atom 6 nach der Hexyl-Kette + 1
			c2Atom=koord(NAtoms-8,:)   ! C2-Atom 6 nach der Hexyl-Kette + 1
			hAtom1(:)=c2Atom(:) 
			sAtom=koord(NAtoms-6,:)    ! S-Atom an Potsiton 6 nach der Hexyl-Kette
			CALL setDistance(c1Atom,hAtom1,1.095) !Abstand anpassen
			Call setAngle(c1Atom,c2Atom,sAtom,hAtom1,(360.0-119.9)) ! 119.9Winkel in Grad
			koordH(k,:)= hAtom1
			atomsorteH(k)='H ' 
			k=k+1
		END IF

		IF(.NOT. HStart) THEN  ! Anfuegen des Ersten H-Atoms zum Absaettigen
			c1Atom=koord(1,:)   ! C1-Atom 
			c2Atom=koord(2,:)   ! C2-Atom
			hAtom1(:)=c2Atom    ! Start-H-Position
			sAtom=koord(6,:)    ! S-Atom an Potsiton 6
			CALL setDistance(c1Atom,hAtom1,1.095) !Abstand anpassen
			Call setAngle(c1Atom,c2Atom,sAtom,hAtom1,(360.0-119.9)) ! 119.9 Winkel in Grad
			! Tauschen H-Atom an den Arrayanfang
			atomsorteH(2:anzahlneu)=atomsorteH(1:anzahlneu-1)
			atomsorteH(1)='H '
			koordH(2:anzahlneu,:)=koordH(1:anzahlneu-1,:)
			koordH(1,:)=hAtom1
			k=k+1
		END IF

		DEALLocate(atomsortedummy)

		IF(DEBUG) THEN
			WRITE(*,*) 'Koordinaten nach h_P3HT ' 
			DO i=1,size(atomsorteH),1
					write(*,*)  atomsorteH(i),(koordH(i,j),j=1,3)
			END DO
			
			write(*,*) 'Koordinaten in xyz ',trim(ziel)
			CALL make_coord_to_xyz(atomsorteH,koordH,size(atomsorteH),ziel)
			WRITE(*,*) ' End h_P3HT'
			
		END IF
		END SUBROUTINE h_P3HT

	!! creates P3MT / adds methy H atoms
	SUBROUTINE h_P3MT(atomsorte,koord,atomsorteH,koordH,NAtoms,ziel)
		IMPLICIT NONE
		Integer, INTENT (IN):: NAtoms
		Real, Dimension(NAtoms,3), INTENT (IN) :: koord
		Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
		REAL, ALLOCATABLE, DIMENSION(:,:), INTENT (OUT) ::koordH
		Character(5), ALLOCATABLE, Dimension(:), INTENT (OUT) :: atomsorteH
		Character(5), ALLOCATABLE, Dimension(:)::atomsortedummy
		Character(500), INTENT (IN) :: ziel
		Integer ::i,k,ind,anzahl,anzahlneu,anzahlringe,ind5RingEnde
		Character(3) :: dummy
		Real, Dimension(3) ::X,cAtom,cAtomRing,hAtom1,hAtom2,hAtom3,c1Atom,c2Atom,sAtom
		Integer, Dimension(NAtoms) :: ind5Ring
		LOGICAL::HStart,HEnde
		Real::Rotwinkel
		LOGICAL::DEBUG=.false.

		HStart=.false.
		HEnde=.false.

		! Bestimmung ob erstes und letztes H-Atom existiert
		IF( TRIM(adjustl(atomsorte(1))) == 'HC' .AND. TRIM(adjustl(atomsorte(2))) == 'CA' ) HStart=.true.
		IF( TRIM(adjustl(atomsorte(NAtoms-7))) == 'HC' ) HEnde=.true.

		!Indexarray fur 5Ringe und Wasserstoffe erzeugen
		anzahl=NAtoms
		i=1
		ind=1
		ind5Ring=0

		DO WHILE(ind <= anzahl)
			ind5Ring(i) = ind
			IF(index(atomsorte(ind),'S') >0) THEN !Hexylgruppe ueberspringen
				ind = ind +6 !jetzt: ind letztes Atom der Hexylgruppe
			END IF
			i=i+1
			ind=ind+1
		END DO
		ind5RingEnde = i-1 !letzter belegter Platz

		IF( HStart .AND. HEnde ) THEN
			anzahlringe = (ind5RingEnde -2)/6              !anzahlringe = (ind5RingEnde -2)/6 !fuer ganze Kette 
			anzahlneu = anzahl - anzahlringe*5 + anzahlringe*3 !Gesamtanzahl Atome in neuer Datei, 5 C weg, 3 H dazu je Ring
		else
			IF(HStart .OR. HEnde) THEN
				anzahlringe = (ind5RingEnde -1)/6  
				anzahlneu = anzahl - anzahlringe*5 + anzahlringe*3 + 1 !Gesamtanzahl Atome in neuer Datei, 5 C weg, 3 H dazu je Ring +1 fuer Anfangs/Abschluss H-Atom
			ELSE 
				anzahlringe = (ind5RingEnde)/6 
				anzahlneu = anzahl - anzahlringe*5 + anzahlringe*3 + 2 !Gesamtanzahl Atome in neuer Datei, 5 C weg, 3 H dazu je Ring +2 fuer Anfangs+Abschluss H-Atom
			END IF
		END IF

		!write(*,*) 'HStart=',HStart
		!write(*,*) 'HEnde= ',HEnde
		!WRITE(*,*) "anzahlringe",anzahlringe
		!write(*,*) "anzahlneu",anzahlneu
		!write(*,*) "ind5RingEnde",ind5RingEnde
		ALLOCATE(koordH(anzahlneu,3))
		ALLOCATE(atomsorteH(anzahlneu))
		ALLocate(atomsortedummy(size(atomsorte)))

		ind =1
		i=1
		DO WHILE(i <= NAtoms)
			 dummy = adjustl(atomsorte(i))
			 atomsorteH(ind) = dummy(1:1)//'  '
			 atomsortedummy(i) = dummy(1:1)//'  '
			 IF(index(atomsorte(i),'S') >0) THEN
				ind = ind+4                ! Ueberspringen um 4 Atome =1*C+3*H
				i=i+6
			 END IF
			ind=ind+1
			i=i+1
		END DO 

		k=1       ! Index fuer das Speichern der Koordinaten in KoordH
		!neue Koordinaten schreiben
		DO i=1,ind5RingEnde,1
			!Write(23,'(2X,A2,1X,3F16.6)') atomsortedummy(ind5Ring(i)),koord(ind5Ring(i),1),koord(ind5Ring(i),2),koord(ind5Ring(i),3)  
			koordH(k,:)=koord(ind5Ring(i),:) !Uebergabe der Koordinaten an koordH
			k=k+1

			IF(index(atomsortedummy(ind5Ring(i)),'S') >0) THEN !H-Atome an Hexylgruppe anfangen
				DO ind=1,3,1 !Atompositionen speichern
					cAtomRing(ind) = koord(ind5Ring(i)-2,ind) !C-Atom an das Hexylgruppe gebunden ist
					cAtom(ind) = koord(ind5Ring(i)+1,ind)  !1. Atom Hexylgruppe
					hAtom1(ind) = koord(ind5Ring(i)+2,ind) !2. Atom der Hexylgruppe liefert ca. Position 1. H
				END DO
				!3 H-Atome an das C-Atom anfuegen
				CALL setDistance(cAtom,hAtom1,1.095) !Abstand anpassen

				DO ind =1,3,1
				hAtom2(ind) = hAtom1(ind) !schon mal die ungefaehre Position
				hAtom3(ind) = hAtom1(ind)
				END DO

				CALL rotate(cAtomRing,cAtom,hAtom2,120.) !in korrekte Position bringen
				CALL rotate(cAtomRing,cAtom,hAtom3,240.)

						!Start Rotation um Dih zum H-Atom anzupassen
						call set_dih_by_rotation_around_axis(hAtom1,cAtom,cAtomRing,koord(ind5Ring(i)-3,:),11.3,Rotwinkel)
						X=hAtom2(:)-cAtom(:)
						call Rotationsmatrix_alpha(X,Rotwinkel,cAtomRing-cAtom,.true.)
						hAtom2(:)=X(:)+cAtom(:)

						X=hAtom3(:)-cAtom(:)
						call Rotationsmatrix_alpha(X,Rotwinkel,cAtomRing-cAtom,.true.)
						hAtom3(:)=X(:)+cAtom(:)

						!Ende Extra Rotation

				!Methylgruppe ausgeben
				!Write(23,'(2X,A2,1X,3F16.6)') 'C ',cAtom(1),cAtom(2),cAtom(3)
				koordH(k,:)=cAtom(:) !Uebergabe der Koordinaten an koordH
				atomsorteH(k)='C ' 
				k=k+1
				!Write(23,'(2X,A2,1X,3F16.6)') 'H ',hAtom1(1),hAtom1(2),hAtom1(3)
				koordH(k,:)=hAtom1(:) !Uebergabe der Koordinaten an koordH
				atomsorteH(k)='H ' 
				k=k+1       
				!Write(23,'(2X,A2,1X,3F16.6)') 'H ',hAtom2(1),hAtom2(2),hAtom2(3)
				koordH(k,:)=hAtom2(:) !Uebergabe der Koordinaten an koordH
				atomsorteH(k)='H ' 
				k=k+1         
				!Write(23,'(2X,A2,1X,3F16.6)') 'H ',hAtom3(1),hAtom3(2),hAtom3(3)
				koordH(k,:)=hAtom3(:) !Uebergabe der Koordinaten an koordH
				atomsorteH(k)='H ' 
				k=k+1 

			END IF
		END DO

		CLOSE(23)

		IF(.NOT. HEnde) THEN  ! Anfuegen des Letzten H-Atoms zum Absaettigen
			c1Atom=koord(NAtoms-7,:)   ! C1-Atom 6 nach der Hexyl-Kette + 1
			c2Atom=koord(NAtoms-8,:)   ! C2-Atom 6 nach der Hexyl-Kette + 1
			hAtom1(:)=c2Atom(:) 
			sAtom=koord(NAtoms-6,:)    ! S-Atom an Potsiton 6 nach der Hexyl-Kette
			CALL setDistance(c1Atom,hAtom1,1.095) !Abstand anpassen
			Call setAngle(c1Atom,c2Atom,sAtom,hAtom1,(360.0-119.9)) ! 119.9Winkel in Grad
			koordH(k,:)= hAtom1
			atomsorteH(k)='H ' 
			k=k+1
		END IF

		IF(.NOT. HStart) THEN  ! Anfuegen des Ersten H-Atoms zum Absaettigen
			c1Atom=koord(1,:)   ! C1-Atom 
			c2Atom=koord(2,:)   ! C2-Atom
			hAtom1(:)=c2Atom    ! Start-H-Position
			sAtom=koord(6,:)    ! S-Atom an Potsiton 6
			CALL setDistance(c1Atom,hAtom1,1.095) !Abstand anpassen
			Call setAngle(c1Atom,c2Atom,sAtom,hAtom1,(360.0-119.9)) ! 119.9 Winkel in Grad
			! Tauschen H-Atom an den Arrayanfang
			atomsorteH(2:anzahlneu)=atomsorteH(1:anzahlneu-1)
			atomsorteH(1)='H '
			koordH(2:anzahlneu,:)=koordH(1:anzahlneu-1,:)
			koordH(1,:)=hAtom1
			k=k+1
		END IF

		!WRITE(*,*) ' P3MT ENDE KOORDINATEN:'
		!DO i=1,size(atomsorteH),1
		!    write(*,*)  atomsorteH(i),(koordH(i,j),j=1,3)
		!END DO
			IF (DEBUG) THEN
						write(*,*) 'Koordinaten in xyz ',trim(ziel)
						CALL make_coord_to_xyz(atomsorteH,koordH,size(atomsorteH),ziel)
						WRITE(*,*) ' P3MT ENDE KOORDINATEN:'
			ENDIF


	END SUBROUTINE h_P3MT

	SUBROUTINE h_diPBI(atomsorte,koord,atomsorteH,koordH,NAtoms,ziel) ! Schneidet die Ketten ab!
			!! Subroutine to cut the chains and substitute by methyl groups (CH3) to a DiPBI-molecule 
			!! obtained by a GROMACS-file.
			IMPLICIT NONE
			Integer, INTENT(IN) :: NAtoms
			Real, Dimension(NAtoms,3), INTENT(IN) :: koord
			REAL, ALLOCATABLE, DIMENSION(:,:), INTENT (OUT) ::koordH
			Character(5),ALLOCATABLE, Dimension(:), INTENT(OUT) :: atomsorteH
			Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
			Character(500) :: ziel
			Real, Dimension(3) ::cAtom,NAtom,X,hAtom1,hAtom2,hAtom3,kreuzprod
			INTEGER::i,p,anzahl_methylgruppen=4
			! Mindex C1-N2-C5-O3-H1-H2-H3
			Integer, Dimension(4,7)::Mindex
			Real::Rotwinkel
			LOGICAL::DEBUG=.false.


			ALLOCATE(koordH(86,3))
			ALLOCATE(atomsorteH(86))
			Mindex=transpose(reshape( &
		&(/ 1, 2, 5, 3, 75, 76, 77, 37, 35, 32, 34, 78, 79, 80, 38, 39, 42, 40, 81, 82, 83, 74, 72, 69,71, 84, 85, 86/), (/ 7, 4/)))
			
			DO i=1,74
					koordH(i,:)=koord(i,:)           !Koordinaten an neuen Array uebergeben
					atomsorteH(i)=atomsorte(i)
			END DO
			! Addition von zusaetzlichen H atomen an C mit Abschneiden der Ketteh
			
	   DO p=1,anzahl_methylgruppen
			
			cAtom=koord(Mindex(p,1),:)
			NAtom=koord(Mindex(p,2),:)
			CALL kreuzprodukt(CAtom - NAtom, cAtom-koord(Mindex(p,3),:),kreuzprod)
			hAtom1 = NAtom
			CALL setDistance(cAtom,hAtom1,1.095)
			CALL rotate(cAtom,(cAtom+kreuzprod),hAtom1,112.5)
			hAtom2 = hAtom1
			hAtom3 = hAtom1
			CALL rotate(NAtom,cAtom,hAtom2,120.) ! Rotationen von hAtom2
			CALL rotate(NAtom,cAtom,hAtom3,240.) ! Rotation von hAtom3
		
		   !Start Rotation um Dih zum H-Atom anzupassen
			call set_dih_by_rotation_around_axis(hAtom1,cAtom,NAtom,koord(Mindex(p,4),:),7.8,Rotwinkel)
			X=hAtom2(:)-cAtom(:)
			call Rotationsmatrix_alpha(X,Rotwinkel,NAtom-cAtom,.true.)
			hAtom2(:)=X(:)+cAtom(:)
	 
			X=hAtom3(:)-cAtom(:)
			call Rotationsmatrix_alpha(X,Rotwinkel,NAtom-cAtom,.true.)
			hAtom3(:)=X(:)+cAtom(:)
			!Ende Extra Rotation
		
			koordH(Mindex(p,5),:)=hAtom1(:)
			koordH(Mindex(p,6),:)=hAtom2(:)
			koordH(Mindex(p,7),:)=hAtom3(:)
			atomsorteH(Mindex(p,5))='H '
			atomsorteH(Mindex(p,6))='H '
			atomsorteH(Mindex(p,7))='H '

	   END DO ! i-Schleife Methylgruppen
	   
			IF (DEBUG) THEN
						write(*,*) 'Koordinaten in xyz ',trim(ziel)
						CALL make_coord_to_xyz(atomsorteH,koordH,size(atomsorteH),ziel)
						write(*,*) 'Ende h_diPBI new'
			ENDIF
	   
	END SUBROUTINE h_diPBI

	SUBROUTINE h_PPDI_propyl(atomsorte,koord,atomsorteH,koordH,NAtoms,ziel) ! Schneidet die Ketten ab!
			!! Subroutine to cut the chains and substitute by propyl groups (CH3-CH-CH3)-N to a PPDI-molecule 
			IMPLICIT NONE
			Integer, INTENT(IN) :: NAtoms
			Real, Dimension(NAtoms,3), INTENT(IN) :: koord
			REAL, ALLOCATABLE, DIMENSION(:,:), INTENT (OUT) ::koordH
			Character(5),ALLOCATABLE, Dimension(:), INTENT(OUT) :: atomsorteH
			Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
			Character(500) :: ziel
			CHARACTER(1)   ::dummy
			Real, Dimension(3) ::cAtom,NAtom,X,hAtom1,hAtom2,hAtom3,kreuzprod,OAtom,hAtomA,hAtomB
			INTEGER::i,j,p,anzahl_methylgruppen=4
			! Mindex C5-C6-N7-O8-H1-H2-H3
			Integer, Dimension(4,7)::Mindex
			Integer, Dimension(6,2)::Cindex
			Real::Rotwinkel,dist_sum_1, dist_sum_2
			LOGICAL::DEBUG=.false.
			
			ALLOCATE(koordH(96,3))
			ALLOCATE(atomsorteH(96))

					
			! Die ersten 4 Zahlen geben jeweils den alten Index an (C5-C6-N7-O9) -- dann kommen die neuen Indizes (H77-H78-H79)
			! O kann O9 oder O20 am N7 werden oder (O81 oder O74 am N81)
			! 4 Methylgruppen werden gesetzt.
			Mindex=transpose(reshape( &
		&(/ 5,6,7,9,78,79,80, 94,6,7,9,84,85,86,  84,83,82,81,88,89,90, 89,83,82,81,94,95,96 /), (/ 7, 4/)))
			
		j=0
		DO i=7,82  !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
				j=j+1
				koordH(j,:)=koord(i,:)           !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
				dummy = TRIM(adjustl(atomsorte(i)))
				atomsorteH(j) = dummy(1:1)//'  ' ! Schneidet alles rechts ab
				!WRITE(*,*) j,atomsorteH(j),koordH(j,:)
		END DO 
				
				
		!!! Uebergabe des C-Atome aus der Seitenkette an die Position im Array 1=alter Index ,2= neuer Index Anzahl der C-Atome durchlaufen als i=1,6 
		!! C5 aus koord wird zum ersten neuen C in koordH C77 daher 5,77 ... dann wird Platz fuer 3 H-Atome gelassen (neuer Index 78 79 80) und C6 wird 
		Cindex=transpose(reshape( (/ 5,77, 6,81, 94,83, 84,87, 83,91, 89,93 /), (/ 2, 6/)))
		Do i=1,6
			!WRITE(*,*) Cindex(i,1),Cindex(i,2)
			koordH(Cindex(i,2),:)=koord(Cindex(i,1),:)
			atomsorteH(Cindex(i,2))='C'
		END DO
		
		!H-Start
		cAtom=koordH(81,:)   !  C-Atom am Randstart
		NAtom=koordH(1,:)  
		hAtomA(:)=koordH(83,:) 
		! Test welches O als Referenz fuer das H-ausgewaehlt werden soll, in dem der groessere Abstand der beiden C-Atome an denen CH3- gebaut werden soll bestimmt wird
		! Test O9 und O20 in gro Nummerierung
		dist_sum_1=norm(koord(9,:)-koord(5,:))+norm(koord(9,:)-koord(94,:))
		dist_sum_2=norm(koord(20,:)-koord(5,:))+norm(koord(20,:)-koord(94,:))
		IF (dist_sum_1 > dist_sum_2) THEN
			OAtom=koord(9,:)
		ELSE 
			OAtom=koord(20,:)
		END IF
		CALL setDistance(cAtom,hAtomA,1.095) 
		call set_dih_by_rotation_around_axis(hAtomA,CAtom,NAtom,OAtom,2.9,Rotwinkel)
		koordH(82,:)= hAtomA
		atomsorteH(82)='H' 

		! H-Ende
		cAtom=koordH(91,:)  ! C-Atom am Randende
		NAtom=koordH(76,:)  
		hAtomB(:)=koordH(93,:)
		! Test welches O als Referenz fuer das H-ausgewaehlt werden soll, in dem der groessere Abstand der beiden C-Atome an denen CH3- gebaut werden soll bestimmt wird
		! Test O81 und O74in gro Nummerierung
		dist_sum_1=norm(koord(81,:)-koord(84,:))+norm(koord(81,:)-koord(89,:))
		dist_sum_2=norm(koord(74,:)-koord(84,:))+norm(koord(74,:)-koord(89,:))
		IF (dist_sum_1 > dist_sum_2) THEN
			OAtom=koord(81,:)
		ELSE 
			OAtom=koord(74,:)
		END IF
		CALL setDistance(cAtom,hAtomB,1.095)
		call set_dih_by_rotation_around_axis(hAtomB,CAtom,NAtom,OAtom,2.9,Rotwinkel)
		koordH(92,:)= hAtomB
		atomsorteH(92)='H' 
		
	   ! Schleife zum Anbau der 4 Methylendgruppen 
	   DO p=1,anzahl_methylgruppen     !! Vorsicht die Benennung der Atome stimmt ab hier nicht mehr mit den Benennungen im PPDI ueberein, da die DIPBI Routine verwendet wurde 
			cAtom=koord(Mindex(p,1),:)
			NAtom=koord(Mindex(p,2),:)
			CALL kreuzprodukt(CAtom - NAtom, cAtom-koord(Mindex(p,3),:),kreuzprod)
			hAtom1 = NAtom
			CALL setDistance(cAtom,hAtom1,1.095)
			CALL rotate(cAtom,(cAtom+kreuzprod),hAtom1,112.5)
			hAtom2 = hAtom1
			hAtom3 = hAtom1
			CALL rotate(NAtom,cAtom,hAtom2,120.) ! Rotationen von hAtom2
			CALL rotate(NAtom,cAtom,hAtom3,240.) ! Rotation von hAtom3
		
		   !Start Rotation um Dih zum H-Atom anzupassen
			if (p==1 .or. p==2) THEN
				call set_dih_by_rotation_around_axis(hAtom1,cAtom,NAtom,hAtomA,60.0,Rotwinkel)
			ELSE IF (p==3 .or. p==4) THEN
				call set_dih_by_rotation_around_axis(hAtom1,cAtom,NAtom,hAtomB,60.0,Rotwinkel)
			END IF
			!call set_dih_by_rotation_around_axis(hAtom1,cAtom,NAtom,koord(Mindex(p,4),:),7.8,Rotwinkel)
			X=hAtom2(:)-cAtom(:)
			call Rotationsmatrix_alpha(X,Rotwinkel,NAtom-cAtom,.true.)
			hAtom2(:)=X(:)+cAtom(:)
	 
			X=hAtom3(:)-cAtom(:)
			call Rotationsmatrix_alpha(X,Rotwinkel,NAtom-cAtom,.true.)
			hAtom3(:)=X(:)+cAtom(:)
			!Ende Extra Rotation
		
			koordH(Mindex(p,5),:)=hAtom1(:)
			koordH(Mindex(p,6),:)=hAtom2(:)
			koordH(Mindex(p,7),:)=hAtom3(:)
			atomsorteH(Mindex(p,5))='H'
			atomsorteH(Mindex(p,6))='H'
			atomsorteH(Mindex(p,7))='H'

	   END DO ! i-Schleife Methylgruppen


		IF (DEBUG) THEN
						write(*,*) 'Koordinaten in xyz ',trim(ziel)
						CALL make_coord_to_xyz(atomsorteH,koordH,size(atomsorteH),ziel)
						WRITE(*,*) 'Ende h_PPDI_propyl'
		ENDIF
		
	END SUBROUTINE h_PPDI_propyl

	SUBROUTINE h_PPDI(atomsorte,koord,atomsorteH,koordH,NAtoms,ziel) ! Schneidet die Ketten ab!
			!!Subroutine to cut the chains and substitute by methyl groups (CH3) to a PPI-molecule 
			!!obtained by a GROMACS-file.
			!! H-Atoms will be added with at the N-Atom with reference to the C-Atom on the oposite ring position (para)position.
			IMPLICIT NONE
			Integer, INTENT(IN) :: NAtoms
			Real, Dimension(NAtoms,3), INTENT(IN) :: koord
			REAL, ALLOCATABLE, DIMENSION(:,:), INTENT (OUT) ::koordH
			Character(5),ALLOCATABLE, Dimension(:), INTENT(OUT) :: atomsorteH
			Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
			Character(500) :: ziel
			CHARACTER(1)::dummy
			Real, Dimension(3) ::c2Atom,c3Atom,NAtom,hAtom1
			INTEGER::i,j
			LOGICAL :: DEBUG=.false.
			
			ALLOCATE(koordH(78,3))
			ALLOCATE(atomsorteH(78))

			if(DEBUG) WRITE(*,*) 'Start h_PPDI' 

			j=0
			DO i=7,82  !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
					j=j+1
					koordH(j,:)=koord(i,:)           !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
					dummy = TRIM(adjustl(atomsorte(i)))
					atomsorteH(j) = dummy(1:1)//'  ' ! Schneidet alles rechts ab
					!WRITE(*,*) j,atomsorteH(j),koordH(j,:)
			END DO
			! Addition von zusaetzlichen H atomen an C mit Abschneiden der Ketteh

			! H-Start
			NAtom=koordH(1,:)   !  N-Atom am Randstart
			c2Atom=koordH(9,:)   ! Referenz C -Atom, welches im eingebauten Ring in der gegenueberliegenden Position (Parastellung) liegt
			hAtom1(:)=c2Atom(:) 
			C3Atom=koord(2,:)    ! S-Atom an Potsiton 6 nach der Hexyl-Kette
			CALL setDistance(NAtom,hAtom1,-1.095) !Abstand anpassen -- das negative Vorzeichen wandelt die Anbaurichtung um
			koordH(77,:)= hAtom1
			atomsorteH(77)='H' 
		
			! H-Ende
			NAtom=koordH(76,:)   !  N-Atom am Randende
			c2Atom=koordH(63,:)  ! Referenz C -Atom, welches im eingebauten Ring in der gegenueberliegenden Position (Parastellung) liegt
			hAtom1(:)=c2Atom(:) 
			C3Atom=koord(75,:)    ! C-Atom seitlich vom anzudockenden N im Ring (in Richtung O) beliebig eines ist auswaehlbar
			CALL setDistance(NAtom,hAtom1,-1.095) !Abstand anpassen -- das negative Vorzeichen wandelt die Anbaurichtung um 
			koordH(78,:)= hAtom1
			atomsorteH(78)='H' 
	 
	 		IF (DEBUG) THEN
						write(*,*) 'Koordinaten in xyz ',trim(ziel)
						CALL make_coord_to_xyz(atomsorteH,koordH,size(atomsorteH),ziel)
						WRITE(*,*) 'h_PPDI  Ende'
			ENDIF
	 
	END SUBROUTINE h_PPDI

	SUBROUTINE h_PPDI_kette(atomsorte,koord,atomsorteH,koordH,NAtoms,ziel) 
	!! Subroutine to add H-Atoms to the chains so you end up with two CH3-CH2-CH2-CH3-CH-CH2-CH2-CH2-CH2-CH3 chains
	!! First copies the Data for the N-Ringsystem-N, then adds the two CH-groups and the big loop adds the CH2-...-CH3 chains.
	!! Addaption von h_DIPBI (uses definition with S (even if there is no S in the molecule)
	!! Im Optput werden die Ketten nach dem N-Ringsystem-N geschrieben. -> Die Reihenfolge wird nicht wie im *.gro beibehalten!
	IMPLICIT NONE
	Integer, INTENT(IN) :: NAtoms
	Real, Dimension(NAtoms,3), INTENT(IN) :: koord
	Character(5), Dimension(NAtoms), INTENT(INOUT) :: atomsorte
	REAL, ALLOCATABLE, DIMENSION(:,:), INTENT (OUT) ::koordH
	Character(5),ALLOCATABLE, Dimension(:), INTENT(OUT) :: atomsorteH
	Character(500), INTENT(IN) :: ziel
	CHARACTER(3) ::dummy
	Integer :: i,j,ind,anzahl,anzahlneu,cAtomRingInd,sAtomInd
	 Real, Dimension(3) :: cAtom,hAtom1,hAtom2,hAtom3,vorigesC,naechstesC,kreuzprod,hAtomold,hAtomA,hAtomB,OAtom,NAtom
	 Integer, Dimension(20) ::ind_C_Ketten
	 LOGICAL:: Cvorher, erste_vorher
	 Integer:: ketten, erste_Kette, ketten_2
	 Integer, Dimension(4):: ind_erste
	 Real::Rotwinkel,dist_sum_1,dist_sum_2
	 LOGICAL::DEBUG=.false.
	
	!WRITE(*,*) 'h_PPDI_kette start'
	!write(*,*) 'NAtoms', NAtoms
	anzahl=NAtoms
	anzahlneu = NAtoms + 46 !Gesamtanzahl Atome in neuer Datei

	allocate(atomsorteH(anzahlneu))
	allocate(koordH(anzahlneu,3))
	! uebergabe der ersten Atome des DIPBI ohne Seitenketten - jeweils vom N 
	j=0
	DO i=7,82  !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
		j=j+1
		koordH(j,:)=koord(i,:)           !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
		dummy = TRIM(adjustl(atomsorte(i)))
		atomsorteH(j) = dummy(1:1)//'  ' ! Schneidet alles rechts ab
		!WRITE(*,*) j,atomsorteH(j),koordH(j,:)
	END DO 


	! Indizes der 48 C Atome in den 4 Seitenketten
	ind_C_Ketten(1)=1   ! C
	ind=1
	do i=5,1,-1
		ind_C_Ketten(ind)=i ! von 1 bis 5 ; Reihenfolge rueckwaerts
		ind=ind+1
	END DO

	! 2. Kettenanteil
	do i=94,98,1
		ind_C_Ketten(ind)=i ! von 94-98
		ind=ind+1
	END DO

	do i=89,93,1
		ind_C_Ketten(ind)=i ! von 89-83
		ind=ind+1
	END DO

	do i=84,88,1
		ind_C_Ketten(ind)=i ! von 84-88
		ind=ind+1
	END DO


	do i=2,5,1
		atomsorte(i)="CH2"
	END DO 
	do i=84,97,1
		atomsorte(i)="CH2"
	END DO 
	atomsorte(1)="CH3"
	atomsorte(98)="CH3"
	atomsorte(93)="CH3"
	atomsorte(88)="CH3"

		!H-Start
		cAtom=koord(6,:)   !  C-Atom am Randstart
		NAtom=koord(7,:)  
		hAtomA(:)=koord(5,:) 
		! Test welches O als Referenz fuer das H-ausgewaehlt werden soll, in dem der groessere Abstand der beiden C-Atome an denen CH3- gebaut werden soll bestimmt wird
		! Test O9 und O20 in gro Nummerierung
		dist_sum_1=norm(koord(9,:)-koord(5,:))+norm(koord(9,:)-koord(94,:))
		dist_sum_2=norm(koord(20,:)-koord(5,:))+norm(koord(20,:)-koord(94,:))
		IF (dist_sum_1 > dist_sum_2) THEN
			OAtom=koord(9,:)
		ELSE 
			OAtom=koord(20,:)
		END IF
		CALL setDistance(cAtom,hAtomA,1.095) 
		call set_dih_by_rotation_around_axis(hAtomA,CAtom,NAtom,OAtom,2.9,Rotwinkel)
		! CH und H ueberfeveb
		koordH(77,:)= koord(6,:)
		atomsorteH(77)='C' 
		koordH(78,:)= hAtomA
		atomsorteH(78)='H' 

		! H-Ende
		cAtom=koord(83,:)  ! C-Atom am Randende
		NAtom=koord(82,:)  
		hAtomB(:)=koord(84,:)
		! Test welches O als Referenz fuer das H-ausgewaehlt werden soll, in dem der groessere Abstand der beiden C-Atome an denen CH3- gebaut werden soll bestimmt wird
		! Test O81 und O74 in gro Nummerierung
		dist_sum_1=norm(koord(81,:)-koord(84,:))+norm(koord(81,:)-koord(89,:))
		dist_sum_2=norm(koord(74,:)-koord(84,:))+norm(koord(74,:)-koord(89,:))
		IF (dist_sum_1 > dist_sum_2) THEN
			OAtom=koord(81,:)
		ELSE 
			OAtom=koord(74,:)
		END IF
		CALL setDistance(cAtom,hAtomB,1.095)
		call set_dih_by_rotation_around_axis(hAtomB,CAtom,NAtom,OAtom,2.9,Rotwinkel)
		koordH(79,:)= koord(83,:)
		atomsorteH(79)='C'   
		koordH(80,:)= hAtomB
		atomsorteH(80)='H' 

		!DO j=1, size(atomsorteH),1
		 !   WRITE(*,*) j,atomsorteH(j),koordH(j,:)
		!END DO
		
		!Do i=1,SiZE(ind_C_Ketten)
		!    WRITE(*,*) ind_C_Ketten(i),atomsorte(ind_C_Ketten(i)),koord(ind_C_Ketten(i),:) 
		!END DO

	cvorher=.false.  !Logikvariable fuer das erste CH2 in jeder Kette
	ketten=0 		 !Abzaehlen der 4 C12-Ketten
	erste_vorher= .false. 	!Logikvariable fuer das zweite CH2 jeder Kette
	ketten_2=1
	j=81  ! Index zum hochzaehlen der Atome
	!neue Koordinaten schreiben 
	!Die entsprechenden H werden jeweils nach dem C-Atom angefuegt
	DO i=1,size(ind_C_Ketten),1
		If (TRIM(atomsorte(ind_C_Ketten(i)))=='CH3' .OR. (TRIM(atomsorte(ind_C_Ketten(i)))=='CH2')) Then
			koordH(j,:)=koord(ind_C_Ketten(i),:)    ! Ausnahme der 4 schon geschriebenen ersten C-Atome der Kette
			atomsorteH(j)='C'        ! Zuerst jeweils das C in der Seitenkette an die Stelle j schreiben
			j=j+1
			!WRITE(*,*) j,ind_C_Ketten(i),atomsorte(ind_C_Ketten(i)),koord(ind_C_Ketten(i),:) 
		End If

		IF(atomsorte(ind_C_Ketten(i)) == 'CH2') THEN !H-Atome an Hexylgruppe anfuegen
			!Falls es das erste CH2 der Kette ist:
			IF(cvorher .eqv. .false.) Then  ! Beginn am Kettenanfang 
				ind_erste(ketten+1)=ind_C_Ketten(i)
				if (ketten==0) Then
				  erste_Kette=ind_C_Ketten(i)
				End if

				!1. C-Atom mit H bestuecken
				DO ind=1,3,1 !Koordinaten merken
					cAtom(ind) = koord(ind_C_Ketten(i),ind)
					naechstesC(ind) = koord(ind_C_Ketten(i+1),ind)
					if ((ketten == 0) .or. (ketten == 1)) Then
						vorigesC(ind) = koord(6,ind)   ! Auswahl von C6 
					ELSE IF(ketten == 2 .or. ketten ==3 ) THEN
						vorigesC(ind) = koord(83,ind)   ! Auswahl von C83
					End if

				END DO
				ketten=ketten+1
				!Write(*,*) 'Ketten', ketten
				if(ketten==4) then
							erste_vorher = .true.
							cvorher = .true.
				End if
			
				CALL kreuzprodukt(cAtom - vorigesC, cAtom -naechstesC,kreuzprod)
				hAtom1 = cAtom + kreuzprod ! Vektor senkrecht zur Ebene der 3 C-Atome
				hAtom2 = cAtom - kreuzprod
			
				CALL rotate(naechstesC,vorigesC,hAtom1,32.)  !Winkel anpassen
				CALL rotate(naechstesC,vorigesC,hAtom2,-32.) ! Rotation nach außen um die Verbinungdachse der Cs
			
				CALL setDistance(cAtom,hAtom1,1.095) !Abstand anpassen
				CALL setDistance(cAtom,hAtom2,1.095) !Abstand anpassen
						
				!Write(2,'(2X,A2,1X,3F16.6)') 'C ',cAtom(1),cAtom(2),cAtom(3)
				!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom1(1),hAtom1(2),hAtom1(3)
				!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom2(1),hAtom2(2),hAtom2(3)
				koordH(j,:)=hAtom1(:)    
				atomsorteH(j)='H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
				j=j+1
				koordH(j,:)=hAtom2(:)    
				atomsorteH(j)='H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
				j=j+1
				cvorher=.true.   

			Else 
				if (erste_vorher .eqv. .true.) Then
					!2. C-Atom mit H bestuecken - hier muess wieder auf das 1. C zugegriffen werden 
					!Daher wird eine Adressierung mit ketten_2 eingefuehrt
					DO ind=1,3,1 !Koordinaten merken
						cAtom(ind) = koord(ind_C_Ketten(i),ind)
						vorigesC(ind) = koord(ind_erste(ketten_2+1),ind) !ketten_2=2 muss erst bei der zweiten Kette loslaufen
						naechstesC(ind) = koord(ind_C_Ketten(i+1),ind)   ! daher ist ketten_2=1 zu Beginn 
					END DO
							  
					erste_vorher = .false.
					ketten_2=ketten_2+1

					
					CALL kreuzprodukt(cAtom - vorigesC, cAtom -naechstesC,kreuzprod)
		
					hAtom1 = cAtom + kreuzprod
					hAtom2 = cAtom - kreuzprod
	 
					CALL rotate(naechstesC,vorigesC,hAtom1,32.) !Winkel anpassen
					CALL rotate(naechstesC,vorigesC,hAtom2,-32.)
					
					CALL setDistance(cAtom,hAtom1,1.095) !Abstand anpassen
					CALL setDistance(cAtom,hAtom2,1.095) !Abstand anpassen
					   
					!Write(2,'(2X,A2,1X,3F16.6)') ' C ',cAtom(1),cAtom(2),cAtom(3)
					!Write(2,'(2X,A2,1X,3F16.6)') ' H ',hAtom1(1),hAtom1(2),hAtom1(3)
					!Write(2,'(2X,A2,1X,3F16.6)') ' H ',hAtom2(1),hAtom2(2),hAtom2(3)
						koordH(j,:)=hAtom1(:)    
						atomsorteH(j)='H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
						j=j+1
						koordH(j,:)=hAtom2(:)    
						atomsorteH(j)='H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
						j=j+1       
				
				Else    ! Durchlaufen vom 3. C-Atom der Kette bis zum vorletzen C-Atom.
						!1. C-Atom mit H bestuecken
					DO ind=1,3,1 !Koordinaten merken
						cAtom(ind) = koord(ind_C_Ketten(i),ind)
						vorigesC(ind) = koord(ind_C_Ketten(i-1),ind)
						naechstesC(ind) = koord(ind_C_Ketten(i+1),ind)
					END DO
							
					CALL kreuzprodukt(cAtom - vorigesC, cAtom -naechstesC,kreuzprod)
					hAtom1 = cAtom + kreuzprod
					hAtom2 = cAtom - kreuzprod
					
					CALL rotate(naechstesC,vorigesC,hAtom1,32.) !Winkel anpassen
					CALL rotate(naechstesC,vorigesC,hAtom2,-32.)
			
					CALL setDistance(cAtom,hAtom1,1.095) !Abstand anpassen
					CALL setDistance(cAtom,hAtom2,1.095) !Abstand anpassen
					hAtomOld=hAtom1
					
					!Write(2,'(2X,A2,1X,3F16.6)') 'C ',cAtom(1),cAtom(2),cAtom(3)
					!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom1(1),hAtom1(2),hAtom1(3)
					!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom2(1),hAtom2(2),hAtom2(3)
					koordH(j,:)=hAtom1(:)    
					atomsorteH(j)='H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
					j=j+1
					koordH(j,:)=hAtom2(:)    
					atomsorteH(j)='H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
					j=j+1
							
					
				END IF!Write(*,*) 'CH2 Ende'
			End if
		Else
			If(atomsorte(ind_C_Ketten(i))=='CH3') THEN 
				cAtomRingInd=  ind_C_Ketten(i - 2)
				sAtomInd= ind_C_Ketten(i)
				!letztes C-Atom mit 3 H-Atomen bestuecken
				DO ind=1,3,1 !Koordinaten merken
					cAtom(ind) = koord(sAtomInd,ind)
					vorigesC(ind) = koord(cAtomRingInd+1,ind)
					naechstesC(ind) = koord(sAtomInd+1,ind) !vorvoriges C-atom
				END DO		
				
				CALL kreuzprodukt(cAtom - vorigesC, cAtom -naechstesC,kreuzprod)
		
				hAtom1 = vorigesC
				CALL setDistance(cAtom,hAtom1,1.095)
				CALL rotate(cAtom,cAtom+kreuzprod,hAtom1,112.)
		
				hAtom2 = hAtom1  !schon mal die ungefaehre Position
				hAtom3 = hAtom1
		
				CALL rotate(vorigesC,cAtom,hAtom2,120.) !in korrekte Position bringen
				CALL rotate(vorigesC,cAtom,hAtom3,240.)
				
			   !Rotation um C-C Achse sodass der Diederwinkel H-C-C-H ~60° wird
			   ! (Korrektur zur passenden Newman-Projektion)
			   call set_dih_by_rotation_around_axis(hAtom1,cAtom,vorigesC,hAtomold,60.,Rotwinkel)
			   hAtom2=hAtom2-cAtom(:)
			   call Rotationsmatrix_alpha(hAtom2,Rotwinkel,vorigesC(:)-cAtom(:),.true.)
			   hAtom2(:)=hAtom2(:)+cAtom(:)
			  
			   hAtom3=hAtom3-cAtom(:)
			   call Rotationsmatrix_alpha(hAtom3,Rotwinkel,vorigesC(:)-cAtom(:),.true.)
			   hAtom3(:)=hAtom3(:)+cAtom(:)

				!letztes C-Atom ausgeben
				!Write(2,'(2X,A2,1X,3F16.6)') 'C ',cAtom(1),cAtom(2),cAtom(3)
				!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom1(1),hAtom1(2),hAtom1(3)
				!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom2(1),hAtom2(2),hAtom2(3)
				!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom3(1),hAtom3(2),hAtom3(3)
				koordH(j,:)=hAtom1(:)    
				atomsorteH(j)='H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
				j=j+1
				koordH(j,:)=hAtom2(:)    
				atomsorteH(j)='H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
				j=j+1
				koordH(j,:)=hAtom3(:)    
				atomsorteH(j)='H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
				j=j+1
				
				cvorher=.false. !Naechste Kette
				erste_vorher=.true. !Naechste Kette
			END IF
		End IF
	END DO
	 !CLOSE(2)

	! molA='.'
	!CALL make_coord_to_xyz_in_dir(atomsorteH,koordH,size(atomsorteH),ziel,molA)
	
		IF (DEBUG) THEN
						write(*,*) 'Koordinaten in xyz ',trim(ziel)
						CALL make_coord_to_xyz(atomsorteH,koordH,size(atomsorteH),ziel)
						WRITE(*,*) 'h_PPDI_Kette Ende'
		ENDIF
		
	END SUBROUTINE h_PPDI_kette

	SUBROUTINE h_PBDT_TS1(atomsorte,koord,atomsorte_H_all,koord_H_all,NAtoms,ziel) ! Schneidet die Ketten ab!
		!! Subroutine to cut the chains and substitute by methyl groups (CH3) to a PPI-molecule 
		!! obtained by a GROMACS-file.
		!! H-Atoms will be added with at the N-Atom with reference to the C-Atom on the oposite ring position (para)position.
		IMPLICIT NONE
		Integer, INTENT(IN) :: NAtoms
		Real, Dimension(NAtoms,3), INTENT(IN) :: koord
		REAL, ALLOCATABLE, DIMENSION(:,:), INTENT (OUT) :: koord_H_all
		Character(5),ALLOCATABLE, Dimension(:), INTENT(OUT) :: atomsorte_H_all
		Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
		Character(500) :: ziel
		CHARACTER(1)::dummy
		Real, Dimension(3) ::c1Atom,hAtom1,hAtom2,SAtom,kreuzprod
		INTEGER::i,j,p,i_start=0,Count_atoms_all=1
		INTEGER::N_CarboxyS2,N_PBDT,N_HC,N_gesamt
		REAL, ALLOCATABLE, DIMENSION(:,:)       :: koordH,koordCarboxyS2,koordPBDT
		Character(5),ALLOCATABLE,  Dimension(:) :: atomsorteH,atomsorteCarboxyS2,atomsortePBDT
		LOGICAL:: poly1=.false.,segment8=.false.,HStart=.true.
		LOGICAL, ALLOCATABLE, DIMENSION(:)::PBDT_chain
		Integer, Dimension(15,2)::Aindex
		Integer, Dimension(33,2)::Change_index
		REAL::Rotwinkel
		LOGICAL :: DEBUG=.false.
		
		HStart=.true.
		poly1=.false.
		segment8=.false.
		
		!! Arrays as temporarry data storage, to send coordinates to subroutines h_CarboxS2_propyl, h_PBDT_CH3
		ALLOCATE(koordCarboxyS2(15,3))
		ALLOCATE(atomsorteCarboxyS2(15))
		
		ALLOCATE(koordPBDT(32,3))
		ALLOCATE(atomsortePBDT(32))
		
		IF (DEBUG) THEN
			WRITE(*,*) 'Start h_PBDT_TS1' 
			DO j=1,NAtoms,1
				WRITE(*,*)  atomsorte(j),koord(j,:)
			END DO 
		END IF
		
		
		! Zaehle die Anzahl der Elemente im Molekuel N_CarboxyS2 ueber Anzahl der F-Atome und N_PBDT=(N_HC-Gruppen/6) uber die Anzahl der HC-Gruppen
		N_CarboxyS2=0
		N_PBDT=0
		DO i=1,NAtoms
			if (TRIM(adjustl(atomsorte(i)))=='F') N_CarboxyS2=N_CarboxyS2+1
			if (TRIM(adjustl(atomsorte(i)))=='HC') N_PBDT=N_PBDT+1
		END DO ! Zahle Anzahl
		N_PBDT =N_PBDT/6
		IF (DEBUG) WRITE(*,*) ' Die Anzahl der Carboxy-Gruppen ist: ',N_CarboxyS2
		IF (DEBUG) WRITE(*,*) ' Die Anzahl der N_PBDT-Gruppen ist: ',N_PBDT   
		N_gesamt=38*N_PBDT+22*N_CarboxyS2+2
		IF (DEBUG) WRITE(*,*) ' Die Gesamtanzahl nach dem Anfuegen der H-Atome betraegt',N_gesamt
		ALLOCATE(PBDT_chain(N_PBDT+N_CarboxyS2))
		ALLOCATE(koord_H_all(N_gesamt,3))
		ALLOCATE(atomsorte_H_all(N_gesamt))
		
		IF( (N_PBDT ==0) .AND. (N_CarboxyS2==0) ) THEN
			WRITE(*,*) 'Fehler: PBDT-TS_oder_CaboxyS2_wurden_nicht_richtig_eingelesen_pruefe_gro-Inputdatei. ENDE!'
			CALL EXIT (1)
		END IF
		PBDT_chain(:)=.false.
		
		! Festlegen der Reihenfolge
		j=0
		N_HC=0
		DO i=1,NAtoms,1
			if (TRIM(adjustl(atomsorte(i)))=='F') THEN
				j=j+1
				PBDT_chain(j)=.false.
			END IF
			if (TRIM(adjustl(atomsorte(i)))=='HC') THEN
				N_HC=N_HC+1
				iF (N_HC == 6) THEN
					j=j+1
					PBDT_chain(j)=.true.
					N_HC=0
				END IF
			END IF
		END DO ! Zahle Anzahl
		
		IF(DEBUG) WRITE(*,*) 'Reihenfolge T= PBDT, F=CarboxylS2'
		IF(DEBUG) THEN
			DO i=1,(N_PBDT+N_CarboxyS2)
			IF( PBDT_chain(i)) THEN
				IF(i==1) THEN
					WRITE(*,'(A5)',ADVANCE='NO') 'PBDT-'
				ELSE IF (i==size(PBDT_chain)) THEN
					WRITE(*,'(A5)') 'PBDT'
				ELSE
					WRITE(*,'(A5)',ADVANCE='NO') 'PBDT-'
				END IF
			ELSE
				IF(i==1) THEN
					WRITE(*,'(A10)',ADVANCE='NO') 'CarboxyS2-'
				ELSE IF (i==size(PBDT_chain)) THEN
					WRITE(*,'(A10)') '-CarboxyS2'
				ELSE 
					WRITE(*,'(A10)',ADVANCE='NO') 'CarboxyS2-'
				END IF
			END IF ! PBDT_chain
			END DO 
		 END IF    

		Count_atoms_all=1 ! Platzlassen fuer H1
		i_start=0
		! Schleife uber alle Teilabschnitte
		DO p=1,(N_PBDT+N_CarboxyS2) 
			IF (PBDT_chain(p)) THEN !PBDT-Abschnitt?
				IF(DEBUG) THEN
					WRITE(*,*) 'Start PBDT_Abschnitt'
					j=0
					DO i=i_start+1,i_start+32  !Bsp 17,48 Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
						j=j+1
						WRITE(*,*) j,atomsorte(i),koord(i,:)
					END DO
				END IF
				!!! Anpassung der Atomreihung in der gro-Datei, da diese nicht immer gleich ist, muss dies nun hier korrigiert werden (vor dem Anfuegen der H-Atome). 
				IF ( TRIM(adjustl(atomsorte(i_start+9))) == 'CH3' .AND. TRIM(adjustl(atomsorte(i_start+2))) == 'S'  ) THEN ! Befindet sich am ersten Teil des 8-mers
					!! Teil 1 (keine Anderung der Anordnung
					Change_index=transpose(reshape( (/ 1,1, 2,2, 3,3, 4,4, 5,5, 6,6, 7,7, 8,8, 9,9, 10,10, 11,11, 12,12, &
					&13,13, 14,14, 15,15, 16,16, 17,17, 18,18, 19,19, 20,20, 21,21, 22,22, 23,23, 24,24, 25,25, 26,26, 27,27, 28,28,&
					&29,29, 30,30, 31,31, 32,32,   32,32 /), (/ 2, 33/)))   
					IF (DEBUG) WRITE(*,*) 'Fall 1'
				ELSE IF ( TRIM(adjustl(atomsorte(i_start+15))) == 'CH3' .AND. TRIM(adjustl(atomsorte(i_start+2))) == 'S' &
						& .AND. TRIM(adjustl(atomsorte(i_start+24))) /= 'CH3' ) THEN !! Teil 2
					!! Change Teil 1 to Teil 2 (letzte indizes sind doppelt, da H-Abschluss moeglich ist)
					Change_index=transpose(reshape( (/ 1,1, 2,2, 3,3, 4,19, 5,20, 6,28, 7,25, 8,26, 9,27, 10,23, 11,24, 12,21, &
					&13,22, 14,18, 15,17, 16,7, 17,8, 18,16, 19,13, 20,14, 21,15, 22,11, 23,12, 24,9, 25,10, 26,4, 27,5, 28,6, &
					&29,32, 30,31, 31,29, 32,30,   32,30 /), (/ 2, 33/)))       
					IF (DEBUG)WRITE(*,*) 'Fall 2'                
				ELSE IF ( TRIM(adjustl(atomsorte(i_start+12))) == 'CH3' ) THEN !! Teil 3,4
					!! Change Teil 1 to Teil 3
					Change_index=transpose(reshape( (/ 1,1, 2,6, 3,5, 4,7, 5,8, 6,9, 7,10, 8,11, 9,12, 10,13, 11,14, 12,15, 13,16, &
					& 14,17, 15,18, 16,19, 17,20, 18,28, 19,25, 20,26, 21,27, 22,23, 23,24, 24,21, 25,22, 26,4, 27,2, 28,3, 29,29, &
					&30,30, 31,31, 32,32,   32,32 /), (/ 2, 33/)))   
					IF (DEBUG) WRITE(*,*) 'Fall 3'    
				ELSE IF ( TRIM(adjustl(atomsorte(i_start+15))) == 'CH3' .AND.  TRIM(adjustl(atomsorte(i_start+6))) == 'S' ) THEN !! Teil 5,6
					Change_index=transpose(reshape( (/ 1,1, 2,6, 3,5, 4,7, 5,8, 6,16, 7,13, 8,14, 9,15, 10,11, 11,12, 12,9, 13,10, &
					& 14,17, 15,18, 16,19, 17,20, 18,28, 19,25, 20,26, 21,27, 22,23, 23,24, 24,21, 25,22, 26,4, 27,2, 28,3, 29,29, &
					&30,30, 31,31, 32,32,   32,32 /), (/ 2, 33/)))   
				   IF (DEBUG) WRITE(*,*) 'Fall 4'            
				ELSE IF ( TRIM(adjustl(atomsorte(i_start+24))) == 'CH3' )  THEN !! Teil 7
					Change_index=transpose(reshape( (/ 1,1, 2,6, 3,5, 4,7, 5,8, 6,16, 7,13, 8,14, 9,15, 10,11, 11,12, 12,9, 13,10, &
					& 14,17, 15,18, 16,19, 17,20, 18,21, 19,22, 20,23, 21,24, 22,25, 23,26, 24,27, 25,28, 26,4, 27,2, 28,3, 29,29, &
					&30,30, 31,31, 32,32,   32,32 /), (/ 2, 33/)))             
				
				ELSE IF ( TRIM(adjustl(atomsorte(i_start+10))) == 'CH3' ) THEN !! Teil 8
					!! Change Teil 1 to Teil 8
					Change_index=transpose(reshape( (/ 1,1, 2,24, 3,23, 4,22, 5,25, 6,33, 7,30, 8,31, 9,32, 10,28, 11,29, 12,26, &
					&13,27, 14,21, 15,15, 16,5, 17,6, 18,7, 19,8, 20,9, 21,10, 22,11, 23,12, 24,13, 25,14, 26,4, 27,2, 28,3, 29,16, &
					&30,17, 31,19, 32,20, 33,18  /), (/ 2, 33/)))  !! mit H-Atom-Ende an letzter Position (33 bzw 18) 
					IF (DEBUG) WRITE(*,*) 'Fall 8'   
					segment8=.true.              
				END IF
			
			
				koordPBDT(:,:)=0
				IF (DEBUG) WRITE(*,*) 'i_start:',i_start,i_start+1,i_start+32
				IF (DEBUG) WRITE(*,*) 'Start vor h_PBDT_CH3'
				j=0
				DO i=i_start+1,i_start+32  !Bsp 17,48 Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
					j=j+1
					koordPBDT(Change_index(j,1),:)=koord(i_start+Change_index(j,2),:)           !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
					dummy = TRIM(adjustl(atomsorte(i_start+Change_index(j,2))))
					atomsortePBDT(Change_index(j,1)) = dummy(1:1)//'  ' ! Schneidet alles rechts ab
					IF (DEBUG) THEN 
			WRITE(*,*) Change_index(j,1),Change_index(j,2),j,atomsorte(i),koord(i,:),' changed_to ',atomsortePBDT(j),koordPBDT(j,:)
					END IF !DEBUG 
				END DO

			
				i_start=i_start+32
				If (allocated(koordH))  deallocate (koordH)
				If (allocated(atomsorteH))  deallocate (atomsorteH)
				CALL h_PBDT_CH3(atomsortePBDT,koordPBDT,atomsorteH,koordH,size(atomsortePBDT),ziel,DEBUG) 
				
				IF (DEBUG) WRITE(*,*) 'ENDE PBDT_Abschnitt'
			  
			ELSE ! CarboxylS2-Gruppe   
				! Test ob man sich am Anfang des 8meres befindet, welches mit F-Atom anfaengt
				if (TRIM(adjustl(atomsorte(i_start+1)))=='F') THEN ! start ist i_start=0 also erstes Atom im Array
					poly1=.true. ! Erstes Polymer!
					! Reihenfolge muss angepasst werden!
					j=0
					Aindex=transpose(reshape( (/ 1,4, 2,3, 3,5, 4,6, 5,7, 6,8, 7,9, 8,10, &
													& 9,11, 10,12, 11,13, 12,2, 13,1, 15,15, 16,14  /), (/ 2, 15/)))

					Do i=i_start+1,i_start+15
						IF (DEBUG) THEN
							WRITE(*,*) Aindex(i,1),Aindex(i,2)
						END IF
						koordCarboxyS2(Aindex(i,2),:)=koord(Aindex(i,1),:)
						atomsorteCarboxyS2(Aindex(i,2))=atomsorte(Aindex(i,1))
					END DO
					i_start=i_start+16
					
					IF (DEBUG) THEN
						WRITE(*,*) 'rein Carb gro-format:'
						DO i =1,15
							WRITE(*,*) atomsorteCarboxyS2(i),koordCarboxyS2(i,:)
						END Do
					END IF 
					
					CALL h_CarboxS2_propyl(atomsorteCarboxyS2,koordCarboxyS2,atomsorteH,koordH,size(atomsorteCarboxyS2),ziel,DEBUG)            
					
					IF (DEBUG) WRITE(*,*) 'End Carboxy1'
					
					!molA='.'
					!CALL make_coord_to_xyz_in_dir(atomsorte_H_all(2:23),koord_H_all(2:23,:),22,ziel,molA)
					
					!!!!Ende Test fuer ersten Polymerabschnitt poly1
				ELSE   ! Hauptteil, nicht erstes Element ist CarboxylS2
					
					IF (DEBUG) THEN
						WRITE(*,*) 'Start Carb'
						DO i=i_start+1,i_start+15 
							WRITE(*,*) atomsorte(i),koord(i,:)
						END DO
					END IF ! DEBUG 
					
					! Abb 1 auf 2 ! Abbildungsvorschriften der einzelnen Carboxyl Abschnittel von 1-8 auf die Reihung der Atome im zweiten Abschnitt!! Abbildungen sind in Gruppen zusammengeordnet
					if (TRIM(adjustl(atomsorte(i_start+1)))=='F') THEN ! start ist i_start=0 also erstes Atom im Array
						Aindex=transpose(reshape( (/ 13, 	1, 	12, 	2, 	2, 	3, 	1, 	4, 	3, 	5, 	4, 	6, 	5, 	7, 	6, 	8, 	7, 	9, 	8, 	10,&
						& 	9, 	11, 	10, 	12, 	11, 	13, 	16, 	14, 	15, 	15 /), (/ 2, 15/)))
						IF (DEBUG) WRITE(*,*) 'FALL_A'
					ELSE IF (TRIM(adjustl(atomsorte(i_start+1)))=='CH3') THEN ! start ist i_start=0 also erstes Atom im Array, Fall, wenn die Atome schon vorsortiert wurden
						Aindex=transpose(reshape( (/ 2,1, 3,2, 4,3, 5,4, 6,5, 7,6, 8,7, 9,8, 10,9, 11,10, 12,11, 13,12, &
						& 14,13, 15,14, 16,15 /), (/ 2, 15/))) ! Ende 14,1 C an der H-Start
						IF (DEBUG) WRITE(*,*) 'FALL_A sorted'
					! Abb 2 auf 2
					ELSE IF (TRIM(adjustl(atomsorte(i_start+7)))=='O') THEN
						Aindex=transpose(reshape( (/ 1, 	1, 	2, 	2, 	3, 	3, 	4, 	4, 	5, 	5, 	6, 	6, 	7, 	7, 	8, 	8, 	9, 	9, 	10, 	10,&
						& 	11, 	11, 	12, 	12, 	13, 	13, 	14, 	14, 	15, 	15 /), (/ 2, 15/)))
						IF (DEBUG) WRITE(*,*) 'FALL_B'
					ELSE IF (TRIM(adjustl(atomsorte(i_start+12)))=='O') THEN
						! Abb 3/4/7/8 (vier Abschnitte als Abbildung ) auf 2
						Aindex=transpose(reshape( (/ 1, 	1, 	15, 	2, 	13, 	3, 	14, 	4, 	6, 	5, 	7, 	6, 	12, 	7, 	8, 	8, 	9, 	9,&
						& 	10, 10, 11, 	11, 	5, 	12, 	4, 	13, 	3, 	14, 	2, 	15 /), (/ 2, 15/)))
						IF (DEBUG) WRITE(*,*) 'FALL_C'
					ELSE IF (TRIM(adjustl(atomsorte(i_start+11)))=='O') THEN
					! Abb 5/6 auf 2
						Aindex=transpose(reshape( (/ 1, 	1, 	2, 	2, 	3, 	3, 	4, 	4, 	5, 	5, 	6, 	6, 	11, 	7, 	7, 	8, 	8, 	9, 	9,&
						& 	10, 	10, 	11, 	12, 	12, 	13, 	13, 	14, 	14, 	15, 	15 /), (/ 2, 15/)))
						IF (DEBUG) WRITE(*,*) 'FALL_D'
					END IF ! Ende Abbildung der indizes um auf indexiserung im zweiten Abschnitt abzubilden.
					
				
					j=0
					IF (DEBUG) WRITE(*,*) 'i_start:',i_start,i_start+1,i_start+15
					DO i=i_start+1,i_start+15  !49,63 Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
							j=j+1
							koordCarboxyS2(Aindex(j,2),:)=koord(i_start+Aindex(j,1),:)           !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
							dummy = TRIM(adjustl(atomsorte(i_start+Aindex(j,1))))
							atomsorteCarboxyS2(Aindex(j,2)) = dummy(1:1)//'  ' ! Schneidet alles rechts ab
							!WRITE(*,*) j,atomsorte(i),atomsorteCarboxyS2(j),koordCarboxyS2(j,:)
					END DO
					
					IF (TRIM(adjustl(atomsorte(i_start+1)))=='CH3') THEN ! Erstes Atom im Array bei Vorsortierung
						i_start=i_start+16
					ELSE
						i_start=i_start+15
					END IF
					CALL h_CarboxS2_propyl(atomsorteCarboxyS2,koordCarboxyS2,atomsorteH,koordH,size(atomsorteCarboxyS2),ziel,DEBUG)
				END IF !Ende Test fuer ersten Polymerabschnitt poly1 / Ende Hauptteil CarboxylS2
			END IF ! PBDT_chain(p)? 
			
			DO i=1,size(atomsorteH) ! Ubergabe an gesamtes file ab Count_atoms_all=2
				Count_atoms_all=Count_atoms_all+1
				atomsorte_H_all(Count_atoms_all)=atomsorteH(i)
				koord_H_all(Count_atoms_all,:)=koordH(i,:)
			END DO
			
			IF(HStart) THEN ! Anbau des ersten H Atomes
				! H-Start
				
				IF( PBDT_chain(1) )THEN
					c1Atom=koordPBDT(1,:)     !  C-Atom am Randende
					SAtom=koordCarboxyS2(29,:)
					hAtom1(:)=koordPBDT(3,:)  ! Referenz C -Atom, welches im eingebauten Ring in der gegenueberliegenden Position (Parastellung) liegt
				ELSE 
					c1Atom=koordCarboxyS2(1,:)
					SAtom=koordCarboxyS2(15,:)
					hAtom1(:)=koordCarboxyS2(14,:)
				END IF    
				CALL setDistance(c1Atom,hAtom1,-1.095) !Abstand anpassen -- das negative Vorzeichen wandelt die Anbaurichtung um 
				!CALL setAngle(c1Atom,SAtom,hAtom1,hAtom1,(3.9))
				Rotwinkel=angle(SAtom,c1Atom,hAtom1)
				
				!IF (DEBUG) !WRITE(*,*) 'Winkel vorher', Rotwinkel
				CALL kreuzprodukt(SAtom-c1Atom, c1Atom-hAtom1,kreuzprod)
				hAtom1=hAtom1-c1Atom(:)
				call Rotationsmatrix_alpha(hAtom1,(119.1-Rotwinkel),kreuzprod-c1Atom,.true.)
				hAtom1(:)=hAtom1(:)+c1Atom(:) 
				!IF (DEBUG) !WRITE(*,*) 'Winkel HStart, hinterher:',angle(SAtom,c1Atom,hAtom1)
				IF (DEBUG) WRITE(*,*) 'HStart','H ',hatom1
				koord_H_all(1,:)=hAtom1
				atomsorte_H_all(1)='H  ' 
				HStart=.false.
			END IF
		
		END DO ! p-Schleife ueber die einzelnen Unterabschnitte
	   

	! H-Ende setze das letze H-Atom     
		IF( PBDT_chain( size(PBDT_chain)) )THEN
			c1Atom=koordPBDT(30,:)     ! C-Atom am Randende
			SAtom=koordCarboxyS2(29,:)
			hAtom2(:)=koordPBDT(15,:)  ! Referenz C -Atom, welches im eingebauten Ring in der gegenueberliegenden Position (Parastellung) liegt
		ELSE 
			c1Atom=koordCarboxyS2(14,:)
			SAtom=koordCarboxyS2(15,:)
			hAtom2(:)=koordCarboxyS2(1,:)
		END IF    
		CALL setDistance(c1Atom,hAtom2,-1.095) !Abstand anpassen -- das negative Vorzeichen wandelt die Anbaurichtung um 
		
		Rotwinkel=angle(SAtom,c1Atom,hAtom2)
		!CALL setAngle(c1Atom,SAtom,hAtom2,hAtom2,-119.9)
		
		CALL kreuzprodukt(SAtom-c1Atom, c1Atom-hAtom2,kreuzprod)
		hAtom2=hAtom2-c1Atom(:)
		call Rotationsmatrix_alpha(hAtom2,(Rotwinkel-119.1),kreuzprod-c1Atom,.true.)
		hAtom2(:)=hAtom2(:)+c1Atom(:) 

		Count_atoms_all=Count_atoms_all+1
		koord_H_all(Count_atoms_all,:)=hAtom2
		atomsorte_H_all(Count_atoms_all)='H  ' 
		IF(DEBUG) write(*,*) 'H-Winkel: ',angle(SAtom,c1Atom,hAtom2)


		!molA='.'
		!CALL make_coord_to_xyz_in_dir(atomsorte_H_all,koord_H_all,size(atomsorte_H_all),ziel,molA)
		
		
		!DO j=1,size(atomsorteH),1
		 !   WRITE(*,*)  j,atomsorteH(j),koordH(j,:)
		!END DO 
		IF (DEBUG) THEN
						write(*,*) 'Koordinaten in xyz ',trim(ziel)
						CALL make_coord_to_xyz(atomsorte_H_all,koord_H_all,size(atomsorteH),ziel)
						IF (DEBUG) WRITE(*,*) 'h_PBDT_TS1 Ende'
		ENDIF   
	   
	END SUBROUTINE h_PBDT_TS1

	SUBROUTINE h_PBDT_CH3(atomsorte,koord,atomsorteH,koordH,NAtoms,ziel,DEBUG) ! Schneidet die Ketten ab!
			!! Subroutine to add H-Atoms to form two methyl-CH3 group  to in h_PBDT_CH3-Part PBDT_TS1-molecule 

			IMPLICIT NONE
			Integer, INTENT(IN) :: NAtoms
			Real, Dimension(NAtoms,3), INTENT(IN) :: koord
			REAL, ALLOCATABLE, DIMENSION(:,:), INTENT (OUT) ::koordH
			Character(5),ALLOCATABLE, Dimension(:), INTENT(OUT) :: atomsorteH
			Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
			LOGICAL,INTENT(IN)::DEBUG
			Character(500) :: ziel
			CHARACTER(1)   ::dummy
			Real, Dimension(3) ::cAtom,NAtom,X,hAtom1,hAtom2,hAtom3,kreuzprod
			INTEGER::i,j,p,anzahl_methylgruppen=2
			! Mindex C10-C9-O9-HAtomA-H1-H2-H3
			Integer, Dimension(2,7)::Mindex
			Real::Rotwinkel
			
			ALLOCATE(koordH(38,3))
			ALLOCATE(atomsorteH(38))
			
			IF (DEBUG) WRITE(*,*) 'start h_PBDT_CH3'
			! Die ersten 4 Zahlen geben jeweils den alten Index an (C9-S8-C7-S6) -- dann kommen die neuen Indizes (H10-H11-H12)
			! 2 Methylgruppen werden gesetzt.
			Mindex=transpose(reshape( &
		&(/ 9,8,7,6,10,11,12  ,21,20,19,18,25,26,27 /), (/ 7, 2/)))
		! Uebergabe in neue Form
		j=0
		DO i=1,9  !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
				j=j+1
				koordH(j,:)=koord(i,:)           !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
				dummy = TRIM(adjustl(atomsorte(i)))
				atomsorteH(j) = dummy(1:1)//'  ' ! Schneidet alles rechts ab
				!WRITE(*,*) j,atomsorteH(j),koordH(j,:)
		END DO 
		j=12 ! ueberspringe 3 H-Atome
		DO i=10,21  !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
			j=j+1
			koordH(j,:)=koord(i,:)           !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
			dummy = TRIM(adjustl(atomsorte(i)))
			atomsorteH(j) = dummy(1:1)//'  ' ! Schneidet alles rechts ab
			!WRITE(*,*) i,atomsorteH(j),koordH(j,:)
		END DO        
		
		j=27 ! ueberspringe 3 H-Atome
		DO i=22,32  !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
			j=j+1
			koordH(j,:)=koord(i,:)           !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
			dummy = TRIM(adjustl(atomsorte(i)))
			atomsorteH(j) = dummy(1:1)//'  ' ! Schneidet alles rechts ab
			!WRITE(*,*) i,atomsorteH(j),koordH(j,:)
		END DO   

		
	   ! Schleife zum Anbau der 2 Methylendgruppen ( Hier gibt es natuerlich kein NAtom!!!!)
	   DO p=1,anzahl_methylgruppen     !! Vorsicht die Benennung der Atome stimmt ab hier nicht mehr mit den Benennungen im h_PBDT_CH3 ueberein, da die DIPBI Routine verwendet wurde 
			cAtom=koord(Mindex(p,1),:)
			NAtom=koord(Mindex(p,2),:)
			CALL kreuzprodukt(CAtom - NAtom, cAtom-koord(Mindex(p,3),:),kreuzprod)
			hAtom1 = NAtom
			CALL setDistance(cAtom,hAtom1,1.095)
			CALL rotate(cAtom,(cAtom+kreuzprod),hAtom1,112.5)
			hAtom2 = hAtom1
			hAtom3 = hAtom1
			CALL rotate(NAtom,cAtom,hAtom2,120.) ! Rotationen von hAtom2
			CALL rotate(NAtom,cAtom,hAtom3,240.) ! Rotation von hAtom3
		
		   !Start Rotation um Dih zum H-Atom anzupassen
			call set_dih_by_rotation_around_axis(hAtom1,cAtom,NAtom,koord(Mindex(p,4),:),60.0,Rotwinkel)

			!call set_dih_by_rotation_around_axis(hAtom1,cAtom,NAtom,koord(Mindex(p,4),:),7.8,Rotwinkel)
			X=hAtom2(:)-cAtom(:)
			call Rotationsmatrix_alpha(X,Rotwinkel,NAtom-cAtom,.true.)
			hAtom2(:)=X(:)+cAtom(:)
	 
			X=hAtom3(:)-cAtom(:)
			call Rotationsmatrix_alpha(X,Rotwinkel,NAtom-cAtom,.true.)
			hAtom3(:)=X(:)+cAtom(:)
			!Ende Extra Rotation
		
			koordH(Mindex(p,5),:)=hAtom1(:)
			koordH(Mindex(p,6),:)=hAtom2(:)
			koordH(Mindex(p,7),:)=hAtom3(:)
			atomsorteH(Mindex(p,5))='H '
			atomsorteH(Mindex(p,6))='H '
			atomsorteH(Mindex(p,7))='H '

	   END DO ! i-Schleife Methylgruppen
	   
		!DO j=1,38
		!    WRITE(*,*) j,atomsorteH(j),koordH(j,:)
		!END DO  
		!   molA='.'
		!CALL make_coord_to_xyz_in_dir(atomsorteH,koordH,size(atomsorteH),ziel,molA)
		IF (DEBUG) THEN
						write(*,*) 'Koordinaten in xyz ',trim(ziel)
						CALL make_coord_to_xyz(atomsorteH,koordH,size(atomsorteH),ziel)
						WRITE(*,*) 'Ende h_PBDT_CH3'
		ENDIF

	END SUBROUTINE h_PBDT_CH3

	SUBROUTINE h_CarboxS2_propyl(atomsorte,koord,atomsorteH,koordH,NAtoms,ziel,debug) ! Schneidet die Ketten ab!
			!! Subroutine to add H-Atoms to form a propyl group (CH3-CH-CH3)-O-C=O --Ring to in CarboxS2-Part(with F-Atom) PBDT_TS1-molecule 
			IMPLICIT NONE
			Integer, INTENT(IN) :: NAtoms
			Real, Dimension(NAtoms,3), INTENT(IN) :: koord
			REAL, ALLOCATABLE, DIMENSION(:,:), INTENT (OUT) ::koordH
			Character(5),ALLOCATABLE, Dimension(:), INTENT(OUT) :: atomsorteH
			Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
			LOGICAL, INTENT(IN) :: debug
			Character(500) :: ziel
			CHARACTER(1)   ::dummy
			Real, Dimension(3) ::cAtom,c2Atom,c3Atom,NAtom,X,hAtom1,hAtom2,hAtom3,kreuzprod,OAtom,hAtomA,hAtomB,OEsterAtom
			INTEGER::i,j,p,anzahl_methylgruppen=2
			! Mindex C10-C9-O9-HAtomA-H1-H2-H3
			Integer, Dimension(2,7)::Mindex
			Integer, Dimension(3,2)::Cindex
			Real::Rotwinkel,dRotwinkel,winkel_A,winkel_B,winkel_opt
			INTEGER::winkel,i_start,i_ende
			
			ALLOCATE(koordH(22,3))
			ALLOCATE(atomsorteH(22))
		IF(debug) WRITE(*,*) 'start h_CarboxS2_propyl'
			! Die ersten 4 Zahlen geben jeweils den alten Index an (C10-C9-O8-HAtomA) -- dann kommen die neuen Indizes (H12-H13-H14)
			! 2 Methylgruppen werden gesetzt.
			Mindex=transpose(reshape( &
		&(/ 10,9,8,6,12,13,14  ,11,9,8,6,16,17,18 /), (/ 7, 2/)))
		!!! Uebergabe des C-Atome aus der Seitenkette an die Position im Array 1=alter Index ,2= neuer Index Anzahl der C-Atome durchlaufen als i=1,6 
		!!  C10 aus koord wird zum ersten neuen C in koordH C11 daher 10,11 ... dann wird Platz fuer 3 H-Atome gelassen (neuer Index 12 13 14) und altes C11 wird dann zu C15 mit (H16 H17 H18)
		Cindex=transpose(reshape( (/ 9,9, 10,11, 11,15 /), (/ 2, 3/)))
		Do i=1,3
			!WRITE(*,*) Cindex(i,1),Cindex(i,2)
			koordH(Cindex(i,2),:)=koord(Cindex(i,1),:)
			atomsorteH(Cindex(i,2))='C'
		END DO
		j=0
		DO i=1,9  !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
				j=j+1
				koordH(j,:)=koord(i,:)           !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
				dummy = TRIM(adjustl(atomsorte(i)))
				atomsorteH(j) = dummy(1:1)//'  ' ! Schneidet alles rechts ab
				!WRITE(*,*) j,atomsorteH(j),koordH(j,:)
		END DO 
		j=18
		DO i=12,15  !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
			j=j+1
			koordH(j,:)=koord(i,:)           !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
			dummy = TRIM(adjustl(atomsorte(i)))
			atomsorteH(j) = dummy(1:1)//'  ' ! Schneidet alles rechts ab
			!WRITE(*,*) j,atomsorteH(j),koordH(j,:)
		END DO        
				
		!H-Start
		cAtom=koord(9,:)   !  C-Atom am Randstart
		c2Atom=koord(10,:) 
		c3Atom=koord(11,:) 
		OEsterAtom=koord(8,:)  
		hAtomA(:)=c2Atom
		OAtom=koord(7,:)
		
		
		! Test fuer positive oder negative Drehrichtung 
		! Erst werden zwei testwinkel fuer hAtomA und hAtomB bestimmt um zu schauen, in welchen Bereich die Rotation durchgefuehrt werden muss
		Rotwinkel=120
		hAtomA(:)=c2Atom
		CALL setDistance(cAtom,hAtomA,1.095)
		hAtomA=hAtomA-cAtom(:)
		call Rotationsmatrix_alpha(hAtomA,Rotwinkel,OEsterAtom(:)-cAtom(:),.true.)
		hAtomA(:)=hAtomA(:)+cAtom(:)
		
		Rotwinkel=240
		hAtomB(:)=c2Atom
		CALL setDistance(cAtom,hAtomB,1.095) 
		hAtomB=hAtomB-cAtom(:)
		call Rotationsmatrix_alpha(hAtomB,Rotwinkel,OEsterAtom(:)-cAtom(:),.true.)
		hAtomB(:)=hAtomB(:)+cAtom(:)
		
		! Dann werden fuer die neuen H-Atome die Abstaende zu C2 und C3 gemessen und der Bereich, fuer den die Abstaende groesser ausfallen wird gewaehlt
		!WRITE (*,*) 'Dist 1' ,(norm(c2Atom-hAtomA)+norm(c3Atom-hAtomA))
		!WRITE (*,*) 'Dist 2' ,(norm(c2Atom-hAtomB)+norm(c3Atom-hAtomB))
		
		
		 IF( (norm(c2Atom-hAtomA)+norm(c3Atom-hAtomA)) > (norm(c2Atom-hAtomB)+norm(c3Atom-hAtomB)) ) THEN
			i_start=90
			i_ende=140
			!WRITE(*,*) 'FALL A'
		 ELSE
			i_start=220
			i_ende=270
			!WRITE(*,*) 'FALL B'
		END IF

		! Es soll nun durch schrittweisen Drehen, aus der Position con C2 um die C1-OEsterAtom-Achse, die Rotation gefunden werden, fuer
		! die die Differenz (dRotwinkel) der beiden Winkel winkel_A(C2-C1-hAtomA) und winkel_B(hAtomA-C1-C3) minimal wird.
		winkel_opt=real(i_start)
		winkel_A=angle(c2Atom,cAtom,hAtomA)
		winkel_B=angle(hAtomA,cAtom,c3Atom)
		dRotwinkel=abs(winkel_A-winkel_B)
		DO winkel=i_start,i_ende,2
			Rotwinkel=REal(winkel)
			hAtomA(:)=c2Atom !Reset
			! Finde den passenden Winkel so, dass die Abweiung dRotwinkel minimal wird
			hAtomA=hAtomA-cAtom(:)
			call Rotationsmatrix_alpha(hAtomA,Rotwinkel,OEsterAtom(:)-cAtom(:),.true.)
			hAtomA(:)=hAtomA(:)+cAtom(:)
			
			winkel_A=angle(c2Atom,cAtom,hAtomA)
			winkel_B=angle(hAtomA,cAtom,c3Atom)
			IF ( abs(winkel_A-winkel_B) < dRotwinkel ) THEN ! Winkel sollen gleich gross sein
				! winkel_opt enthaelt zum Schluss die optimale Rotation
				winkel_opt=Rotwinkel
				dRotwinkel=abs(winkel_A-winkel_B)
			END IF
			
			!WRITE(*,*) 'Winkel',Rotwinkel,winkel_A,winkel_B,winkel_opt
		END DO 
		
		! Rotation mit optimalem Winkel: winkel_opt
		hAtomA(:)=c2Atom
		CALL setDistance(cAtom,hAtomA,1.095) 
		hAtomA=hAtomA-cAtom(:)
		call Rotationsmatrix_alpha(hAtomA,winkel_opt,OEsterAtom(:)-cAtom(:),.true.)
		hAtomA(:)=hAtomA(:)+cAtom(:)
		koordH(10,:)=hAtomA 
		atomsorteH(10)='H  ' 
		!winkel_A=angle(c2Atom,cAtom,hAtomA)
		!winkel_B=angle(hAtomA,cAtom,c3Atom)
		!WRITE(*,*) 'Final Winkel',Rotwinkel,winkel_A,winkel_B,winkel_opt
		
	   !!! Schleife zum Anbau der 2 Methylendgruppen ( Hier gibt es natuerlich kein NAtom!!!!)
	   DO p=1,anzahl_methylgruppen     !! Vorsicht die Benennung der Atome stimmt ab hier nicht mehr mit den Benennungen im CarboxyS2 ueberein, da die DIPBI Routine verwendet wurde 
			cAtom=koord(Mindex(p,1),:)
			NAtom=koord(Mindex(p,2),:)
			CALL kreuzprodukt(CAtom - NAtom, cAtom-koord(Mindex(p,3),:),kreuzprod)
			hAtom1 = NAtom
			CALL setDistance(cAtom,hAtom1,1.095)
			CALL rotate(cAtom,(cAtom+kreuzprod),hAtom1,112.5)
			hAtom2 = hAtom1
			hAtom3 = hAtom1
			CALL rotate(NAtom,cAtom,hAtom2,120.) ! Rotationen von hAtom2
			CALL rotate(NAtom,cAtom,hAtom3,240.) ! Rotation von hAtom3
		
		   !Start Rotation um Dih zum H-Atom anzupassen
			call set_dih_by_rotation_around_axis(hAtom1,cAtom,NAtom,hAtomA,60.0,Rotwinkel)

			!call set_dih_by_rotation_around_axis(hAtom1,cAtom,NAtom,koord(Mindex(p,4),:),7.8,Rotwinkel)
			X=hAtom2(:)-cAtom(:)
			call Rotationsmatrix_alpha(X,Rotwinkel,NAtom-cAtom,.true.)
			hAtom2(:)=X(:)+cAtom(:)
	 
			X=hAtom3(:)-cAtom(:)
			call Rotationsmatrix_alpha(X,Rotwinkel,NAtom-cAtom,.true.)
			hAtom3(:)=X(:)+cAtom(:)
			!Ende Extra Rotation
		
			koordH(Mindex(p,5),:)=hAtom1(:)
			koordH(Mindex(p,6),:)=hAtom2(:)
			koordH(Mindex(p,7),:)=hAtom3(:)
			atomsorteH(Mindex(p,5))='H '
			atomsorteH(Mindex(p,6))='H '
			atomsorteH(Mindex(p,7))='H '

	   END DO ! i-Schleife Methylgruppen

		IF (DEBUG) THEN
						write(*,*) 'Koordinaten in xyz ',trim(ziel)
						CALL make_coord_to_xyz(atomsorteH,koordH,size(atomsorteH),ziel)
		ENDIF

	END SUBROUTINE h_CarboxS2_propyl

	SUBROUTINE h_diPBI_kette(atomsorte,koord,atomsorteH,koordH,NAtoms,ziel) 
	!! Adds H Atoms to the total side chain in DIPBI
	IMPLICIT NONE
	Integer, INTENT(IN) :: NAtoms
	Real, Dimension(NAtoms,3), INTENT(IN) :: koord
	Character(5), Dimension(NAtoms), INTENT(INOUT) :: atomsorte
	REAL, ALLOCATABLE, DIMENSION(:,:), INTENT (OUT) ::koordH
	Character(5),ALLOCATABLE, Dimension(:), INTENT(OUT) :: atomsorteH
	Character(500), INTENT(IN) :: ziel
	Integer :: i,j,ind,anzahl,anzahlneu,cAtomRingInd,sAtomInd
	 Real, Dimension(3) :: cAtom,hAtom1,hAtom2,hAtom3,vorigesC,naechstesC,kreuzprod,hAtomold
	 Integer, Dimension(48) :: ind_C_Ketten
	 LOGICAL:: Cvorher, erste_vorher
	 Integer:: ketten, erste_Kette, ketten_2
	 Integer, Dimension(4):: ind_erste
	 Real::Rotwinkel
	 LOGICAL :: DEBUG=.false.
	 
	if(debug) write(*,*) 'NAtoms', NAtoms
	anzahl=NAtoms
	anzahlneu = NAtoms + 100 !Gesamtanzahl Atome in neuer Datei
	!write(*,*) 'Anzahl neu H-DIPBI_KETTE',anzahlneu ! 218 ?
	allocate(atomsorteH(anzahlneu))
	allocate(koordH(anzahlneu,3))
	! uebergabe der ersten 74 Atome des DIPBI ohne Seitenketten - jeweils mit N und erstem C-Atom
	do j=1,74,1
		koordH(j,:)=koord(j,:)    
		atomsorteH(j)=atomsorte(j)   
	END DO ! Wert von j nach der Schleife ist j=75

	! Indizes der 48 C Atome in den 4 Seitenketten
	ind_C_Ketten(1)=1   ! C
	do i=0,10,1
		ind_C_Ketten(i+2)=75+i ! von 75-85
	END DO
	ind_C_Ketten(13)=37     ! C
	do i=0,10,1
	ind_C_Ketten(i+14)=86+i ! von 86-96
	END DO
	ind_C_Ketten(25)=38   ! C
	do i=0,10,1
	ind_C_Ketten(i+26)=97+i ! von 97-107
	END DO
	ind_C_Ketten(37)=74   ! C
	do i=0,10,1
	ind_C_Ketten(i+38)=108+i ! von 108-118
	END DO


	atomsorte(1)="CH2"
	atomsorte(37)="CH2"
	atomsorte(38)="CH2"
	atomsorte(74)="CH2"
	do i=75,118,1
		atomsorte(i)="CH2"
	END DO 
	atomsorte(85)="CH3"
	atomsorte(96)="CH3"
	atomsorte(107)="CH3"
	atomsorte(118)="CH3"

	cvorher=.false.  !Logikvariable fuer das erste CH2 in jeder Kette
	ketten=0 		 !Abzaehlen der 4 C12-Ketten
	erste_vorher= .false. 	!Logikvariable fuer das zweite CH2 jeder Kette
	ketten_2=1

	!neue Koordinaten schreiben 
	!Die entsprechenden H werden jeweils nach dem C-Atom angefuegt
	DO i=1,size(ind_C_Ketten),1
			If (TRIM(atomsorte(ind_C_Ketten(i)))=='CH3' .OR. (TRIM(atomsorte(ind_C_Ketten(i)))=='CH2')) Then
					IF( ind_C_Ketten(i)/=1 .AND. ind_C_Ketten(i)/=37 .AND. ind_C_Ketten(i)/=38 .AND. ind_C_Ketten(i)/=74 ) THEN
					koordH(j,:)=koord(ind_C_Ketten(i),:)    ! Ausnahme der 4 schon geschriebenen ersten C-Atome der Kette
					atomsorteH(j)=' C'        ! Zuerst jeweils das C in der Seitenkette an die Stelle j schreiben
					j=j+1
					END IF
			End If

		IF(atomsorte(ind_C_Ketten(i)) == 'CH2') THEN !H-Atome an Hexylgruppe anfuegen
			!Falls es das erste CH2 der Kette ist:
			IF(cvorher .eqv. .false.) Then  ! Beginn am Kettenanfang 
				sAtomInd=ind_C_Ketten(i)
				ind_erste(ketten+1)=ind_C_Ketten(i)
				if (ketten==0) Then
				  erste_Kette=ind_C_Ketten(i)
				End if

				!1. C-Atom mit H bestuecken
				DO ind=1,3,1 !Koordinaten merken
					cAtom(ind) = koord(sAtomInd,ind)
					naechstesC(ind) = koord(ind_C_Ketten(i+1),ind)
					if ((ketten == 0) .or. (ketten == 2)) Then
						vorigesC(ind) = koord(sAtomInd +1,ind)   ! Auswahl von C1 und C38 
						Else
						vorigesC(ind) = koord(sAtomInd -2,ind)    ! Auswahl von C37 und C74
					End if

				END DO
				ketten=ketten+1
				!Write(*,*) 'Ketten', ketten
				if(ketten==4) then
							erste_vorher = .true.
							cvorher = .true.
				End if
			
				CALL kreuzprodukt(cAtom - vorigesC, cAtom -naechstesC,kreuzprod)
				hAtom1 = cAtom + kreuzprod ! Vektor senkrecht zur Ebene der 3 C-Atome
				hAtom2 = cAtom - kreuzprod
			
				CALL rotate(naechstesC,vorigesC,hAtom1,32.)  !Winkel anpassen
				CALL rotate(naechstesC,vorigesC,hAtom2,-32.) ! Rotation nach außen um die Verbinungdachse der Cs
			
				CALL setDistance(cAtom,hAtom1,1.095) !Abstand anpassen
				CALL setDistance(cAtom,hAtom2,1.095) !Abstand anpassen
			
				!Write(2,'(2X,A2,1X,3F16.6)') 'C ',cAtom(1),cAtom(2),cAtom(3)
				!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom1(1),hAtom1(2),hAtom1(3)
				!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom2(1),hAtom2(2),hAtom2(3)
				koordH(j,:)=hAtom1(:)    
				atomsorteH(j)=' H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
				j=j+1
				koordH(j,:)=hAtom2(:)    
				atomsorteH(j)=' H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
				j=j+1
				cvorher=.true.
				
			Else 

				if (erste_vorher .eqv. .true.) Then
					!2. C-Atom mit H bestuecken - hier muess wieder auf das 1. C zugegriffen werden 
					!Daher wird eine Adressierung mit ketten_2 eingefuehrt
					DO ind=1,3,1 !Koordinaten merken
						cAtom(ind) = koord(ind_C_Ketten(i),ind)
						vorigesC(ind) = koord(ind_erste(ketten_2+1),ind) !ketten_2=2 muss erst bei der zweiten Kette loslaufen
						naechstesC(ind) = koord(ind_C_Ketten(i+1),ind)   ! daher ist ketten_2=1 zu Beginn 
					END DO
							  
					erste_vorher = .false.
					ketten_2=ketten_2+1

					
					CALL kreuzprodukt(cAtom - vorigesC, cAtom -naechstesC,kreuzprod)
		
					hAtom1 = cAtom + kreuzprod
					hAtom2 = cAtom - kreuzprod
	 
					CALL rotate(naechstesC,vorigesC,hAtom1,32.) !Winkel anpassen
					CALL rotate(naechstesC,vorigesC,hAtom2,-32.)
					
				
					CALL setDistance(cAtom,hAtom1,1.095) !Abstand anpassen
					CALL setDistance(cAtom,hAtom2,1.095) !Abstand anpassen
		
					!Write(2,'(2X,A2,1X,3F16.6)') 'C ',cAtom(1),cAtom(2),cAtom(3)
					!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom1(1),hAtom1(2),hAtom1(3)
					!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom2(1),hAtom2(2),hAtom2(3)
						koordH(j,:)=hAtom1(:)    
						atomsorteH(j)=' H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
						j=j+1
						koordH(j,:)=hAtom2(:)    
						atomsorteH(j)=' H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
						j=j+1       
				
				Else    ! Durchlaufen vom 3. C-Atom der Kette bis zum vorletzen C-Atom.
						!1. C-Atom mit H bestuecken
					DO ind=1,3,1 !Koordinaten merken
						cAtom(ind) = koord(ind_C_Ketten(i),ind)
						vorigesC(ind) = koord(ind_C_Ketten(i-1),ind)
						naechstesC(ind) = koord(ind_C_Ketten(i+1),ind)
					END DO
							
					CALL kreuzprodukt(cAtom - vorigesC, cAtom -naechstesC,kreuzprod)
					hAtom1 = cAtom + kreuzprod
					hAtom2 = cAtom - kreuzprod
					
					CALL rotate(naechstesC,vorigesC,hAtom1,32.) !Winkel anpassen
					CALL rotate(naechstesC,vorigesC,hAtom2,-32.)
			
					CALL setDistance(cAtom,hAtom1,1.095) !Abstand anpassen
					CALL setDistance(cAtom,hAtom2,1.095) !Abstand anpassen
					hAtomOld=hAtom1
					
					!Write(2,'(2X,A2,1X,3F16.6)') 'C ',cAtom(1),cAtom(2),cAtom(3)
					!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom1(1),hAtom1(2),hAtom1(3)
					!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom2(1),hAtom2(2),hAtom2(3)
							koordH(j,:)=hAtom1(:)    
							atomsorteH(j)=' H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
							j=j+1
							koordH(j,:)=hAtom2(:)    
							atomsorteH(j)=' H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
							j=j+1
							
					
				END IF!Write(*,*) 'CH2 Ende'
			End if
		Else
			If(atomsorte(ind_C_Ketten(i))=='CH3') THEN 
				cAtomRingInd=  ind_C_Ketten(i - 2)
				sAtomInd= ind_C_Ketten(i)
				!letztes C-Atom mit 3 H-Atomen bestuecken
				DO ind=1,3,1 !Koordinaten merken
					cAtom(ind) = koord(sAtomInd,ind)
					vorigesC(ind) = koord(cAtomRingInd+1,ind)
					naechstesC(ind) = koord(sAtomInd+1,ind) !vorvoriges C-atom
				END DO		
				
				CALL kreuzprodukt(cAtom - vorigesC, cAtom -naechstesC,kreuzprod)
		
				hAtom1 = vorigesC
				CALL setDistance(cAtom,hAtom1,1.095)
				CALL rotate(cAtom,cAtom+kreuzprod,hAtom1,112.)
		
				hAtom2 = hAtom1  !schon mal die ungefaehre Position
				hAtom3 = hAtom1
		
				CALL rotate(vorigesC,cAtom,hAtom2,120.) !in korrekte Position bringen
				CALL rotate(vorigesC,cAtom,hAtom3,240.)
				
			   !Rotation um C-C Achse sodass der Diederwinkel H-C-C-H ~60° wird
			   ! (Korrektur zur passenden Newman-Projektion)
			   call set_dih_by_rotation_around_axis(hAtom1,cAtom,vorigesC,hAtomold,60.,Rotwinkel)

			   hAtom2=hAtom2-cAtom(:)
			   call Rotationsmatrix_alpha(hAtom2,Rotwinkel,vorigesC(:)-cAtom(:),.true.)
			   hAtom2(:)=hAtom2(:)+cAtom(:)
			  
			   hAtom3=hAtom3-cAtom(:)
			   call Rotationsmatrix_alpha(hAtom3,Rotwinkel,vorigesC(:)-cAtom(:),.true.)
			   hAtom3(:)=hAtom3(:)+cAtom(:)

				!letztes C-Atom ausgeben
				!Write(2,'(2X,A2,1X,3F16.6)') 'C ',cAtom(1),cAtom(2),cAtom(3)
				!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom1(1),hAtom1(2),hAtom1(3)
				!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom2(1),hAtom2(2),hAtom2(3)
				!Write(2,'(2X,A2,1X,3F16.6)') 'H ',hAtom3(1),hAtom3(2),hAtom3(3)
						koordH(j,:)=hAtom1(:)    
						atomsorteH(j)=' H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
						j=j+1
						koordH(j,:)=hAtom2(:)    
						atomsorteH(j)=' H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
						j=j+1
						koordH(j,:)=hAtom3(:)    
						atomsorteH(j)=' H'        ! Zuerst jeweils H in der Seitenkette an die Stelle j schreiben
						j=j+1
				
				cvorher=.false. !Naechste Kette
				erste_vorher=.true. !Naechste Kette
			END IF
		End IF
	END DO
	 !CLOSE(2)

			IF (DEBUG) THEN
						write(*,*) 'Koordinaten in xyz ',trim(ziel)
						CALL make_coord_to_xyz(atomsorteH,koordH,size(atomsorteH),ziel)
			ENDIF
	END SUBROUTINE h_diPBI_kette

	SUBROUTINE h_cut_chain_HDI(atomsorte,koord,NAtoms,atomsorteH,koordH,ziel) ! Schneidet die Ketten ab!
			!! Subroutine to cut the chains and substitute by methyl groups (CH3) to a HDI-molecule 
			!! obtained by a GROMACS-file.
			IMPLICIT NONE
			Integer, INTENT(IN) :: NAtoms
			Real, Dimension(NAtoms,3), INTENT(IN) :: koord
			Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
			REAL, ALLOCATABLE, DIMENSION(:,:), INTENT (OUT) ::koordH
			Character(5),ALLOCATABLE, Dimension(:), INTENT(OUT) :: atomsorteH
			Character(500) :: ziel
			CHARACTER(1)::dummy
			Real, Dimension(3) ::CAtom,hAtom1
			INTEGER::i,j
			LOGICAL::DEBUG=.false.
	 

			IF( NAtoms==170) THEN ! HDI
					WRITE(*,*) 'h_cut_chain_HDI' 
					ALLOCATE(koordH(56,3))
					ALLOCATE(atomsorteH(56))
					j=0
					DO i=1,56  !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
							j=j+1
							koordH(j,:)=koord(i,:)           !Koordinaten an neuen Array uebergeben nicht die Seitenketten! 
							dummy = TRIM(adjustl(atomsorte(i)))
							atomsorteH(j) = dummy(1:1)//'  ' ! Schneidet alles rechts ab
					END DO

					! C28 durch H ersetzen 
					CAtom=koordH(25,:)   !  C-Atom am Randende
					hAtom1(:)=koordH(28,:) 
					CALL setDistance(CAtom,hAtom1,1.095) !Abstand anpassen -- das negative Vorzeichen wandelt die Anbaurichtung um 
					koordH(28,:)= hAtom1
					atomsorteH(28)='H ' 
					
					! C31 durch H ersetzen 
					CAtom=koordH(29,:)   !  C-Atom am Randende
					hAtom1(:)=koordH(31,:) 
					CALL setDistance(CAtom,hAtom1,1.095) !Abstand anpassen -- das negative Vorzeichen wandelt die Anbaurichtung um 
					koordH(31,:)= hAtom1
					atomsorteH(31)='H ' 
					
					IF (DEBUG) THEN
						DO i=1,56
							WRITE(*,*) atomsorteH(i),koordH(i,:)
						END DO 
						WRITE(*,*) 'Ende h_cut_chain_HDI'
					END IF
			ELSE ! Not the correct size 
					! Uebergabe ohne Bearbeitung der H-Atome
					ALLOCATE(koordH(NAtoms,3))
					ALLOCATE(atomsorteH(NAtoms))
					DO i=1,NAtoms
						koordH(i,:)=koord(i,:)
						atomsorteH(i)=atomsorte(i)
					END DO    
					write(*,*) ' Keine Bearbeitung der H-Atome in h_cut_chain_HDI'
			END IF ! h_cut_chain_HDI
			
			IF (DEBUG) THEN
						write(*,*) 'Koordinaten in xyz ',trim(ziel)
						CALL make_coord_to_xyz(atomsorteH,koordH,size(atomsorteH),ziel)
			ENDIF
	END SUBROUTINE h_cut_chain_HDI

	SUBROUTINE alq3_rename_elements(atomsorte,koord,NAtoms,atomsorteH,koordH,ziel) 
			!! Subroutine alq3_rename_elements, H-Atoms or bonds are not affected!
			!! obtained by a GROMACS-file.
			IMPLICIT NONE
			Integer, INTENT(IN) :: NAtoms
			Real, Dimension(NAtoms,3), INTENT(IN) :: koord
			Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
			REAL, ALLOCATABLE, DIMENSION(:,:), INTENT (OUT) ::koordH
			Character(5),ALLOCATABLE, Dimension(:), INTENT(OUT) :: atomsorteH
			Character(500) :: ziel
			INTEGER::i
			LOGICAL::DEBUG=.false.
			
		IF(NAtoms==52)THEN ! check for Alq3 number of elements
			IF (DEBUG) WRITE(*,*) 'Start alq3_rename_elements'
			ALLOCATE(koordH(52,3))
				ALLOCATE(atomsorteH(52))
			DO i=1,NAtoms
				koordH(i,:)=koord(i,:)
				IF (index(atomsorte(i),'H') .ne. 0) THEN
					 atomsorteH(i)='H'
				ELSE IF (index(atomsorte(i),'C') .ne. 0) THEN
					 atomsorteH(i)='C'
				ELSE IF (index(atomsorte(i),'N') .ne. 0) THEN
					 atomsorteH(i)='N'
				ELSE IF (index(atomsorte(i),'O') .ne. 0) THEN
					 atomsorteH(i)='O'
				ELSE IF (index(atomsorte(i),'Al') .ne. 0) THEN
					!WRITE(*,*) 'Warning: use H Atom instead of Al in Alq3!'
					atomsorteH(i)='Al'   ! 'Al'  ! use H as a dummy element for Alq3 calculations
				ELSE
					WRITE(*,*) 'Error: Element was not expected in Alq3 molecule: CALL EXIT (1)'
					CALL EXIT (1)		
				END IF ! check elements
			END DO ! loop element array
			
			IF (DEBUG) THEN
						write(*,*) 'Koordinaten in xyz ',trim(ziel)
						CALL make_coord_to_xyz(atomsorteH,koordH,size(atomsorteH),ziel)
						DO i=1,NAtoms
							WRITE(*,*) atomsorteH(i),koordH(i,:)
						END DO 
						WRITE(*,*) 'Ende alq3_rename_elements'
			END IF
		ELSE
			WRITE(*,*) 'Error: molecule is not Alq3'
		END IF
	END SUBROUTINE alq3_rename_elements

	SUBROUTINE how_many_h_atoms_to_mol(R_u_I,atomsorte,residue_names,NAtoms,N_Resids,GesamtanzahlH,KETTE,PPDI_Propyl)
		!! SUBROUTINE to determine the number of all atoms, if H-Atoms are included
		!! OUTPUT:  GesamtanzahlH
		IMPLICIT NONE
		INTEGER ::NAtoms,N_Resids
		INTEGER, Dimension(N_Resids+1,2), INTENT(IN)    :: R_u_I
		Character(5), Dimension(NAtoms), INTENT(IN)     :: atomsorte  
		Character(5),Dimension(N_Resids), INTENT(IN)    :: residue_names
		LOGICAL, INTENT(IN)    :: KETTE,PPDI_Propyl
		INTEGER, INTENT(OUT)   :: GesamtanzahlH
		Character(5) :: residue_name
		INTEGER::i,j,k,NAtomsH
		LOGICAL::DEBUG=.false.
		!LOGICAL::  DIPBI,DIPBI_KETTE,P3HT,P3MT,P3HT_KETTE,PPDI,PPDI_KETTE,PBDT_TS1,HDI_KETTE
		!!! fuer h_P3HT
		INTEGER::ind,ind5RingEnde,anzahl,anzahlringe,anzahlneu,N_CarboxyS2,N_PBDT
		LOGICAL::HStart=.false.,HEnde=.false.
		INTEGER, ALLOCATABLE, DIMENSION(:) ::ind5Ring
		
		
		GesamtanzahlH=0
		NAtomsH=0
		! Schleife, um alles Resids durchzulaufen und um daraus die Anzahl der Atome mit Wasserstoff abgesaettigt zu bestimmen. 
		DO i=1,N_Resids
				residue_name=residue_names(i)
				IF ('THP'==TRIM(residue_name(1:3))) THEN     !!1) P3HT / P3MT Check residue_name   
					IF(KETTE) THEN   !!!!! P3HT  !!!!!!
						HStart=.false.
						HEnde=.false.

						! Bestimmung ob erstes und letztes H-Atom existiert
						IF(TRIM(adjustl(atomsorte(R_u_I(i,2))))=='HC' .AND. &
							&TRIM(adjustl(atomsorte(R_u_I(i,2)+1)))=='CA') HStart=.true.
						IF(TRIM(adjustl(atomsorte(R_u_I(i+1,2)-8))) == 'HC' ) HEnde=.true.

						!Indexarray fur 5Ringe und Wasserstoffe erzeugen
						anzahl=R_u_I(i+1,2)-R_u_I(i,2)
						ALLOCATE(ind5Ring(anzahl))
						k =1
						ind=1
						ind5Ring=0
						DO WHILE(ind <= anzahl)
							ind5Ring(k) = ind
							IF(index(atomsorte(R_u_I(i,2)+ind),'S') >0) THEN !Hexylgruppe ueberspringen
								ind = ind +6 !jetzt: ind letztes Atom der Hexylgruppe
							END IF
							k=k+1
							ind=ind+1
						END DO
						ind5RingEnde = k-1 !letzter belegter Platz

						!Write(*,*) 'HStart',HStart,'HEnde',HEnde

						IF( HStart .AND. HEnde ) THEN
							anzahlringe = (ind5RingEnde -2)/6                   !anzahlringe = (ind5RingEnde -2)/6 !fuer ganze Kette 
							anzahlneu = anzahl + anzahlringe*13                 !Gesamtanzahl Atome in neuer Datei
						ELSE
							IF(HStart .OR. HEnde) THEN
							anzahlringe = (ind5RingEnde -1)/6  
							anzahlneu = anzahl + anzahlringe*13 + 1 !Gesamtanzahl Atome in neuer Datei +1 fuer Anfangs/Abschluss H-Atom
							ELSE 
							anzahlringe = (ind5RingEnde)/6 
							anzahlneu = anzahl + anzahlringe*13 + 2 !Gesamtanzahl Atome in neuer Datei +2 fuer Anfangs+Abschluss H-Atom
							END IF
						END IF
						DEALLOCATE(ind5Ring)
						NAtomsH=anzahlneu
					ELSE !! h_P3MT  !!! P3MT
						!!! P3MT Determine number of atoms in P3MT
						HStart=.false.
						HEnde=.false.

						! Bestimmung ob erstes und letztes H-Atom existiert
							IF( TRIM(adjustl(atomsorte(R_u_I(i,2)))) == 'HC' .AND. &
							&TRIM(adjustl(atomsorte(R_u_I(i,2)+1))) == 'CA' ) HStart=.true.
						IF( TRIM(adjustl(atomsorte(R_u_I(i+1,2)-8))) == 'HC' ) HEnde=.true.

						!Indexarray fur 5Ringe und Wasserstoffe erzeugen
						anzahl=R_u_I(i+1,2)-R_u_I(i,2)
						ALLOCATE(ind5Ring(anzahl))
						k=1
						ind=1
						ind5Ring=0
						DO WHILE(ind <= anzahl)
							ind5Ring(k) = ind
							IF(index(atomsorte(R_u_I(i,2)+ind),'S') >0) THEN !Hexylgruppe ueberspringen
								ind = ind +6 !jetzt: ind letztes Atom der Hexylgruppe
							END IF
							k=k+1
							ind=ind+1
						END DO
						ind5RingEnde = k-1 !letzter belegter Platz
						IF( HStart .AND. HEnde ) THEN
							anzahlringe = (ind5RingEnde -2)/6              !anzahlringe = (ind5RingEnde -2)/6 !fuer ganze Kette 
							anzahlneu = anzahl - anzahlringe*5 + anzahlringe*3 !Gesamtanzahl Atome in neuer Datei, 5 C weg, 3 H dazu je Ring
						ELSE
							IF(HStart .OR. HEnde) THEN
							anzahlringe = (ind5RingEnde -1)/6  
							anzahlneu = anzahl - anzahlringe*5 + anzahlringe*3 + 1 !Gesamtanzahl Atome in neuer Datei, 5 C weg, 3 H dazu je Ring +1 fuer Anfangs/Abschluss H-Atom
							ELSE 
							anzahlringe = (ind5RingEnde)/6 
							anzahlneu = anzahl - anzahlringe*5 + anzahlringe*3 + 2 !Gesamtanzahl Atome in neuer Datei, 5 C weg, 3 H dazu je Ring +2 fuer Anfangs+Abschluss H-Atom
							END IF
						END IF
						DEALLOCATE(ind5Ring)
						NAtomsH=anzahlneu
						IF(DEBUG) THEN
							WRITE(*,*) 'P3MT NAtomsH 1:',NAtomsH,' anzahlringe:',anzahlringe,' ind',ind,HStart,HEnde
						END IF
					END IF    ! h_P3MT oder h_P3HT mit Kette


				ELSE IF( TRIM(residue_name)=='DIPBI' ) THEN  ! DIPBI
					IF(KETTE) THEN !h_diPBI_kette 
					NAtomsH=218
					ELSE  ! Methyl-Gruppe
					NAtomsH=86
					END IF  
				ELSE IF ('HDI'==TRIM(residue_name(1:3)) ) THEN
					IF(KETTE)THEN
					anzahl=R_u_I(i+1,2)-R_u_I(i,2) 
					IF( anzahl .LE. 57) THEN
						NAtomsH=56
					ELSE
						NAtomsH=170
					END IF   
					ELSE ! h_cut_chain_HDI => NatomsH=56
					NAtomsH=56
					END IF
				ELSE IF ('PPDI'==TRIM(residue_name(1:4)) ) THEN
					IF(KETTE) THEN
					NAtomsH=144
					ELSE IF(PPDI_Propyl) THEN
					NAtomsH=96
					ELSE ! H-Atoms fuer h_PPDI 
					NAtomsH=78
					END IF !PPDI
				ELSE IF ( '8poly'==TRIM(residue_name(1:5)) ) THEN
					! Zaehle die Anzahl der Elemente im Molekuel N_CarboxyS2 ueber Anzahl der F-Atome und N_PBDT=(N_HC-Gruppen/6) uber die Anzahl der HC-Gruppen
					N_CarboxyS2=0
					N_PBDT=0
					DO j=R_u_I(i,2),R_u_I(i+1,2)-1  ! TO DO INDEX FALSCH!!!
					if (TRIM(adjustl(atomsorte(j)))=='F')  N_CarboxyS2=N_CarboxyS2+1
					if (TRIM(adjustl(atomsorte(j)))=='HC') N_PBDT=N_PBDT+1
					END DO ! Zahle Anzahl
					N_PBDT =N_PBDT/6
					IF (DEBUG) WRITE(*,*) ' Die Anzahl der Carboxy-Gruppen ist: ',N_CarboxyS2
					IF (DEBUG) WRITE(*,*) ' Die Anzahl der N_PBDT-Gruppen ist: ',N_PBDT   
					NAtomsH=38*N_PBDT+22*N_CarboxyS2+2
					IF (DEBUG) WRITE(*,*) ' Die Gesamtanzahl nach dem Anfuegen der H-Atome betraegt',NAtomsH
				ELSE
					NAtomsH=R_u_I(i+1,2)-R_u_I(i,2)
				END IF 	 !! Check residue_name   	


			GesamtanzahlH=GesamtanzahlH+NAtomsH
		END DO !NAtoms
		IF(DEBUG) THEN
		WRITE(*,*)  'how_many_h_atoms_to_mol GesamtanzahlH: ', GesamtanzahlH
		END IF
	END SUBROUTINE how_many_h_atoms_to_mol

!!!---------------------------------------------------------------------------------------------------------------!!!!
!!!    End Functions to manipulate the H-Atoms in molecular coordinates                                           !!!!
!!!---------------------------------------------------------------------------------------------------------------!!!!

 
	!!!	-------------------------------------------------------------- data_analysis ----------------------------------------'
	subroutine data_analysis()
		!!	WRITE(*,*) ' Program with a basic analysis on data set'
		!!	WRITE(*,*) ' filename: Data file with one column of data points '
		!!	WRITE(*,*) ' USE:   CALCULATOR          filename        '
		!!	WRITE(*,*) ' --------------------------------------------------------------'
		!!	WRITE(*,*) ' List of CALCULATORS:'
		!!	WRITE(*,*) ' AVERAGE'
		!!	WRITE(*,*) ' SIGMA'
		!!	WRITE(*,*) ' MEDIAN'
		!!	WRITE(*,*) ' MAXVAL'
		!!	WRITE(*,*) ' MINVAL'
		!!	WRITE(*,*) ' AVERAGE_LOG10_ABS'
		!!	WRITE(*,*) ' AVERAGE_ABS'
		!!	WRITE(*,*) ' --------------------------------------------------------------'
		!!	WRITE(*,*) ' AVERAGE_LOG10_ABS: Program calculates average and standard deviation (sigma) for log10(|x|)'
		!!	WRITE(*,*) ' All values with |x| < cutoff_log10 are neglected!'
		!!	WRITE(*,*) ' Programm expects a single column of data in filename'
		!!	WRITE(*,*) ' cutoff_log10: cutoff where data is omitted e.g 1.0E-20 '
		!!	WRITE(*,*) ' --------------------------------------------------------------'
		!!	WRITE(*,*) ' AVERAGE_ABS: take the norm |x| before evaluating the average and standard deviation (sigma) '
		!!	WRITE(*,*) ' --------------------------------------------------------------'
		!!	WRITE(*,*) '  data_analysis AVERAGE_LOG10_ABS          filename        [ cutoff_log10 ] '
		!!	WRITE(*,*) '  data_analysis AVERAGE_LOG10_ABS           rates_h.dat         1.0E-20     '

		implicit none
		real*8::cutoff_log10
		real*8,allocatable, dimension(:)::values
		integer::N_data_points
		real*8::average
		real*8::sigma
		logical::Datei_vorhanden=.false.,inputline_ok=.false.,read_data_filename=.false.
		integer::i,ierror
		CHARACTER(LEN=500)::method,filename,dummy
		
		logical,allocatable, dimension(:)::mask
				
				
		cutoff_log10=1.0D-20
		filename='colums_datafilename.dat'
		!! initialized. do not change here!
		inputline_ok=.false.
		read_data_filename=.false.
		
		IF (command_argument_count() > 2 ) THEN
				CALL get_command_argument(2,method)
				IF( TRIM(method) == 'AVERAGE_LOG10_ABS') THEN
						read_data_filename=.true.
								
						IF (command_argument_count() > 4 ) THEN ! read cutoff_log10
							CALL get_command_argument(4,dummy)
							READ(dummy,'(F12.8)') cutoff_log10
						END IF ! read cutoff_log10
						inputline_ok=.true.
						
				ELSE IF(TRIM(method) == 'MEDIAN' .OR. TRIM(method) == 'median') THEN
					method='MEDIAN'
					read_data_filename=.true.
					inputline_ok=.true.
				ELSE IF(TRIM(method) == 'MAXVAL' .OR. TRIM(method) == 'maxval') THEN
					method='MAXVAL'
					read_data_filename=.true.
					inputline_ok=.true.
				ELSE IF(TRIM(method) == 'MINVAL' .OR. TRIM(method) == 'minval') THEN
					method='MINVAL'
					read_data_filename=.true.
					inputline_ok=.true.
				ELSE IF  (TRIM(method) == 'SUM' .OR. TRIM(method) == 'sum' .OR. &
						& TRIM(method) == 'SUMME' .OR. TRIM(method) == 'summme') THEN
					method='SUM'
					read_data_filename=.true.
					inputline_ok=.true.
				ELSE IF( TRIM(method) == 'AVERAGE' .OR. TRIM(method) == 'average') THEN
					method='AVERAGE'
					read_data_filename=.true.
					inputline_ok=.true.
				ELSE IF( TRIM(method) == 'AVERAGE_ABS' .OR. TRIM(method) == 'average_abs') THEN
					method='AVERAGE_ABS'
					read_data_filename=.true.
					inputline_ok=.true.
				END IF
				
		END IF
		IF(.NOT. inputline_ok) THEN
			WRITE(*,*) ' Program with a basic analysis on data set'

			WRITE(*,*) ' filename: Data file with one column of data points '
			WRITE(*,*) ' USE:   CALCULATOR          filename        '
			WRITE(*,*) ' --------------------------------------------------------------'
			WRITE(*,*) ' List of CALCULATORS:'
			WRITE(*,*) ' AVERAGE'
			WRITE(*,*) ' SIGMA'
			WRITE(*,*) ' MEDIAN'
			WRITE(*,*) ' MAXVAL'
			WRITE(*,*) ' MINVAL'
			WRITE(*,*) ' SUM'
			WRITE(*,*) ' AVERAGE_LOG10_ABS'
			WRITE(*,*) ' AVERAGE_ABS'
			WRITE(*,*) ' --------------------------------------------------------------'
			WRITE(*,*) ' AVERAGE_LOG10_ABS: Program calculates average and standard deviation (sigma) for log10(|x|)'
			WRITE(*,*) ' All values with |x| < cutoff_log10 are neglected!'
			WRITE(*,*) ' Programm expects a single column of data in filename'
			WRITE(*,*) ' cutoff_log10: cutoff where data is omitted e.g 1.0E-20 '
			WRITE(*,*) ' --------------------------------------------------------------'
			WRITE(*,*) ' AVERAGE_ABS: take the norm |x| before evaluating the average and standard deviation (sigma) '
			WRITE(*,*) ' --------------------------------------------------------------'
			WRITE(*,*) '  Usage:'
			WRITE(*,*) '  data_analysis  AVERAGE_LOG10_ABS          filename        [ cutoff_log10 ] '
			WRITE(*,*) '  data_analysis  AVERAGE_LOG10_ABS           rates_h.dat         1.0E-20     '
			CALL EXIT(1)
		ELSE
			IF( TRIM(method) == 'AVERAGE_LOG10_ABS') THEN
				WRITE(*,*) '       AVERAGE_LOG10_ABS          filename        [ cutoff_log10 ] '
				WRITE(*,*) 'USE: ',TRIM(method),'       ',TRIM(filename),'  ',cutoff_log10
			ELSE IF(TRIM(method) == 'median') THEN
				WRITE(*,*) 'USE: ',TRIM(method),'       ',TRIM(filename)
			ELSE
				WRITE(*,*) 'USE: ',TRIM(method),'       ',TRIM(filename)
			ENDIF
		END IF
		
		
		if(read_data_filename) then
			CALL get_command_argument(3,filename)
			inquire(file=TRIM(filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
			IF( .NOT. Datei_vorhanden) THEN
									WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden: '//TRIM(filename)
									WRITE(*,*) ' ENDE'
									CALL EXIT (1)
			END IF 
		end if ! read_data_filename
		
		
		N_data_points=Read_rows_file2(filename)
		
		IF(N_data_points > 0 ) THEN
			write(*,*) 'Read: ',TRIM(filename)
			open(unit=370,file=TRIM(filename),status='old',action='read',iostat=ierror)
			ALLOCATE(values(N_data_points))
			values=0.0
		ELSE
			WRITE(*,*) 'Error: small N_data_points: ',N_data_points
			CALL EXIT(1)
		END IF
		DO i=1,N_data_points
			!!!! read            
			READ(370,*,IOSTAT=ierror) values(i)
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(filename),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
			!WRITE(*,*) values(i),ierror
		END DO ! Read Data
		
		IF( TRIM(method) == 'AVERAGE_LOG10_ABS') THEN
			average=0.0
			sigma=0.0
			CALL calc_AVERAGE_LOG10_ABS(N_data_points,values,cutoff_log10,average,sigma)
		ELSE IF(TRIM(method) == 'MEDIAN') THEN
			ALLOCATE(mask(N_data_points))
			mask=.true.
			write(*,*) 'median:: ',calc_median(N_data_points,values,mask)
			
		ELSE IF(TRIM(method) == 'MAXVAL') THEN
			write(*,*) 'maximum value:',maxval(values),'  at position: ',MAXLOC(values)
		ELSE IF(TRIM(method) == 'MINVAL') THEN
			write(*,*) 'minimum value:',minval(values),'  at position: ',MINLOC(values)
		ELSE IF(TRIM(method) == 'SUM') THEN
			write(*,*) 'Number of data points: ',size(values) 
			write(*,*) 'Sum value: ',SUM(values)
		ELSE IF(TRIM(method) == 'AVERAGE') THEN
			call average_and_stdev(N_data_points,values,average,sigma)
			WRITE(*,*) ' average: ', average, ' +/- ',sigma
			WRITE(*,'(A24,1ES12.4,A5,1ES12.4)') ' AVERAGE: ', average, ' +/- ',sigma
		ELSE IF(TRIM(method) == 'SIGMA') THEN
			call average_and_stdev(N_data_points,values,average,sigma)
			WRITE(*,'(A24,1f20.16,A5,1ES12.4)') ' sigma: ',sigma
			WRITE(*,'(A24,1ES12.4)') ' SIGMA: ',sigma
		ELSE IF(TRIM(method) == 'AVERAGE_ABS') THEN
			values=abs(values)
			call average_and_stdev(N_data_points,values,average,sigma)
			WRITE(*,*) ' average_abs              : ', average, ' +/- ',sigma
			WRITE(*,'(A24,1ES12.4,A5,1ES12.4)') ' AVERAGE_ABS              : ', average, ' +/- ',sigma
		END IF
	end subroutine data_analysis

	subroutine average_and_stdev(N_data_points,values,average,sigma)
		!! calculates the average and the standard deviation of a data set in values
		implicit none
		real*8,allocatable, dimension(:),INTENT(IN)::values
		integer,INTENT(IN)::N_data_points
		real*8,INTENT(OUT)::average
		real*8,INTENT(OUT)::sigma
		integer::i,N_count
		
		average=0.0
		sigma=0.0
		N_count=0
		DO i=1,N_data_points
			IF( isnan(values(i))) THEN
					WRITE(*,*) 'Warning: Nan found at position ',i,values(i)
					CYCLE
			ELSE
							average = average + values(i)
							N_count= N_count + 1
			ENDIF
		ENDDO
		average=average/N_count
		
		DO i=1,N_data_points
			IF( isnan(values(i))) THEN
				CYCLE
			ELSE
				sigma = sigma + (average - values(i))**2
			ENDIF
		ENDDO
		sigma = SQRT(sigma/(N_count -1))
		
	end subroutine average_and_stdev

	subroutine calc_AVERAGE_LOG10_ABS(N_data_points,values,cutoff_log10,average,sigma)
		!! calculates average log10(abs(x))
		implicit none
		real*8,INTENT(IN)::cutoff_log10
		real*8,allocatable, dimension(:)::values
		integer,INTENT(IN)::N_data_points

		real*8,INTENT(OUT)::average
		real*8,INTENT(OUT)::sigma
		logical::warning_negative_counts
		integer::i,N_count,N_count_sigma,negative_count,zero_count
		real*8::num
		real*8::zero,total_sum,total_average,total_sigma
		logical, allocatable, dimension(:)::mask
		logical, allocatable, dimension(:)::RESULT
		logical::debug=.false.
		
		average=0.0
		sigma=0.0
		N_count=0
		N_count_sigma=0
		negative_count=0
		warning_negative_counts=.false.
		zero=0.0
		zero_count =0
		total_sum=0
		total_average=0
		total_sigma=0
		
		ALLOCATE(mask(N_data_points))
		ALLOCATE(Result(N_data_points))
		mask=.true.
		!! Find zero in the array values
		!RESULT = FINDLOC(values(:),zero,dim=N_data_points,mask=mask)
		
		do i=1,N_data_points
			!write(*,*) 'tmp i ',i, values(i), log10(abs(values(i)))
			if (values(i) < zero ) then !! Filter 0
					warning_negative_counts=.true.
					negative_count = negative_count +1
					mask(i)=.false.
			else if ( abs(values(i)) < TINY(values(i)) ) then !! Filter 0
					zero_count = zero_count +1
					mask(i)=.false.
			else if( abs(values(i)) >  cutoff_log10) then
					num=log10(abs(values(i)))
					IF( abs(num) == 0.0E0 .OR. isnan(num) ) then
						write(*,*) ' FOUND ZERO'
						mask(i)=.false.
						CYCLE
					ELSE
						total_sum = total_sum + values(i)
						average = average + num
						N_count= N_count + 1
					ENDIF
				if(debug) write(*,*) values(i), log10(abs(values(i))), average/N_count
			endif
		enddo
		
		average=average/REAL(N_count)
		total_average = total_sum / REAL(N_count)
		sigma=0.0
		total_sigma=0
		N_count_sigma=0
		!!! calculate sigma
		do i=1,N_data_points
			if (values(i) < zero ) then !! Filter 0
				cycle
			else if ( abs(values(i)) < TINY(values(i)) ) then !! Filter 0
				cycle
			else if( abs(values(i)) >  cutoff_log10) then
				total_sigma = total_sigma + ( total_average - values(i) )**2
				sigma = sigma +  (average - log10(abs(values(i))) )**2
				N_count_sigma = N_count_sigma +1
			endif
		enddo
		sigma = SQRT(sigma/(N_count_sigma -1))
		total_sigma= SQRT(total_sigma/(N_count_sigma -1))
		
		
			IF(warning_negative_counts) then
				write(*,*) "WARNING: Negative value in log10|x| encountered! , Skipped ",negative_count," data points. "
			ENDIF
			
			IF(zero_count > 0) THEN
				write(*,*) 'WARNING: skipped zero data points: ',zero_count
			END IF
			
			IF(N_count > 2) THEN
				WRITE(*,*) ' cutoff_log10: ', cutoff_log10,'  for ',N_count,'data points.'
				write(*,'(A24,1ES12.4)') ' MEDIAN: ', calc_median(N_data_points,values,mask)
				WRITE(*,'(A24,1ES12.4,A5,1ES12.4)') ' average              : ', total_average, ' +/- ',total_sigma
				WRITE(*,'(A24,1ES12.4,A5,1ES12.4)') ' average log10 abs(x) : ', average, ' +/- ',sigma
				
				WRITE(*,'(A24,1ES12.4,A5,2ES12.4)') ' conversion 10^average :',10**average,' +/- ',10**(average + sigma),10**(average - sigma)
			ELSE
				write(*,*) 'Warning small number of relyable log10|x| data points.'
				
			END IF
			
			
			
	end subroutine calc_AVERAGE_LOG10_ABS

	real*8 function calc_median(N_data_points,values,mask)
		!! calculates the median of the array "values" for all data points with mask(:)=.true. 
		implicit none
		integer::N_data_points
		real*8, dimension(N_data_points)::values
		logical, allocatable, dimension(:)::mask
		real*8, allocatable, dimension(:)::tmp_values
		integer::i,j,n_values_ok
		real*8::median
		logical::debug=.false.
		
		
		n_values_ok=COUNT(mask(:))
		allocate(tmp_values(n_values_ok))
		
		j=0
		do i=1,N_data_points
			if(mask(i)) then ! data to array
				j=j+1
				tmp_values(j)=values(i)
			end if
		end do ! i
		call SortArray8(tmp_values,n_values_ok)
		
		if ( mod(n_values_ok,2)==0 ) then ! gerade
			if(debug) write(*,*) 'gerade:',n_values_ok
			median=0.5*(tmp_values(n_values_ok/2) + tmp_values(n_values_ok/2 + 1) )
		else 
			if(debug) write(*,*) 'ungerade:',n_values_ok
			median=tmp_values(n_values_ok/2 + 1)
		end if 
		if(debug) write(*,*) 'median: ',median
		calc_median=median
	end function calc_median

	!!!	-------------------------------------------------------------- data_analysis ----------------------------------------'


	
end module small_functions
!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!!  END small functions module
!!! ------------------------------------------------------------------------------------------------------------------- !!!



!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!!       module with kmc programm
!!! ------------------------------------------------------------------------------------------------------------------- !!!
module KMC_class


	type KMC_event_t
			 real*8, dimension(3)::dr
			 integer::destination
			 
			 real*8::rate

			!! stuff for Coulomb interaction
			real*8 Jeff2
			real*8 reorg_out
			real*8 initialrate
			
			!!! current 
			real*8, dimension(3):: current
			real*8 :: current_norm
			!! intramolecular transition?
			logical::intramolecular
	end type KMC_event_t

	type KMC_Node_t
		type(KMC_event_t),allocatable, dimension(:)::event
		integer::id
		character(len=500)::node_name
		real*8, dimension(3)::position    ! [m] im kMC programm
		integer::occupied 
		integer::injectable
		real*8:: siteenergy       ! [eV]
		real*8:: occupationtime   ! [s]
		real*8:: EscapeRate		  ! [s**-1]
		integer::event_size
		
		!! coulomb stuff / updated charges
		real*8:: reorg_intorig  != UnCnN     [eV]
		real*8:: reorg_intdest  != UcNcC     [eV]
		real*8:: internalenergy != UcCnN     [eV]
		
		!!
		real*8, dimension(3)::current
		real*8 :: current_norm
		
		!! characterize hopping site type 
		integer::node_type_id
	end type KMC_Node_t

	type KMC_Chargecarrier_t
		integer             ::id
		real*8, dimension(3):: koord,dr_travelled,dI_travelled
		type(KMC_Node_t)::node
		integer, allocatable, dimension(:) :: nodevisited
	end type KMC_Chargecarrier_t
	
	type KMC_intramolecular_pair
		integer::id
		integer::seg1
		integer::seg2
		character(len=500) ::name1,name2
	end type KMC_intramolecular_pair
	
	type KMC_united_node_t
		integer::id
		integer::seg1,seg2
		real*8::rate12,rate21
		real*8::a1,a2
		real*8, dimension(3)::position1,position2
		real*8, dimension(3)::position
		integer::node_type_id_1,node_type_id_2
	end type KMC_united_node_t
	
	type KMC_grid_t
		!! number of intramolecular hopping pairs
		integer*8::N_intramolecular_pairs
		type(KMC_intramolecular_pair), allocatable, dimension(:)::intramolecular_pairs
		!! N_hopping_site_list: Maximum number of different hopping site names in the system/all nodes
		integer                                      :: N_hopping_site_list
		!! hopping_site_list(N_hopping_site_list) collects all names of the hopping sites 
		character(len=500), allocatable, dimension(:):: hopping_site_list
		!! hopping_pair_matrix(A,B) for jumps from A to B
		integer*8, allocatable ,dimension(:,:)       :: hopping_pair_matrix
		!! hopping_pair_matrix(A,B) for jumps from A to B for intramolecular charge transport
		integer*8, allocatable ,dimension(:,:)       :: hopping_pair_matrix_intra
		!! counts the number of intermolecular jumps 
		integer*8::N_jumps_intermolecular
		!! counts the number of intramolecular jumps 
		integer*8::N_jumps_intramolecular
		
		
		!! Unite two nodes with high transitions to a single node
		integer*8::number_of_united_nodes
		type(KMC_united_node_t), allocatable, dimension(:)::united_node_list
	end type KMC_grid_t
	
	type KMC_result_t
			integer::id
			integer::number_of_nodes
			!! KMC resulting occupation numbers.
			REAL*8,ALLOCATABLE, DIMENSION(:)::occP
			REAL*8::fieldX,fieldY,fieldZ
			REAL*8,DIMENSION(3)::average_mobility
			REAL*8::runtime
			REAL*8::simtime
			integer::numberofcharges
			type (KMC_Chargecarrier_t), ALLOCATABLE, DIMENSION(:)::carrier
	end type KMC_result_t
	
	type gro_data_t
		!!! grofile data as a reference. It is not mendatory for the current evaluation
		integer										   :: id
		CHARACTER(LEN=500)                             :: gro_inputfile
		Character(5), ALLOCATABLE, Dimension(:)        :: atomsorte,residue_names
		REAL, ALLOCATABLE, DIMENSION(:,:)              :: koord,vel
		INTEGER::N_Atoms
		INTEGER, ALLOCATABLE, DIMENSION(:)             :: residue_numbers,atom_numbers
		INTEGER, ALLOCATABLE, DIMENSION(:,:)           :: R_u_I
		INTEGER::N_Resids
		CHARACTER(LEN=3)::koord_unit
		REAL::x_box
		REAL::y_box
		REAL::z_box
		LOGICAL:: has_side_chains
	end type gro_data_t
		
	type KMC_setup_t
			!!! KMC setup parameters
			LOGICAL::debug
			CHARACTER(len=1)::carriertype
			INTEGER::numberofcharges
			REAL*8::fieldX
			REAL*8::fieldY
			REAL*8::fieldZ
			INTEGER*8::maxsteps
			REAL*8::runtime
			REAL*8::temperature
			CHARACTER(500)::stopcondition
			REAL*8::outputtime
			REAL*8::nexttrajoutput
			CHARACTER(500):: trajectoryfilename
			CHARACTER(500):: xyz_trajectoryfilename
			!! votca_statfile.sql filename: default: state.sql  
			CHARACTER(500):: votca_sql_name
			CHARACTER(500):: votca_options_name
			CHARACTER(500):: injectionmethod
			CHARACTER(500):: injection_segment_type
			INTEGER::injection_node
			INTEGER, DIMENSION(64)::injection_node_list
			LOGICAL::store_trajectory
			LOGICAL::printtrajcsv
			LOGICAL::calc_VOTCA_style
			INTEGER::set_seed
			!type(KMC_grid_t)::grid
			
			!! unites nodes N1 and N2 to N1*
			logical::unite_notes_for_kmc
			logical::unite_nodes_with_same_type
			real*8::cutoffk1k2
			
			!! PATHWAY 
			LOGICAL::calc_pathway
			LOGICAL::reset_pathway_at_initial_site
			INTEGER::N_testpathways
			LOGICAL::check_hopping_pair_composition
			LOGICAL::set_rates_to_current
			
			!! PATHWAY 
			! grofile data
			CHARACTER(500)::gro_inputfile
			LOGICAL::wrap_all_molecules_into_the_box
			!!-- unites all molecules if it is unwraped with PBC in the *.gro file
			LOGICAL:: unite_PBC_split_molecule 
			LOGICAL::read_reference_grofile
			LOGICAL::dump_grofile_dI_travelled_max
			!! Cut the side chains from the DIPBI and P3HT Molecule in the gro_data
			!! Caution, other molecular typers are not implemented yet.
			LOGICAL:: cut_side_chains_in_gro
			
			!! Escape rate data 
			LOGICAL::makeEscapeRateFile
			CHARACTER(LEN=500):: EscapeRateFile
			
			!! Activate kmc meta dynamics  to improve sampling of improbable transitions (rough energy landscape)   default: kmcmetadynamics=.false.
			LOGICAL:: kmcmetadynamics
			!! alpha = exp{ - 1 / (kB T) }
			REAL*8:: kmcmetadynamics_alpha
			
			
			!! calc_pathway_Dijkstra algorithmus -- Find the pathway with lowest coasts.
			LOGICAL:: calc_pathway_Dijkstra
			CHARACTER(LEN=500):: modus_Dijkstra
			!! Start index select by id
			INTEGER:: start_Dijkstra ,ziel_Dijkstra
			!! Define a zone for inital points and and dublicate it for a second final zone for the target of a box transversing pathway in PBC
			LOGICAL::calc_pathway_between_zones
			!! Loop calculatins for all start nodes in the initial start zone.  [default:loopstartzone = .false. ]
			LOGICAL::loopstartzone
			!! Dijkstra network file store the Dijkstra network. [default: write_Networkfile_Dijkstra =.false.]
			LOGICAL ::write_Networkfile_Dijkstra =.false.
			!! Dijkstra network file, to load or store the Dijkstra network.
			CHARACTER(LEN=500):: networkfile_Dijkstra 
			!! Zonenbreite fuer Start und Endzone in Angstroem default: 5 Ang --> 
			REAL*8 :: Zonenbreite
			!! log_10 ( Abs( R )) 
			LOGICAL :: log10abs
			
			
			!!! ---------------------------------------------------------------------------
			!!! variables for enumerated_gro_to_VOTCA_DIPBI_P3HT_prepare
			logical::DIPBI_P3HT_calc                                   
			logical::DIPBI_P3MT_calc                                  
			logical::PPDI_PBDT_TS1_calc                             
			logical::KETTE    
				
				
			logical::modify_mol_h_atoms                                         
			logical::create_mapping_file                                                    
			logical::create_fake_topology                                                  
			logical::create_votca_boxfile                                                    
			logical::create_molpol_options_files                                        
			logical::create_gromp_mdp_file                                               
			logical::create_jobwriter_single_sites_file                               
			logical::create_jobwriter_pairs_pewald3d_file                         
			logical::create_mps_tab                                                           
			
			logical::print_coordH_to_xyz                                                            
			
				!! Use the HOMO and LUMO levels for ZINDO orbitals  --                                                      
				!! Adapt this, if other J_AB than VOTCA MOO/iZINDO method is used  --                                                    
			logical::orbs_ZINDO                                                
			logical::read_lambda_files                                                 
				!! Adds H atoms at the intrachain P3HT junctions between neighbouring segments, for the treatment of each segement as an entire molecule / site   --                                                      
				!! This is relevant for the concordance of the number of atoms in the QM files in *.mps files.  --                                                      >
			logical::add_virtual_H_atoms_to_gro                                               
			
				!! exclude_virtual_H_atoms=.true.   sets virtual H atoms to 1 in <virtual_mps> section => Excludes H in Emultipole calculation   --                                                      
				!! exclude_virtual_H_atoms=.false.  sets virtual H atoms to 0 in <virtual_mps> section => Includes H in Emultipole calculation    --                                                      
			logical::exclude_virtual_H_atoms                                     !!!!--	exclude_virtual_H_atoms=.true.   --                                                      
			
			
				!! make_geo_orbs_mps_g09 
				!! extra_files_modus = [false, all, make_g09_for_mps, make_ZINDO, make_xyz, make_folders]    applied in "make_geo_orbs_mps_g09"     --                                                      
				!! make_g09_for_mps: creates g09 inputfiles for the geometries to evaluate with data for *.mps files  --                                                      
				!! make_ZINDO: creates g09 input files for the ZINDO calculations, which are needed for *.orbs  --                                                      
				!! make_xyz: creates name1_n.xyz for the QC_FILE folder as needed for VOTCA calculations.  --                                                      
				!! make_folders: creates folders QC_FILES and MP_FILES
			logical::create_geo_orbs_mps_g09                                                   
			character(len=50) :: extra_files_modus                                                   
				
			!! mps.tab filename for background polarization.  default: mps_tab_filename='mps.tab'  
			character(len=500) ::mps_tab_filename
				
				
			!! default: use_votca_global_file_folder=.false.    
			!! default: MP_FILES_folder=MP_FILES    
			!! default: QC_FILES_folder=QC_FILES  
			character(len=500) :: MP_FILES_folder, QC_FILES_folder
			logical::use_votca_global_file_folder 
			
			!!! End variables for enumerated_gro_to_VOTCA_DIPBI_P3HT_prepare        
			!!! ---------------------------------------------------------------------------			
			
			
			!!! ---------------------------------------------------------------------------		
			!!! Variables for rates_to_votca_sqlfile
			  !logical :: DIPBI_P3HT_calc 
			  !logical :: DIPBI_P3MT_calc 
			  logical :: P3HT_pur_calc 
			  logical :: P3MT_pur_calc 
			  !logical :: PPDI_PBDT_TS1_calc 
			  integer :: N_Neighbours
			  logical  :: multigeo_setup 
			  integer :: Geo_Step
			  CHARACTER(LEN=50) :: rate_type        !!! default [rate_type="marcus"]
			  logical :: set_dE_out_and_l_out_to_zero 
			  logical :: set_J_AB_intermolecular_to_zero 
			  Real    :: Kondo                             !!! Kondo-Parameter in Weiß-Dorsey Rate 
			  logical :: TEST_RATES 
			  logical :: set_filenames 
			  character(500)  :: l_out_filename             !!! l_out_filename='data/l_out_filename.dat'    !!!'l_out_filename_P3HT_pur_1000ps_900K_65_G0_add_H_not_virtual.dat'
			  character(500)  :: E_multipole_filename       !!! E_multipole_filename='data/E_out_filename.dat'  
			  character(500)  :: J_AB_filename              !!! J_AB_filename='data/Datenauswertung_SAB_H_H0_Jab_H0_H0_SAB_L0_L0_Jab_L0_L0_G0.dat'
			  character(500)  :: dE_in_el_filename
			  character(500)  :: dE_in_lo_filename
			  character(500)  :: lambda_in_el_filename
			  character(500)  :: lambda_in_lo_filename
			  
			  logical :: Read_J_AB_from_sql_file 
			  logical :: Read_J_AB 

			  logical :: linear_scaling_J_AB 
			  character(LEN=50)   ::  J_AB_fit_method_geometry     !!! J_AB_fit_method_geometry='Lin_Combi'
			  logical :: scale_dipro_results 
			  character(LEN=50)   :: x_scale_method  !!!  x_scale_method='PM3'
			  character(LEN=50)   :: y_scale_method  !!!  y_scale_method='CDFT'
			  logical :: Read_COM_COM_H_MA_MMA_theta_Data_from_J_AB_file 

			  logical :: use_min_d_COM_vector_list 
			  !! Select  min_d_modus = [COM, MA, MMA, RCOM] 
			  character(LEN=500)  :: min_d_modus
			  logical :: print_data_collection_files 
			  logical :: mobility_estimate 
			  logical :: make_Histogramm 
			  logical :: read_intramolecular_data 
			  logical :: use_fit_intramolecular   
			  logical :: use_dE_in_AB__approx__dE_vert_CDFT 
			  
			  logical :: Use_reference_data_from_P3HT32mer
			  logical :: use_lambda_out_random_number_Gauss_distribution_data
			  logical :: Read_l_out
			  !! E_multiiplote with Thole model for electrostatic contributions dE
			  logical :: Read_E_multipole_out
			  !! Gaussian distribution for P3HT or DIPBI data for lam_out and E_out:  E_out_randomized_distribution=.true.
			  logical ::E_out_randomized_distribution
			  
			  !! Center and and standard width for Gaussian destributions
			  real::def_E_multi_h
			  real::sig_E_multi_h
			  real::def_E_multi_e
			  real::sig_E_multi_e
			   !! Mean values: $ \lambda_{ \text{out}}^{h} =0.157 \pm 0.014$ eV, $ \lambda_{ \text{out}}^{e} =0.132 \pm 0.012$ eV
			  real::def_lam_out_h
			  real::sig_lam_out_h
			  real::def_lam_out_e
			  real::sig_lam_out_e
			  
			!!! End variables for rates_to_votca_sqlfile
			!!! ---------------------------------------------------------------------------		

	
			!!! ---------------------------------------------------------------------------
			!!! variables for calc_current_I_from_kmc_data
			logical :: scale_to_interval_0_1                                                                                                                
			logical :: make_current_to_cubefile                                                                                                         
			logical :: use_logscale_I                                                                                                                           
			!! calculate log10 from p_occ for the displayed occupation numbers default: use_logscale_p_occ          
			logical :: use_logscale_p_occ                                                                                                                 
			!! creates a *.pdb file with points in a row, which can form a coloured bar.
			logical :: make_scale_p_occ_pdb                                                                                                             
			!! Number of points in the scale file
			integer :: N_occ_scale_points 
			!! creates a *.pdb file with points in a row, which can form a coloured bar.
			logical :: make_scale_I_pdb                                                                                                                 
			integer :: N_I_scale_points 
			logical :: current_only_use_sites_with_highest_contributions                                                                    
			logical :: occupations_only_use_sites_with_highest_contributions                                                             
			logical :: calc_high_current_pathway                                                                                                      
			!logical :: read_reference_grofile                                                                                                              
			!logical :: wrap_all_molecules_into_the_box                                                                                              
			
			!! for the visualization in vmd. default: scale_J_vmd_factor=1.0
			real :: scale_J_vmd_factor=10.0

			real :: J_max_percent_cutoff=0.95           !!!0.0001 !!!0.9  !! [0.0,1.0]  e.g. J_max_percent_cutoff=0.9 only the highest  currents 10% are printed. J_max_percent_cutoff=1.0 => All are printed
			real :: p_occ_max_percent_cutoff=0.95   !!!! highest 95 => highest 5 % of occupation numbers is printed

			!! scalefactor for partitioning of boxes. scalefactor = [0,1]  for the durrent density plots
			!! good value: scalebox=0.03 DIPBI/P3HTcd !! only change small scale eg: 0.025 P3HT
			real :: scalebox=0.025
			!! Select the equation to calculate the local current.
			logical :: calc_local_current_dr
			!! set_filenames
			!!! grofile data for pdb with current in the occupation column
			!character(len=500) :: gro_inputfile  !!="my_grofile.gro" 	
			character(len=500) :: current_I_out_filename   !!='my_current_I_out_arrow_vmd.dat'
			character(len=500) :: tot_occ_filename 
			character(len=500) :: marcus_rate_filename     !!='marcus_rate_statefile.dat'
			character(len=500) :: no_box_COM_file          !!='no_box_filename.dat'
			!!! end variables for calc_current_I_from_kmc_data
			!!! ---------------------------------------------------------------------------

			!!! ---------------------------------------------------------------------------
			!!! DIPRO variables
			integer          ::NCPUS               
			integer          ::NODE              
			integer          ::MEM               
			Character(500)   ::QUEUE             
			integer          ::TIME              
			Character(500)   ::sub               
			Character(500)   ::g09_SKF_path   
			Character(500)   ::dftb_plus_SKF_path          
			Character(500)   ::dftb_plus_path  
			logical          ::moment_of_inertia_tensor   
			!!! DIPRO_pair       
			logical          ::read_DIPRO_gro    
			integer          ::residA            
			Character(500)   ::typeA             
			integer          ::residB            
			Character(500)   ::typeB             
			Character(500)   ::calculation_method
			Character(500)   ::g09inputline     
			integer          ::trajstep          
			integer          ::Num               
			logical          ::read_DIPRO_xyz    
			Character(500)   ::monomerAxyz       
			Character(500)   ::monomerBxyz       
			!!! End DIPRO variables
			!!! ---------------------------------------------------------------------------
			
			!!! lambda_out_dE_out
			Character(500) :: neighbourlist_filename   !! Datei mit der Liste der Nachbarn.
			logical :: calc_lambda_out_entire_box                                                   !! Berechnung von allen resids fuer die Wahl von resid1
			logical :: calc_lambda_out_single_pair                                                   !! Berechne nur ein Paar: resid1 resid2
			logical :: calc_lambda_out_nearest_neighbours_list_NN_max                  !! Beschrenkung auf eine feste Anzahl an Nachbarn z.B. N_NN_max                            12 (Empfohlen)
			logical :: calc_lambda_out_r_cut_NN                                                      !! Berechne die Naechsten Nachbarn anhand eines Abstandskriterium: r_cut_NN ( Nicht verwechseln mit r_cut_lambda_out
			logical :: calc_lambda_out_nearest_neighbours_list_all                           !! Berechne fuer alle moeglichen Nachbarn in der Liste lambda_out. (Kann sehr lang werden)
			logical :: calc_molpol             
			Character(Len=500) :: select_calc_molpol                                       !!'  calc_molpol: alpha   'r_cut_lambda_out                           0.0 ! Angstroem ! Gesamtkugel fuer Berechnung von lambda_out  select_calc_molpol  [alpha, r_cut ,all ]
			real :: r_cut_lambda_out                             !! Angstroem ! Gesamtkugel fuer Berechnung von lambda_out 
			real :: r_cut_NN                                          !! Angstroem ! Maximale Umkreis der naechsten Nachbarn ( ob Paar berechnet werden soll)
			integer :: N_NN_max                                       !! Anzahl der naechsten Nachbarn fuer die zu resid1 die zweite resid gefunden werden soll. default                           12
			!!! lambda_out_dE_out 
			
			!!! lambda_in
			logical :: read_lambda_in_xyz
			logical :: read_lambda_in_gro
			logical :: extra_SP_lambda_in
	end type KMC_setup_t
	
	type KMC_system_t
		integer::id
		integer::number_of_nodes
		logical::has_nodes
		logical::has_KMC_setup
		logical::has_gro_data
		logical::has_kmc_results
		logical::has_grid
		integer::N_KMC_results
		type(gro_data_t)   ::gro_data
		type(KMC_Node_t)  ,allocatable, dimension(:) :: KMC_Nodes
		type(KMC_grid_t) :: KMC_grid
		type(KMC_result_t),allocatable, dimension(:) :: KMC_results
		type (KMC_setup_t)                           :: KMC_setup
	end type KMC_system_t
	
	
	!! global variables
	type (KMC_system_t) ,public :: KMC_system
	type (KMC_setup_t)  ,public :: KMC_setup
	!! --- Berechnung von Start zur Zielzone in Dijkstra---
	type(KMC_Node_t),allocatable,dimension(:) :: start_zone, mitte_zone, end_zone, tmp_zone, drei_zonen
	
	contains 

	subroutine set_defaults_KMC_system(KMC_system)
			implicit none
			type(KMC_system_t) :: KMC_system
			 KMC_system%id =1
			 KMC_system%number_of_nodes =0
			 KMC_system%has_nodes =.false.
			 KMC_system%has_grid =.false.
			 KMC_system%N_KMC_results =0
			 KMC_system%has_kmc_results =.false.
			 KMC_system%has_KMC_setup =.false.
			 KMC_system%has_gro_data =.false.
	end subroutine set_defaults_KMC_system

	subroutine update_KMC_system_nodes(nodes)
			type (KMC_Node_t), allocatable, dimension(:), intent(in)::nodes
			integer::NN
			NN=size(nodes)
			if(  allocated(KMC_system%KMC_Nodes)) then
				if( KMC_system%number_of_nodes /= NN) then
					deallocate(KMC_system%KMC_Nodes)
				endif 
			endif
			
			if( .not. allocated(KMC_system%KMC_Nodes)) then
				allocate(KMC_system%KMC_Nodes(NN))
			endif
			KMC_system%number_of_nodes=NN
			KMC_system%KMC_Nodes=nodes
			KMC_system%has_nodes=.true.
	end subroutine update_KMC_system_nodes
	
	subroutine update_KMC_system_gro_data(gro_data)
			type(gro_data_t)   ::gro_data
			KMC_system%gro_data=gro_data
			KMC_system%has_gro_data=.true.
	end subroutine update_KMC_system_gro_data

	subroutine update_KMC_system_grid(grid)
			type(KMC_grid_t)   ::grid
			KMC_system%KMC_grid=grid
			KMC_system%has_grid=.true.
	end subroutine update_KMC_system_grid


	!! adds an an event (possible charge transfer jump) to the node 
	subroutine KMC_system_Add_KMCResult(KMC_system, NeueVerbindung)
			implicit none
			type(KMC_system_t)     :: KMC_system
			type(KMC_result_t)     :: NeueVerbindung


			IF( .not. (allocated(KMC_system%KMC_results))) THEN
					allocate(KMC_system%KMC_results(1))
					KMC_system%KMC_results(1)=NeueVerbindung
					KMC_system%N_KMC_results=1
					KMC_system%has_kmc_results=.true.
			ELSE
					call append_result_to_KMC_results(KMC_system%KMC_results,NeueVerbindung)
					KMC_system%N_KMC_results= KMC_system%N_KMC_results + 1
			ENDIF
	end subroutine KMC_system_Add_KMCResult

	!! Increases the KMC_results, 
	subroutine append_result_to_KMC_results(KMC_results,NeueVerbindung)
						!! appends the NeueVerbindung to the list of events in KMC_results
						implicit none
						type (KMC_result_t), intent(in)::NeueVerbindung
						type (KMC_result_t), ALLOCATABLE, INTENT(INOUT) :: KMC_results(:)
						type (KMC_result_t), ALLOCATABLE :: new_KMC_results(:) 
						integer::n_results

						n_results=size(KMC_results)
						allocate(new_KMC_results(n_results+1))

						new_KMC_results(1:n_results)=KMC_results(1:n_results)

						new_KMC_results(n_results+1) = NeueVerbindung

						deallocate(KMC_results)
						allocate(KMC_results(n_results+1))
						!! transfer results
						KMC_results(:) = new_KMC_results(:)

						deallocate(new_KMC_results)
	end subroutine append_result_to_KMC_results

	!! KMC_setup options
	subroutine set_defaults_KMC_setup(setup)
		implicit none
		type(KMC_setup_t) :: setup
		
		setup%debug=.false.
		
		!! carriertype=[h,e]    holes or electrons
		setup%carriertype='h'
		!! number of charges for VSSM modus, default:  numberofcharges=1
		setup%numberofcharges=1
		
		!! default 1.0E7 [V/m]
		setup%fieldX=0.0		!!! Field in [V/m]
		setup%fieldY=1.0E7		!!! Field in [V/m]
		setup%fieldZ=0.0		!!! Field in [V/m]
		
		!! defaults
		setup%maxsteps=INT(1.0E5)   !! sampling default: maxstep=1.0E10  ; quick check: maxstep=1.0E5
		!!!
		setup%runtime=1.0E-1    !!   simulation time in [s] seconds  !! Do not use runtimes > 100
		
		!! temperature [K] ; default: temperature=300.0
		setup%temperature=300.0D0
		
		!! stopcondition= "steps", "runtime"  ; default: steps
		!! Prefer steps, as the simulation time my alter significantly depending on the input rates.
		setup%stopcondition="steps"
		setup%outputtime=1.0D10
		setup%nexttrajoutput=INT(1.0D9,8)
		setup%trajectoryfilename='my_trajectory.csv'
		setup%printtrajcsv=.false.
		setup%xyz_trajectoryfilename="my_single_charge_trajectory.xyz"
		!! votca_statfile.sql filename: default: state.sql    
		setup%votca_sql_name="state.sql"
		setup%votca_options_name='options_cpt_run_P3HT_inter_and_intra_h.xml'
		
		!!! injectionmethod='random'  , 
		!!! injectionmethod="injection_node"   ; selects a single node for charge injection, set :injection_node as node_id or Resid"
		!!! injectionmethod="injection_node_list" ; selects the nodes from the list below
		!!! injectionmethod="injection_segment_type" ; selects the nodes from the list below
		setup%injectionmethod='random'
		setup%injection_node=1322 
		setup%injection_segment_type=''
		
		!!! maximum select:injectionmethod='injection_node_list'   max 64 
		setup%injection_node_list(:)=1
		setup%injection_node_list(1)=1358 !6057 
		setup%injection_node_list(2)=6230
		setup%injection_node_list(3)=1767
		setup%injection_node_list(4)=2212
		setup%injection_node_list(5)=4501
		setup%injection_node_list(6)=1997
		setup%injection_node_list(7)=4456
		setup%injection_node_list(8)=2319
		setup%injection_node_list(9)=2085
		setup%injection_node_list(10)=6451
		
		
		!!! store_trajectory
		setup%store_trajectory=.false.
		
		!! Check hopping pairs for jumps form type A to type B and count the number of jumps; default: [check_hopping_pair_composition=.true.]
		setup%check_hopping_pair_composition=.true.
		
		!! If calc_VOTCA_style=.true. some BUGs in VOTCA code are included here, for comparability of results.   [default: setup%calc_VOTCA_style=.false.]
		!! 1) calculation of the mobility and orientation of the external field. $mu =  <v> * F^{ext}$
		setup%calc_VOTCA_style=.false.
		
		
		!! default: set_seed=0 => create new random seed ; else use an integer number as a seed for kmc simulations.
		setup%set_seed=0
		
		!! Escape rate data 
		setup%makeEscapeRateFile=.false.
		setup%EscapeRateFile="Escape_Rate_File.dat"
		
		!! unite_notes_for_kmc: make two nodes to one, if the rates are dominant and back and forth rates are high. [default:  unite_notes_for_kmc=.false.]
		setup%unite_notes_for_kmc=.false.
		!! Two nodes N1 and N2 can only be united if they posses the same type.  [default: unite_nodes_with_same_type=.true.]
		setup%unite_nodes_with_same_type=.true.
		!! cutoff for the rates to unite two nodes to a single node. k1/k2 > cutoffk1k2
		setup%cutoffk1k2=10000 
		
		
		!! SETUP FOR KMC PATHWAY FINDER 
		!! Switch to calculat a pathway with high current inside the morphology [default: calc_pathway=.false.]
		setup%calc_pathway=.false.
		!! for pathfinder settings: When writing out the charge carrier trajectory on can reset the system, if a charge comes back to the origin, [default: reset_pathway_at_initial_site=.false.]
		setup%reset_pathway_at_initial_site=.false.
		!! sets the number of calculated test pathways / iterations in the pathway routine
		setup%N_testpathways=1
		!! Replace the rates by the resulting current and do kmc on the current network. (not recommended) setup%set_rates_to_current [default: set_rates_to_current=.false.]
		setup%set_rates_to_current=.false.
		
		!! Gromacs inputfile with coordinates. (not used in KMC)
		setup%gro_inputfile="gromacs_inputfile.gro"
		setup%read_reference_grofile=.true. 
		setup%wrap_all_molecules_into_the_box=.true. 
		!! unites all molecules if it is unwraped with PBC in the *.gro file  [default: unite_PBC_split_molecule=.false. ]
		setup%unite_PBC_split_molecule=.false. 
		
		!! Cut the side chains from the DIPBI and P3HT Molecule in the gro_data [default: cut_side_chains_in_gro=.false. ]
		!! Caution, other molecular typers are not implemented yet.
		setup%cut_side_chains_in_gro=.false.
		
		!! Write out all molecules in the gro format, which were visited in the KMC run.
		setup%dump_grofile_dI_travelled_max=.true.
		
		!! Activate kmc meta dynamics  to improve sampling of improbable transitions (rough energy landscape)   [default: kmcmetadynamics=.false.]
		setup%kmcmetadynamics=.false.
		!! alpha = exp{ - 1 / (kB T) }
		setup%kmcmetadynamics_alpha=0.995
		
		
		!!! ---------------------------------------------------------------------------
		!! calc_pathway_Dijkstra    default::calc_pathway_Dijkstra=.false.
		setup%calc_pathway_Dijkstra=.false.
		
		!! modus_Dijkstra == 'Dijkstra_kmc_network' or  'Dijkstra_newNetwork' or  'Dijkstra_loadNetwork' 
		setup%modus_Dijkstra='Dijkstra_kmc_network'
		
		!! Start index select by id. default: [start_Dijkstra = 1,ziel_Dijkstra =2]
		setup%start_Dijkstra = 1
		setup%ziel_Dijkstra  = 2
		!! Define a zone for inital points and and dublicate it for a second final zone for the target of a box transversing pathway in PBC  [default: alc_pathway_between_zones=.false. ]
		setup%calc_pathway_between_zones=.false.
		!! Loop calculatins for all start nodes in the initial start zone.  [default:loopstartzone = .false. ]
		setup%loopstartzone=.false.
		
		!! Dijkstra network file store the Dijkstra network. [default: write_Networkfile_Dijkstra =.false.]
		setup%write_Networkfile_Dijkstra =.false.
		
		!! Dijkstra network file, to load or store the Dijkstra network.
		setup%networkfile_Dijkstra='net1.txt'
		
		!! Zonenbreite fuer Start und Endzone in Angstroem  default: [Zonenbreite = 5] Ang
		setup%Zonenbreite = 5
		!! log_10 ( Abs( R ))   ;   [dafault: log10abs = .false.]
		setup%log10abs = .false.
		
		!!! ---------------------------------------------------------------------------
		!!! ---------------------------------------------------------------------------
		!! Defaults for enumerated_gro_to_VOTCA_DIPBI_P3HT_prepare
			setup%DIPBI_P3HT_calc=.false.                                    
			setup%DIPBI_P3MT_calc=.false.                                   
			setup%PPDI_PBDT_TS1_calc=.false.                              
			setup%KETTE=.false.     
			
			
			setup%modify_mol_h_atoms=.false.                                          
			setup%create_mapping_file=.false.                                                     
			setup%create_fake_topology=.false.                                                   
			setup%create_votca_boxfile=.false.                                                     
			setup%create_molpol_options_files=.false.                                         
			setup%create_gromp_mdp_file=.false.                                                
			setup%create_jobwriter_single_sites_file=.false.                                
			setup%create_jobwriter_pairs_pewald3d_file=.false.                          
			setup%create_mps_tab=.false.                                                            
		
			setup%print_coordH_to_xyz=.false.                                                             
		
			!! Use the HOMO and LUMO levels for ZINDO orbitals  --                                                      
			!! Adapt this, if other J_AB than VOTCA MOO/iZINDO method is used  --                                                    
			setup%orbs_ZINDO=.true.                                                    
			setup%read_lambda_files=.false.                                                  
			!! Adds H atoms at the intrachain P3HT junctions between neighbouring segments, for the treatment of each segement as an entire molecule / site   --                                                      
			!! This is relevant for the concordance of the number of atoms in the QM files in *.mps files.  --                                                      >
			setup%add_virtual_H_atoms_to_gro=.false.                                                
		
			!! exclude_virtual_H_atoms=.true.   sets virtual H atoms to 1 in <virtual_mps> section => Excludes H in Emultipole calculation   --                                                      
			!! exclude_virtual_H_atoms=.false.  sets virtual H atoms to 0 in <virtual_mps> section => Includes H in Emultipole calculation    --                                                      
			setup%exclude_virtual_H_atoms=.true.                                       !!!!--	exclude_virtual_H_atoms=.true.   --                                                      
		
		
			!! make_geo_orbs_mps_g09 
			!! extra_files_modus = [false, all, make_g09_for_mps, make_ZINDO, make_xyz, make_folders]    applied in "make_geo_orbs_mps_g09"     --                                                      
			!! make_g09_for_mps: creates g09 inputfiles for the geometries to evaluate with data for *.mps files  --                                                      
			!! make_ZINDO: creates g09 input files for the ZINDO calculations, which are needed for *.orbs  --                                                      
			!! make_xyz: creates name1_n.xyz for the QC_FILE folder as needed for VOTCA calculations.  --                                                      
			!! make_folders: creates folders QC_FILES and MP_FILES
			setup%create_geo_orbs_mps_g09=.false.                                                    
			setup%extra_files_modus="false"                              
			
			
                     
			
			!! mps.tab filename for background polarization.  default: mps_tab_filename='mps.tab'  
			setup%mps_tab_filename='mps.tab'                                                
			
			
			!! default: use_votca_global_file_folder=.false.    
			!! default: MP_FILES_folder=MP_FILES    
			!! default: QC_FILES_folder=QC_FILES  
			setup%MP_FILES_folder='MP_FILES' 
			setup%QC_FILES_folder='QC_FILES'
			setup%use_votca_global_file_folder = .false. 
			!!! End Defaults for enumerated_gro_to_VOTCA_DIPBI_P3HT_prepare        
			!!! ---------------------------------------------------------------------------


			!!! ---------------------------------------------------------------------------		
			!!! Defaults for rates_to_votca_sqlfile
			!! System 
			setup%DIPBI_P3HT_calc=.false.
			setup%DIPBI_P3MT_calc=.false.
			setup%P3HT_pur_calc=.false.
			setup%P3MT_pur_calc=.false.
			setup%PPDI_PBDT_TS1_calc=.false.
			!! Number of neighbours in the neighbourlistfile
			setup%N_Neighbours=13

			!! multigeo dafault: multigeo_setup=.false.
			setup%multigeo_setup=.false.
			!! default: Geo_Step=0 for multigeo_setup. Usually parameter is extracted from input data _G${Geo_step} in *.gro file
			setup%Geo_Step=0

			!! rate_type = "jortner" or "marcus" or "weiss_dorsey"
			setup%rate_type="marcus"

			!! set all outer_sphere contributions to zero dE_out und lambda_out, overrides all other cases.
			setup%set_dE_out_and_l_out_to_zero=.false.
			!! set all J_AB_intermolecular to zero. Only check intramolecular transport. default: set_J_AB_intermolecular_to_zero=.false.
			setup%set_J_AB_intermolecular_to_zero=.false.

			!! Kondo parameter alpha for weiss-dorsey rate
			!! Asadi. et A. Nature Com. 2013
			!! default: Votca Kondo=4.0 ; rr-P3HT = 3.6 ; rr-P3HT doped 6.75  
			setup%Kondo=4.0 

			!!! Default: TEST_RATES=.false. only evaluates rates with selected properties.
			setup%TEST_RATES=.false.
			setup%set_filenames=.false.
			setup%l_out_filename='data/l_out_filename.dat'    !!!'l_out_filename_P3HT_pur_1000ps_900K_65_G0_add_H_not_virtual.dat'
			setup%E_multipole_filename='data/E_out_filename.dat'  
			setup%J_AB_filename='data/Datenauswertung_SAB_H_H0_Jab_H0_H0_SAB_L0_L0_Jab_L0_L0_G0.dat'
			setup%dE_in_el_filename='data/dE_in_el_filename.dat'
			setup%dE_in_lo_filename='data/dE_in_lo_filename.dat'
			setup%lambda_in_el_filename='data/lambda_in_el_filename.dat'
			setup%lambda_in_lo_filename='data/lambda_in_lo_filename.dat'
			!! J_AB 
			setup%Read_J_AB_from_sql_file=.false.
			setup%Read_J_AB=.true.

			!! Parametrized for DIPBI:P3MT [3mer,5mer,7mer]
			!! Scaling J_AB(y) = f(x) * J_AB
			!! Available methods:   y_scale_method=[CDFT,PBE/6-311G**,B3LYP/3-21G,PM3]
			!! Available methods:   x_scale_method=[PBE/6-311G**,ZINDO,PM3,DFTB/MIO,DFTB/3OB,B3LYP/3-21G*,B3LYP/6-31G*,B3LYP/6-311G**]
			!! Caution, not all combinations are implemented.
			setup%scale_dipro_results=.true.
			setup%linear_scaling_J_AB=.true.
			setup%x_scale_method='PM3'
			setup%y_scale_method='CDFT'


			!! Can read the geometric data from the J_AB_file and evaluate the matrix element J_AB via a linear fit from the geomentic data
			!!  
			!! Use a method in the list: J_AB_fit_method_geometry=[MA,MMA,COM_H,Lin_Combi]
			!! MA = minimal distance, MMA = mean minimal distance,  COM = center of mass distanc, COM_H = center of mass distance with hydrogen atoms included,
			!! Lin_Combi: Use a linear combination for a fit of MA,MMA,COM_H to obtain a value for J_AB_hole, J_AB_elec 
			setup%Read_COM_COM_H_MA_MMA_theta_Data_from_J_AB_file=.false.
			setup%J_AB_fit_method_geometry='Lin_Combi'

			!! min distvector with subhopping sites
			setup%use_min_d_COM_vector_list=.false.
			!! Select  min_d_modus = [COM, MA, MMA, RCOM] 
			setup%min_d_modus='COM'

			setup%print_data_collection_files=.false.
			setup%mobility_estimate=.false.
			setup%make_Histogramm=.false.
			setup%DEBUG=.false.

			!! Intramolecular 
			setup%read_intramolecular_data=.true.
			!! uses cosfit for | J_AB(el)| and scaled dE_intra_el=-0.65* dE_intra_lo  !!! default=.false.
			setup%use_fit_intramolecular=.false.  
			!! use vertical energy gap from CDFT dE_vert_CDFT to approximate the dE_in_AB=dE_A_in -dE_B_in  !!! default=.false.
			setup%use_dE_in_AB__approx__dE_vert_CDFT=.true.
			
			
			setup%Use_reference_data_from_P3HT32mer=.false.
			setup%use_lambda_out_random_number_Gauss_distribution_data=.false.
			setup%Read_l_out=.false.
			!! E_multiiplote with Thole model for electrostatic contributions dE
			setup%Read_E_multipole_out=.false.
			!! Gaussian distribution for P3HT or DIPBI data for lam_out and E_out:  E_out_randomized_distribution=.true.
			setup%E_out_randomized_distribution=.false.
			
			!! Default P3HT values
			setup%def_E_multi_h=-0.131
			setup%sig_E_multi_h=0.146
			setup%def_E_multi_e=0.120
			setup%sig_E_multi_e=0.126
			!! Mean values: $ \lambda_{ \text{out}}^{h} =0.157 \pm 0.014$ eV, $ \lambda_{ \text{out}}^{e} =0.132 \pm 0.012$ eV
			setup%def_lam_out_h=0.157
			setup%sig_lam_out_h=0.014
			setup%def_lam_out_e=0.132
			setup%sig_lam_out_e=0.012
			
			
			!!! Defaults for rates_to_votca_sqlfile
			!!! ---------------------------------------------------------------------------	


			!!!----------------------------------------------------------------------------- --> 	
			!!!--  Defaults variables for calc_current_I_from_kmc_data  / current_I_form_votca_sql_data  --> 	

			!!	$\mathbf{I}_i = \frac{1}{2} e \sum_{j} ( p^{\text{occ}}_i k_{ij} - p^{\text{occ}}_j k_{ji}) \mathbf{d}_{ij}$
			!!  or
			!!  Caution: Is an increasing current with an increasing hopping distance usefull?
			!!  Alternative: calc_local_current_dr =.false.
			!!  $\mathbf{I}_i = \frac{1}{2} e \sum_{j} ( p^{\text{occ}}_i k_{ij} - p^{\text{occ}}_j k_{ji}) \mathbf{e}_{ij}$
			!!
			!!  Use the unite vector  $\mathbf{e}_{ij} = \mathbf{d}_{ij} / |d_{ij}|$ for the i -> j distance 
			setup%calc_local_current_dr =.true.
			!! carriertype h / e ; hole or electron
			!carriertype='h'
			setup%scale_to_interval_0_1=.true.
			setup%make_current_to_cubefile=.false.
			setup%use_logscale_I=.false.
			!! calculate log10 from p_occ for the displayed occupation numbers default: use_logscale_p_occ=.true. 
			setup%use_logscale_p_occ=.false.
			!! creates a *.pdb file with points in a row, which can form a coloured bar.
			setup%make_scale_p_occ_pdb=.false.
			!! Number of points in the scale file
			setup%N_occ_scale_points=100
			
			!! creates a *.pdb file with points in a row, which can form a coloured bar.
			setup%make_scale_I_pdb=.false.
			setup%N_I_scale_points=100
			
			
			setup%current_only_use_sites_with_highest_contributions=.true.
			setup%occupations_only_use_sites_with_highest_contributions=.true.
			setup%calc_high_current_pathway=.false. 
			 
			!!! grofile data for pdb with current in the occupation column
			!gro_inputfile="my_grofile.gro" 	 
			!read_reference_grofile=.true. 
			!wrap_all_molecules_into_the_box=.true. 
			!!! for the visualization in vmd. default: scale_J_vmd_factor=1.0
			setup%scale_J_vmd_factor=10.0

			setup%J_max_percent_cutoff=0.95       !!!0.0001 !!!0.9  !! [0.0,1.0]  e.g. J_max_percent_cutoff=0.9 only the highest  currents 10% are printed. J_max_percent_cutoff=1.0 => All are printed
			setup%p_occ_max_percent_cutoff=0.95   !!!! highest 95 => highest 5 % of occupation numbers is printed

			!! scalefactor for partitioning of boxes. scalefactor = [0,1]
			!! good value: scalebox=0.03 DIPBI/P3HTcd !! only change small scale eg: 0.025 P3HT
			!!
			setup%scalebox=0.025
			!! default: 
			setup%tot_occ_filename="tot_occ_filename.dat"
			setup%marcus_rate_filename="marcus_rate_id_drX_drY_drZ_marcus_rate12_rate21.dat"
			setup%no_box_COM_file="no_box_COM_file.xyz"
			!setup%votca_sql_filename="state.sql"
			setup%current_I_out_filename="my_current_I_out_arrow_vmd.dat"
			
			!!! end defaults     calc_current_I_from_kmc_data
			!!!----------------------------------------------------------------------------- --> 	
	



			!!!----------------------------------------------------------------------------- --> 	
			!!!--  variables for DIPRO // gro_to_DIPRO --> 	
			setup%NCPUS=8           !!!</NCPUS>  !!-- Number of CPUS -->
			setup%NODE=1            !!!</NODE>   !!-- Number of nodes for parallel calculations -->
			setup%MEM=8             !!!</MEM>    !!-- Select the Memory in G09 input.inp. The Memory is given in GB: default MEM=8 -->
			setup%QUEUE="default"   !!!</QUEUE>  !!-- select the name of the queue for the evaluation -->NCPUS=8
			setup%TIME=1            !!!</TIME>   !!-- calculation time in hours -->NODE=1
			setup%sub="sub_g09"     !!!</sub>    !!-- submission: select the program  sub= 'sub_g09' for Gaussian09 or 'sub_dftb+' for DFTB+ programm package ; defMEM=8!GB
			setup%g09_SKF_path="/opt/files/DFTB_skf_files/mio-1-1"  !! g09 MIO-1-1 Slater-Koster-Parameter files f
			setup%dftb_plus_path="/home/t/t_koch08/dftb+/dftbplus-17.1.x86_64-linux/bin/"      !!!</dftb_plus_path> !!-- Pathway to the DFTB+ executable -->TIME=1
			setup%dftb_plus_SKF_path="/home/t/t_koch08/dftb+/3ob-3-1/"   !!! Slater-Koster-file path for dftb+ files auf edoras
			!!-- Evaluates the moment_of_inertia_tensor for the DIPRO pair.  default: moment_of_inertia_tensor =.false.
			setup%moment_of_inertia_tensor =.false.
			
			!!-- DIPRO_pair 
			!!-- DO NOT use read_DIPRO_gro=1 and read_DIPRO_xyz=1 at the same time ! -->
			!!--  monomerA and monomerB are selected by resid1 and resid2 from gro_inputfile (read_DIPRO_gro=1).  -->

			setup%read_DIPRO_gro=.false.              !!!</read_DIPRO_gro>   !!-- Reads the data for a DIPRO calculation from the following section, if read_DIPRO_pair=1 ; default: read_DIPRO_pair=0 => OFF! -->
			!!!		<gro_inputfile>equi_2000ps_500k_DIPBI.gro</gro_inputfile>  !!-- INPUT morphology.gro -->
			
			setup%residA=1         !!!</residA>         !!-- Resid from molecule A -->
			setup%typeA="DIPBI"    !!!</typeA>          !!-- Molecular type from molecule A -->
			setup%residB=2         !!!</residB>         !!-- Resid from molecule B -->
			setup%typeB="DIPBI"    !!!</typeB>          !!-- Molecular type from molecule B -->
			setup%calculation_method="B3LYP_6-31Gs"     !!-- PM3</calculation_method>  !!-- Identify method for the folder. Caution: Do not use * or / here! -->
			setup%g09inputline=' B3LYP/6-31G* SCF(XQC,MaxConventionalCycles=400,MaxCycle=800) '  !!</g09inputline>  !!-- g09 inputline -->
			setup%trajstep=0                            !!!-- </trajstep>  !!--  Morphology counter !!! Auswahl des Schrittes der Geometrie in gro-file -->
			setup%Num=0                                 !!!</Num>          !!--  DIPRO calculation counter !!! urchzaehlen der Ordnungsrechnungsnummer -->
				
			!!--  monomerA and monomerB are selected by monomerA.xyz and monomerB.xyz  (read_DIPRO_xyz=1).  -->
			setup%read_DIPRO_xyz=.false.                !!!</read_DIPRO_xyz>   !!-- Reads the data for a DIPRO calculation from the following section, if read_DIPRO_xyz=1 ; default: read_DIPRO_xyz=0 => OFF! -->
			setup%monomerAxyz="monomerA.xyz"     !!!</monomerAxyz>
			setup%monomerBxyz="monomerB.xyz"     !!!</monomerBxyz>
			!!!!-- DIPRO_pair
			!!!!----------------------------------------------------------------------------- --> 	
			
			
			!!!   lambda_out_dE_out
			setup%neighbourlist_filename = 'my_sorted_neighbours.ngh'
			setup%calc_lambda_out_entire_box=.false.                                   !! Berechnung von allen resids fuer die Wahl von resid1
			setup%calc_lambda_out_single_pair=.true.                                   !! Berechne nur ein Paar: resid1 resid2
			setup%calc_lambda_out_nearest_neighbours_list_NN_max=.false. !! Beschrenkung auf eine feste Anzahl an Nachbarn z.B. N_NN_max =12 (Empfohlen)
			setup%calc_lambda_out_r_cut_NN=.false.                                    !! Berechne die Naechsten Nachbarn anhand eines Abstandskriterium: r_cut_NN ( Nicht verwechseln mit r_cut_lambda_out
			setup%calc_lambda_out_nearest_neighbours_list_all=.false.         !! Berechne fuer alle moeglichen Nachbarn in der Liste lambda_out. (Kann sehr lang werden)
			setup%calc_molpol=.false.
			setup%select_calc_molpol=''      !!'  select_calc_molpol: alpha   'r_cut_lambda_out=0.0 ! Angstroem ! Gesamtkugel fuer Berechnung von lambda_out  select_calc_molpol =[alpha, r_cut ,all ]
			setup%r_cut_lambda_out=15.0       !! Angstroem ! Gesamtkugel fuer Berechnung von lambda_out 
			setup%r_cut_NN=35.0              !! Angstroem ! Maximale Umkreis der naechsten Nachbarn ( ob Paar berechnet werden soll)
			setup%N_NN_max=12                !! Anzahl der naechsten Nachbarn fuer die zu resid1 die zweite resid gefunden werden soll. default=12
			!!!! End lambda_out_dE_out
			
			!!!  lambda_in_pair
			!!- reads the input coordinates from *.xyz files in monomerAxyz and monomerBxyz [default: read_lambda_in_xyz=.false.]
			setup%read_lambda_in_xyz=.false.
			!!- Reads the geometric data from the *.gro in "gro_inputfile" [default: read_lambda_in_gro=.false.]
			setup%read_lambda_in_gro=.false.
			!!- create a number of extra g09 scf files for calculations on optimized structures, as the SCF energies may differ  SCF_x_Opt_x_ with x=[n,el,lo] ; [default: extra_SP_lambda_in=false.]
			setup%extra_SP_lambda_in=.false.
			!!!  lambda_in_pair
	end subroutine set_defaults_KMC_setup


	!! Read the options.xml file and stores keywords and values in KMC_setup
	subroutine read_votca_optionsfile(kMC_options_filename,KMC_setup,read_section)
		use small_functions
		implicit none
		Character(500), INTENT(IN)      :: kMC_options_filename
		type(KMC_setup_t),INTENT(INOUT) :: KMC_setup
		Character(LEN=*), INTENT(IN)    :: read_section

		!! local variables
		integer::i,j,l,N_lines,ind1,ind2,ierror
		Character(LEN=1000)  :: line,dummy,dummy2,section,value,keyword
		Character(LEN=1)     :: delimiterA,delimiterB
		logical :: keywordtwice,read_section_all
		integer :: N_keywords
		Character(1000), ALLOCATABLE, Dimension(:) :: keywordsfound
		integer::i_value
		real*8::real_number
		Character(1)    :: tab 
		logical:: debug=.false.
		
		tab = ACHAR(9)
		
		if( file_exists(kMC_options_filename)) then
			if(check_filetermination(kMC_options_filename,'.xml'))then
				write(*,*) 'Setup data from  kMC_options_filename.xml: ',TRIM(kMC_options_filename)
			endif 
		end if 
		
		N_lines=Read_rows_file2(kMC_options_filename)
		if(  allocated(keywordsfound))    deallocate(keywordsfound)
		if( .not. allocated(keywordsfound)) allocate(keywordsfound(N_lines))
		N_keywords=0
		keywordsfound(:)=''
		keywordtwice=.false.
		read_section_all=.false.
		if(debug) write(*,*) 'read_section: ',trim(read_section)
		if( ( index('all',TRIM(read_section)) /= 0 ) .or. ( index('ALL',TRIM(read_section)) /= 0 ) ) then
			read_section_all=.true.
		endif
		OPEN(UNIT=70,FILE=TRIM(kMC_options_filename),STATUS='OLD',ACTION='READ',IOSTAT=ierror)
		
		delimiterA='>'
		delimiterB='<'
		loop_i: DO i=1,N_lines
			READ (70, '(A)',IOSTAT=ierror) line ! reading the entire line from input file
			!!! replace each tab in the line with a space.
			DO j = 1, LEN(line)
				! replace each tab in the line with a space.
				IF (  line(j:j)==tab  )  line(j:j)=' '
			END DO
			line=TRIM(line(index(ADJUSTL(line),'<'):))   !!! delete all spaces on the left till first "<"
			dummy2=TRIM(line)
			!write(*,*) 'dummy2: ',TRIM(dummy2)
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(kMC_options_filename),' aufgetreten.  Line:',i
				WRITE(*,*) TRIM(line)
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			ELSE IF(ierror < 0) THEN
				exit loop_i
			END IF

			if( LEN_TRIM(line) < 4 ) then
				cycle
			endif
		
			if(debug) write(*,*) TRIM(ADJUSTL(line))
			!!! delete comments
			if( index(ADJUSTL(line(1:2)),'<!') /= 0 ) then ! cycle comment "<!"  
				cycle
			else if( index(TRIM(line),'!') /= 0 ) then    !!e.g.  <!-- 4 t_koch08 -->
				line=line(:index(TRIM(line),'!')-2)
				!write(*,*) 'without comment: ',TRIM(line)
				if( LEN_TRIM(line) < 2 ) then  !! cycle pure comments e.g. <!-- IMPORT DATA ++++ >
					cycle
				endif
			endif
			
			!! Split the string, looking for indizes with the start of keywords
			ind1 = index(TRIM(line),TRIM(adjustl(delimiterA))) 
			ind2 = index(TRIM(line),TRIM(adjustl(delimiterB)),.true.)  !BACK index
			IF( line(1:2) == '/' ) THEN !! end section 
				!write(*,*) 'END Section: ',TRIM(line)
			ELSE IF( ind2 < ind1) THEN !! start section
				section=TRIM(ADJUSTL(line(ind2+1:LEN_TRIM(line)-1)))
				if (section(1:2) == '/') then
					section=''
					!write(*,*) 'END Section: ',TRIM(section)
					cycle
				endif
				!write(*,*) 'Section: ',TRIM(section)
				cycle
			ELSE IF( (ind1 .ne. 0) .AND. (ind2 .ne. 0) )THEN  ! keywords exist in stri
					dummy=TRIM(ADJUSTL(line(:ind1)))
					value=TRIM(ADJUSTL(line(ind1+1:ind2-1)))
					keyword=TRIM(ADJUSTL(line(ind2+2:LEN_TRIM(line)-1)))
					!write(*,*) TRIM(dummy)
					!write(*,*) TRIM(value)
					!write(*,*) TRIM(keyword)
					!write(*,*) TRIM(line)
					!write(*,*) TRIM(keyword),'     ',TRIM(value)
					!write(*,*) '---'
			ELSE
				WRITE(*,*) 'ERROR: Reading xml file ',TRIM(line),' in line ',i
				WRITE(*,*) TRIM(dummy2)
				CALL EXIT(1)
			ENDIF
			
			IF (( index('debug',TRIM(keyword)) /= 0 ) .OR. &
						&(index('DEBUG',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "debug"))THEN
							KMC_setup%debug=.true.
						ELSE
							KMC_setup%debug=.false. 
						END IF
			ENDIF
			
			
			IF( (read_section_all) .or. ( index(TRIM(read_section),TRIM(section)) /= 0 ) ) THEN
				if(debug) write(*,*) Trim(section),"   ",trim(keyword),"   ",TRIM(ADJUSTL(value))
				continue
			ELSE
				CYCLE
			ENDIF
			keywordtwice=.false.
			DO l=1,N_keywords
					IF( TRIM(ADJUSTL(keywordsfound(l))) == TRIM(ADJUSTL(keyword)) ) THEN 
						keywordtwice=.true.
					ENDIF
					IF(keywordtwice) THEN
						EXIT
					ENDIF 
			END DO
			
			IF(keywordtwice) THEN
				write(*,*) '##################################################################################################'
				write(*,*) '# Warning: The keyword "',TRIM(ADJUSTL(keyword)),'" is found twice in '//TRIM(kMC_options_filename)//''
				write(*,*) '#          Make sure your read the data correctly!'
				write(*,*) '##################################################################################################'
			ELSE ! append keyword to list
					N_keywords = N_keywords + 1
					keywordsfound(N_keywords) = TRIM(ADJUSTL(keyword))
			ENDIF
			!write(*,*) 'loop_i:',i
			!!! START Check sections
			!! carriertype=[h,e]    holes or electrons
			
			
			write(*,*) 'Reading: ',Trim(section),"   ",trim(keyword),"   ",TRIM(ADJUSTL(value))
			!!!!---------------------------------------------------------------------------------------------------------------!!!!
			!!!!    READ enumerated_gro_to_VOTCA_DIPBI_P3HT_prepare  from options.xml                                          !!!!
			!!!!---------------------------------------------------------------------------------------------------------------!!!!


			IF ((TRIM(section) == 'enumerated_gro_to_VOTCA_DIPBI_P3HT_prepare') .OR. (TRIM(section) == 'grotovotca') .OR. & 
			&   (TRIM(section) == 'gro_to_VOTCA')  .OR.  &
			&   (TRIM(section) == 'enumeratedgrotoVOTCADIPBIP3HTprepare') .OR. (TRIM(section) == 'gro_to_votca')  ) THEN
				if (( index('debug',TRIM(keyword)) /= 0 ) .OR. &
						&(index('DEBUG',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "debug"))THEN
							KMC_setup%debug=.true.
						ELSE
							KMC_setup%debug=.false. 
						END IF 
														  
				else if (( index('DIPBI_P3HT_calc',TRIM(keyword)) /= 0 ) .OR. &
						&(index('DIPBIP3HTcalc',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "DIPBI_P3HT_calc"))THEN
							KMC_setup%DIPBI_P3HT_calc=.true.
						ELSE
							KMC_setup%DIPBI_P3HT_calc=.false. 
						END IF 
				else if (( index('DIPBI_P3MT_calc',TRIM(keyword)) /= 0 ) .OR. &
						&(index('DIPBIP3MTcalc',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "DIPBI_P3MT_calc"))THEN
							KMC_setup%DIPBI_P3MT_calc=.true.
						ELSE
							KMC_setup%DIPBI_P3MT_calc=.false. 
						END IF 
				else if (( index('PPDI_PBDT_TS1_calc',TRIM(keyword)) /= 0 ) .OR. &
						&(index('PPDIPBDTTS1calc',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "PPDI_PBDT_TS1_calc"))THEN
							KMC_setup%PPDI_PBDT_TS1_calc=.true.
						ELSE
							KMC_setup%PPDI_PBDT_TS1_calc=.false. 
						END IF 
				else if ( (index('KETTE',TRIM(keyword)) /= 0 ) .OR.  ( index('kette',TRIM(keyword)) /= 0 )  .OR. &
						& (index('Kette',TRIM(keyword)) /= 0 ) .or. (index('chain',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "KETTE"))THEN
							KMC_setup%KETTE=.true.
						ELSE
							KMC_setup%KETTE=.false. 
						END IF 

				else if (( index('modify_mol_h_atoms',TRIM(keyword)) /= 0 ) .OR. &
						&(index('modifymolhatoms',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "modify_mol_h_atoms"))THEN
							KMC_setup%modify_mol_h_atoms=.true.
						ELSE
							KMC_setup%modify_mol_h_atoms=.false. 
						END IF 
				else if (( index('create_mapping_file',TRIM(keyword)) /= 0 ) .OR. &
						&(index('createmappingfile',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "create_mapping_file"))THEN
							KMC_setup%create_mapping_file=.true.
						ELSE
							KMC_setup%create_mapping_file=.false. 
						END IF 					
				else if (( index('create_fake_topology',TRIM(keyword)) /= 0 ) .OR. &
						&(index('createfaketopology',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "create_fake_topology"))THEN
							KMC_setup%create_fake_topology=.true.
						ELSE
							KMC_setup%create_fake_topology=.false. 
						END IF 
				else if (( index('create_votca_boxfile',TRIM(keyword)) /= 0 ) .OR. &
						&(index('createvotcaboxfile',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "create_votca_boxfile"))THEN
							KMC_setup%create_votca_boxfile=.true.
						ELSE
							KMC_setup%create_votca_boxfile=.false. 
						END IF 
				else if (( index('create_molpol_options_files',TRIM(keyword)) /= 0 ) .OR. &
						&(index('createmolpoloptionsfiles',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "create_molpol_options_files"))THEN
							KMC_setup%create_molpol_options_files=.true.
						ELSE
							KMC_setup%create_molpol_options_files=.false. 
						END IF 	
				else if (( index('create_gromp_mdp_file',TRIM(keyword)) /= 0 ) .OR. &
						&(index('creategrompmdpfile',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "create_gromp_mdp_file"))THEN
							KMC_setup%create_gromp_mdp_file=.true.
						ELSE
							KMC_setup%create_gromp_mdp_file=.false. 
						END IF 	
				else if (( index('create_jobwriter_single_sites_file',TRIM(keyword)) /= 0 ) .OR. &
						&(index('createjobwritersinglesitesfile',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "create_jobwriter_single_sites_file"))THEN
							KMC_setup%create_jobwriter_single_sites_file=.true.
						ELSE
							KMC_setup%create_jobwriter_single_sites_file=.false. 
						END IF 
				else if (( index('create_jobwriter_pairs_pewald3d_file',TRIM(keyword)) /= 0 ) .OR. &
						&(index('createjobwriterpairspewald3dfile',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "create_jobwriter_pairs_pewald3d_file"))THEN
							KMC_setup%create_jobwriter_pairs_pewald3d_file=.true.
						ELSE
							KMC_setup%create_jobwriter_pairs_pewald3d_file=.false. 
						END IF 
				else if (( index('create_mps_tab',TRIM(keyword)) /= 0 ) .OR. &
						&(index('creatempstab',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "create_mps_tab"))THEN
							KMC_setup%create_mps_tab=.true.
						ELSE
							KMC_setup%create_mps_tab=.false. 
						END IF 		
				else if (( index('print_coordH_to_xyz',TRIM(keyword)) /= 0 ) .OR. &
						&(index('printcoordHtoxyz',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "print_coordH_to_xyz"))THEN
							KMC_setup%print_coordH_to_xyz=.true.
						ELSE
							KMC_setup%print_coordH_to_xyz=.false. 
						END IF 	
				else if (( index('orbs_ZINDO',TRIM(keyword)) /= 0 ) .OR. &
						&(index('orbsZINDO',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "orbs_ZINDO"))THEN
							KMC_setup%orbs_ZINDO=.true.
						ELSE
							KMC_setup%orbs_ZINDO=.false. 
						END IF 
				else if (( index('read_lambda_files',TRIM(keyword)) /= 0 ) .OR. &
						&(index('readlambdafiles',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "read_lambda_files"))THEN
							KMC_setup%orbs_ZINDO=.true.
						ELSE
							KMC_setup%orbs_ZINDO=.false. 
						END IF 
				else if (( index('add_virtual_H_atoms_to_gro',TRIM(keyword)) /= 0 ) .OR. &
						&(index('addvirtualHatomstogro',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "add_virtual_H_atoms_to_gro"))THEN
							KMC_setup%add_virtual_H_atoms_to_gro=.true.
						ELSE
							KMC_setup%add_virtual_H_atoms_to_gro=.false. 
						END IF 
				else if (( index('create_geo_orbs_mps_g09',TRIM(keyword)) /= 0 ) .OR. &
						&(index('creategeoorbsmpsg09',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "create_geo_orbs_mps_g09"))THEN
							KMC_setup%create_geo_orbs_mps_g09=.true.
						ELSE
							KMC_setup%create_geo_orbs_mps_g09=.false. 
						END IF 		
				else if (( index('create_geo_orbs_mps_g09',TRIM(keyword)) /= 0 ) .OR. &
						&(index('creategeoorbsmpsg09',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "create_geo_orbs_mps_g09"))THEN
							KMC_setup%create_geo_orbs_mps_g09=.true.
						ELSE
							KMC_setup%create_geo_orbs_mps_g09=.false. 
						END IF 	
				else if (( index('extra_files_modus',TRIM(keyword)) /= 0 ) .OR. &
						&(index('creategeoorbsmpsg09',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "0") .OR. (TRIM(value) == "false") .OR. (TRIM(value) == "extra_files_modus"))THEN
							KMC_setup%extra_files_modus="false"
						ELSE IF ((TRIM(value) == "all") .or. (TRIM(value) == "true") .or. (TRIM(value) == "1"))THEN 
							KMC_setup%extra_files_modus="all"
						ELSE IF (TRIM(value) == "make_g09_for_mps")  THEN 
							KMC_setup%extra_files_modus="make_g09_for_mps"
						ELSE IF (TRIM(value) == "make_ZINDO")  THEN 
							KMC_setup%extra_files_modus="make_ZINDO"
						ELSE IF (TRIM(value) == "make_xyz")  THEN 
							KMC_setup%extra_files_modus="make_xyz"
						ELSE IF (TRIM(value) == "make_folders")  THEN 
							KMC_setup%extra_files_modus="make_folders"	
						ELSE
							WRITE(*,*) 'Error: The extra_files_modus is not available!'
							WRITE(*,*) 'Select one of the following modi.'
							WRITE(*,*) 'extra_files_modus = [false, all, make_g09_for_mps, make_ZINDO, make_xyz, make_folders]'
							WRITE(*,*) 'The modus is applied in subroutine "make_geo_orbs_mps_g09"  '        
							WRITE(*,*) ' make_g09_for_mps: creates g09 inputfiles for the geometries to evaluate with data '& 
										&//'for *.mps files '
							WRITE(*,*) ' make_ZINDO: creates g09 input files for the ZINDO calculations, which are needed for *.orbs '
							WRITE(*,*) ' make_xyz: creates name1_n.xyz for the QC_FILE folder as needed for VOTCA calculations. '
							WRITE(*,*) ' make_folders: creates folders QC_FILES and MP_FILES'
							CALL EXIT(1)
						ENDIF
				else if (( index('votca_sql_name',TRIM(keyword)) /= 0 ) .OR. &
						&(index('votcasqlname',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%votca_sql_name=TRIM(ADJUSTL(value))
				else if (( index('mps_tab_filename',TRIM(keyword)) /= 0 ) .OR. &
						&(index('mpstabfilename',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%mps_tab_filename=TRIM(ADJUSTL(value))
				else if (( index('use_votca_global_file_folder',TRIM(keyword)) /= 0 ) .OR. &
						&(index('usevotcaglobalfilefolder',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "use_votca_global_file_folder"))THEN
							KMC_setup%use_votca_global_file_folder=.true.
						ELSE
							KMC_setup%use_votca_global_file_folder=.false. 
						END IF 	
				else if (( index('MP_FILES_folder',TRIM(keyword)) /= 0 ) .OR. &
						&(index('MP_FILES',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%MP_FILES_folder=TRIM(ADJUSTL(value))
							!! default: MP_FILES_folder=MP_FILES  
				else if (( index('QC_FILES_folder',TRIM(keyword)) /= 0 ) .OR. &
						&(index('QC_FILES',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%QC_FILES_folder=TRIM(ADJUSTL(value))  
							!! default: QC_FILES_folder=QC_FILES  
				else if ( (index('use_min_d_COM_vector_list',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('usemindCOMvectorlist',TRIM(keyword)) /= 0 )  .OR. &
						& (index('usemindcomvectorlist',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "use_min_d_COM_vector_list") )THEN
							KMC_setup%use_min_d_COM_vector_list=.true.
						ELSE
							KMC_setup%use_min_d_COM_vector_list=.false. 
						END IF 	
				else if ( (index('min_d_modus',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('mindmodus',TRIM(keyword)) /= 0 )   .OR. &
						& (index('min_d_modus',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%min_d_modus=trim(value)
				endif !! END SECTION  enumerated_gro_to_VOTCA_DIPBI_P3HT_prepare 
				
				
			!!!!-----------------------------------------------------!!!!
			!!!!    READ KMC MULTIPLE options.xml                    !!!!
			!!!!-----------------------------------------------------!!!!
			ELSE IF( TRIM(section) == 'kmcmultiple') THEN
				if ( index('runtime',TRIM(keyword)) /= 0 ) THEN 
						READ (value, '(F16.12)',IOSTAT=ierror) real_number
						KMC_setup%runtime=REAL(real_number,8)
						KMC_setup%maxsteps=INT(real_number,8)
				else if ( index('outputtime',TRIM(keyword)) /= 0 ) THEN 
						write(*,*) 'Warning ignore: ',TRIM(keyword),"  ",TRIM(value)  
				else if ( index('trajectoryfile',TRIM(keyword)) /= 0 ) then
						IF( index(value((LEN_TRIM('.csv')):),'.csv') /= 0 ) THEN
							KMC_setup%trajectoryfilename=TRIM(ADJUSTL(value))
							KMC_setup%xyz_trajectoryfilename=TRIM(value(:LEN_TRIM(value)-4))//'.xyz'
						ELSE IF( index(value((LEN_TRIM('.xyz')):),'.xyz') /= 0 ) THEN
							KMC_setup%trajectoryfilename=TRIM(value(:LEN_TRIM(value)-4))//'.csv'
							KMC_setup%xyz_trajectoryfilename=TRIM(value(:LEN_TRIM(value)-4))//'.xyz'
						END IF !!! *.csv or *xyz
				else if ( index('seed',TRIM(keyword)) /= 0 ) then 
							IF( (TRIM(value) == "0") .OR. (TRIM(value) == "123") .OR. (TRIM(value) == "*") )THEN
								KMC_setup%set_seed=0
							ELSE   !! Set seed to integer
								READ (value, '(I12)',IOSTAT=ierror) i_value
								KMC_setup%set_seed=i_value 
							ENDIF
				else if ( index('injectionmethod',TRIM(keyword)) /= 0 ) then 
							!!! injectionmethod='random'  , 
							!!! injectionmethod="injection_node"   ; selects a single node for charge injection, set :injection_node as node_id or Resid"
							!!! injectionmethod="injection_node_list" 
							IF (TRIM(value) == "random") THEN
								KMC_setup%injectionmethod='random' 
							ELSE IF( (TRIM(value) == "injectionnode") .OR. (TRIM(value) == "injection_node")) THEN
								KMC_setup%injectionmethod="injection_node"
							ELSE IF( (TRIM(value) == "injection_node_list") .OR. (TRIM(value) == "injectionnodelist") )THEN
								KMC_setup%injectionmethod="injection_node_list" 
							ELSE IF( (TRIM(value) == "injection_segment_type") .OR. (TRIM(value) == "injectionsegmenttype") .OR. &
								&    (TRIM(value) == "segmenttype")  .OR. (TRIM(value) == "segment") .OR. (TRIM(value) == "name") )THEN
								KMC_setup%injectionmethod="injection_segment_type" 
							ENDIF
				else if ( (index('injection_segment_type',TRIM(keyword)) /= 0) .OR. & 
						& (index('injectionsegmenttype',TRIM(keyword)) /= 0) )then 
							!!! injectionmethod='random'  , 
							!!! injectionmethod="injection_node"   ; selects a single node for charge injection, set :injection_node as node_id or Resid"
							!!! injectionmethod="injection_node_list" 
							IF (TRIM(value) == "random") THEN
								KMC_setup%injectionmethod='random' 
								KMC_setup%injection_segment_type=''
							ELSE IF ( .not. is_numeric(TRIM(value))) THEN
								KMC_setup%injection_segment_type=TRIM(value)
							ENDIF
				else if ( index('injection',TRIM(keyword)) /= 0 ) then 
							IF((TRIM(value) /= "*") )THEN
								WRITE(*,*) 'Select single injection node: ',TRIM(value)
								READ (value, '(I12)',IOSTAT=ierror) i_value 
								KMC_setup%injection_node=i_value 
							ENDIF
				else if ( index('numberofcharges',TRIM(keyword)) /= 0 ) then 
							READ (value, '(I12)',IOSTAT=ierror) i_value
							KMC_setup%numberofcharges=i_value
				else if ( index('fieldX',TRIM(keyword)) /= 0 ) then 
							real_number=str2real8(value)
							KMC_setup%fieldX=real_number
				else if ( index('fieldY',TRIM(keyword)) /= 0 ) THEN 
							real_number=str2real8(value)
							KMC_setup%fieldY=real_number
				else if ( index('fieldZ',TRIM(keyword)) /= 0 ) then 
							real_number=str2real8(value)
							KMC_setup%fieldZ=real_number
				else if ( index('carriertype',TRIM(keyword)) /= 0 ) then 
							!! carriertype=[h,e]    holes or electrons
							IF( (TRIM(value) == "h") .OR. (TRIM(value) == "hole") .OR. (TRIM(value) == "lo") )THEN
								KMC_setup%carriertype='h'
							ELSE IF( (TRIM(value) == "e") .OR. (TRIM(value) == "electron") .OR. (TRIM(value) == "el") )THEN
								KMC_setup%carriertype='e'
							END IF
							
				else if ( index('temperature',TRIM(keyword)) /= 0 ) then 
							Write(*,*) 'temperature: ',TRIM(value)
							KMC_setup%temperature=str2real8(value)
				else if ( index('explicitcoulomb',TRIM(keyword)) /= 0 ) then 
							IF( (TRIM(value) == "1"))THEN
								Write(*,*) 'Warning. explicitcoulomb is not implemented.'
							END IF
							
				else if ( index('rates',TRIM(keyword)) /= 0 ) then 
								write(*,*) 'Ignore:',TRIM(keyword),' ',TRIM(value)
				!!  Extra keywords not used in VOTCA but in kmc_fortran
				else if ( index('calc_VOTCA_style',TRIM(keyword)) /= 0 ) then 
							write(*,*) 'Found:',TRIM(keyword),' ',TRIM(value)
							IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "calc_VOTCA_style"))THEN
								KMC_setup%calc_VOTCA_style=.true.
							ELSE
								KMC_setup%calc_VOTCA_style=.false.
							END IF
							
				else if ( index('stopcondition',TRIM(keyword)) /= 0 ) then 
							IF( (TRIM(value) == "steps") ) THEN
								KMC_setup%stopcondition="steps"
							ELSE IF (TRIM(value) == "runtime") THEN
								KMC_setup%stopcondition="runtime"
							END IF
							
				else if ( index('outputtime',TRIM(keyword)) /= 0 ) then 
						KMC_setup%outputtime=str2real8(value)
				else if ( index('nexttrajoutput',TRIM(keyword)) /= 0 ) then 
						KMC_setup%nexttrajoutput=str2real8(value)
				else if ( (index('store_trajectory',TRIM(keyword)) /= 0) .OR. (index('storetrajectory',TRIM(keyword)) /= 0) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "store_trajectory"))THEN
							KMC_setup%store_trajectory=.true.
						ELSE
							KMC_setup%store_trajectory=.false.
						END IF
						
				else if ( index('debug',TRIM(keyword)) /= 0 ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "debug"))THEN
							KMC_setup%debug=.true.
						ELSE
							KMC_setup%debug=.false.
						END IF
				else if ( index('printtrajcsv',TRIM(keyword)) /= 0 ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "printtrajcsv"))THEN
							KMC_setup%printtrajcsv=.true.
						ELSE
							KMC_setup%printtrajcsv=.false.
						END IF
						
						
				else if (( index('makeEscapeRateFile',TRIM(keyword)) /= 0 )  .OR. & !! Escape rate data 
						& (index('makeescaperatefile',TRIM(keyword)) /= 0 )) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "makeescaperatefile"))THEN
							KMC_setup%makeEscapeRateFile=.true.
						ELSE
							KMC_setup%makeEscapeRateFile=.false.
						END IF
				else if (( index('EscapeRateFile',TRIM(keyword)) /= 0 )  .OR. & !! Escape rate data 
						& (index('escaperatefile',TRIM(keyword)) /= 0 )) then 
							KMC_setup%EscapeRateFile=TRIM(ADJUSTL(value))
							
				else if (( index('checkhoppingpaircomposition',TRIM(keyword)) /= 0 )  .OR. & !! Escape rate data 
						& (index('check_hopping_pair_composition',TRIM(keyword)) /= 0 )) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "check_hopping_pair_composition"))THEN
							KMC_setup%check_hopping_pair_composition=.true.
						ELSE
							KMC_setup%check_hopping_pair_composition=.false.
						END IF
				else if (( index('kmcmetadynamics',TRIM(keyword)) /= 0 )  .OR. & !! Escape rate data 
						& (index('kmc_meta_dynamics',TRIM(keyword)) /= 0 )) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "kmcmetadynamics"))THEN
							KMC_setup%kmcmetadynamics=.true.
						ELSE
							KMC_setup%kmcmetadynamics=.false.
						END IF
							
				else if (( index('alpha',TRIM(keyword)) /= 0 ) .OR. ( index('kmcmetadynamicsalpha',TRIM(keyword)) /= 0 )) then 
						real_number=str2real8(value)
						KMC_setup%kmcmetadynamics_alpha=real_number
						
						
						
				else if (( index('unitenotesforkmc',TRIM(keyword)) /= 0 )  .OR. & !! unite_notes_for_kmc: make two nodes to one, if the rates are dominant and back and forth rates are high.
						& (index('unite_notes_for_kmc',TRIM(keyword)) /= 0 )) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "unitenotesforkmc"))THEN
							KMC_setup%unite_notes_for_kmc=.true.
						ELSE
							KMC_setup%unite_notes_for_kmc=.false.
						END IF
				else if (( index('unitenodeswithsametype',TRIM(keyword)) /= 0 )  .OR. & !! Two nodes N1 and N2 can only be united if they posses the same type.  default: unite_nodes_with_same_type=.true.
						& (index('unite_nodes_with_same_type',TRIM(keyword)) /= 0 )) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "unite_nodes_with_same_type"))THEN
							KMC_setup%unite_nodes_with_same_type=.true.
						ELSE
							KMC_setup%unite_nodes_with_same_type=.false.
						END IF
							
						
				else if (( index('cutoffk1_k2',TRIM(keyword)) /= 0 ) .OR. ( index('cutoffk1k2',TRIM(keyword)) /= 0 )) then 
						real_number=str2real8(value)
						KMC_setup%cutoffk1k2=real_number !! cutoff for the rates to unite two nodes to a single node. k1/k2 > cutoffk1k2
							
				!! START READ  SETUP FOR KMC PATHWAY FINDER 
				!! Switch to calculat a check_hopping_pair_compositionpathway with high current inside the morphology default: calc_pathway=.false.
				else if (( index('calc_pathway',TRIM(keyword)) /= 0 )  .OR. & !! Wrap molecules in *.gro back into the box using periodic boundary conditions.
						& (index('calculate_highest_current_pathway',TRIM(keyword)) /= 0 )) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "calc_pathway"))THEN
							KMC_setup%calc_pathway=.true.
						ELSE
							KMC_setup%calc_pathway=.false. 
						END IF 
						
				else if (( index('reset_pathway_at_initial_site',TRIM(keyword)) /= 0 )  .OR. & 
						& (index('reset_pathway',TRIM(keyword)) /= 0 )) then 
						!! for pathfinder settings: When evaluating the charge carrier trajectory on can reset the system, if a charge comes back to the origin before crossing the box in the desired direction, default: reset_pathway_at_initial_site=.false.
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "reset_pathway"))THEN
							KMC_setup%reset_pathway_at_initial_site=.true.
						ELSE
							KMC_setup%reset_pathway_at_initial_site=.false. 
						END IF 
				else if (( index('N_testpathways',TRIM(keyword)) /= 0 )  .OR. ( index('numberofpathways',TRIM(keyword)) /= 0 )  .OR. &
						& (index('Number_of_calculated_pathways',TRIM(keyword)) /= 0 )) then 
						READ (value, '(I12)',IOSTAT=ierror) i_value
						KMC_setup%N_testpathways=i_value
						
				!! Gromacs inputfile with coordinates. (not used in KMC)
				else if (( index('gro_inputfile',TRIM(keyword)) /= 0 )  .OR. & !! gromacs morphology file
						& (index('gro',TRIM(keyword)) /= 0 )) then 
						IF(file_exists(value)) THEN
							KMC_setup%gro_inputfile=TRIM(ADJUSTL(value))
							KMC_setup%read_reference_grofile=.true. 
						ELSE
							KMC_setup%read_reference_grofile=.false. 
						END IF
				else if (( index('wrap_all_molecules_into_the_box',TRIM(keyword)) /= 0 )  .OR. & !! Wrap molecules in *.gro back into the box using periodic boundary conditions.
						& (index('wrap_pbc',TRIM(keyword)) /= 0 )) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "wrap_pbc"))THEN
							KMC_setup%wrap_all_molecules_into_the_box=.true.
						ELSE
							KMC_setup%wrap_all_molecules_into_the_box=.false. 
						END IF 
						
				else if (( index('cut_side_chains_in_gro',TRIM(keyword)) /= 0 )  .OR. & !! Cut the side chains e.g. from DIPBI and P3HT.
						& (index('cutsidechainsingro',TRIM(keyword)) /= 0 )) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "cut_side_chains_in_gro"))THEN
							KMC_setup%cut_side_chains_in_gro=.true.
						ELSE
							KMC_setup%cut_side_chains_in_gro=.false. 
						END IF 
				else if (( index('unite_PBC_split_molecule',TRIM(keyword)) /= 0 )  .OR. & !!!-- unites all molecules if it is unwraped with PBC in the *.gro file
						& (index('unitePBCsplitmolecule',TRIM(keyword)) /= 0 )) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "unitePBCsplitmolecule"))THEN
							KMC_setup%unite_PBC_split_molecule=.true.
						ELSE
							KMC_setup%unite_PBC_split_molecule=.false. 
						END IF 

						
				else if (( index('dump_grofile_dI_travelled_max',TRIM(keyword)) /= 0 )  .OR. & !! Write out a gromacs *.gro file for the molecules on the pathway with the highest current
						& (index('dump_gro_dI_max',TRIM(keyword)) /= 0 )) then 
						!! Write out all molecules in the gro format, which were visited in the KMC run.
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "dump_gro_dI_max"))THEN
							KMC_setup%dump_grofile_dI_travelled_max=.true.
						ELSE
							KMC_setup%dump_grofile_dI_travelled_max=.false. 
						END IF 
						
				else if (( index('setratestocurrent',TRIM(keyword)) /= 0 )  .OR. & 						
						& (index('set_rates_to_current',TRIM(keyword)) /= 0 )) then 
						!! Replace the rates by the resulting current and do kmc on the current network. (not recommended) setup%set_rates_to_current default: set_rates_to_current=.false.
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "set_rates_to_current"))THEN
							KMC_setup%set_rates_to_current=.true.
						ELSE
							KMC_setup%set_rates_to_current=.false. 
						END IF 
				else if (( index('votca_sql_name',TRIM(keyword)) /= 0 ) .OR. &
						&(index('votcasqlname',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%votca_sql_name=TRIM(ADJUSTL(value))
				else 
					cycle
				endif !!! END READ  SETUP FOR KMC PATHWAY FINDER 
				!!!! END  section = kmcmultiple
				!!!!-----------------------------------------------------------------------------------------------------------------!!!!
				
			!!!!---------------------------------------------------------------------------!!!!
			!!!!       Read  Dijkstra / dijkstra  options from options.xml                 !!!!
			!!!!---------------------------------------------------------------------------!!!!
			ELSE IF( TRIM(section) == 'dijkstra' .or.  TRIM(section) == 'Dijkstra' ) THEN
				if (( index('calc_pathway_Dijkstra',TRIM(keyword)) /= 0 )  .OR. & 						
						& (index('calcpathwayDijkstra',TRIM(keyword)) /= 0 )) then 
						!! !! calc_pathway_Dijkstra    default::calc_pathway_Dijkstra=.false.
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "calc_pathway_Dijkstra"))THEN
							KMC_setup%calc_pathway_Dijkstra=.true.
						ELSE
							KMC_setup%calc_pathway_Dijkstra=.false. 
						END IF 
				else if (( index('modus_Dijkstra',TRIM(keyword)) /= 0 ) .OR. (index('Dijkstra',TRIM(keyword)) /= 0 ) ) then
						
						IF( (TRIM(value) == "0") .OR. (TRIM(value) == "false")  .OR. (TRIM(value) == "'false'") ) then
							KMC_setup%calc_pathway_Dijkstra=.false.
							write(*,*) 'Warning:  No modus_Dijkstra selected.  Turn calc_pathway_Dijkstra: ',KMC_setup%calc_pathway_Dijkstra
						ELSE IF( (TRIM(value) == "Dijkstra_kmcNetwork") .OR. (TRIM(value) == "DijkstrakmcNetwork") )THEN
							KMC_setup%modus_Dijkstra='Dijkstra_kmcNetwork'
							KMC_setup%calc_pathway_Dijkstra=.true.
						ELSE IF ( (TRIM(value) == "Dijkstra_newNetwork") .OR. (TRIM(value) == "DijkstranewNetwork") )THEN
							KMC_setup%modus_Dijkstra='Dijkstra_newNetwork'
							KMC_setup%calc_pathway_Dijkstra=.true.
						ELSE IF ( (TRIM(value) == "Dijkstra_loadNetwork") .OR. (TRIM(value) == "DijkstraloadNetwork") )THEN
							KMC_setup%modus_Dijkstra='Dijkstra_loadNetwork'
							KMC_setup%calc_pathway_Dijkstra=.true.
						ELSE
							KMC_setup%calc_pathway_Dijkstra=.false.
						END IF
				else if (( index('start_Dijkstra',TRIM(keyword)) /= 0 ) .OR. (index('startDijkstra',TRIM(keyword)) /= 0 ) ) then
						READ (value, '(I12)',IOSTAT=ierror) i_value
						KMC_setup%start_Dijkstra=i_value
				else if (( index('ziel_Dijkstra',TRIM(keyword)) /= 0 ) .OR. (index('zielDijkstra',TRIM(keyword)) /= 0 ) ) then
						READ (value, '(I12)',IOSTAT=ierror) i_value
						KMC_setup%ziel_Dijkstra=i_value
				else if (( index('calc_pathway_between_zones',TRIM(keyword)) /= 0 ) .OR. &
						&(index('calcpathwaybetweenzones',TRIM(keyword)) /= 0 ) ) then
						!! Define a zone for inital points and and dublicate it for a second final zone for the target of a box transversing pathway in PBC
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "calc_pathway_between_zones"))THEN
							KMC_setup%calc_pathway_between_zones=.true.
						ELSE
							KMC_setup%calc_pathway_between_zones=.false. 
						END IF 
				else if (( index('loop_start_zone',TRIM(keyword)) /= 0 ) .OR. &
						&(index('loopstartzone',TRIM(keyword)) /= 0 ) ) then
						!!-- Loop for all initial nodes in the start zone default: loopstartzone=0 -->
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "loopstartzone"))THEN
							KMC_setup%loopstartzone=.true.
						ELSE
							KMC_setup%loopstartzone=.false. 
						END IF 
						
						
				else if (( index('write_Networkfile_Dijkstra',TRIM(keyword)) /= 0 )  .OR. & 						
						& (index('writenetworkfiledijkstra',TRIM(keyword)) /= 0 )) then 
						!! Dijkstra network file store the Dijkstra network. [default: write_Networkfile_Dijkstra =.false.]
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "write_Networkfile_Dijkstra"))THEN
							KMC_setup%write_Networkfile_Dijkstra=.true.
						ELSE
							KMC_setup%write_Networkfile_Dijkstra=.false. 
						END IF 
				else if (( index('networkfile_Dijkstra',TRIM(keyword)) /= 0 )  .OR. & !! gromacs morphology file
						& (index('networkfileDijkstra',TRIM(keyword)) /= 0 )) then 
						KMC_setup%networkfile_Dijkstra=TRIM(ADJUSTL(value))
				else if (( index('zonenbreite',TRIM(keyword)) /= 0 ) .OR. (index('zone',TRIM(keyword)) /= 0 ) ) then
						real_number=str2real8(value)
						KMC_setup%zonenbreite=real_number
				else if (( index('Log10Abs',TRIM(keyword)) /= 0 )  .OR.  ( index('Log10AbsR',TRIM(keyword)) /= 0 )  .OR. & 						
						& (index('log10abs',TRIM(keyword)) /= 0 )  .OR.  ( index('log10abs_R',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "log10abs"))THEN
							KMC_setup%log10abs=.true.
						ELSE
							KMC_setup%log10abs=.false. 
						END IF 
				else if ( index('carriertype',TRIM(keyword)) /= 0 ) then 
							!! carriertype=[h,e]    holes or electrons
							IF( (TRIM(value) == "h") .OR. (TRIM(value) == "hole") .OR. (TRIM(value) == "lo") )THEN
								KMC_setup%carriertype='h'
							ELSE IF( (TRIM(value) == "e") .OR. (TRIM(value) == "electron") .OR. (TRIM(value) == "el") )THEN
								KMC_setup%carriertype='e'
							END IF


				else
					cycle ! dijkstra 
				end if
				!!! END  = dijkstra
				!!!!----------------------------------------------------------------------!!!!
						
			ELSE IF ((TRIM(section) == 'calc_current_I') .OR. (TRIM(section) == 'calccurrentI') ) THEN
				!!!!----------------------------------------------------------------------------!!!!
				!!!!   variables for calc_current_I  from                 options.xml           !!!!
				!!!!----------------------------------------------------------------------------!!!!
				
				if ( index('carriertype',TRIM(keyword)) /= 0 ) then 
							!! carriertype=[h,e]    holes or electrons
							IF( (TRIM(value) == "h") .OR. (TRIM(value) == "hole") .OR. (TRIM(value) == "lo") )THEN
								KMC_setup%carriertype='h'
							ELSE IF( (TRIM(value) == "e") .OR. (TRIM(value) == "electron") .OR. (TRIM(value) == "el") )THEN
								KMC_setup%carriertype='e'
							END IF
				else if (( index('scale_to_interval_0_1',TRIM(keyword)) /= 0 ) .OR. &
						&(index('scaletointerval',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
							& (TRIM(value) == "scale_to_interval_0_1"))THEN
							KMC_setup%scale_to_interval_0_1=.true.
						ELSE
							KMC_setup%scale_to_interval_0_1=.false. 
						END IF 	
				else if (( index('make_current_to_cubefile',TRIM(keyword)) /= 0 ) .OR. &
						&(index('makecurrenttocubefile',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
							& (TRIM(value) == "make_current_to_cubefile"))THEN
							KMC_setup%make_current_to_cubefile=.true.
						ELSE
							KMC_setup%make_current_to_cubefile=.false. 
						END IF 	
				else if (( index('use_logscale_I',TRIM(keyword)) /= 0 ) .OR. &
						&(index('uselogscaleI',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
							& (TRIM(value) == "use_logscale_I"))THEN
							KMC_setup%use_logscale_I=.true.
						ELSE
							KMC_setup%use_logscale_I=.false. 
						END IF 	
				else if (( index('use_logscale_p_occ',TRIM(keyword)) /= 0 ) .OR. &
						&(index('uselogscalepocc',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
							& (TRIM(value) == "use_logscale_p_occ"))THEN
							KMC_setup%use_logscale_p_occ=.true.
						ELSE
							KMC_setup%use_logscale_p_occ=.false. 
						END IF 	
				else if (( index('make_scale_p_occ_pdb',TRIM(keyword)) /= 0 ) .OR. &
						&(index('makescalep_occpdb',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
							& (TRIM(value) == "make_scale_p_occ_pdb"))THEN
							KMC_setup%make_scale_p_occ_pdb=.true.
						ELSE
							KMC_setup%make_scale_p_occ_pdb=.false. 
						END IF 	
				else if (( index('make_scale_I_pdb',TRIM(keyword)) /= 0 ) .OR. &
						&(index('makescaleIpdb',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
							& (TRIM(value) == "make_scale_I_pdb"))THEN
							KMC_setup%make_scale_I_pdb=.true.
						ELSE
							KMC_setup%make_scale_I_pdb=.false. 
						END IF 	
				else if (( index('N_occ_scale_points',TRIM(keyword)) /= 0 ) .OR. &
						&(index('Noccscalepoints',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%N_occ_scale_points=str2int(value)
				else if (( index('N_I_scale_points',TRIM(keyword)) /= 0 ) .OR. &
						&(index('NIscalepoints',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%N_I_scale_points=str2int(value)
				else if (( index('current_only_use_sites_with_highest_contributions',TRIM(keyword)) /= 0 ) .OR. &
						&(index('currentonlyusesiteswithhighestcontributions',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
							& (TRIM(value) == "current_only_use_sites_with_highest_contributions"))THEN
							KMC_setup%current_only_use_sites_with_highest_contributions=.true.
						ELSE
							KMC_setup%current_only_use_sites_with_highest_contributions=.false. 
						END IF 	
				else if (( index('occupations_only_use_sites_with_highest_contributions',TRIM(keyword)) /= 0 ) .OR. &
						&(index('occupationsonlyusesiteswithhighestcontributions',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
							& (TRIM(value) == "occupations_only_use_sites_with_highest_contributions"))THEN
							KMC_setup%occupations_only_use_sites_with_highest_contributions=.true.
						ELSE
							KMC_setup%occupations_only_use_sites_with_highest_contributions=.false. 
						END IF 	
				else if (( index('calc_high_current_pathway',TRIM(keyword)) /= 0 ) .OR. &
						&(index('calchighcurrentpathway',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
							& (TRIM(value) == "calc_high_current_pathway"))THEN
							KMC_setup%calc_high_current_pathway=.true.
						ELSE
							KMC_setup%calc_high_current_pathway=.false. 
						END IF 	
				else if (( index('read_reference_grofile',TRIM(keyword)) /= 0 ) .OR. &
						&(index('readreferencegrofile',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
							& (TRIM(value) == "read_reference_grofile"))THEN
							KMC_setup%read_reference_grofile=.true.
						ELSE
							KMC_setup%read_reference_grofile=.false. 
						END IF 	
				else if (( index('wrap_all_molecules_into_the_box',TRIM(keyword)) /= 0 ) .OR. &
						&(index('wrapallmoleculesintothebox',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
							& (TRIM(value) == "wrap_all_molecules_into_the_box"))THEN
							KMC_setup%wrap_all_molecules_into_the_box=.true.
						ELSE
							KMC_setup%wrap_all_molecules_into_the_box=.false. 
						END IF 	
						
				else if (( index('scale_J_vmd_factor',TRIM(keyword)) /= 0 ) .OR. &
						&(index('scaleJvmdfactor',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%scale_J_vmd_factor=str2real(value)
				else if (( index('J_max_percent_cutoff',TRIM(keyword)) /= 0 ) .OR. &
						&(index('J_max_percent_cutoff',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%J_max_percent_cutoff=str2real(value)
				else if (( index('p_occ_max_percent_cutoff',TRIM(keyword)) /= 0 ) .OR. &
						&(index('poccmaxpercentcutoff',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%p_occ_max_percent_cutoff=str2real(value)
				else if (( index('scalebox',TRIM(keyword)) /= 0 ) .OR. &
						&(index('scalebox',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%scalebox=str2real(value)
				else if (( index('calc_local_current_dr',TRIM(keyword)) /= 0 ) .OR. &
						&(index('calclocalcurrentdr',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
							& (TRIM(value) == "calc_local_current_dr"))THEN
							KMC_setup%calc_local_current_dr=.true.
						ELSE
							KMC_setup%calc_local_current_dr=.false. 
						END IF 	
							
				else if (( index('set_filenames',TRIM(keyword)) /= 0 ) .OR. &
						&(index('setfilenames',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
							& (TRIM(value) == "set_filenames"))THEN
							KMC_setup%set_filenames=.true.
						ELSE
							KMC_setup%set_filenames=.false. 
						END IF 	
				else if (( index('votca_sql_filename',TRIM(keyword)) /= 0 ) .OR. &
						& (index('votcasqlfilename',TRIM(keyword)) /= 0 ) .OR. &
						& (index('votca_sql_name',TRIM(keyword)) /= 0 ) .OR. &
						& (index('votcasqlname',TRIM(keyword)) /= 0 ) ) then    
							KMC_setup%votca_sql_name=trim(value)
							write(*,*) 'tmp sql: ',trim(value)
				else if (( index('gro_inputfile',TRIM(keyword)) /= 0 ) .OR. &
						&(index('groinputfile',TRIM(keyword)) /= 0 ) ) then     
							KMC_setup%gro_inputfile=trim(value)
				else if (( index('current_I_out_filename',TRIM(keyword)) /= 0 ) .OR. &
						&(index('currentIoutfilename',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%current_I_out_filename=trim(value)
				else if (( index('tot_occ_filename',TRIM(keyword)) /= 0 ) .OR. &
						&(index('totoccfilename',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%tot_occ_filename=trim(value)
				else if (( index('marcus_rate_filename',TRIM(keyword)) /= 0 ) .OR. &
						&(index('marcusratefilename',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%marcus_rate_filename=trim(value)
				else if (( index('no_box_COM_file',TRIM(keyword)) /= 0 ) .OR. &
						&(index('noboxCOMfile',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%no_box_COM_file=trim(value)
				end if !!! calc_current_I
				!!!!----------------------------------------------------------------------------!!!!
				!!!!   End variables for calc_current_I  from             options.xml           !!!!
				!!!!----------------------------------------------------------------------------!!!!
						
			ELSE IF ((TRIM(section) == 'rates_to_votca_sqlfile') .OR. (TRIM(section) == 'rates_to_votca_sql_file')  .OR. &
			&   (TRIM(section) == 'ratestovotcasqlfile') .OR. (TRIM(section) == 'rates_to_VOTCA_sqlfile')) THEN
				!!!!----------------------------------------------------------------------!!!!
				!!!!    READ  READ rates_to_votca_sql_file          options.xml           !!!!
				!!!!----------------------------------------------------------------------!!!!
				if (( index('DIPBI_P3HT_calc',TRIM(keyword)) /= 0 ) .OR. &
						&(index('DIPBIP3HTcalc',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "DIPBIP3HTcalc"))THEN
							KMC_setup%DIPBI_P3HT_calc=.true.
						ELSE
							KMC_setup%DIPBI_P3HT_calc=.false. 
						END IF 
				else if (( index('DIPBI_P3MT_calc',TRIM(keyword)) /= 0 ) .OR. &
						&(index('DIPBIP3MTcalc',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "DIPBI_P3MT_calc"))THEN
							KMC_setup%DIPBI_P3MT_calc=.true.
						ELSE
							KMC_setup%DIPBI_P3MT_calc=.false. 
						END IF 
				else if (( index('P3HT_pur_calc',TRIM(keyword)) /= 0 ) .OR. &
						&(index('P3HTpurcalc',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "P3HT_pur_calc"))THEN
							KMC_setup%P3HT_pur_calc=.true.
						ELSE
							KMC_setup%P3HT_pur_calc=.false. 
						END IF 
				else if (( index('P3MT_pur_calc',TRIM(keyword)) /= 0 ) .OR. &
						&(index('P3MTpurcalc',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "P3MT_pur_calc"))THEN
							KMC_setup%P3MT_pur_calc=.true.
						ELSE
							KMC_setup%P3MT_pur_calc=.false. 
						END IF 
				else if (( index('PPDI_PBDT_TS1_calc',TRIM(keyword)) /= 0 ) .OR. &
						&(index('PPDIPBDTTS1calc',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "PPDI_PBDT_TS1_calc"))THEN
							KMC_setup%PPDI_PBDT_TS1_calc=.true.
						ELSE
							KMC_setup%PPDI_PBDT_TS1_calc=.false. 
						END IF 
						
				else if (( index('N_Neighbours',TRIM(keyword)) /= 0 ) .OR. &
						&(index('NNeighbours',TRIM(keyword)) /= 0 ) ) then                                                   
						WRITE(*,*) 'Select number of neighbours  N_Neighbours: ',TRIM(value)
						READ (value, '(I12)',IOSTAT=ierror) i_value 
						KMC_setup%N_Neighbours=i_value 
				else if (( index('multigeo_setup',TRIM(keyword)) /= 0 ) .OR. &
						& (index('multigeosetup',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "multigeo_setup"))THEN
							KMC_setup%multigeo_setup=.true.
						ELSE
							KMC_setup%multigeo_setup=.false. 
						END IF 
				else if (( index('Geo_Step',TRIM(keyword)) /= 0 ) .OR. &
						& (index('GeoStep',TRIM(keyword)) /= 0 ) ) then                                                   
						!WRITE(*,*) 'Select  Geo_Step: ',TRIM(value)
						READ (value, '(I12)',IOSTAT=ierror) i_value 
						KMC_setup%Geo_Step=i_value 
				else if (( index('rate_type',TRIM(keyword)) /= 0 ) .OR. &
						& (index('ratetype',TRIM(keyword)) /= 0 ) ) then     
						KMC_setup%rate_type=TRIM(ADJUSTL(value))

				else if (( index('set_dE_out_and_l_out_to_zero',TRIM(keyword)) /= 0 ) .OR. &
						&(index('setdEoutandlouttozero',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value)=="1") .OR. (TRIM(value)=="true") .OR.(TRIM(value)=="set_dE_out_and_l_out_to_zero"))THEN
							KMC_setup%set_dE_out_and_l_out_to_zero=.true.
						ELSE
							KMC_setup%set_dE_out_and_l_out_to_zero=.false. 
						END IF 
				else if (( index('set_J_AB_intermolecular_to_zero',TRIM(keyword)) /= 0 ) .OR. &
						& (index('setJabintermoleculartozero',TRIM(keyword)) /= 0 ) .OR. &
						& (index('setJABintermoleculartozero',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR.(TRIM(value)=="set_J_AB_inter_zero"))THEN
							KMC_setup%set_J_AB_intermolecular_to_zero=.true.
						ELSE
							KMC_setup%set_J_AB_intermolecular_to_zero=.false. 
						END IF 
				else if (( index('Kondo',TRIM(keyword)) /= 0 ) .OR. &
						& (index('kondo',TRIM(keyword)) /= 0 ) ) then                                                   
						WRITE(*,*) 'Read Kondo: ',TRIM(value)
						KMC_setup%Kondo=str2real(value)
				else if ( index('temperature',TRIM(keyword)) /= 0 ) then 
							Write(*,*) 'temperature: ',TRIM(value)
							KMC_setup%temperature=str2real8(value)
				else if (( index('TEST_RATES',TRIM(keyword)) /= 0 ) .OR. ( index('TESTRATES',TRIM(keyword)) /= 0 ) .OR. &
						& (index('test_rates',TRIM(keyword)) /= 0 ) .or. (index('testrates',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "test_rates"))THEN
							KMC_setup%TEST_RATES=.true.
						ELSE
							KMC_setup%TEST_RATES=.false. 
						END IF 
				else if (( index('set_filenames',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('setfilenames',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "set_filenames"))THEN
							KMC_setup%set_filenames=.true.
						ELSE
							KMC_setup%set_filenames=.false. 
						END IF 
				else if (( index('l_out_filename',TRIM(keyword)) /= 0 ) .OR. &
						& (index('loutfilename',TRIM(keyword)) /= 0 ) ) then      	
						IF( (TRIM(value) /= '0') .AND. (TRIM(value) /= 'false') .AND. (TRIM(value) /= 'False')) THEN
							KMC_setup%l_out_filename=TRIM(ADJUSTL(value))
						ENDIF
				else if (( index('E_multipole_filename',TRIM(keyword)) /= 0 ) .OR. &
						& (index('Emultipolefilename',TRIM(keyword)) /= 0 ) ) then     
						IF( (TRIM(value) /= '0') .AND. (TRIM(value) /= 'false') .AND. (TRIM(value) /= 'False')) THEN
							KMC_setup%E_multipole_filename=TRIM(ADJUSTL(value))
						ENDIF
				else if (( index('J_AB_filename',TRIM(keyword)) /= 0 ) .OR. (index('Jabfilename',TRIM(keyword)) /= 0 )  .OR.  &
						& (index('JABfilename',TRIM(keyword)) /= 0 )  .OR. (index('jabfilename',TRIM(keyword)) /= 0 ) ) then      	
						IF( (TRIM(value) /= '0') .AND. (TRIM(value) /= 'false') .AND. (TRIM(value) /= 'False')) THEN
							KMC_setup%J_AB_filename=TRIM(ADJUSTL(value))
						ENDIF
				else if (( index('dE_in_el_filename',TRIM(keyword)) /= 0 ) .OR. (index('dEinelfilename',TRIM(keyword)) /= 0 )  .OR.&
						& (index('dE_in_e_filename',TRIM(keyword)) /= 0 ) .OR. (index('dE_in_el_file',TRIM(keyword)) /= 0 ) ) then      	
						IF( (TRIM(value) /= '0') .AND. (TRIM(value) /= 'false') .AND. (TRIM(value) /= 'False')) THEN
							KMC_setup%dE_in_el_filename=TRIM(ADJUSTL(value))
						ENDIF
				else if (( index('dE_in_lo_filename',TRIM(keyword)) /= 0 ) .OR. (index('dEinlofilename',TRIM(keyword)) /= 0 )  .OR.&
						& (index('dE_in_h_filename',TRIM(keyword)) /= 0 ) .OR. (index('dE_in_lo_file',TRIM(keyword)) /= 0 ) ) then      	
						IF( (TRIM(value) /= '0') .AND. (TRIM(value) /= 'false') .AND. (TRIM(value) /= 'False')) THEN
							KMC_setup%dE_in_lo_filename=TRIM(ADJUSTL(value))
						ENDIF
				else if ( (index('lambda_in_el_filename',TRIM(keyword)) /= 0 ) .OR. &
						& (index('lambdainelfilename',TRIM(keyword)) /= 0 ) .OR.&
						& (index('l_in_e_filename',TRIM(keyword)) /= 0 ).OR. &
						& (index('lambda_in_el_file',TRIM(keyword)) /= 0 ) ) then
						IF( (TRIM(value) /= '0') .AND. (TRIM(value) /= 'false') .AND. (TRIM(value) /= 'False')) THEN      	
							KMC_setup%lambda_in_el_filename=TRIM(ADJUSTL(value))
						ENDIF
				else if (( index('lambda_in_lo_filename',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('lambdainlofilename',TRIM(keyword)) /= 0 ) .OR. &
						& (index('l_in_h_filename',TRIM(keyword)) /= 0 ) .OR. &
						& (index('lambda_in_lo_file',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) /= '0') .AND. (TRIM(value) /= 'false') .AND. (TRIM(value) /= 'False')) THEN
							KMC_setup%lambda_in_lo_filename=TRIM(ADJUSTL(value))
						ENDIF
				else if (( index('set_filenames',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('setfilenames',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "set_filenames") )THEN
							KMC_setup%set_filenames=.true.
						ELSE
							KMC_setup%set_filenames=.false. 
						END IF 
				else if ( ((index('Read_J_AB_from_sql_file',TRIM(keyword)) /= 0 ) .OR. &
						& (index('ReadJabfromsqlfile',TRIM(keyword)) /= 0 )  .OR.   &
						& (index('ReadJABfromsqlfile',TRIM(keyword)) /= 0 ) ) .AND. &
						& ('Read_J_AB' /= TRIM(adjustl(keyword)) )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "Read_J_AB_from_sql_file") )THEN
							KMC_setup%Read_J_AB_from_sql_file=.true.
						ELSE
							KMC_setup%Read_J_AB_from_sql_file=.false. 
						END IF 
				else if (( index('Read_J_AB',TRIM(keyword)) /= 0 ) .OR.  (index('ReadJAB',TRIM(keyword)) /= 0 )  .OR.  &
						& (index('readjab',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "Read_J_AB") )THEN
							KMC_setup%Read_J_AB=.true.
						ELSE
							KMC_setup%Read_J_AB=.false. 
						END IF 
				else if (( index('linear_scaling_J_AB',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('linearscalingJAB',TRIM(keyword)) /= 0 )  .OR.  &
						& (index('linearscalingjab',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "linear_scaling_J_AB") )THEN
							KMC_setup%linear_scaling_J_AB=.true.
						ELSE
							KMC_setup%linear_scaling_J_AB=.false. 
						END IF 
				else if (( index('J_AB_fit_method_geometry',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('JABfitmethodgeometry',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('jabfitmethodgeometry',TRIM(keyword)) /= 0 )  ) then                                                   
						KMC_setup%J_AB_fit_method_geometry=TRIM(ADJUSTL(value))
				else if (( index('scale_dipro_results',TRIM(keyword)) /= 0 ) .OR. &
						& (index('scalediproresults',TRIM(keyword)) /= 0 ) .OR. &
						& (index('ScaleDiproResults',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "scale_dipro_results") )THEN
							KMC_setup%scale_dipro_results=.true.
						ELSE
							KMC_setup%scale_dipro_results=.false. 
						END IF 		
				else if (( index('x_scale_method',TRIM(keyword)) /= 0 ) .OR. &
						& (index('xscalemethod',TRIM(keyword)) /= 0 ) .OR. &
						& (index('XscaleMethod',TRIM(keyword)) /= 0 )  ) then                                                   
						KMC_setup%x_scale_method=TRIM(ADJUSTL(value))                  !!!  x_scale_method='PM3'
				else if (( index('y_scale_method',TRIM(keyword)) /= 0 ) .OR.  (index('yscalemethod',TRIM(keyword)) /= 0 ) .OR. &
						& (index('YscaleMethod',TRIM(keyword)) /= 0 )  ) then                                                   
						KMC_setup%y_scale_method=TRIM(ADJUSTL(value))	        !!!  y_scale_method='CDFT'			
				else if (( index('Read_COM_COM_H_MA_MMA_theta_Data_from_J_AB_file',TRIM(keyword)) /= 0 ) .OR. &
						& (index('ReadgeodatafromJabfile',TRIM(keyword)) /= 0 )  .OR.  &
						& (index('ReadCOMCOMHMAMMAthetaDatafromJABfile',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. &
						&   (TRIM(value) == "Read_COM_COM_H_MA_MMA_theta_Data_from_J_AB_file") )THEN
							KMC_setup%Read_COM_COM_H_MA_MMA_theta_Data_from_J_AB_file=.true.
						ELSE
							KMC_setup%Read_COM_COM_H_MA_MMA_theta_Data_from_J_AB_file=.false. 
						END IF 		
				else if ( (index('use_min_d_COM_vector_list',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('usemindCOMvectorlist',TRIM(keyword)) /= 0 )  .OR. &
						& (index('usemindcomvectorlist',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "use_min_d_COM_vector_list") )THEN
							KMC_setup%use_min_d_COM_vector_list=.true.
						ELSE
							KMC_setup%use_min_d_COM_vector_list=.false. 
						END IF 	
				else if ( (index('min_d_modus',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('mindmodus',TRIM(keyword)) /= 0 )   .OR. &
						& (index('min_d_modus',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%min_d_modus=trim(value)
							
				else if (( index('printdatacollectionfiles',TRIM(keyword)) /= 0 ) .OR. &
						& (index('print_data_collection_files',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('print_data_collection_files',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "print_data_collection_files") )THEN
							KMC_setup%print_data_collection_files=.true.
						ELSE
							KMC_setup%print_data_collection_files=.false. 
						END IF 	
				else if (( index('mobility_estimate',TRIM(keyword)) /= 0 ) .OR.  (index('mobility_estimate',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('mobilityestimate',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "mobility_estimate") )THEN
							KMC_setup%mobility_estimate=.true.
						ELSE
							KMC_setup%mobility_estimate=.false. 
						END IF 
				else if (( index('make_Histogramm',TRIM(keyword)) /= 0 )     .OR.  (index('makehistogramm',TRIM(keyword)) /= 0 )  .OR.  &
						& (index('makeHistogramm',TRIM(keyword)) /= 0 )  .OR.  (index('make_histogramm',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "make_Histogramm") )THEN
							KMC_setup%make_Histogramm=.true.
						ELSE
							KMC_setup%make_Histogramm=.false. 
						END IF 
				else if (( index('read_intramolecular_data',TRIM(keyword)) /= 0 ) .OR. &
						& (index('readintramoleculardata',TRIM(keyword)) /= 0 )   .OR. &
						& (index('read_intramolecular_data',TRIM(keyword)) /= 0 ) .OR. &
						& (index('ReadIntramolecularData',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "read_intramolecular_data") )THEN
							KMC_setup%read_intramolecular_data=.true.
						ELSE
							KMC_setup%read_intramolecular_data=.false. 
						END IF 
				else if ( (index('use_fit_intramolecular',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('usefitintramolecular',TRIM(keyword)) /= 0 )  .OR.  &
						& (index('Use_Fit_Intramolecular',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('UseFitIntramolecular',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "use_fit_intramolecular") ) THEN
							KMC_setup%use_fit_intramolecular=.true.
						ELSE
							KMC_setup%use_fit_intramolecular=.false. 
						END IF 
				else if (( index('use_dE_in_AB__approx__dE_vert_CDFT',TRIM(keyword)) /= 0 )  .OR. &
						& (index('use_dE_in_AB__approx__dE_vert_CDFT',TRIM(keyword)) /= 0 )  .OR. &
						& (index('usedEinABapproxdEvertCDFT',TRIM(keyword)) /= 0 )  .OR. &
						& (index('use_dE_in_AB_approx_dE_vert_CDFT',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
						&   (TRIM(value) == "use_dE_in_AB__approx__dE_vert_CDFT") )THEN
							KMC_setup%use_dE_in_AB__approx__dE_vert_CDFT=.true.
						ELSE
							KMC_setup%use_dE_in_AB__approx__dE_vert_CDFT=.false. 
						END IF 
				else if (( index('Use_reference_data_from_P3HT32mer',TRIM(keyword)) /= 0 )  .OR. &
						& (index('usereferencedatafromP3HT32mer',TRIM(keyword)) /= 0 )  .OR. &
						& (index('UseReferenceDataFromP3HT32mer',TRIM(keyword)) /= 0 )  .OR. &
						& (index('Use_Reference_Data_From_P3HT32mer',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
						&   (TRIM(value) == "Use_reference_data_from_P3HT32mer") )THEN
							KMC_setup%Use_reference_data_from_P3HT32mer=.true.
						ELSE
							KMC_setup%Use_reference_data_from_P3HT32mer=.false. 
						END IF 
				else if (( index('use_lambda_out_random_number_Gauss_distribution_data',TRIM(keyword)) /= 0 )  .OR. &
						& (index('uselambdaoutrandomnumberGaussdistributiondata',TRIM(keyword)) /= 0 )  .OR. &
						& (index('uselambdaoutrandomnumbergaussdistributiondata',TRIM(keyword)) /= 0 )  .OR. &
						& (index('lambdaoutgauss',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
						&   (TRIM(value) == "gauss") )THEN
							KMC_setup%use_lambda_out_random_number_Gauss_distribution_data=.true.
						ELSE
							KMC_setup%use_lambda_out_random_number_Gauss_distribution_data=.false. 
						END IF 
				else if (( index('Read_l_out',TRIM(keyword)) /= 0 )  .OR. &
						& (index('Readlout',TRIM(keyword)) /= 0 )  .OR. &
						& (index('readlout',TRIM(keyword)) /= 0 )  .OR. &
						& (index('readlambdaout',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
						&   (TRIM(value) == "Read_l_out") )THEN
							KMC_setup%Read_l_out=.true.
						ELSE
							KMC_setup%Read_l_out=.false. 
						END IF 
				else if (( index('Read_E_multipole_out',TRIM(keyword)) /= 0 )  .OR. &
						& (index('ReadEmultipoleout',TRIM(keyword)) /= 0 )  .OR. &
						& (index('reademultipoleout',TRIM(keyword)) /= 0 )  .OR. &
						& (index('reademultipole',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
						&   (TRIM(value) == "Read_E_multipole_out") )THEN
							KMC_setup%Read_E_multipole_out=.true.
						ELSE
							KMC_setup%Read_E_multipole_out=.false. 
						END IF 
				else if (( index('E_out_randomized_distribution',TRIM(keyword)) /= 0 )  .OR. &
						& (index('EoutRandomizedDistribution',TRIM(keyword)) /= 0 )  .OR. &
						& (index('eoutrandomizeddistribution',TRIM(keyword)) /= 0 )  .OR. &
						& (index('Eoutrandomizeddistribution',TRIM(keyword)) /= 0 )  ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
						&   (TRIM(value) == "E_out_randomized_distribution") )THEN
							KMC_setup%E_out_randomized_distribution=.true.
						ELSE
							KMC_setup%E_out_randomized_distribution=.false. 
						END IF 
				else if (( index('Eouth',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('E_out_h',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('def_E_multi_h',TRIM(keyword)) /= 0 )  ) then                                                   
						KMC_setup%def_E_multi_h=str2real(value)
				else if (( index('sigEouth',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('sig_E_out_h',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('sig_E_multi_h',TRIM(keyword)) /= 0 )  ) then                                                   
						KMC_setup%sig_E_multi_h=str2real(value)
				else if (( index('Eoute',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('E_out_e',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('def_E_multi_e',TRIM(keyword)) /= 0 )  ) then                                                   
						KMC_setup%def_E_multi_e=str2real(value)
				else if (( index('sigEoute',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('sig_E_out_e',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('sig_E_multi_e',TRIM(keyword)) /= 0 )  ) then                                                   
						KMC_setup%sig_E_multi_e=str2real(value)
				else if (( index('louth',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('l_out_h',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('lambda_out_h',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('def_lam_out_h',TRIM(keyword)) /= 0 )  ) then                                                   
						KMC_setup%def_lam_out_h=str2real(value)
				else if (( index('siglouth',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('sig_l_out_h',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('sig_lambda_out_h',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('sig_lam_out_h',TRIM(keyword)) /= 0 )  ) then                                                   
						KMC_setup%sig_lam_out_h=str2real(value)
				else if (( index('loute',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('l_out_e',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('lambda_out_e',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('def_lam_out_e',TRIM(keyword)) /= 0 )  ) then                                                   
						KMC_setup%def_lam_out_e=str2real(value)
				else if (( index('sigloute',TRIM(keyword)) /= 0 ) .OR. & 
						& (index('sig_l_out_e',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('sig_lambda_out_e',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('sig_lam_out_e',TRIM(keyword)) /= 0 )  ) then                                                   
						KMC_setup%sig_lam_out_e=str2real(value)							
						
				endif !!! section == rates_to_votca_sql_file
				!!!!----------------------------------------------------------------------------!!!!
				!!!!   END READ rates_to_votca_sql_file          options.xml                    !!!!
				!!!!----------------------------------------------------------------------------!!!!
				
				
			ELSE IF ((TRIM(section) == 'DIPRO') .OR. (TRIM(section) == 'dipro') ) THEN
				!!!!----------------------------------------------------------------------------!!!!
				!!!!   variables for DIPRO  from                 options.xml                    !!!!
				!!!!----------------------------------------------------------------------------!!!!
				if (( index('NCPUS',TRIM(keyword)) /= 0 ) .OR. &
						&(index('ncpus',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%NCPUS=str2int(value)
				else if (( index('NODE',TRIM(keyword)) /= 0 ) .OR. &
						&(index('node',TRIM(keyword)) /= 0 ) ) then   
							KMC_setup%NODE=str2int(value)
				else if (( index('MEM',TRIM(keyword)) /= 0 ) .OR. &
						&(index('mem',TRIM(keyword)) /= 0 ) ) then   
							KMC_setup%MEM=str2int(value)
				else if (( index('QUEUE',TRIM(keyword)) /= 0 ) .OR. &
						&(index('queue',TRIM(keyword)) /= 0 ) ) then   
							KMC_setup%QUEUE=TRIM(ADJUSTL(value))
				else if (( index('TIME',TRIM(keyword)) /= 0 ) .OR. &
						&(index('TIME',TRIM(keyword)) /= 0 ) ) then   
							KMC_setup%TIME=str2int(value)
				else if (( index('SUB',TRIM(keyword)) /= 0 ) .OR. &
						&(index('sub',TRIM(keyword)) /= 0 ) ) then   
							KMC_setup%sub=TRIM(ADJUSTL(value))
				else if (( index('g09_SKF_path',TRIM(keyword)) /= 0 ) .OR. (index('g09_skf_path',TRIM(keyword)) /= 0 ) .OR. &
						&(index('g09SKFpath',TRIM(keyword)) /= 0 ) .OR. (index('g09skfpath',TRIM(keyword)) /= 0 )  ) then   
							KMC_setup%g09_SKF_path=TRIM(ADJUSTL(value))
				else if (( index('dftb_plus_SKF_path',TRIM(keyword)) /= 0 ) .OR. (index('dftb_plus_skf_path',TRIM(keyword)) /= 0 ) .OR. &
						&(index('dftb+SKFpath',TRIM(keyword)) /= 0 ) .OR. (index('dftb+skfpath',TRIM(keyword)) /= 0 )  ) then   
							KMC_setup%dftb_plus_SKF_path=TRIM(ADJUSTL(value))
				else if (( index('dftb_plus_path',TRIM(keyword)) /= 0 ) .OR. &
						&(index('dftbpluspath',TRIM(keyword)) /= 0 ) ) then   
							KMC_setup%dftb_plus_path=TRIM(ADJUSTL(value))
				else if (( index('votca_sql_name',TRIM(keyword)) /= 0 ) .OR. &
						&(index('votcasqlname',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%votca_sql_name=TRIM(ADJUSTL(value))
							write(*,*) 'tmp  votca_sql_name: ',trim(value)
				else if (( index('moment_of_inertia_tensor',TRIM(keyword)) /= 0 ) .OR. & 
						&( index('traegheitstensor',TRIM(keyword)) /= 0 ) .OR. &
						&( index('momentofinertiatensor',TRIM(keyword)) /= 0 ) ) then   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "moment_of_inertia_tensor"))THEN
							KMC_setup%moment_of_inertia_tensor=.true.
						ELSE
							KMC_setup%moment_of_inertia_tensor=.false. 
						END IF 
				end if !!! section DIPRO
				!!!!----------------------------------------------------------------------------!!!!
				!!!!   END  variables for DIPRO  from                 options.xml               !!!!
				!!!!----------------------------------------------------------------------------!!!!
			ELSE IF ((TRIM(section) == 'DIPRO_pair') .OR. (TRIM(section) == 'DIPROpair') ) THEN
				!!!!----------------------------------------------------------------------------!!!!
				!!!!   variables for DIPRO_pair variables  from                 options.xml     !!!!
				!!!!----------------------------------------------------------------------------!!!!
				if (( index('read_DIPRO_gro',TRIM(keyword)) /= 0 ) .OR. &
						&(index('read_DIPRO_gro',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
						&   (TRIM(value) == "read_DIPRO_gro") )THEN
							KMC_setup%read_DIPRO_gro=.true.
						ELSE
							KMC_setup%read_DIPRO_gro=.false. 
						END IF 
				else if (( index('gro_inputfile',TRIM(keyword)) /= 0 ) .OR. &
						&(index('groinputfile',TRIM(keyword)) /= 0 ) ) then   
							KMC_setup%gro_inputfile=TRIM(ADJUSTL(value))
				else if (( index('residA',TRIM(keyword)) /= 0 ) .OR. &
						&(index('residA',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%residA=str2int(value)
				else if (( index('typeA',TRIM(keyword)) /= 0 ) .OR. &
						&(index('TYPEA',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%typeA=TRIM(ADJUSTL(value))
				else if (( index('residB',TRIM(keyword)) /= 0 ) .OR. &
						&(index('residB',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%residB=str2int(value)
				else if (( index('typeB',TRIM(keyword)) /= 0 ) .OR. &
						&(index('TYPEB',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%typeB=TRIM(ADJUSTL(value))
				else if (( index('calculation_method',TRIM(keyword)) /= 0 ) .OR. &
						&(index('calculationmethod',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%calculation_method=TRIM(ADJUSTL(value))
				else if (( index('g09_inputline',TRIM(keyword)) /= 0 ) .OR. &
						&(index('g09inputline',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%g09inputline=TRIM(ADJUSTL(value))
				else if (( index('trajstep',TRIM(keyword)) /= 0 ) .OR. &
						&(index('trajstep',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%trajstep=str2int(value)
				else if (( index('Num',TRIM(keyword)) /= 0 ) .OR. &
						&(index('num',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%Num=str2int(value)
				else if (( index('read_DIPRO_xyz',TRIM(keyword)) /= 0 ) .OR. &
						&(index('readDIPROxyz',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
						&   (TRIM(value) == "read_DIPRO_xyz") )THEN
							KMC_setup%read_DIPRO_xyz=.true.
						ELSE
							KMC_setup%read_DIPRO_xyz=.false. 
						END IF 
				else if (( index('monomerA_xyz',TRIM(keyword)) /= 0 ) .OR. &
						&(index('monomerAxyz',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%monomerAxyz=TRIM(ADJUSTL(value))
				else if (( index('monomerB_xyz',TRIM(keyword)) /= 0 ) .OR. &
						&(index('monomerBxyz',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%monomerBxyz=TRIM(ADJUSTL(value))
				endif !!! DIPRO_pair 
				!!!!----------------------------------------------------------------------------!!!!
				!!!!   END variables for DIPRO_pair variables  from             options.xml     !!!!
				!!!!----------------------------------------------------------------------------!!!!
			ELSE IF ((TRIM(section) == 'lambda_in_pair') .OR. (TRIM(section) == 'lambdainpair') ) THEN
				!!!!----------------------------------------------------------------------------!!!!
				!!!!   variables for lambda_in_pair variables  from             options.xml     !!!!
				!!!!----------------------------------------------------------------------------!!!!
				if (( index('read_lambda_in_gro',TRIM(keyword)) /= 0 ) .OR. &
						&(index('readlambdaingro',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
						&   (TRIM(value) == "read_lambda_in_gro") )THEN
							KMC_setup%read_lambda_in_gro=.true.
						ELSE
							KMC_setup%read_lambda_in_gro=.false. 
						END IF 
				else if (( index('gro_inputfile',TRIM(keyword)) /= 0 ) .OR. &
						&(index('groinputfile',TRIM(keyword)) /= 0 ) ) then   
							KMC_setup%gro_inputfile=TRIM(ADJUSTL(value))
				else if (( index('residA',TRIM(keyword)) /= 0 ) .OR. &
						&(index('residA',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%residA=str2int(value)
				else if (( index('typeA',TRIM(keyword)) /= 0 ) .OR. &
						&(index('TYPEA',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%typeA=TRIM(ADJUSTL(value))
				else if (( index('residB',TRIM(keyword)) /= 0 ) .OR. &
						&(index('residB',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%residB=str2int(value)
				else if (( index('typeB',TRIM(keyword)) /= 0 ) .OR. &
						&(index('TYPEB',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%typeB=TRIM(ADJUSTL(value))
				else if (( index('calculation_method',TRIM(keyword)) /= 0 ) .OR. &
						&(index('calculationmethod',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%calculation_method=TRIM(ADJUSTL(value))
				else if (( index('g09_inputline',TRIM(keyword)) /= 0 ) .OR. &
						&(index('g09inputline',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%g09inputline=TRIM(ADJUSTL(value))
				else if (( index('trajstep',TRIM(keyword)) /= 0 ) .OR. &
						&(index('trajstep',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%trajstep=str2int(value)
				else if (( index('Num',TRIM(keyword)) /= 0 ) .OR. &
						&(index('num',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%Num=str2int(value)
				else if (( index('extra_SP_lambda_in',TRIM(keyword)) /= 0 ) .OR. &
						&(index('extraSPlambdain',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
						&   (TRIM(value) == "extra_SP_lambda_in") )THEN
							KMC_setup%extra_SP_lambda_in=.true.
						ELSE
							KMC_setup%extra_SP_lambda_in=.false. 
						END IF 
							
				else if (( index('read_lambda_in_xyz',TRIM(keyword)) /= 0 ) .OR. &
						&(index('readlambdainxyz',TRIM(keyword)) /= 0 ) ) then                                                   
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
						&   (TRIM(value) == "read_lambda_in_xyz") )THEN
							KMC_setup%read_lambda_in_xyz=.true.
						ELSE
							KMC_setup%read_lambda_in_xyz=.false. 
						END IF 
				else if (( index('monomerA_xyz',TRIM(keyword)) /= 0 ) .OR. &
						&(index('monomerAxyz',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%monomerAxyz=TRIM(ADJUSTL(value))
				else if (( index('monomerB_xyz',TRIM(keyword)) /= 0 ) .OR. &
						&(index('monomerBxyz',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%monomerBxyz=TRIM(ADJUSTL(value))
				endif !!! lambda_in_pair 
				!!!!----------------------------------------------------------------------------!!!!
				!!!!   END variables for lambda_in_pair variables  from         options.xml     !!!!
				!!!!----------------------------------------------------------------------------!!!!
			ELSE IF ((TRIM(section) == 'lambda_out_dE_out') .OR. (TRIM(section) == 'lambdaoutdEout') ) THEN
				!!!!----------------------------------------------------------------------------!!!!
				!!!!   variables for lambda_out_dE_out variables  from          options.xml     !!!!
				!!!!----------------------------------------------------------------------------!!!!

				
				if (( index('calc_lambda_out_entire_box',TRIM(keyword)) /= 0 ) .OR. &
						&(index('calclambdaoutentirebox',TRIM(keyword)) /= 0 ) ) then 
						IF(  (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. &
							&(TRIM(value) == "calc_lambda_out_entire_box"))THEN
							KMC_setup%calc_lambda_out_entire_box=.true.
						ELSE
							KMC_setup%calc_lambda_out_entire_box=.false. 
						END IF
				else if (( index('r_cut_NN',TRIM(keyword)) /= 0 ) .OR. ( index('r_cut',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('rcutNN',TRIM(keyword)) /= 0 ) ) then 
						KMC_setup%r_cut_NN=str2real(value)
				else if (( index('calc_lambda_out_single_pair',TRIM(keyword)) /= 0 ) .OR. &
						&(index('calclambdaoutsinglepair',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. &
						&   (TRIM(value) == "calc_lambda_out_single_pair"))THEN
							KMC_setup%calc_lambda_out_single_pair=.true.
						ELSE
							KMC_setup%calc_lambda_out_single_pair=.false. 
						END IF 				
				else if (( index('calc_lambda_out_nearest_neighbours_list_NN_max',TRIM(keyword)) /= 0 ) .OR. &
						&(index('calclambdaoutnearestneighbourslistNNmax',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. &
						&   (TRIM(value) == "calc_lambda_out_nearest_neighbours_list_NN_max"))THEN
							KMC_setup%calc_lambda_out_nearest_neighbours_list_NN_max=.true.
						ELSE
							KMC_setup%calc_lambda_out_nearest_neighbours_list_NN_max=.false. 
						END IF 
				else if (( index('calc_lambda_out_r_cut_NN',TRIM(keyword)) /= 0 ) .OR. &
						&(index('calclambdaoutrcutNN',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. & 
							& (TRIM(value) == "calc_lambda_out_r_cut_NN"))THEN
							KMC_setup%calc_lambda_out_r_cut_NN=.true.
						ELSE
							KMC_setup%calc_lambda_out_r_cut_NN=.false. 
						END IF 	
				else if (( index('calc_lambda_out_nearest_neighbours_list_all',TRIM(keyword)) /= 0 ) .OR. &
						&(index('calclambdaoutnearestneighbourslistall',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. &
							&(TRIM(value) == "calc_lambda_out_nearest_neighbours_list_all"))THEN
							KMC_setup%calc_lambda_out_nearest_neighbours_list_all=.true.
						ELSE
							KMC_setup%calc_lambda_out_nearest_neighbours_list_all=.false. 
						END IF 		
				else if (( index('calc_molpol',TRIM(keyword)) /= 0 ) .OR. &
						&(index('calcmolpol',TRIM(keyword)) /= 0 ) ) then 
						IF( (TRIM(value) == "1") .OR. (TRIM(value) == "true") .OR. (TRIM(value) == "calc_molpol"))THEN
							KMC_setup%calc_molpol=.true.
						ELSE
							KMC_setup%calc_molpol=.false. 
						END IF 
				else if (( index('select_calc_molpol',TRIM(keyword)) /= 0 ) .OR. &
						&(index('selectcalcmolpol',TRIM(keyword)) /= 0 ) ) then 
						KMC_setup%select_calc_molpol=TRIM(ADJUSTL(value))
				
				else if (( index('r_cut_lambda_out',TRIM(keyword)) /= 0 ) .OR. &
						&(index('rcutlambdaout',TRIM(keyword)) /= 0 ) ) then 
						KMC_setup%r_cut_lambda_out=str2real(value)
				else if (( index('r_cut_NN',TRIM(keyword)) /= 0 ) .OR. ( index('r_cut',TRIM(keyword)) /= 0 ) .OR.  &
						& (index('rcutNN',TRIM(keyword)) /= 0 ) ) then 
						KMC_setup%r_cut_NN=str2real(value)
				else if (( index('N_NN_max',TRIM(keyword)) /= 0 ) .OR. &
						&(index('NNNmax',TRIM(keyword)) /= 0 ) ) then 
						KMC_setup%N_NN_max=str2int(value)
				else if (( index('neighbourlist_filename',TRIM(keyword)) /= 0 ) .OR. &
						&(index('neighbourlistfilename',TRIM(keyword)) /= 0 ) ) then 
						KMC_setup%neighbourlist_filename=TRIM(ADJUSTL(value))
				else if (( index('gro_inputfile',TRIM(keyword)) /= 0 ) .OR. &
						&(index('groinputfile',TRIM(keyword)) /= 0 ) ) then   
							KMC_setup%gro_inputfile=TRIM(ADJUSTL(value))
				else if (( index('residA',TRIM(keyword)) /= 0 ) .OR. &
						&(index('residA',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%residA=str2int(value)
				else if (( index('typeA',TRIM(keyword)) /= 0 ) .OR. &
						&(index('TYPEA',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%typeA=TRIM(ADJUSTL(value))
				else if (( index('residB',TRIM(keyword)) /= 0 ) .OR. &
						&(index('residB',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%residB=str2int(value)
				else if (( index('typeB',TRIM(keyword)) /= 0 ) .OR. &
						&(index('TYPEB',TRIM(keyword)) /= 0 ) ) then                                                   
							KMC_setup%typeB=TRIM(ADJUSTL(value))
				endif !!! lambda_out_dE_out
				!!!!----------------------------------------------------------------------------!!!!
				!!!!   End variables for lambda_out_dE_out variables  from      options.xml     !!!!
				!!!!----------------------------------------------------------------------------!!!!
			END IF ! section = ?
			
		ENDDO loop_i ! cycle lines in *.xml file
		CLOSE(70) ! options.xml
		
	end subroutine read_votca_optionsfile



	!! adds an an event (possible charge transfer jump) to the node 
	subroutine Node_AddEvent(node, seg2,  rate12,  dr,  Jeff2,  reorg_out)
		implicit none
		type(KMC_Node_t)      :: node
		type(KMC_event_t)     :: newEvent
		integer, intent(in)   :: seg2
		real*8, intent(in)    :: rate12
		real*8, dimension(3)  :: dr
		real*8:: Jeff2
		real*8:: reorg_out
	 
		newEvent%destination = seg2
		newEvent%rate = rate12
		newEvent%intramolecular=.false.
		newEvent%initialrate = rate12
		newEvent%dr = dr
		newEvent%Jeff2 = Jeff2
		newEvent%reorg_out = reorg_out
		newEvent%current = 0.0   
		newEvent%current_norm = 0.0

		IF( .not. (allocated(node%event))) THEN
				allocate(node%event(1))
				node%event(1)=newEvent
				node%event_size=1
		ELSE
				call append_event_to_event_list(node%event,newEvent)
				node%event_size=node%event_size+1
		ENDIF

	end subroutine Node_AddEvent


	!! removes an an event with id_event
	subroutine Node_removeEvent(node, event_id)
		implicit none
		type(KMC_Node_t)      :: node
		integer, intent(in)   :: event_id
		
		if((node%event_size ==0) .OR. (event_id < 0) .OR. (event_id > node%event_size) ) then
			write(*,*) 'Error: Can not remove the event ',event_id,' form node_id',node%id
		else
			call remove_event_from_event_list(node%event,event_id)
			node%event_size=node%event_size-1
		endif
		
	end subroutine Node_removeEvent



	!! Increases the list of events, 
	subroutine append_event_to_event_list(event_list,newEvent)
					!! appends the newEvent to the list of events in event_list
					implicit none
					type (KMC_event_t), intent(in)::newEvent
					type (KMC_event_t), ALLOCATABLE, INTENT(INOUT) :: event_list(:)
					type (KMC_event_t), ALLOCATABLE :: new_event_list(:) 
					integer::n_events

					n_events=size(event_list)
					allocate(new_event_list(n_events+1))

					new_event_list(1:n_events)=event_list(1:n_events)

					new_event_list(n_events+1) = newEvent

					deallocate(event_list)
					allocate(event_list(n_events+1))
					!! transfer event
					event_list(:) = new_event_list(:)

					deallocate(new_event_list)
	end subroutine append_event_to_event_list


	!! decreases the list of events.
	subroutine remove_event_from_event_list(event_list,event_id)
					!! removes Event from list of events in event_list
					implicit none
					type (KMC_event_t), ALLOCATABLE, INTENT(INOUT) :: event_list(:)
					integer, intent(in) ::event_id
					type (KMC_event_t), ALLOCATABLE :: new_event_list(:) 
					integer::n_events

					n_events=size(event_list)-1
					allocate(new_event_list(n_events))

					if( event_id == 1) then
						new_event_list(1:n_events)= event_list(2:n_events+1)
					else if(  event_id == n_events+1) then
						new_event_list(1:n_events)= event_list(1:n_events)
					else
						new_event_list(1:event_id-1)=event_list(1:event_id-1)
						new_event_list(event_id:n_events)=event_list(event_id+1:n_events+1)
					endif
					
					deallocate(event_list)
					allocate(event_list(n_events))
					
					!! transfer event
					event_list(:) = new_event_list(:)

					deallocate(new_event_list)
	end subroutine remove_event_from_event_list


	!!! Adds id to list of forbidden nodes/ destinations
	integer function Forbidden(do_newnode_id, forbiddendests, n_forbidden)
			IMPLICIT NONE
			INTEGER, INTENT(IN)::do_newnode_id,n_forbidden
			INTEGER, ALLOCATABLE, DIMENSION(:), INTENT(IN)::forbiddendests
			INTEGER  ::i,forbidden_found
			
			forbidden_found=0
			if(n_forbidden==0) then
				forbidden_found=0
			else
					do i=1,n_forbidden
						if( do_newnode_id == forbiddendests(i)) then
							forbidden_found=1
							EXIT
						endif 
					enddo
			end if
			
			
			Forbidden=forbidden_found
	end function Forbidden



	!! Checks if a "node"  is in the list of the forbidden destination sites "forbidden_dests"
	integer function Surrounded(node, forbidden_dests, n_forbidden)
			IMPLICIT NONE
			type(KMC_Node_t), INTENT(IN)                    :: node
			INTEGER, INTENT(IN)                           ::n_forbidden
			INTEGER, ALLOCATABLE, DIMENSION(:), INTENT(IN)::forbidden_dests
			INTEGER  ::i,j,surrounded_found
			INTEGER  :: thisevent_possible
			surrounded_found = 1
			
			!!! for(unsigned int i=0; i<node->event.size(); i++)
			do i=1,node%event_size
					thisevent_possible = 1
					!!! for(unsigned int j=0; j<forbiddendests.size(); j++)
					do j=1,n_forbidden
						if(node%event(i)%destination == forbidden_dests(j)) then
							thisevent_possible = 0
							EXIT 
						endif
					enddo ! j=1,n_forbidden
					if(thisevent_possible == 1) then
						surrounded_found = 0
						EXIT 
					endif  ! thisevent_possible
			enddo ! node%event_size 
			Surrounded=surrounded_found
	end function  Surrounded


!!!!!!!!!!!!! NODE FUNCTIONS


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!  KMC FUNCTIONS
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

!! Reads the data from an *.sql file to the node 
!! ( HERE array "newNode" represent the entire network of hopping sites and events )
!! dumps the data form the *.sql file into temporary fortran readable files.
!! EscapeRates are evaluated.
	subroutine LoadGraph_from_sql(KMC_setup,node,numberofpairs,number_of_nodes)
		use small_functions
		implicit none
		type (KMC_Node_t), ALLOCATABLE, DIMENSION(:)::node
		!type (KMC_Node_t)::newNode
		type (KMC_setup_t)::KMC_setup
		type (KMC_grid_t)::KMC_grid
		INTEGER, INTENT(OUT)::numberofpairs,number_of_nodes
		CHARACTER(LEN=500)::votca_sql_name
		CHARACTER(LEN=1)::carriertype
		Character(10000) :: tmp_readfile,lio
		CHARACTER(LEN=10000):: bashline
		integer::i,j,l,ierror
		integer*8::k8
		REAL*8, DIMENSION(3)::nodeposition,dr
		
		!!! Read variables
		REAL*8::posX, posY, posZ, UnCnN, UcNcC, eAnion,eNeutral,eCation,UcCnN 
		REAL*8::siteenergy
		CHARACTER(LEN=500)::node_name
		INTEGER::newid
		!!! Read variables 
		INTEGER::seg1,seg2
		REAL*8 ::rate12,drx,dry,drz,Jeff2,reorg_out
		REAL*8 ::internalenergy
		Real*8::newEscapeRate
		LOGICAL::Datei_vorhanden,debug=.false.
		
		!! variables to setup KMC_grid
		INTEGER::a,a_max,b
		!! check if jumps from site_type A to site_type B occures and sum statistics
		!INTEGER                                             :: N_hopping_site_list
		CHARACTER(LEN=500), ALLOCATABLE,DIMENSION(:)        :: hopping_site_list
		!INTEGER*8, ALLOCATABLE,DIMENSION(:,:)               :: hopping_pair_matrix
		!INTEGER*8, ALLOCATABLE,DIMENSION(:,:)               :: hopping_pair_matrix_intra
		
		!! reading intramolecular pairs
		INTEGER*8::N_intramolecular
		CHARACTER(LEN=50)::name1,name2
		!! Escape rate data 
		LOGICAL::makeEscapeRateFile
		CHARACTER(LEN=500):: EscapeRateFilename
		
		carriertype=KMC_setup%carriertype
		votca_sql_name=KMC_setup%votca_sql_name
		debug=KMC_setup%debug
		makeEscapeRateFile=KMC_setup%makeEscapeRateFile
		EscapeRateFilename=KMC_setup%EscapeRateFile
		lio=TRIM(make_lio())//'_'//TRIM(str(KMC_setup%set_seed))
		
		!!------------------------------------------------------
		!! 	Load node data to nodes
		!!------------------------------------------------------   
		IF( file_exists(votca_sql_name)) THEN
			WRITE(*,*) ' Use: ',TRIM(votca_sql_name)
		END IF 
		if(debug)then
				write(*,*) "LOADING GRAPH from database file: " ,TRIM(votca_sql_name)
		endif
		
		tmp_readfile=TRIM(make_tmp_readfilename('nodes',votca_sql_name,KMC_setup%set_seed))
		write(*,*) 'tmp_readfile: ',TRIM(tmp_readfile)

		!!    votca::tools::Statement *stmt = db.Prepare("SELECT _id, name, posX, posY, posZ, UnCnN"+_carriertype+", UcNcC"+_carriertype+",eAnion,eNeutral,eCation,ucCnN"+_carriertype+" FROM segments;");
		bashline=' sqlite3 '//TRIM(votca_sql_name)
		bashline=TRIM(bashline)//" ' SELECT _id, name, posX, posY, posZ, UnCnN"//TRIM(carriertype)//", UcNcC"//TRIM(carriertype)//&
											&",eAnion,eNeutral,eCation,UcCnN"//TRIM(carriertype)//" FROM segments '  > "//TRIM(tmp_readfile)
		WRITE(*,*) TRIM(bashline)
		CALL execute_command_line(TRIM(bashline)) 
		bashline=" sed -i 's/|/   /g' "//TRIM(tmp_readfile)
		CALL execute_command_line(TRIM(bashline)) 
		bashline=" sed -i 's/e/E/g' "//TRIM(tmp_readfile)
		CALL execute_command_line(TRIM(bashline)) 
		
		
		number_of_nodes=Read_rows_file(tmp_readfile,lio)
		ALLOCATE(node(number_of_nodes))
		
		
		
		OPEN(UNIT=600,FILE=TRIM(tmp_readfile),STATUS='OLD',ACTION='READ',IOSTAT=ierror)

		do i=1,number_of_nodes
				READ(600,*) newid, node_name, posX, posY, posZ, UnCnN, UcNcC, eAnion, eNeutral, eCation, UcCnN 
				!IF(DEBUG) WRITE(*,*)  newid, TRIM(node_name), posX, posY, posZ, UnCnN, UcNcC, eAnion,eNeutral,eCation,UcCnN
				IF(ierror < 0) EXIT
				IF(ierror > 0) THEN
					WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(tmp_readfile),' aufgetreten.  Line:',i
					WRITE(*,*)  newid, TRIM(node_name), posX, posY, posZ, UnCnN, UcNcC, eAnion,eNeutral,eCation,UcCnN
					WRITE(*,*) 'Beende Einlesen !'
					CALL EXIT (1)
				END IF
				node(i)%id = newid
				node(i)%node_name = TRIM(node_name)
				nodeposition(1) = posX*1E-9  
				nodeposition(2) = posY*1E-9
				nodeposition(3) = posZ*1E-9          !! converted from nm to m
				node(i)%position = nodeposition
				node(i)%reorg_intorig = UnCnN  !! UnCnN
				node(i)%reorg_intdest = UcNcC  !! UcNcC
				!!!double eAnion = stmt%Column<double>(7);
				!!!double eNeutral = stmt%Column<double>(8);
				!!!double eCation = stmt%Column<double>(9);
				internalenergy = UcCnN !! UcCnN
				siteenergy = 0
				
				if( carriertype == "e")then
					siteenergy = eAnion + internalenergy
				else if( carriertype == "h") then
					siteenergy = eCation + internalenergy
				endif !_carriertype
				
				node(i)%siteenergy = siteenergy
				
				node(i)%injectable = 1
				node(i)%occupied = 0
				node(i)%current=0
				node(i)%current_norm=0
		enddo ! number_of_nodes  read
		
		CLOSE(600)
		
		! remove temporary file 'rm  tmp_readfile_nodes_'
		INQUIRE(file=TRIM(tmp_readfile),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
		IF(Datei_vorhanden) THEN ! 	
			CALL delete_file_and_check(tmp_readfile)
		ELSE
			WRITE(*,*) 'Error: while reading tmp_readfile_nodes_*.dat: '//TRIM(tmp_readfile)
			CALL EXIT(1)
		END IF

		
		
		!!! grid count hopping types end
		!! check the number of different hopping site names and create a list for all different names and a matrix: 
		!! KMC_grid contains: 
		!! N_hopping_site_list: Maximum number of differen hopping site names in the system/all nodes
		!! hopping_site_list(N_hopping_site_list)
		!! hopping_pair_matrix(A,B) for jumps from A to B
		!! hopping_pair_matrix_intra(A,B) for intramolecular jumps from A to B
						ALLOCATE(hopping_site_list(number_of_nodes))
						hopping_site_list=" "
						a_max=1
						hopping_site_list(1)=node(1)%node_name
						node(1)%node_type_id = a_max
						!WRITE(*,*) " tmp: ",TRIM(hopping_site_list(1))
						WRITE(*,*) TRIM(hopping_site_list(1))," ",node(1)%node_type_id 
						DO i=1,number_of_nodes
							a_loop: do a=1,a_max
								if( TRIM(node(i)%node_name) == TRIM(hopping_site_list(a)) )THEN 
									node(i)%node_type_id = a
									exit a_loop
								end if 
								if(a==a_max) then !! new node_name found
									a_max=a_max+1
									node(i)%node_type_id = a_max
									hopping_site_list(a_max)=TRIM(node(i)%node_name)
									WRITE(*,*) TRIM(hopping_site_list(a_max))," ",node(i)%node_type_id 
								end if
							end do a_loop
						END DO
						
						ALLOCATE(KMC_grid%hopping_site_list(a_max))
						ALLOCATE(KMC_grid%hopping_pair_matrix(a_max,a_max))
						ALLOCATE(KMC_grid%hopping_pair_matrix_intra(a_max,a_max))
						KMC_grid%N_hopping_site_list=a_max
						KMC_grid%hopping_site_list=""
						KMC_grid%hopping_pair_matrix=0
						KMC_grid%hopping_pair_matrix_intra=0
						DO a=1,KMC_grid%N_hopping_site_list
							KMC_grid%hopping_site_list(a)=hopping_site_list(a)
							if(debug)  WRITE(*,*) TRIM(KMC_grid%hopping_site_list(a)),&
											&(KMC_grid%hopping_pair_matrix(a,b), b=1,KMC_grid%N_hopping_site_list)
						END DO
						!! counts the number of intermolecular jumps 
						KMC_grid%N_jumps_intermolecular=0
						!! counts the number of intramolecular jumps 
						KMC_grid%N_jumps_intramolecular=0
						!! number_of_united_nodes to a single node
						KMC_grid%number_of_united_nodes=0
						
						if(debug) then
							WRITE(*,*)  'N_hopping_site_list:  ',KMC_grid%N_hopping_site_list
							WRITE(*,*)  'hopping_site_list:    ',KMC_grid%hopping_site_list(:)
							WRITE(*,*)  'hopping_pair_matrix:  ',KMC_grid%hopping_pair_matrix(:,:)
						endif ! debug
						!! uebergabe an KMC_setup; to do 
						
						CALL update_KMC_system_grid(KMC_grid)
						
		!!! grid count hopping types end
		
		if(debug)then
			write(*,*) "segments: " ,size(node) 
		endif 
		
		!!------------------------------------------------------
		!! Load pairs and rates
		!!------------------------------------------------------
		numberofpairs = 0

		!!! Erstelle String lio=Durcheinander, um die Rechnungen mit Hilfe von Zufallszahlen einzigartig zu machen, sodass keine Interferenzen mit anderen Rechnungen ggf. im gleichen Ordner auftreten können. 
		tmp_readfile=TRIM(make_tmp_readfilename('pairs',votca_sql_name,KMC_setup%set_seed))
		
		
		!!!!stmt = db.Prepare("SELECT seg1 AS 'segment1', seg2 AS 'segment2', rate12"+_carriertype+" AS 'rate', drX, drY, drZ, Jeff2"+_carriertype+", lO"+_carriertype+" FROM pairs UNION SELECT seg2-1 AS 'segment1', seg1-1 AS 'segment2', rate21"+_carriertype+" AS 'rate', -drX AS 'drX', -drY AS 'drY', -drZ AS 'drZ', Jeff2"+_carriertype+", lO"+_carriertype+" FROM pairs ORDER BY segment1;");
		!!! seg1-1 AS 'segment1' replaced by seg1   as the index in fortran starts with 1!!!
		bashline=' sqlite3 '//TRIM(votca_sql_name)
		bashline=TRIM(bashline)//' " '//"  SELECT seg1 AS 'segment1', seg2 AS 'segment2', rate12"//TRIM(carriertype)//&
				&" AS 'rate', drX, drY, drZ, Jeff2"//TRIM(carriertype)//", lO"//TRIM(carriertype)//&
				&" FROM pairs UNION SELECT seg2 AS 'segment1', seg1 AS 'segment2', rate21"//TRIM(carriertype)//&
				&" AS 'rate', -drX AS 'drX', -drY AS 'drY', -drZ AS 'drZ', Jeff2"//TRIM(carriertype)//", lO"//TRIM(carriertype)//&
				&' FROM pairs ORDER BY segment1; " > '//TRIM(tmp_readfile)
		WRITE(*,*) TRIM(bashline)
		CALL execute_command_line(TRIM(bashline)) 
		bashline=" sed -i 's/|/   /g' "//TRIM(tmp_readfile)
		CALL execute_command_line(TRIM(bashline)) 
		bashline=" sed -i 's/e/E/g' "//TRIM(tmp_readfile)
		CALL execute_command_line(TRIM(bashline)) 

		OPEN(UNIT=700,FILE=TRIM(tmp_readfile),STATUS='OLD',ACTION='READ',IOSTAT=ierror)
		
		
		numberofpairs=Read_rows_file(tmp_readfile,lio)
		write(*,*) 'numberofpairs: ',numberofpairs/2
		write(*,*) 'Start reading pair data from sql database: ',TRIM(votca_sql_name) 
		do i=1,numberofpairs
				Read(700,*,IOSTAT=ierror)  seg1,seg2,rate12,drx,dry,drz,Jeff2,reorg_out
				!WRITE(*,*) seg1,seg2,rate12,drx,dry,drz,Jeff2,reorg_out
				IF(ierror < 0) EXIT
				IF(ierror > 0) THEN
					WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(tmp_readfile),' aufgetreten.'
					WRITE(*,*) seg1,seg2,rate12,drx,dry,drz,Jeff2,reorg_out
					WRITE(*,*) 'Beende Einlesen !'
					CALL EXIT (1)
				END IF
				
				
				dr(1)=drx*1.0D-9  !! converted from nm to m
				dr(2)=dry*1.0D-9  !! converted from nm to m
				dr(3)=drz*1.0D-9  !! converted from nm to m
				call Node_AddEvent(node(seg1), seg2,  rate12,  dr,  Jeff2,  reorg_out)
				
		enddo 
		close(700)
		numberofpairs = numberofpairs/2


		! remove temporary file 'rm  tmp_readfile_pairs_'
		INQUIRE(file=TRIM(tmp_readfile),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
		IF(Datei_vorhanden) THEN !!!
			CALL delete_file_and_check(tmp_readfile)
		ELSE
			WRITE(*,*) 'Error: while reading tmp_readfile_pairs_*.dat: '//TRIM(tmp_readfile)
			CALL EXIT(1)
		END IF


		!!--------------------------------------------------------------------------------------
		!! Read pairs for intramolecular charge transfer transitions
		!!-----------------------------------------------------------------------------------
		!! Temporary file to detmine a list of intramolecular transitions
		!! WARNING: Implementation has to be checked for every new donor:acceptor system
		tmp_readfile=TRIM(make_tmp_readfilename('intramolecular_pairs',votca_sql_name,KMC_setup%set_seed))
		bashline=' sqlite3 '//TRIM(votca_sql_name)
		bashline=TRIM(bashline)//' " '//" SELECT pairs.seg1,mol1.name,pairs.seg2,mol2.name FROM pairs "//&  !!! list with seg1,name1,seg2,name2
				&"INNER JOIN segments AS mol1 ON mol1.id == pairs.seg1 "//&
				&"INNER JOIN segments AS mol2 ON mol2.id == pairs.seg2 "//&
				&"WHERE ( pairs.seg2=pairs.seg1-1 OR  pairs.seg2=pairs.seg1+1) "//&   !!! pairs for seg2= seg1 + 1 or  seg1= seg2 + 1  !! Only intramolecular segments !! Warning this definition is not unique!
				&"AND ( mol1.name !='DIPBI' AND  mol2.name !='DIPBI' ) AND "//&     !!! exclude acceptor names in the list
				&" ( mol1.name !='DPBIK' OR  mol2.name !='DPBIK') AND ( NOT (mol1.name  OR  mol2.name LIKE 'PPDI%') ) "//' " > '//&
				&TRIM(tmp_readfile)
		WRITE(*,*) TRIM(bashline)
		CALL execute_command_line(TRIM(bashline)) 
		bashline=" sed -i 's/|/   /g' "//TRIM(tmp_readfile)
		CALL execute_command_line(TRIM(bashline)) 

		OPEN(UNIT=800,FILE=TRIM(tmp_readfile),STATUS='OLD',ACTION='READ',IOSTAT=ierror)
		
		!!lio=TRIM(make_lio())//TRIM(str(KMC_setup%set_seed))
		N_intramolecular=Read_rows_file(tmp_readfile,lio)
		IF( N_intramolecular > 5) THEN
				ALLOCATE(KMC_grid%intramolecular_pairs(N_intramolecular))
				j=0
				DO i=1,int(N_intramolecular,4)
					READ(800,*) seg1,name1,seg2,name2
					if(debug) WRITE(*,*)  seg1,TRIM(name1),seg2,TRIM(name2)
					IF( (TRIM(name1) == 'DIPBI') .OR. (TRIM(name2) == 'DIPBI') ) THEN
						N_intramolecular=N_intramolecular-1
						CYCLE
					ELSE  !!! standard
						j=j+1
						KMC_grid%intramolecular_pairs(j)%id=j
						KMC_grid%intramolecular_pairs(j)%seg1=seg1
						KMC_grid%intramolecular_pairs(j)%seg2=seg2
						KMC_grid%intramolecular_pairs(j)%name1=TRIM(name1)
						KMC_grid%intramolecular_pairs(j)%name2=TRIM(name2)
					END IF
				END DO
				KMC_grid%N_intramolecular_pairs=N_intramolecular
		ELSE
			!! Single dummy allocation
			KMC_grid%N_intramolecular_pairs=0
			ALLOCATE(KMC_grid%intramolecular_pairs(1))
			KMC_grid%intramolecular_pairs(1)%id=1
			KMC_grid%intramolecular_pairs(1)%seg1=0
			KMC_grid%intramolecular_pairs(1)%seg2=0
			KMC_grid%intramolecular_pairs(1)%name1="NOpair"
			KMC_grid%intramolecular_pairs(1)%name2="NOpair"
		ENDIF
		
		l=0
		do i=1,number_of_nodes
				do j=1,node(i)%event_size
					k_loop: do k8=1, KMC_grid%N_intramolecular_pairs
						IF(  ((node(i)%event(j)%destination == KMC_grid%intramolecular_pairs(k8)%seg2) .AND. &
							& (node(i)%id == KMC_grid%intramolecular_pairs(k8)%seg1) ) &
							& .OR. &
							&((node(i)%event(j)%destination == KMC_grid%intramolecular_pairs(k8)%seg1) .AND. &
							& (node(i)%id == KMC_grid%intramolecular_pairs(k8)%seg2) ) )THEN
							 !! set intramolecular transfer
							 node(i)%event(j)%intramolecular=.true.
							 l=l+1
							 CYCLE k_loop
						END IF
					enddo k_loop
				enddo !j 
		enddo !number_of_nodes
		
		write(*,*) 'INTRAMOLECULAR TRANSITIONS:',l,'  N_intramolecular_pairs: ',N_intramolecular
		
		! remove temporary file 'rm  tmp_readfile_pairs_'
		INQUIRE(file=TRIM(tmp_readfile),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
		IF(Datei_vorhanden) THEN !!!
			CALL delete_file_and_check(tmp_readfile)
		ELSE
			write(*,*) 'Error: while reading  tmp_readfile_intramolecular_pairs_*.dat: '//TRIM(tmp_readfile)
			call exit(1)
		END IF

		if(debug)then
			write(*,*) "pairs: ",  numberofpairs
		endif 
		
		!! Update global data KMC_system
		call update_KMC_system_grid(KMC_grid)
		
		!! END Temporary file to detmine a list of intramolecular transitions
		!!--------------------------------------------------------------------------------------
		
		
		
		!!--------------------------------------------------------------------------------------
		!!! Calculate initial escape rates !!!THIS SHOULD BE MOVED SO THAT IT'S NOT DONE TWICE IN CASE OF COULOMB INTERACTION!!!
		!!! InitEscapeRate
		!!------------------------------------------------------
		!! calculate escape rates for nodes
		!!------------------------------------------------------

		IF(makeEscapeRateFile) THEN
				EscapeRateFilename='Escape_rates_'//TRIM(votca_sql_name(:LEN_TRIM(votca_sql_name)-4))//'.dat'
				inquire(file=TRIM(EscapeRateFilename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
				if(Datei_vorhanden) then ! 	
					write(*,*) 'File already exists: ',TRIM(EscapeRateFilename)
					makeEscapeRateFile=.false.
				else
					OPEN(UNIT=900,FILE=TRIM(EscapeRateFilename),STATUS='UNKNOWN',ACTION='WRITE',IOSTAT=ierror)
				endif
		ENDIF ! makeEscapeRateFile
		do i=1,number_of_nodes
				newEscapeRate=0.0
				do j=1,node(i)%event_size
					newEscapeRate = newEscapeRate + node(i)%event(j)%rate
				enddo 
				node(i)%escaperate = newEscapeRate
				
				if(makeEscapeRateFile) then
					write(900,'(I8,A20,1ES16.8)') node(i)%id,TRIM(node(i)%node_name),newEscapeRate 
				endif ! makeEscapeRateFile
				if(debug)then
					write(*,*) "Escape rate for segment " , node(i)%id," was set to ",newEscapeRate 
				endif
		enddo 
		
		!! update KMC_system
		call update_KMC_system_nodes(node)
		write(*,*) 'tmp kmc_votca_sql_name:  ',TRIM(KMC_setup%votca_sql_name)

		WRITE(*,*) 'LoadGraph done'
	end subroutine LoadGraph_from_sql



!! temporary, block of one event / possible jump  from the list of events.
!! It is used, e.g. if the target site is occupied.
	subroutine block_event_from_event_list(blocked_forbidden_node_id, do_oldnode)
			use small_functions
			implicit none
			type(KMC_Node_t), intent(inout)::do_oldnode
			INTEGER::blocked_forbidden_node_id
			INTEGER::k,j,blocked_forbidden_event_id
			LOGICAL:: debug=.false.
			REAL*8::EscapeRate
			
			if(debug) then
				write(*,*)  'forbidden destination: ',blocked_forbidden_node_id
				write(*,*) ' Current list  of destinations  do_oldnode: ', do_oldnode%event(1:do_oldnode%event_size)%destination
			end if 
			!! find forbidden event id for a given node_id
			do j=1,do_oldnode%event_size
				
				!write(*,*) do_oldnode%event(j)%destination,  blocked_forbidden_node_id
				if (do_oldnode%event(j)%destination == blocked_forbidden_node_id ) then
						blocked_forbidden_event_id=j
				endif 
			end do 
			
			
			
			!! deactivate event in the list, shift the events so blocked_forbidden_id is taken out  
			do k=blocked_forbidden_event_id+1, do_oldnode%event_size
				do_oldnode%event(k-1)=do_oldnode%event(k)
			enddo 
			
			!!! reduce the possible number of events.
			do_oldnode%event_size=do_oldnode%event_size-1
			!!! recalculate the escape rate		
			EscapeRate=0.0
			do k=1,do_oldnode%event_size
				EscapeRate = EscapeRate + do_oldnode%event(k)%rate
			end do 
			do_oldnode%EscapeRate=EscapeRate
			if(debug) then
				write(*,*) 'blocked_forbidden_event_id:',blocked_forbidden_event_id
				write(*,*) ' Reduced list of destinations  do_oldnode: ', do_oldnode%event(1:do_oldnode%event_size)%destination
			endif

	end subroutine block_event_from_event_list



	integer function get_random_node_id(number_of_nodes)
				implicit none
				integer, intent(in)::number_of_nodes
				integer::node_id
				real::HARVEST

				node_id=-1
				do while( (node_id < 1) .OR.  node_id > number_of_nodes) 
					CALL RANDOM_NUMBER(HARVEST)
					!! select node with a random number	
					node_id=int(HARVEST*number_of_nodes)
				enddo 
				get_random_node_id=node_id
	end function get_random_node_id

!!! End KMC specific functions



!!  KMC FUNCTION: kmc_run_VSSM 
!! routine uses distances in dr in [m] meters 
!!                           rates in [s**-1] 
!!                           simulation time in [s] seconds
!!  VSSM:    Variable step size method
!!  Input:   node         (Network with rates and possible events)
!!  Output:  occupation numbers: occP
!!
!!!!  KMCMultiple::RunVSSM(node, _runtime, _numberofcharges, RandomVariable, coulomb);
SUBROUTINE kmc_run_VSSM(node, KMC_setup, KMC_result)
	use small_functions
    IMPLICIT NONE

	type (KMC_Node_t), ALLOCATABLE, DIMENSION(:)::node
	type (KMC_setup_t):: KMC_setup
	type (KMC_result_t), INTENT(INOUT)  :: KMC_result
    real*8, allocatable, dimension(:) :: occP
    
    type (KMC_grid_t) :: grid
	type (KMC_Chargecarrier_t), ALLOCATABLE, DIMENSION(:)::carrier
	type (KMC_Chargecarrier_t) ::new_Chargecarrier
	
	!! Pointer
	type (KMC_Chargecarrier_t)  ::do_affectedcarrier
	type (KMC_Node_t)           ::do_oldnode,do_newnode
	
	integer::numberofcharges
    integer::ininterval
    real*8, allocatable, dimension(:,:) ::startposition
    integer, allocatable, dimension(:)  ::startpositionid
	
	LOGICAL::do_newnode_NULL
	integer:: number_of_nodes
    REAL*8,DIMENSION(3)::dr,dr_travelled,dI
    REAL::HARVEST
    REAL*8::simtime
  	REAL*8::runtime
    INTEGER*8::step,maxsteps
    CHARACTER(LEN=500)::stopcondition,injectionmethod
    INTEGER, DIMENSION(64)::injectionnodelist
    
    CHARACTER(LEN=2):: carriertype
    REAL*8::rand_u,u,cumulated_rate,dt
    LOGICAL:: explicitcoulomb=.false.
    INTEGER::i,j,k,l,m,ierror,level1step

    !! output
    REAL*8::outputtime,nexttrajoutput
    REAL*8::nextoutput,nextstepoutput
    Real*8::outputfrequency,outputstepfrequency
	LOGICAL::store_trajectory
	
    !!! mobility
	REAL*8 :: absolute_field
	REAL*8, DIMENSION(3) ::fieldfactors,average_mobility,velocity,mobility
	REAL*8::fieldX,fieldY,fieldZ
	INTEGER::node_id,injectionnode

	REAL*8::box_x,box_y,box_z
	REAL  ::xbox,ybox,zbox
	CHARACTER(LEN=10000)::bashline
	CHARACTER(LEN=500)::trajectoryfilename,xyz_trajectoryfilename
	!! injection
	REAL*8::deltaE, energypercarrier, totalenergy 
	! REAL*8:: EscapeRate
	
	!! Forbidden destsinations, nodes
	INTEGER, ALLOCATABLE, DIMENSION(:)::forbidden_dests,forbidden_nodes
	INTEGER:: n_forbidden_nodes, n_forbidden_dests,  blocked_forbidden_id
	
	!! Parameters
	REAL*8, PARAMETER::m2Ang=1.0D+10,Ang2m=1.0D-10
	REAL*8 :: casi_zero=1.0D-20
	!! DEBUG MODE
	LOGICAL::debug=.false.
	LOGICAL::calc_VOTCA_style=.false.
	LOGICAL::printtrajcsv=.false.
	REAL*8, DIMENSION(3) ::box
	
	LOGICAL::check_hopping_pair_composition
	INTEGER::a,b
	INTEGER*8::n_jumps
	LOGICAL::unite_notes_for_kmc
	
	CHARACTER(LEN=50)::lio
	!!! temporary 
	INTEGER:: k_max,j_jump
	REAL*8::anteil_k_max
	!! KMC meta dynamics
	REAL*8::kmcmetadynamics_alpha
	LOGICAL::kmcmetadynamics
	INTEGER::destination
	
	INTEGER, ALLOCATABLE, DIMENSION(:)::seed
	!! pathway finder
	CHARACTER(LEN=500)::dr_dI_xyz_trajectoryfilename,votca_sql_name,p_occ_filename
	LOGICAL::file_available,calc_pathway,store_KMC_result,reset_pathway_at_initial_site
	LOGICAL::pathway_found=.false.
	INTEGER::N_reset_pathway
	
	store_KMC_result=.true.
	debug=KMC_setup%debug
	
	if(debug)then
		write(*,*) 'start kmc_run_VSSM routine'
	endif 
	
	carriertype=KMC_setup%carriertype
	numberofcharges=KMC_setup%numberofcharges
	

	fieldX=KMC_setup%fieldX
	fieldY=KMC_setup%fieldY
	fieldZ=KMC_setup%fieldZ
   
    !! defaults
	maxsteps=KMC_setup%maxsteps
	runtime=KMC_setup%runtime
	stopcondition=KMC_setup%stopcondition
	outputtime=KMC_setup%outputtime
	nexttrajoutput=KMC_setup%nexttrajoutput
	trajectoryfilename=KMC_setup%trajectoryfilename
	injectionmethod=KMC_setup%injectionmethod
	injectionnode=KMC_setup%injection_node
	injectionnodelist=KMC_setup%injection_node_list
	
	store_trajectory=KMC_setup%store_trajectory
	printtrajcsv=KMC_setup%printtrajcsv
	xyz_trajectoryfilename=KMC_setup%xyz_trajectoryfilename
	
	calc_VOTCA_style=KMC_setup%calc_VOTCA_style  
	
	kmcmetadynamics=KMC_setup%kmcmetadynamics
	kmcmetadynamics_alpha=KMC_setup%kmcmetadynamics_alpha
	
	!! Check hopping pairs for jumps form type A to type B and count the number of jumps
	check_hopping_pair_composition=KMC_setup%check_hopping_pair_composition
	grid = KMC_system%KMC_grid 
	unite_notes_for_kmc= KMC_setup%unite_notes_for_kmc 
	
	!! Pathway 
	calc_pathway=KMC_setup%calc_pathway
	reset_pathway_at_initial_site=KMC_setup%reset_pathway_at_initial_site
	votca_sql_name=KMC_setup%votca_sql_name
	  
	outputfrequency = runtime/10
	outputstepfrequency = maxsteps/10
	
	
	if(debug) then
						WRITE(*,*)  'N_hopping_site_list: ',grid%N_hopping_site_list
						DO k=1,grid%N_hopping_site_list
							WRITE(*,*)  'hopping_site_list: ',TRIM(grid%hopping_site_list(k))
						ENDDO
						WRITE(*,*)  'hopping_pair_matrix: ',grid%hopping_pair_matrix(:,:)
	endif ! debug
	
	
	
	
	if(store_trajectory .OR. calc_pathway)then
		outputfrequency = runtime/10
		outputstepfrequency=0
		!!reset_pathway_at_initial_site=.true.
		xyz_trajectoryfilename=KMC_setup%xyz_trajectoryfilename
		open(unit=70,file=TRIM(xyz_trajectoryfilename),status='replace',action='write',iostat=ierror)
		
		if(calc_pathway) then
			pathway_found=.false.
			stopcondition = "steps"
			outputstepfrequency=1
			dr_dI_xyz_trajectoryfilename='dr_dI_'//TRIM(xyz_trajectoryfilename(:LEN_TRIM(xyz_trajectoryfilename)-4))//'.dat'
			open(unit=80,file=TRIM(dr_dI_xyz_trajectoryfilename),status='replace',action='write',iostat=ierror)
			inquire(file=TRIM(KMC_setup%votca_sql_name),exist=file_available)
			IF(file_available) THEN
							
							CALL Read_boxsize_from_sql(votca_sql_name,xbox,ybox,zbox) !!! Output in Angstroem
							box_x=Real(xbox*Ang2m,8)
							box_y=Real(ybox*Ang2m,8)
							box_z=Real(zbox*Ang2m,8)
							write(*,*) 'Box: ',box_x,box_y,box_z,' [m]'
			ELSE !! dummy settings 
							box_x=13.90228*1D-9  !m 
							box_y=26.96753*1D-9  !m 
							box_z=14.58116*1D-9  !m 
			ENDIF
			
			!! Select pathway direction via field direction.
			if( abs(fieldX) == 0 ) then
				box(1)=box_x*20
			else
				box(1)=box_x
			endif
			if( abs(fieldY) == 0 ) then
				box(2)=box_y*20
			else
				box(2)=box_y
			endif
			if( abs(fieldZ) == 0 ) then
				box(3)=box_z*20
			else
				box(3)=box_z
			endif

		endif !calc_pathway
	end if
	
	number_of_nodes=size(node)
	
	lio=TRIM(make_lio())//TRIM(str(KMC_setup%set_seed))
	IF(KMC_setup%set_seed == 0) THEN
		call init_random_seed()
		call RANDOM_NUMBER(HARVEST)
	ELSE
		write(*,*) 'Set seed: ',KMC_setup%set_seed
		allocate(seed(int(KMC_setup%set_seed)))
		! set seed(:) somehow
		seed=KMC_setup%set_seed
		call random_seed(put=seed)
		call RANDOM_NUMBER(HARVEST)
	END IF
		
	write(*,*) 'initialize with random number:  ',HARVEST
	if(.true.) then
			 write(*,*) '------- KMC start settings ------------------------------'
			 write(*,*) ' Algorithm: VSSM for Multiple Charges     '
			 write(*,'(A22,I12)')        '  numberofcharges:    ',numberofcharges
			 write(*,'(A22,I12)')        '  number_of_nodes:    ',number_of_nodes
			 write(*,'(A22,A12)')        '  carriertype:        ',TRIM(carriertype)
			 write(*,'(A22,3ES12.4,A6)') '  field:              ',fieldX,fieldY,fieldZ,' [V/m]'
			 write(*,'(A22,1ES12.4)')    '  maxsteps:           ',REAL(maxsteps)
			 write(*,'(A22,1ES12.4)')    '  runtime:            ',runtime
			 write(*,'(A22,A12)')        '  stopcondition:      ',TRIM(stopcondition)
			 write(*,'(A22,1ES12.4)')    '  outputtime:         ',outputtime
			 write(*,'(A22,1ES12.4)')    '  nexttrajoutput:     ',nexttrajoutput
			 
			 write(*,*) '  injectionmethod:    ', TRIM(injectionmethod)
			 write(*,*) '  set seed: ',KMC_setup%set_seed
			 write(*,*) '  store_trajectory: ',store_trajectory
			 write(*,*) '  print_trajectory.csv: ',printtrajcsv
			if(printtrajcsv .and. store_trajectory) then
			 write(*,*) '  trajectoryfilename: ',TRIM(trajectoryfilename)
			endif
			if(store_trajectory) then
				write(*,*) '  xyz_trajectoryfilename: ',TRIM(xyz_trajectoryfilename)
			endif
			if(unite_notes_for_kmc)then
				write(*,*) '  unite_notes_for_kmc: ',unite_notes_for_kmc
				write(*,*) '  unite_nodes_with_same_type: ',KMC_setup%unite_nodes_with_same_type
				write(*,'(A35,F10.2)') '   unite relative rate cutoffk1k2: ',KMC_setup%cutoffk1k2
			endif
			 
			if(calc_pathway) then
				write(*,*) 'dr_dI_xyz_trajectoryfilename:  ',TRIM(dr_dI_xyz_trajectoryfilename)
				write(*,*) 'reset_pathway_at_initial_site: ',reset_pathway_at_initial_site
				write(*,*) 'outputstepfrequency:           ',outputstepfrequency
			endif

			if(kmcmetadynamics)then
				write(*,*) ' +++ Use kmc metadynamics  +++ '
				write(*,'(A42,1ES12.4)') ' alpha = exp{ - 1 / (kB T) } =',kmcmetadynamics_alpha
			endif
			 write(*,*) '---------------------------------------------------'
	end if
    
    

    !! Injection

    deltaE = 0
    energypercarrier=0
    totalenergy = 0
    !! pathway: count the number of reset for the charge at the initial position.
    N_reset_pathway=0

	ALLOCATE(forbidden_nodes(number_of_nodes))
	ALLOCATE(forbidden_dests(number_of_nodes))
	ALLOCATE(occP(number_of_nodes))
	occP=0.0
	forbidden_nodes=0
	n_forbidden_nodes=0
	forbidden_dests=0
	n_forbidden_dests=0
	

	if (TRIM(stopcondition) == "runtime") then
			if( (abs(runtime-0.0E0) > 1.0E2))then
				stopcondition = "steps"
				maxsteps =INT(runtime,8)
				write(*,*) "stop condition: " , maxsteps , " steps." 
				write(*,*) "(If you specify runtimes larger than 100 kmcmultiple assumes that you are specifying the number of steps.)"
			else
				stopcondition = "runtime"
				write(*,*) "stop condition: ", runtime , " seconds runtime."
				write(*,*) "(If you specify runtimes larger than 100 kmcmultiple assumes that you are specifying the number of steps.)"
			endif !! runtime
	endif 

    
    if(numberofcharges > number_of_nodes) then
        write(*,*) "ERROR in kmcmultiple: specified number of charges is greater than the number of nodes."
        write(*,*) "This conflicts with single occupation."
		call exit(1)
    endif
    
	if( printtrajcsv .and. store_trajectory) then
		open(unit=500,file=TRIM(trajectoryfilename),status='replace',action='write',iostat=ierror)
		write(*,*) "Writing trajectory to " , trim(trajectoryfilename), "."
	endif
	
    if(outputtime > casi_zero ) then  !! outputtime /= 0
        bashline=" time[s]  "
        do i=1,numberofcharges
            bashline=TRIM(bashline)//" carrier"//TRIM(str(i))//"_x"   
            bashline=TRIM(bashline)//" carrier"//TRIM(str(i))//"_y"    
            bashline=TRIM(bashline)//" carrier"//TRIM(str(i))//"_z"   
            if(i==numberofcharges)then      
				if( printtrajcsv .and. store_trajectory) then
	              write(500,*) TRIM(bashline)
	            endif
            endif
        enddo
    endif	
    




    
	!!----------------------------------------------------------------------------------------------------
	!!! Start: Initialize list of charge carrieres
	allocate(startposition(numberofcharges,3))
	allocate(startpositionid(numberofcharges))
	allocate(carrier(numberofcharges))
	write(*,*) "looking for injectable nodes..." 

	if( TRIM(injectionmethod) == 'injection_segment_type' ) then
		j=0
		do i=1,number_of_nodes
			if(node(i)%injectable == 1) then
				if(  TRIM(ADJUSTL(KMC_setup%injection_segment_type)) == TRIM(ADJUSTL(node(i)%node_name)) ) then
					j=j+1
					node(i)%injectable=1
				else 
					node(i)%injectable=0
				endif
			endif ! injectable ?
		enddo ! number_of_nodes
		if( (j==0) .or. (j < numberofcharges)) then
			write(*,*) 'injection_segment_type: ',trim(KMC_setup%injection_segment_type)
			write(*,*) 'Error: injectionmethod="injection_segment_type" selected and no appropiate starting site found'
			call exit(1)
		else
			write(*,*) 'Use  injection_segment_type:  ',trim(KMC_setup%injection_segment_type),'  and ',j,' possible sites found.'
		endif
	endif ! injection_segment_type
	
	do i=1,numberofcharges  	 
		new_Chargecarrier%id = i
		if( TRIM(injectionmethod) == 'injection_node' ) then
			write(*,*) 'selection start id: ',injectionnode
			node_id=injectionnode
			if( (injectionnode > number_of_nodes) .or. (injectionnode < 0) ) then
				write(*,*) 'Error: injectionnode is out of range: ',injectionnode
				call exit(1)
			endif
		else if( TRIM(injectionmethod) == 'injection_node_list' ) then
			write(*,*) 'selection start id: ',injectionnodelist(i)
			if( (injectionnodelist(i) > number_of_nodes) .or. (injectionnodelist(i) < 0) ) then
				write(*,*) 'Error: injectionnodelist is out of range: ',injectionnodelist(i) 
				call exit(1)
			endif
			node_id=injectionnodelist(i)
		else if( TRIM(injectionmethod) == 'random' ) then
			node_id=get_random_node_id(number_of_nodes)
		else ! random
			node_id=get_random_node_id(number_of_nodes)
		end if
		new_Chargecarrier%node = node(node_id)
		ininterval = 1
		if ( TRIM(injectionmethod) == 'equilibrated') then
			ininterval = 0
		endif
		if(debug) write(*,*) 'new_Chargecarrier%node%occupied: ', new_Chargecarrier%node%occupied
		if(debug) write(*,*) 'new_Chargecarrier%node%injectable: ', new_Chargecarrier%node%injectable
		if(debug) write(*,*) 'node(new_Chargecarrier%node%id)%injectable: ',node(new_Chargecarrier%node%id)%injectable

		do while( (node(new_Chargecarrier%node%id)%occupied == 1) .OR. &
				& (node(new_Chargecarrier%node%id)%injectable /= 1) .OR. (ininterval /= 1) )
			!! maybe already occupied? or maybe not injectable?
			!! select node with a random number	
				node_id=(get_random_node_id(number_of_nodes))
				new_Chargecarrier%node = node(node_id) 
			if( TRIM(injectionmethod) == "equilibrated") then
				   !! check if charge is in the acceptance interval
					if( (new_Chargecarrier%node%siteenergy >= energypercarrier-0*deltaE ) .AND. &
					  & (new_Chargecarrier%node%siteenergy <= energypercarrier+2*deltaE ) .AND. &
					  & (new_Chargecarrier%node%occupied == 0) .AND. &
					  & (new_Chargecarrier%node%injectable == 1) ) then
						ininterval = 1
					endif 
				
			endif !injectionmethod == "equilibrated"?
		enddo !! already occupied or node not injectable?
		!! write(*,*) "selected segment " , newCharge&node&id , " which has energy " , newCharge%node%siteenergy , " within the interval [", energypercarrier-0*deltaE , ", " , energypercarrier+2*deltaE ,"]"
		new_Chargecarrier%node%occupied = 1
		node(new_Chargecarrier%node%id)%occupied = 1
		node(new_Chargecarrier%node%id)%injectable = 0
		new_Chargecarrier%dr_travelled =(/0.0, 0.0, 0.0/)
		new_Chargecarrier%dI_travelled =(/0.0, 0.0, 0.0/)
		do k=1,3        
			startposition(i,k) = new_Chargecarrier%node%position(k)
		enddo
		startpositionid(i)= new_Chargecarrier%node%id
		! visited nodes by a charge carrier
		if( .not. allocated(new_Chargecarrier%nodevisited) ) then ! allocate array for visited nodes
			allocate(new_Chargecarrier%nodevisited(number_of_nodes))
		endif
		new_Chargecarrier%nodevisited=0
		
		
		write(*,*) "starting position for charge " , i , ": segment " , new_Chargecarrier%node%id, &
				& ' destinations:',new_Chargecarrier%node%event(1:new_Chargecarrier%node%event_size)%destination
		carrier(i)=new_Chargecarrier
    enddo ! numberofcharges initalize charges  
	
    !!! End: Initialize list of charge carrieres
    !!----------------------------------------------------------------------------------------------------

	write(*,*) "End initialize"
	do i=1,numberofcharges
			write(*,*) carrier(i)%node%id,carrier(i)%node%position
	enddo 
	
	
	
	!!!!----------------------------------------------------------------------------------------------------
    !!! Start kmc VSSM (variable step size method)
    !!!!----------------------------------------------------------------------------------------------------
    simtime=0
    step=0
    nextoutput = outputfrequency
    nextstepoutput = outputstepfrequency


    write(*,*) " Start kmc VSSM (variable step size method)"
	do while((TRIM(stopcondition) == "runtime" .AND. simtime < runtime) .OR. (TRIM(stopcondition) == "steps" .AND. step < maxsteps))

		cumulated_rate = 0.0
		if( explicitcoulomb) THEN
				WRITE(*,*) "explicitcoulomb not implemented"
				CALL EXIT(1)
				!KMCMultiple::RateUpdateCoulomb(node,carrier,coulomb);
		endif

		DO i=1,numberofcharges 
			cumulated_rate =  cumulated_rate +  carrier(i)%node%EscapeRate
		END DO !! calcualte cumulated rate 

		if(abs(cumulated_rate) < casi_zero) THEN  ! abs(cumulated_rate) == 0
			!!  this should not happen: no possible jumps defined for a node
			WRITE(*,*) "ERROR in kmcmultiple: Incorrect rates in the database file. All the escape rates for the current setting are 0."
			CALL EXIT(1)
		end if

        !! go forward in time
		dt = 0.0
		CALL RANDOM_NUMBER(HARVEST)
		rand_u = 1.0d0-REAL(HARVEST,8)
		do while(rand_u < casi_zero )  !!! while(rand_u == 0)
				WRITE(*,*) "WARNING: encountered 0 as a random variable! New try." 
				CALL RANDOM_NUMBER(HARVEST)
				rand_u = 1.0d0-REAL(HARVEST,8)
		end do 
		dt = -1.0d0 / cumulated_rate * log(rand_u)
		simtime = simtime + dt
		if(debug) then
			WRITE(*,*)  "simtime = ",simtime,' + ', dt
		endif !debug

		step = step + 1

		!! advance time vor every charge carrier        
		do i=1,numberofcharges 
				!! carrier(i)%node%occupationtime = carrier(i)%node%occupationtime + dt
				node(carrier(i)%node%id)%occupationtime = node(carrier(i)%node%id)%occupationtime + dt
		enddo 

        !! ResetForbidden(forbiddennodes)
		forbidden_nodes=0
		n_forbidden_nodes=0        
        
        level1step = 0
        
       
        !!!------------------------------
        !! LEVEL 1
        !!!------------------------------
        do while(level1step == 0)    
            
		!! determine which electron will escape

		CALL RANDOM_NUMBER(HARVEST)
		u = 1.0d0-REAL(HARVEST,8)          
		do i=1,numberofcharges 
				
				u = u - carrier(i)%node%EscapeRate/cumulated_rate
				if(u <= 0)then
							do_oldnode = carrier(i)%node
							do_affectedcarrier = carrier(i)
							EXIT !break
				endif
				do_oldnode = carrier(i)%node
				do_affectedcarrier = carrier(i)
		enddo
				
            !! double maxprob = 0.;
            !! double newprob = 0.;
            !! myvec dr;
		if(debug) then
			WRITE(*,*)"Charge number ",do_affectedcarrier%id," which is sitting on segment ",do_oldnode%id," will escape!"
		endif !debug		
		if(Forbidden(do_oldnode%id, forbidden_nodes, n_forbidden_nodes) == 1)then
			continue
		endif !forbidden
  
      
            !! determine where it will jump to
            !!  ResetForbidden(forbiddendests)
			n_forbidden_dests=0
			forbidden_dests=0            
			
			do while(.true.) !! Level2
				!!!------------------------------
				!! LEVEL 2
				!!!------------------------------
				if(debug)then
					write(*,*) " There are ", do_oldnode%event_size, " possible jumps for this charge:"
					write(*,*) " Possible destinations: ",do_oldnode%event(1:do_oldnode%event_size)%destination
				endif

				do_newnode_NULL=.true.
				!! nullify(do_newnode) 
				CALL RANDOM_NUMBER(HARVEST)
				u = 1.0d0-REAL(HARVEST,8) 

				do j= 1, int(do_oldnode%event_size)  !do_oldnode%event_size 
					j_jump=j
					if(debug)then
						write(*,*) " destination: ",do_oldnode%event(j)%destination ,do_oldnode%event(j)%rate,&
						&do_oldnode%event(j)%rate/do_oldnode%EscapeRate , do_oldnode%event_size
	
						!write(*,*) " rate: ",do_oldnode%event(j)%rate 
					endif !debug 
					u = u - do_oldnode%event(j)%rate/do_oldnode%EscapeRate
					if(u <= 0) then
											do_newnode = node(do_oldnode%event(j)%destination)
											dr = do_oldnode%event(j)%dr
											dI = do_oldnode%event(j)%current
											do_newnode_NULL=.false.
											EXIT
					endif ! u <= 0
					do_newnode = node(do_oldnode%event(j)%destination)
					!do_newnode_NULL=.false.
					dr = do_oldnode%event(j)%dr
					dI = do_oldnode%event(j)%current
				enddo !j
				

				
				if(.false.) then
				anteil_k_max=0.0
				do j=1, int(do_oldnode%event_size)
					if ( anteil_k_max < do_oldnode%event(j)%rate/do_oldnode%EscapeRate ) then
						k_max=j
						anteil_k_max=do_oldnode%event(j)%rate/do_oldnode%EscapeRate
					endif
				end do 

					!!! differen index, ziel_id(k_max), rate(k_max)  , anteil p(k_max)/p_escape 
					!!!              ziel_id(k_jump),   rate(k_jump) , anteil p(k_jump)/p_escape     ; |dr|
					if( step == 1) then
						write(80,*) ' old_node destination k_max:  rate(i_max)  rate/k_esc  jump_dest   k_jump  k_jump/k_esc '//&
						&' dr  |dr|   dI   |dI|'//&   
						&' dr_traveled  |dr_traveled|  dI_traveled  |dI_traveled|   ' !!! ' position[Ang] '
					else
						write(80,'(I3,I6,2ES12.4,I6,18ES12.4)') int(j_jump-k_max),&
						!write(80,*) int(j_jump-k_max),&
						& int(do_oldnode%event(k_max)%destination),&
						& do_oldnode%event(k_max)%rate,&
						& do_oldnode%event(k_max)%rate/do_oldnode%EscapeRate, &
						& int(do_oldnode%event(j_jump)%destination),&
						& do_oldnode%event(j_jump)%rate,&
						& do_oldnode%event(j_jump)%rate/do_oldnode%EscapeRate, &
						& dr,norm8(dr),dI,norm8(dI),&
						& carrier(do_affectedcarrier%id)%dr_travelled,&
						& norm8(carrier(do_affectedcarrier%id)%dr_travelled),&
						& carrier(do_affectedcarrier%id)%dI_travelled, &
						& norm8(carrier(do_affectedcarrier%id)%dI_travelled)
						!!! & do_oldnode%position(1)*1E+10,do_oldnode%position(2)*1E+10,do_oldnode%position(3)*1E+10
					endif
				endif !.false. == deaktivated


				
				if(debug) then
					write(*,*) '-------- start jump control tmp write --------'
					do k=1,do_newnode%event_size
						WRITE(*,'(I3,A5,A10,3I7,ES12.3,A10,3I6,ES12.3,f8.2)')  k,' tmp:', &  !! carrier(1)%node%id,carrier(1)%node%event(k)%destination, do_oldnode%event_size,&									
						&  ' oldnode: ',do_oldnode%id, do_oldnode%event_size, do_oldnode%event(k)%destination, do_oldnode%event(k)%rate,    &
						&   'newnode: ',do_newnode%id, do_newnode%event_size, do_newnode%event(k)%destination, do_newnode%event(k)%rate, &
						&				(do_newnode%event(k)%rate/do_newnode%EscapeRate)*100
						!& , 'carrier:', carrier(1)%node%id, carrier(1)%node%event(k)%destination, carrier(1)%node%event_size
					!write(*,*) carrier(i)%node%event(1:carrier(i)%node%event_size)
					enddo
					write(*,*) '-------- end tmp write --------'       
				endif !debug


				if(do_newnode_NULL )then  !!! .or. (.not. associated(do_newnode)) 
					if(debug)then 
						write(*,*) " Node ",do_oldnode%id," is SURROUNDED "
						write(*,*) " by forbidden destinations and zero rates. Adding it to the list of forbidden nodes." 
						write(*,*) " After that: selection of a new escape node."
					endif
					
					!  AddForbidden(do_oldnode%id, forbiddennodes)
					n_forbidden_nodes=n_forbidden_nodes+1
					forbidden_nodes(n_forbidden_nodes)=do_oldnode%id
					
					!! int nothing=0;
					EXIT !!break; !! select new escape node (ends level 2 but without setting level1step to 1)
				endif !do_newnode == NULL
				
				if(debug)then
						write(*,*)  "Selected jump: ",do_newnode%id
				endif !debug
				
				!! check after the event if this was allowed
				!if(Forbidden(do_newnode%id, forbiddendests) == 1)then
				if(Forbidden(do_newnode%id, forbidden_dests, n_forbidden_dests) == 1)then
					if(debug) then
						write(*,*)  "Node " ,do_newnode%id," is FORBIDDEN. Now selection new hopping destination."
					endif !debug
					!!! Reduce the list
					!! block id from the oldnode
					if( .not. calc_VOTCA_style) then
						blocked_forbidden_id=do_newnode%id
						call block_event_from_event_list(blocked_forbidden_id, do_oldnode)
					endif
					continue
				end if ! Forbidden

				!! if the new segment is unoccupied: jump; if not: add to forbidden list and choose new hopping destination
				
				if( (node(do_newnode%id)%occupied == 1) )then  !!  do_newnode%occupied == 1
					
					!if(Surrounded(do_oldnode, forbiddendests) == 1) then
					if( Surrounded(do_oldnode, forbidden_dests, n_forbidden_dests) == 1) then
						
						if(debug)then 
								write(*,*) "Node ",do_oldnode%id, " is SURROUNDED by forbidden destinations."
								write(*,*) "Adding it to the list of forbidden nodes. After that: selection of a new escape node." 
								!! AddForbidden(do_oldnode%id, forbiddennodes)
								n_forbidden_nodes=n_forbidden_nodes+1
								forbidden_nodes(n_forbidden_nodes)=do_oldnode%id								
								EXIT !!!break; // select new escape node (ends level 2 but without setting level1step to 1)
						endif ! debug
					endif 
					
				    if(debug)then 
						write(*,*) "Selected segment: ",do_newnode%id," is already OCCUPIED. Added to forbidden list."
					endif ! debug
						
					!!   AddForbidden(do_newnode%id, forbiddendests)
					n_forbidden_dests=n_forbidden_dests+1
					forbidden_dests(n_forbidden_dests)=do_newnode%id
					!! block id from the oldnode
					blocked_forbidden_id=do_newnode%id
					if(debug)write(*,*) 'blocked_forbidden_id: ',blocked_forbidden_id
					if( .not. calc_VOTCA_style) then
						call block_event_from_event_list(blocked_forbidden_id, do_oldnode)
					endif
				    if(debug)then
							write(*,*) "Now choosing different hopping destination."
					endif
					continue !! select new destination
				
				else ! do_newnode%occupied /= 1
							
							!do_newnode%occupied = 1
							!do_oldnode%occupied = 0
							
							node(do_newnode%id)%occupied = 1
							node(do_oldnode%id)%occupied = 0
							!do_affectedcarrier%node = do_newnode
							!do_affectedcarrier%dr_travelled = do_affectedcarrier%dr_travelled + dr
							carrier(do_affectedcarrier%id)%node = do_newnode
							carrier(do_affectedcarrier%id)%dr_travelled = carrier(do_affectedcarrier%id)%dr_travelled + dr
							carrier(do_affectedcarrier%id)%dI_travelled = carrier(do_affectedcarrier%id)%dI_travelled + dI
							
							if( carrier(do_affectedcarrier%id)%nodevisited(do_newnode%id) == 0) then 
								carrier(do_affectedcarrier%id)%nodevisited(do_newnode%id)=1
							endif ! visited nodes
							
							
							
							
							
							!! Add jump A to B to matrix to count hoppings /transitions => hopping_pair_matrix(A,B) = hopping_pair_matrix(A,B) + 1
							grid%hopping_pair_matrix(node(do_oldnode%id)%node_type_id, node(do_newnode%id)%node_type_id)= &
								 & grid%hopping_pair_matrix(node(do_oldnode%id)%node_type_id, node(do_newnode%id)%node_type_id) + 1
							

							!WRITE(*,*) 'TMP grid: ',grid%hopping_pair_matrix(node(do_oldnode%id)%node_type_id, node(do_newnode%id)%node_type_id)
							!write(*,*) 'TMP jump  affected id:',do_affectedcarrier%id,'  <new:',do_newnode%id,' old:',do_oldnode%id
							
							!! count intramolecular hopping 
							if(do_oldnode%event(j_jump)%intramolecular) then
								grid%N_jumps_intramolecular = grid%N_jumps_intramolecular + 1
								!! Add jump A to B to matrix to count intramolecular hoppings / transitions => hopping_pair_matrix(A,B) = hopping_pair_matrix(A,B) + 1
								grid%hopping_pair_matrix_intra(node(do_oldnode%id)%node_type_id,node(do_newnode%id)%node_type_id)=&
								& grid%hopping_pair_matrix_intra(node(do_oldnode%id)%node_type_id,node(do_newnode%id)%node_type_id)+1
							else
								!! count intermolecular hopping 
								grid%N_jumps_intermolecular = grid%N_jumps_intermolecular + 1
							endif 
							
							!! KMC meta dynamics
							if(kmcmetadynamics) then
								!!! Update rates  outgoing
								do l=1,node(do_oldnode%id)%event_size
									node(do_oldnode%id)%event(l)%rate=  node(do_oldnode%id)%event(l)%rate * kmcmetadynamics_alpha
								enddo
								!!! Update rates incoming
								do l=1,node(do_oldnode%id)%event_size
									destination = node(do_oldnode%id)%event(l)%destination
									do m=1, node(destination)%event_size
										if( node(destination)%event(m)%destination == do_oldnode%id ) then
											node(destination)%EscapeRate = node(destination)%EscapeRate &
																	  &- (1-kmcmetadynamics_alpha) * node(destination)%event(m)%rate 
																	  
											node(destination)%event(m)%rate= node(destination)%event(m)%rate * kmcmetadynamics_alpha
											
										endif 
									end do 
								enddo
								!!! Update escape rate
								node(do_oldnode%id)%EscapeRate = node(do_oldnode%id)%EscapeRate * kmcmetadynamics_alpha
								
								
							endif !kmcmetadynamics
							
							
							!do k=1,number_of_nodes
							!	if( node(k)%occupied == 1) then
							!			write(*,*) 'occupied: ',node(k)%id,node(k)%occupied
							!	endif 
							!enddo 
							level1step = 1
							if(debug) then
								write(*,*) "Charge has jumped to segment: ",do_newnode%id, "."
							endif
							EXIT !!break; // this ends LEVEL 2 , so that the time is updated and the next MC step started
							
				endif ! occupied

			!! END LEVEL 2
			end do !END LEVEL 2
		!! END LEVEL 1
		end do !LEVEL 1    


    
		if( (abs(outputtime) > casi_zero) .AND. (simtime > nexttrajoutput) ) then    !! output the trajectory::    outputtime /= 0
			
			nexttrajoutput = simtime + outputtime
			if( printtrajcsv .and. store_trajectory) then
				write(500,*)  simtime   !!!traj << simtime << "\t";
				do i=1,numberofcharges 
					write(500,*)  startposition(i,1) + carrier(i)%dr_travelled(1)	!!getX() << "\t";
					write(500,*)  startposition(i,2) + carrier(i)%dr_travelled(2)	!!getY() << "\t";
					write(500,*)  startposition(i,3) + carrier(i)%dr_travelled(3)	!!getZ();
					
					if (i < numberofcharges-1) then
					
						write(500,*)" "
					else
						write(500,*)" "  !!!traj << endl;
					endif
				enddo 
			endif ! printtrajcsv .and. store_trajectory
		endif !! output the trajectory
		
		
		if((stopcondition == "runtime") .AND. (simtime > nextoutput)) then
			nextoutput = simtime + outputfrequency
			write(*,*) '  remaining time: ',runtime-simtime
			write(*,*) "printtime(int((runtime/simtime-1) * (int(time(NULL)) - realtime_start))); "
        else if((stopcondition == "steps") .AND.  (step > nextstepoutput)) then
			nextstepoutput = step + outputstepfrequency
			!progressbar(double(step)/double(maxsteps));
			
			if(debug) write(*,*) '  remaining steps: ', maxsteps-step
			
			if(store_trajectory) then
					if(calc_pathway) then 
					do l=1,numberofcharges
						if( carrier(l)%node%id == startpositionid(l) ) then  !!! Charge is back at initial side?
							do k=1,3 ! box_x, box_y, box_z
							!write(*,*) 'tmp: l=',l,'check path: ',abs(carrier(l)%dr_travelled(k)), " >=", box(k) 
							if ( abs(carrier(l)%dr_travelled(k)) >= box(k) ) then !!! calc_pathway crossed the box?
									!//TRIM(Real2str(average_mobility(2)))  
									bashline=' path_data_all: '
									write(*,*) ' remaining steps: '//TRIM(str(int(maxsteps-step)))
									bashline=TRIM(bashline)//' remaining steps: '//TRIM(str(int(maxsteps-step)))
									write(*,*) ' steps done: '//TRIM(str(int(step)))
									bashline=TRIM(bashline)//' steps done: '//TRIM(str(int(step)))
									write(*,*) ' Charge '//TRIM(str(l))//' crossed the box with ',box(k)*1E+10,' [Ang]'
									bashline=TRIM(bashline)//" Charge "//TRIM(str(l))// " crossed the box with "//&
											&TRIM(Real8str(box(k)*1E+10))//' [Ang]'
									write(*,*) " Start Position: ", "O", startposition(l,:)*1E+10
									bashline=TRIM(bashline)//" Start Position:  "
									do m=1,3
										bashline=TRIM(bashline)//"  "//TRIM(Real8str(startposition(l,m)*1E+10))
									enddo
									write(*,*) " End   Position:" ,  "O",carrier(l)%node%position(1:3)*1E+10
									bashline=TRIM(bashline)//" End Position: "
									do m=1,3
										bashline=TRIM(bashline)//" "//TRIM(Real8str(carrier(l)%node%position(m)*1E+10))
									enddo
									write(*,*) "   dr_travelled: ", carrier(l)%dr_travelled(:)*1E+10
									bashline=TRIM(bashline)//"   dr_travelled: "
									do m=1,3
										bashline=TRIM(bashline)//" "//TRIM(Real8str(carrier(l)%dr_travelled(m)*1E+10))
									enddo 
									write(*,*) " |dr_travelled|: ", norm8(carrier(l)%dr_travelled)*1E+10
									bashline=TRIM(bashline)//" |dr_travelled|: "//TRIM(Real8str( norm8(carrier(l)%dr_travelled)*1E+10))
									
									write(*,*) "   dI_travelled: ", carrier(l)%dI_travelled(:)
									
									bashline=TRIM(bashline)//"   dI_travelled: "
									do m=1,3
										bashline=TRIM(bashline)//"   "//TRIM(Real8str(carrier(l)%dI_travelled(m)))
									enddo 
									write(*,*) " |dI_travelled|: ", norm8(carrier(l)%dI_travelled)
									bashline=TRIM(bashline)//" |dI_travelled|: "//TRIM(Real8str(norm8(carrier(l)%dI_travelled) ))
									do i=1,numberofcharges
										write(*,*) i,norm8(carrier(i)%dI_travelled(:))," dI_travelled: ",carrier(i)%dI_travelled(:)
									enddo 
									
									write(80,*) TRIM(bashline)
									!!! TERMINATE kMC pathway finder, as a pathway was found.
									WRITE(*,*) 'TERMINATE kMC pathway finder, as a pathway was found!'
									pathway_found=.true.
									step=maxsteps
							endif
							enddo ! directions
							
							if(reset_pathway_at_initial_site .AND. (.NOT. pathway_found) ) then !! Start reset pathway
								if( carrier(l)%node%id == startpositionid(l) ) then
									IF(debug) write(*,*) 'Reset data for charge: ',carrier(l)%node%id
									N_reset_pathway=N_reset_pathway+1
									!! Reset dr, dI
									carrier(l)%dr_travelled= 0.0
									carrier(l)%dI_travelled= 0.0
									simtime=0
									carrier(l)%nodevisited=0
									do k=1,number_of_nodes
										node(k)%occupationtime = 0.0
									enddo
									!! Replace the trajectory file 
									CLOSE(70)
									open(unit=70,file=TRIM(xyz_trajectoryfilename),status='replace',iostat=ierror)
									CLOSE(80)
									open(unit=80,file=TRIM(dr_dI_xyz_trajectoryfilename),status='replace',action='write',iostat=ierror)
									if(debug) write(*,*) 'Replace: ',TRIM(xyz_trajectoryfilename)
								end if ! reset_pathway_at_initial_site
							endif !injectionnode ?
							
						endif  !!! Charge is back at initial side?
					enddo ! numberofcharges: l
					endif !calc_pathway
					

					write(70,*) numberofcharges
					write(70,*) " "
					do k=1,numberofcharges
							write(70,*) "O",carrier(k)%node%position(1:3)*1E+10  !!! convert back [m] to [angstroem]
					end do
					
					
			endif ! store_trajectory
			
			!write(*,*) ' printtime(int((double(maxsteps)/double(step)-1) * (int(time(NULL)) - realtime_start))); '
		endif !! stopcondition
    enddo  !!do while((stopcondition  !!! kmc loop!!
    !!progressbar(1.);
    
    !!!!----------------------------------------------------------------------------------------------------
    !!! END kmc VSSM (variable step size method)
    !!!!----------------------------------------------------------------------------------------------------


	!!!!----------------------------------------------------------------------------------------------------
	!!! Start kmc analysis 
    !!!!----------------------------------------------------------------------------------------------------    
    
    
    if( abs(outputtime) > casi_zero ) then    !! ( abs(outputtime) /= 0
		if( printtrajcsv .and. store_trajectory) then
			close(500)
			write(*,*) "traj.close() "
		endif
    endif

	!!!!!
	!!!!  calculate occupation probabilities from occupation times    
	do j=1,number_of_nodes
			occP(j) = node(j)%occupationtime / simtime / numberofcharges
    enddo !! node size
 
	!! Check if a model with united nodes (N1,N2) => UN1 was used. And evaluate the occupation numbers for N1 and N2 from the united node UN1
	!! Standard VSSM kmc does not use this option.
	if( (unite_notes_for_kmc).AND.(KMC_system%KMC_grid%number_of_united_nodes > 0) )then
		CALL update_occP_for_united_nodes(occP,KMC_system%KMC_grid%united_node_list)
	endif ! united_nodes
	
    write(*,*) "finished KMC simulation after " , step , " steps." 
    write(*,*) "simulated time " ,simtime ," seconds." 
    write(*,*) "runtime: ",runtime
   !! printtime(time(NULL) - realtime_start); 

    write(*,*) "Average velocities (m/s): " 
	dr_travelled=0.0
	DO i=1,numberofcharges 
		write(*,*) "    charge " , i , ": " , carrier(i)%dr_travelled/simtime , '(m/s)', carrier(i)%dr_travelled,'  (m)'
		!write(*,*) "    charge " , i , ": " , carrier(i)%dr_travelled/simtime 
		dr_travelled = dr_travelled + carrier(i)%dr_travelled
	ENDDO !! i=1,numberofcharges 

	dr_travelled = dr_travelled / numberofcharges
    
    
    !!! cout ,std::scientific ,"  Overall average velocity (m/s): " << dr_travelled/simtime*1e-9 << endl; !! old code if dr is in nm
     write(*,*) "  Overall average velocity (m/s): ", dr_travelled/simtime

    write(*,*) "Distances travelled (m): " 
	do i=1,numberofcharges 
		
		write(*,*)  "    charge ",i, ": ",carrier(i)%dr_travelled 
	end do 	!! numberofcharges 


    !!!! calculate mobilities
	absolute_field = sqrt(fieldX*fieldX + fieldY*fieldY + fieldZ*fieldZ)
	if ( absolute_field > casi_zero ) then !!!  absolute_field /= 0.0
	
		average_mobility=0.0
		fieldfactors=0.0
		IF(calc_VOTCA_style) THEN
				if (abs(fieldX) > casi_zero ) then  !! abs(fieldX) /= 0
					fieldfactors(1)=1.0E4/fieldX
				endif !x
				if (abs(fieldY) > casi_zero ) then
					fieldfactors(2)=1.0E4/fieldY
				endif !y
				if (abs(fieldZ) > casi_zero ) then
					fieldfactors(3)=1.0E4/fieldZ
				endif !z
		ELSE
				if (abs(fieldX) > casi_zero ) then
					fieldfactors(1)=1.0E4*fieldX / (absolute_field**2)
				endif !x
				if (abs(fieldY) > casi_zero ) then
					fieldfactors(2)=1.0E4*fieldY / (absolute_field**2)
				endif !y
				if (abs(fieldZ) > casi_zero ) then
					fieldfactors(3)=1.0E4*fieldZ / (absolute_field**2)
				endif !z
		END IF ! => Modified VOTCA bug

		write(*,*) "Mobilities (cm^2/Vs): "

		do i=1,numberofcharges 

			velocity = carrier(i)%dr_travelled/simtime
			do k=1,3   !  elementwiseproduct(velocity, fieldfactors)
				mobility(k) = velocity(k) * fieldfactors(k)  
			enddo 
			
			average_mobility = average_mobility + mobility
			!write(*,*) "    charge " , i , ": "
			bashline="    charge "//TRIM(str(i))//": "
			if (abs(fieldX) > casi_zero) then
				!write(*,*) "    charge "//TRIM(str(i))//": ","<muX>=" , TRIM(Real8str(mobility(1)))  
				bashline=TRIM(bashline)//" muX="//TRIM(Real8str(mobility(1)))  
			endif !x
			if (abs(fieldY) > casi_zero) then
				!write(*,*) "    charge "//TRIM(str(i))//": ","<muY>=" , TRIM(Real8str(mobility(2)))  
				bashline=TRIM(bashline)//" muY="//TRIM(Real8str(mobility(2))) 
			endif !y
			if (abs(fieldZ) > casi_zero) then
				!write(*,*) "    charge "//TRIM(str(i))//": ","<muZ>=" , TRIM(Real8str(mobility(3))) 
				bashline=TRIM(bashline)//" muZ="//TRIM(Real8str(mobility(3)))   
			endif !z
			write(*,*) TRIM(bashline)
			
		enddo !! do numberofcharges 
        
		if (numberofcharges /= 0) then
			bashline="  Overall average mobility "
			average_mobility = average_mobility / numberofcharges
			if (abs(fieldX) > casi_zero) then
				!write(*,*) "<muX>=" , average_mobility(1) 
				bashline=TRIM(bashline)//" <muX>="//TRIM(Real8str(average_mobility(1)))//'  '  
			endif
			if (abs(fieldY) > casi_zero) then
				!write(*,*) "<muY>=" , average_mobility(2)  
				bashline=TRIM(bashline)//" <muY>="//TRIM(Real8str(average_mobility(2)))//'  '    
			endif
			if (abs(fieldZ) > casi_zero) then
			    !write(*,*) "<muZ>=" , average_mobility(3)  
			    bashline=TRIM(bashline)//" <muZ>="//TRIM(Real8str(average_mobility(3)))//'  '    
			endif
			write(*,*) TRIM(bashline)
		endif !numberofcharges /= 0 , average mobilities
		
	endif  !!! field not zero.
	
	write(*,*) TRIM(bashline)//'  '//TRIM(xyz_trajectoryfilename)
	bashline=''
	do i=1,numberofcharges
			bashline='carrier '//TRIM(str(i))// ' resid visited nodes: '
			do j=1,number_of_nodes
				if( carrier(i)%nodevisited(j) == 1) then 
					bashline=TRIM(bashline)//' '//TRIM(str(j))
				endif
			enddo
			write(*,*) TRIM(bashline)//'  '//TRIM(xyz_trajectoryfilename)
			bashline=''
    enddo
    
	
	
	if(check_hopping_pair_composition) then 
		!write(*,*) ' '
		write(*,*) '--------------------------- hopping_pair_matrix --------------------------------'
		write(*,*) 'A \ B| ',(trim(grid%hopping_site_list(a))//'       ', a=1,grid%N_hopping_site_list)
		!write(*,*) ' '
		do a=1,grid%N_hopping_site_list
			write(*,*) trim(grid%hopping_site_list(a)),(int(grid%hopping_pair_matrix(a,b)), b=1,grid%N_hopping_site_list)
		end do
		!write(*,*) ' '
		
		write(*,*) '--------------------------- total normalized hopping_pair_matrix ----------------------'
		write(*,*) 'A \ B| ',(trim(grid%hopping_site_list(a))//'  ', a=1,grid%N_hopping_site_list)
		n_jumps=SUM(grid%hopping_pair_matrix)
		if( n_jumps == 0) then
			write(*,*) 'No intermolecular charge transfer:  n_jumps=',n_jumps
		else
			do a=1,grid%N_hopping_site_list
				write(*,*) trim(grid%hopping_site_list(a)),&
				& (percent(Real(grid%hopping_pair_matrix(a,b),8)/Real(n_jumps,8)), b=1,grid%N_hopping_site_list)  !!! implicit loop
			end do
		endif 
		write(*,*) '-----------------------------------------------------------------------------------'
		
		
		
		write(*,*) '--------------------------- normalized hopping_pair_matrix INTRA molecular ----------------------'
		write(*,*) 'A \ B| ',(trim(grid%hopping_site_list(a))//'  ', a=1,grid%N_hopping_site_list)
		n_jumps=SUM(grid%hopping_pair_matrix_intra)
		if( n_jumps == 0) then
			write(*,*) 'No intramolecular charge transfer:  n_jumps=',n_jumps
		else
			do a=1,grid%N_hopping_site_list
				write(*,*) trim(grid%hopping_site_list(a)),&
				& (percent(Real(grid%hopping_pair_matrix_intra(a,b),8)/Real(n_jumps,8)), b=1,grid%N_hopping_site_list)  !!! implicit loop
			end do
		endif
		write(*,*) '-----------------------------------------------------------------------------------'
		
		
		
		if( n_jumps == 0) then
			write(*,*) 'No intramolecular charge transfer:  n_jumps=',n_jumps
		else
		
			n_jumps=SUM(grid%hopping_pair_matrix)-SUM(grid%hopping_pair_matrix_intra)
			write(*,*) 'Only intermolecular jumps: ',n_jumps
			write(*,*) '--------------------------- normalized hopping_pair_matrix INTER molecular ----------------------'
			write(*,*) 'A \ B| ',(trim(grid%hopping_site_list(a))//'  ', a=1,grid%N_hopping_site_list)

			if( n_jumps == 0) then
				write(*,*) 'No intramolecular charge transfer:  n_jumps=',n_jumps
			else
				do a=1,grid%N_hopping_site_list
					write(*,*) trim(grid%hopping_site_list(a)),&
					& (percent(Real(grid%hopping_pair_matrix(a,b)-grid%hopping_pair_matrix_intra(a,b),8)/Real(n_jumps,8)), &
					&   b=1,grid%N_hopping_site_list)  !!! implicit loop
				end do
			endif
		endif ! n_jumps == 0 ?
		
		write(*,*) '-----------------------------------------------------------------------------------'
		
		if( (grid%N_jumps_intermolecular > 0)  .AND. (grid%N_jumps_intramolecular > 0) ) then
			n_jumps=grid%N_jumps_intermolecular+grid%N_jumps_intramolecular
			write(*,*) ' N_jumps_intermolecular: ',grid%N_jumps_intermolecular,' N_jumps_intramolecular: ',grid%N_jumps_intramolecular
			write(*,*) ' N_jumps_intermolecular: ',percent(grid%N_jumps_intermolecular/Real(n_jumps,8)),'  %',&
					  &' N_jumps_intramolecular: ',percent(grid%N_jumps_intramolecular/Real(n_jumps,8)),'  %'
		endif ! inter vs. intra molecular jumps
		
		!! update the KMC_system
		call update_KMC_system_grid(grid)
	end if ! check_hopping_pair_composition   
    
    if(store_KMC_result) then
			KMC_result%number_of_nodes=number_of_nodes
			if( .not. allocated(KMC_result%occP)) then
				allocate(KMC_result%occP(number_of_nodes))
				KMC_result%occP=0
			endif
			do i=1,number_of_nodes
				KMC_result%occP(i)=occP(i)
			enddo
			KMC_result%fieldX=fieldX
			KMC_result%fieldY=fieldY
			KMC_result%fieldZ=fieldZ
			KMC_result%average_mobility=average_mobility
			KMC_result%runtime=runtime
			KMC_result%simtime=simtime
			KMC_result%numberofcharges=numberofcharges
			if( .not. allocated(KMC_result%carrier)) then
				allocate(KMC_result%carrier(numberofcharges))
			end if
			do j=1,numberofcharges
				KMC_result%carrier(j)=carrier(j)
			enddo
			
			p_occ_filename='p_occ_'//TRIM(KMC_setup%xyz_trajectoryfilename(:LEN_TRIM(KMC_setup%xyz_trajectoryfilename)-4))//'.dat'
			open(unit=91,file=TRIM(p_occ_filename),status='replace',action='write',iostat=ierror)
			write(91,*) '###  simtime: ',KMC_result%simtime
			do i=1,number_of_nodes
				write(91,'(1ES20.12)') KMC_result%occP(i)
			enddo
			close(91)
			
			!! update KMC_system
			call update_KMC_system_nodes(node)
			call KMC_system_Add_KMCResult(KMC_system, KMC_result)
			
	end if 
	
	if ( abs(SUM(occP)-1.0D0) > 1.0E-4)then
		write(*,*) 'Error: The occupations do not sum to 1.0 as one obtains: ',SUM(occP)
		call exit(1)
	endif
	

	if(calc_pathway) then
		write(*,*) 'N_reset_pathway: ',N_reset_pathway
	endif
	
	write(*,*) 'kmc_run_VSSM done.'
	return !!occP
	
END SUBROUTINE kmc_run_VSSM
!!!! END KMC FUNCTION: kmc_run_VSSM 





!! subroutine unite_notes_for_kmc
!! Input:
!! nodes
!! cutoff_k1_k2_unite_nodes%KMC_setup
!! unite_nodes_with_same_type%KMC_setup
!!
!! Output:
!! 
!!
!! Routine that unites two nodes with high k_12 <-> k_21 to a single node.
!! The initial node ids are N1 and N2.
!! We unite two nodes with the approximations for single dominating rates: $k_1^{esc} \approx k_12$ and $k_2^{esc} \approx k_21$ 
!! So the initial escape rates are dominated by a single jump.
!! The unification criterion is set by e.g. cutoff_k1_k2_unite_nodes=1000.  
!! a) All rates from N1 are ordered and the fraction of  (k_max / k_max-1) >  cutoff_k1_k2_unite_nodes
!! b) All rates from N2 are ordered and the fraction of  (k_max / k_max-1) >  cutoff_k1_k2_unite_nodes
!! c) Both sites need to be the same type node_type_id1 = node_type_id2   unite_nodes_with_same_type=T
!! -> if all criteria are accepted N1 and N2 are united to a new node N1*.
!! The new node N1* is set to N1 and translated to the geometric center between N1 and N2. (using periodic boundary conditions)
!! All incoming rates to N2 form nearest neighbours NN are redirected to N1*.    NN -> N2 united NN-->N1*
!! The rate from N1* to a neighboring node i is evaluated as: 
!! $k_{N1*i} =  a1 * k_{1i}    +   a2 *k_{2i}$
!! with $a1 = 1/k_1^{esc} / ( 1/k_1^{esc} + 1/k_2^{esc} )  = k_21 / ( k_12 + k_21) $
!! and  $a2 = 1/k_2^{esc} / ( 1/k_1^{esc} + 1/k_2^{esc} )  = k_12 / ( k_12 + k_21) $
!!
!! In N1* the rates k_12 and k_21 are deleted from the list of rates.
!! All escape rates are updated again.
!!
!! After the kMC simulation the occupation numbers are redistributed to the initial sites due to the factors a1 and a2.
!! occP_N1  = a1 * occP_N1* 
!! occP_N2  = a2 * occP_N1* 
!! It is done in subroutine update_occP_for_united_nodes
subroutine unite_notes_for_kmc(nodes, KMC_setup)
	use small_functions
	implicit none
	type (KMC_Node_t), ALLOCATABLE, DIMENSION(:)::nodes
	type (KMC_setup_t):: KMC_setup
	
	type(KMC_united_node_t), ALLOCATABLE, DIMENSION(:) :: united_node_list
	type(KMC_united_node_t)::new_united_node
	!! local variables
	real*8, allocatable, dimension(:)::rate_list1,rate_list2
	real*8::newEscapeRate
	real*8::rate_max,a1,a2
	!real*8::rate
	real::box_x,box_y,box_z
	integer::number_of_united_nodes
	real*8::cutoff_k1_k2_unite_nodes
	logical::unite_nodes_with_same_type
	integer::number_of_nodes,N1,N2
	integer::i,j,k,i_max1,i_max2,ind_j
	real*8,dimension(3) :: r_shift
	real,  dimension(3) :: vec
	real,  dimension(3) :: box
	real*8,PARAMETER::Ang2m=1.0D10
	logical::share_neighbour
	logical::debug
	
	debug=.false.
	write(*,*) '--- start unite_notes_for_kmc ---'
	cutoff_k1_k2_unite_nodes=KMC_setup%cutoffk1k2       !! 	k1 / k2 >  cutoffk1k2
	unite_nodes_with_same_type=KMC_setup%unite_nodes_with_same_type
	number_of_nodes=size(nodes)
	!!! get boxsize 
	CALL Read_boxsize_from_sql(KMC_setup%votca_sql_name,box_x,box_y,box_z) !!! Output in Angstroem
	box(1)=REAL(box_x*Ang2m,4)
	box(2)=REAL(box_y*Ang2m,4)
	box(3)=REAL(box_z*Ang2m,4)
	write(*,*) 'Boxsize in [m] ', box(1),box(2),box(3)
	
	!! 
	if(.not. allocated(united_node_list)) then
		allocate(united_node_list(number_of_nodes))
	endif
	
	number_of_united_nodes=0
	!! loop node N1
	loop_N1: do N1=1,number_of_nodes ! number_of_nodes
			
			!! create temporary list for all rates from node i
			ALLOCATE(rate_list1(nodes(N1)%event_size))
			i_max1=1
			rate_max=nodes(N1)%event(1)%rate 
			do j=1,nodes(N1)%event_size
				rate_list1(j)=nodes(N1)%event(j)%rate
				!write(*,'(I6,1ES12.4)') nodes(N1)%event(j)%destination, nodes(N1)%event(j)%rate
				if( rate_list1(j) > rate_max ) then
					rate_max=rate_list1(j)
					i_max1=j
				endif
			end do 
			
			if(debug) write(*,*)  'rate list N1: ',(rate_list1(j),j=1,nodes(N1)%event_size)
			call SortArray8(rate_list1,nodes(N1)%event_size)
			if(debug) write(*,*)  'sorted rate list N1: ',(rate_list1(j),j=1,nodes(N1)%event_size)
			if(debug) write(*,*) 'k_max/k_max-1:', rate_list1(nodes(N1)%event_size) / rate_list1(nodes(N1)%event_size-1),&
					& ' cutoff_k1_k2_unite_nodes: ',cutoff_k1_k2_unite_nodes
			
			
			
			if( rate_list1(nodes(N1)%event_size) / rate_list1(nodes(N1)%event_size-1) > cutoff_k1_k2_unite_nodes ) then
				!! Node N2
				N2=nodes(N1)%event(i_max1)%destination
				if((unite_nodes_with_same_type) .AND. (nodes(N1)%node_type_id /= nodes(N2)%node_type_id))then ! Check if two nodes have different node_type_id
					DEALLOCATE(rate_list1)
					write(*,*) 'CYCLE unite pair N1:',N1,' N2: ',N2
					cycle loop_N1
				endif
				ALLOCATE(rate_list2(nodes(N2)%event_size))
				i_max2=1
				rate_max=nodes(N2)%event(1)%rate 
				do j=1,nodes(N2)%event_size
					rate_list2(j)=nodes(N2)%event(j)%rate
					if( rate_list2(j) > rate_max ) then
						rate_max=rate_list2(j)
						i_max2=j
					endif
				enddo 
				if(debug) write(*,*) 'tmp: i_max2:',i_max2,' rate21:',nodes(N2)%event(i_max2)%rate
				call SortArray8(rate_list2,nodes(N2)%event_size)
				
				
				if( N1 == nodes(N2)%event(i_max2)%destination ) then 
					if(debug)write(*,*)'pair: ',N1,N2,' rate12:',nodes(N1)%event(i_max1)%rate,'rate21:',nodes(N2)%event(i_max2)%rate
					if( rate_list2(nodes(N2)%event_size) / rate_list2(nodes(N2)%event_size-1) > cutoff_k1_k2_unite_nodes  ) then
						number_of_united_nodes = number_of_united_nodes + 1
						
						a1=nodes(N2)%event(i_max2)%rate / ( nodes(N1)%event(i_max1)%rate + nodes(N2)%event(i_max2)%rate )
						a2=nodes(N1)%event(i_max1)%rate / ( nodes(N1)%event(i_max1)%rate + nodes(N2)%event(i_max2)%rate )
						WRITE(*,'(A20,2I6,A6,1ES12.4,A6,1ES12.4,A6,F8.4,A6,F8.4)') 'Unite the nodes ',N1,N2,' with ',&
								&nodes(N1)%event(i_max1)%rate,' <-> ',nodes(N2)%event(i_max2)%rate,' a1: ',a1,'  a2: ',a2
						if(debug) then
							write(*,*) 'dest N1:'!!,(nodes(N1)%event(j)%destination, j=1,nodes(N1)%event_size)
							do j=1,nodes(N1)%event_size
								write(*,'(I6,1ES12.4)')  nodes(N1)%event(j)%destination,nodes(N1)%event(j)%rate
							enddo
							write(*,*) 'dest N2:'!!,(nodes(N2)%event(j)%destination, j=1,nodes(N2)%event_size)
							do j=1,nodes(N2)%event_size
								write(*,'(I6,1ES12.4)')  nodes(N2)%event(j)%destination,nodes(N2)%event(j)%rate
							enddo
						endif ! debug
						
						!! Set data for united node
						new_united_node%id=number_of_united_nodes
						new_united_node%seg1=N1
						new_united_node%seg2=N2
						new_united_node%rate12=nodes(N1)%event(i_max1)%rate
						new_united_node%rate21=nodes(N2)%event(i_max2)%rate
						new_united_node%a1=a1
						new_united_node%a2=a2
						new_united_node%position1=nodes(N1)%position
						new_united_node%position2=nodes(N2)%position
						
						!! Start unite sites N1 and N2 on the geometric center for N1*
						r_shift=(nodes(N1)%position - nodes(N2)%position ) /2.0
						do k=1,3 !!! PBC correction
							if(r_shift(k) > box(k) ) then
								r_shift(k) = r_shift(k) - box(k)
							else if ( -1.0*r_shift(k) > box(k) ) then
								r_shift(k) = r_shift(k) + box(k)
							endif
						enddo
						
						!! Define new center
						vec = (nodes(N1)%position + nodes(N2)%position ) /2.0
						CALL position_PBC_correction(vec,box(1),box(2),box(3))
						nodes(N1)%position = vec
						new_united_node%position=vec
						
						!! Remove jump N1 -> N2
						call Node_RemoveEvent(nodes(N1), i_max1)
						!! Remove jump N2 -> N1
						call Node_RemoveEvent(nodes(N2), i_max2)
						
						!! node N2 is not injectable any more
						nodes(N2)%injectable=0
						
						!! UPDATE ALL rates at N1
						do i=1, nodes(N1)%event_size
							nodes(N1)%event(i)%rate = a1* nodes(N1)%event(i)%rate
							nodes(N1)%event(i)%dr   =  nodes(N1)%event(i)%dr  - r_shift
						enddo ! evert_size
						
						
						!! REPOINT ALL rates from N2 to N1*
						DO i=1,Number_of_nodes
							DO j=1,nodes(i)%event_size
								if( nodes(i)%event(j)%destination == N2 ) then
									!! Umlenken von N2 auf N1*
									!write(*,*) 'Repoint ',nodes(i)%id,'->',nodes(i)%event(j)%destination
									nodes(i)%event(j)%destination = N1
									nodes(i)%event(j)%dr = nodes(i)%event(j)%dr + r_shift
									!write(*,*) 'to ',nodes(i)%id,'->',nodes(i)%event(j)%destination,' with ',nodes(i)%event(j)%rate
								end if 
							END DO ! j events
						END DO !! POINT ALL rates from N2 to N1*

						
						
						!! ADD rates from N2 to N1 list
						loop_i: do i=1,nodes(N2)%event_size
							if( nodes(N2)%event(i)%destination == N1) then
									write(*,*) 'Error: the transition should be kicked out before!'
									cycle loop_i
							else
								share_neighbour=.false.
								!! Loop neighbours from N1
								loop_NN: DO j=1,nodes(N1)%event_size
									if( nodes(N1)%event(j)%destination == nodes(N2)%event(i)%destination) then
										ind_j=j
										share_neighbour=.true.
										EXIT loop_NN
									endif
								ENDDO loop_NN
								
								IF( share_neighbour ) THEN
									if(debug) write(*,*) 'share_neighbour: ',nodes(N1)%event(ind_j)%destination 
									nodes(N1)%event(ind_j)%rate   =  nodes(N1)%event(ind_j)%rate   +  a2* nodes(N2)%event(i)%rate 
									nodes(N1)%event(ind_j)%dr     =  nodes(N2)%event(i)%dr + r_shift
								ELSE
									 !Node_AddEvent(nodes(N1), seg2,  rate12,  dr,  Jeff2,  reorg_out)
									 CALL Node_AddEvent(nodes(N1), nodes(N2)%event(i)%destination, a2* nodes(N2)%event(i)%rate,  &
												  & nodes(N2)%event(i)%dr + r_shift, nodes(N2)%event(i)%Jeff2,  nodes(N2)%event(i)%reorg_out)
											  
									!! deactivate rate from N2
									nodes(N2)%event(i)%rate=0.0
								ENDIF ! Check of rate from N2  is already  in the list of N1
							endif ! pass jump to N1
						enddo loop_i
						
						if(debug) then
							write(*,*) 'New destinations N1: '
							do j=1,nodes(N1)%event_size
								write(*,'(I6,1ES12.4)')  nodes(N1)%event(j)%destination,nodes(N1)%event(j)%rate
							enddo
						endif !debug
						
						!! Append new united node to the list
						united_node_list(number_of_united_nodes) = new_united_node
					endif ! N2 -> N1 cutoff_k1_k2_unite_nodes 
				endif !! N2 -> N1 ??
				DEALLOCATE(rate_list2)
			endif !  N1 -> N2 cutoff_k1_k2_unite_nodes 
			
			
			
			DEALLOCATE(rate_list1)
	enddo loop_N1 !number_of_nodes
	
	
	!! UPDATE all escape rates
	do i=1,number_of_nodes
			newEscapeRate=0.0
			do j=1,nodes(i)%event_size
				newEscapeRate = newEscapeRate + nodes(i)%event(j)%rate
			enddo 
			nodes(i)%escaperate = newEscapeRate
	enddo 
	
	!! Reduce size of united_node_list
	if( .not. allocated(KMC_system%KMC_grid%united_node_list)) then
		ALLOCATE(KMC_system%KMC_grid%united_node_list(number_of_united_nodes))
		KMC_system%KMC_grid%number_of_united_nodes=number_of_united_nodes
	endif
	
	if( KMC_system%KMC_grid%number_of_united_nodes == number_of_united_nodes) then
		do i=1,number_of_united_nodes
			KMC_system%KMC_grid%united_node_list(i)=united_node_list(i)
		enddo
	else
		write(*,*) 'Error: Missmatch in the number_of_united_nodes: ',number_of_united_nodes
		call exit(1)
	endif
	
	
	if(debug) then
		write(*,*) '---  seg1  seg2    rate12    rate21 ---'
		do i=1,number_of_united_nodes
			write(*,'(2I8,2ES14.4)') united_node_list(i)%seg1,united_node_list(i)%seg2,&
									&united_node_list(i)%rate12,united_node_list(i)%rate21
		enddo
		write(*,*) '---'
	endif
	DEALLOCATE(united_node_list)
	write(*,*) ' Number of united nodes: ',number_of_united_nodes,'  from ',number_of_nodes
	write(*,*) '--- end unite_notes_for_kmc ---'

end subroutine unite_notes_for_kmc


!! Update the occupation number for the initial nodes seg1 and seg2 form the united node occP
!! After the kMC simulation the occupation numbers are redistributed to the initial sites due to the factors a1 and a2.
!! occP_N1  = a1 * occP_N1* 
!! occP_N2  = a2 * occP_N1* 
subroutine update_occP_for_united_nodes(occP,united_node_list)
	use small_functions
	implicit none
	real*8,allocatable,dimension(:)::occP
	type(KMC_united_node_t), allocatable, dimension(:)::united_node_list
	integer::number_of_united_nodes,i
	
	number_of_united_nodes=size(united_node_list)
    if(number_of_united_nodes /= 0) then
		do i=number_of_united_nodes,1,-1 !! reverse direction of construction, so decomposition is applied if more than 2 nodes are united.
			!write(*,*) 'A',occP(united_node_list(i)%seg1),occP(united_node_list(i)%seg2),united_node_list(i)%a1,united_node_list(i)%a2
			occP(united_node_list(i)%seg2) = united_node_list(i)%a2 * occP(united_node_list(i)%seg1)
			occP(united_node_list(i)%seg1) = united_node_list(i)%a1 * occP(united_node_list(i)%seg1)
			!write(*,*) 'B',occP(united_node_list(i)%seg1),occP(united_node_list(i)%seg2),united_node_list(i)%a1,united_node_list(i)%a2
		enddo
    endif
end subroutine update_occP_for_united_nodes



!! READ DATA FROM GROFILE
!! Subroutine to read the grofile data to gro_data_t
!!
SUBROUTINE read_grofile_data(gro_data,setup)
		use small_functions
		IMPLICIT NONE
		type (gro_data_t)  :: gro_data
		type (KMC_setup_t) :: setup
		
		CHARACTER(LEN=500)                             :: gro_inputfile
		Character(5), ALLOCATABLE, Dimension(:)        :: atomsorteA,residue_names
		REAL, ALLOCATABLE, DIMENSION(:,:)              :: koordA,vel
		INTEGER, ALLOCATABLE, DIMENSION(:)             :: residue_numbers,atom_numbers
		INTEGER, ALLOCATABLE, DIMENSION(:,:)           :: R_u_I
		INTEGER::Gesamtanzahl,N_Resids
		CHARACTER(LEN=500)::dummyname,line
		INTEGER::start_index,end_index

		INTEGER::N_DIPBI,N_PPDI,N_P3HT,N_P3HT_segments,N_PBDT_TS1,N_PBDT_TS1_segments,N_Species
		INTEGER::ierror
		CHARACTER(10) :: lio
		INTEGER::i,j,k,residue_number_old,residue_number
		CHARACTER(LEN=5000)::Bashline
		REAL::x_box,y_box,z_box
		!REAL::nm2Ang=10.0
		
		gro_inputfile=setup%gro_inputfile
		
		! Einlesen
		IF(file_exists(gro_inputfile)) THEN
			OPEN(UNIT=17,FILE=TRIM(gro_inputfile),STATUS='OLD',IOSTAT=ierror)
		ENDIF
		Read(17,*) dummyname                             !Einlesen des Infokopfes im File
		Read(17,*) Gesamtanzahl                          !Einlesen der Atomanzahl im File
			!!! Erstelle String lio=Durcheinander, um die Rechnungen mit Hilfe von Zufallszahlen einzigartig zu machen, sodass keine Interferenzen mit anderen Rechnungen ggf. im gleichen Ordner auftreten können. 
			lio=TRIM(make_lio())
			!! Einlesen der Anzahl der Resids=N_Mol aus gro-file
			Bashline="start_index=$(sed -n '3p' "//TRIM(gro_inputfile)//' | cut -c 1-5) ; end_index=$(tail -2 '//TRIM(gro_inputfile)//&
			&' | head -1 | cut -c 1-5) ; echo ${start_index}  ${end_index} >> s2e_'//TRIM(lio)//'.dat'  ! start 2 end 
			write(*,*) 'tmp: ',trim(Bashline) 
			CALL execute_command_line(TRIM(Bashline)) 
			OPEN(UNIT=32,FILE='s2e_'//TRIM(lio)//'.dat',STATUS='unknown',IOSTAT=ierror,action='read')
			READ(32,*) start_index,end_index
			CLOSE(32)
			Bashline=' rm s2e_'//TRIM(lio)//'.dat '
			CALL execute_command_line(TRIM(Bashline)) 

			N_Resids=end_index-start_index+1
			WRITE(*,*)'  N_Resids= ',N_Resids,' in ',TRIM(gro_inputfile)
			WRITE(*,*)'  N_Atoms=  ',Gesamtanzahl,' in ',TRIM(gro_inputfile)
		ALLOCATE(atomsorteA(Gesamtanzahl))
		ALLOCATE(koordA(Gesamtanzahl,3))
		ALLOCATE(vel(Gesamtanzahl,3))           ! velocities(:,v_x,v_y,v_z)
		ALLOCATE(R_u_I(N_Resids+1,2)) ! einen Eintrag mehr, damit an der letzten Stelle, der R_u_I: Resid_und_start_index(N_Resids,Gesamtanzahl+1,2) stehen kann, um die Schleifenbegrenzungen nicht anpassen zu muessen

		ALLOCATE(residue_names(Gesamtanzahl))
		ALLOCATE(residue_numbers(Gesamtanzahl))
		ALLOCATE(atom_numbers(Gesamtanzahl))


		!!! initialize system
		!call init_system(system)

		koordA=0.0
		vel=0.0
		R_u_I=0
		R_u_I(N_Resids+1,1)=-100
		R_u_I(N_Resids+1,2)=Gesamtanzahl+1
		residue_number_old=-1
		i=0
		N_DIPBI=0
		N_PPDI=0
		N_P3HT=0
		N_P3HT_segments=0
		N_PBDT_TS1=0
		N_PBDT_TS1_segments=0
		N_Species=0
		DO j=1,Gesamtanzahl
				READ(17, "(a)",IOSTAT=ierror) line
				BACKSPACE(UNIT=17)
				IF(ierror < 0) EXIT
				IF(ierror > 0) THEN
					WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(gro_inputfile),' aufgetreten.'//TRIM(line)
					WRITE(*,*) 'Beende Einlesen !'
					CALL EXIT (1)
				END IF
			!WRITE(*,*) 'laenge',LEN(TRIM(line)),' line: ',TRIM(line)
			IF (LEN(TRIM(line)) .le. 45 ) THEN ! check if no velocities are written
				!WRITE(*,*) 'case 1'
				!READ(17,*) dummyname
				!WRITE(*,*) dummyname
				!READ(17,'(i5,2a5,i5,3f8.3)') residue_number,residue_name,dummyname,i,x,y,z
				!WRITE(*,*) residue_number,residue_name,trim(dummyname),i,x,y,z
					READ(17,'(i5,2a5,i5,3f8.3)',IOSTAT=ierror) residue_numbers(j),residue_names(j),atomsorteA(j),atom_numbers(j),&
													&koordA(j,1),koordA(j,2),koordA(j,3)
					!WRITE(*,'(i5,2a5,i5,3f8.3)',IOSTAT=ierror) residue_numbers(j),residue_names(j),atomsorteA(j),atom_numbers(j),&
					!							   &koordA(j,1),koordA(j,2),koordA(j,3)

			ELSE ! ordinary *.gro file
					Read(17,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) residue_numbers(j),residue_names(j),atomsorteA(j),atom_numbers(j),&
														   &koordA(j,1),koordA(j,2),koordA(j,3),vel(j,1),vel(j,2),vel(j,3)
					!WRITE(*,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) residue_numbers(j),residue_names(j),atomsorteA(j),atom_numbers(j),&
					!                                      &koordA(j,1),koordA(j,2),koordA(j,3),vel(j,1),vel(j,2),vel(j,3)
			END IF
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(gro_inputfile),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
			residue_number=residue_numbers(j)
			IF (residue_number /= residue_number_old ) THEN
				i=i+1
				R_u_I(i,1)=residue_number
				R_u_I(i,2)=j
				residue_number_old=residue_number
				IF((residue_names(j) == 'DIPBI') .OR. (residue_names(j) == 'DPBIK'))THEN
					N_DIPBI=N_DIPBI+1
				ELSE IF (residue_names(j)(1:4) == 'PPDI') THEN
					N_PPDI=N_PPDI+1
				ELSE IF (residue_names(j) == '8poly') THEN
					N_PBDT_TS1_segments=N_PBDT_TS1_segments+1
					IF( TRIM(adjustl(atomsorteA(j))) == 'CH3') THEN ! new PBDT_TS1 chain-Start with segment A and a CH3 group.
						N_PBDT_TS1=N_PBDT_TS1+1			
					END IF ! new PBDT_TS1 chain-Start
				ELSE IF ((residue_names(j)(1:3) == 'THP') .OR. (residue_names(j)(1:2) == 'PH') .OR. (residue_names(j)(1:2) == 'PM'))THEN
					N_P3HT_segments=N_P3HT_segments+1
					IF( (residue_names(j)(1:5) == 'THP1A') .OR. (residue_names(j)(5:5) == 'S') )THEN ! 32mer start
						N_P3HT=N_P3HT+1
					END IF ! 32mer start
				ELSE 
					N_Species=N_Species+1
				END IF
			END IF
			IF( i == N_Resids+1) EXIT
			IF (i==0 .and. j==Gesamtanzahl ) THEN
			   write(*,*) ' Error: Es ist ein Fehler beim Einlesen ausgetreten: '//TRIM(gro_inputfile)
			   write(*,*) ' ENDE '
			   CALL EXIT (1)
		   END IF  
		END DO
		Read(17,*,IOSTAT=ierror) x_box,y_box,z_box
		IF( ierror > 0) STOP 'Error: Reading_the_boxsize'
		CLOSE(17)
		
		
		
		
		
		
		
		!! Uebergabe an gro_data_t struktur
		
		ALLOCATE(gro_data%atomsorte(Gesamtanzahl))
		ALLOCATE(gro_data%koord(Gesamtanzahl,3))
		ALLOCATE(gro_data%vel(Gesamtanzahl,3))           ! velocities(:,v_x,v_y,v_z)
		ALLOCATE(gro_data%R_u_I(N_Resids+1,2)) ! einen Eintrag mehr, damit an der letzten Stelle, der R_u_I: Resid_und_start_index(N_Resids,Gesamtanzahl+1,2) stehen kann, um die Schleifenbegrenzungen nicht anpassen zu muessen

		ALLOCATE(gro_data%residue_names(Gesamtanzahl))
		ALLOCATE(gro_data%residue_numbers(Gesamtanzahl))
		ALLOCATE(gro_data%atom_numbers(Gesamtanzahl))

		
		!!! initialize system
		!call init_system(system)
		gro_data%id=1
		gro_data%N_Atoms=Gesamtanzahl
		gro_data%N_Resids=N_Resids
		gro_data%gro_inputfile=TRIM(gro_inputfile)
		
		
		gro_data%koord=0.0
		gro_data%vel=0.0
		gro_data%R_u_I=0
		gro_data%R_u_I(N_Resids+1,1)=-100
		gro_data%R_u_I(N_Resids+1,2)=Gesamtanzahl+1
		
		DO j=1,Gesamtanzahl
			gro_data%residue_numbers(j)=residue_numbers(j)
			gro_data%residue_names(j)=residue_names(j)
			gro_data%atomsorte(j)=atomsorteA(j)
			gro_data%atom_numbers(j)=atom_numbers(j)
			DO k=1,3
					gro_data%koord(j,k)=koordA(j,k)	
					gro_data%vel(j,k)=vel(j,k)
			ENDDO
		END DO
		
		DO j=1,N_Resids
				gro_data%R_u_I(j,1)= R_u_I(j,1)
				gro_data%R_u_I(j,2)= R_u_I(j,2)
		END DO
		
		gro_data%x_box=x_box
		gro_data%y_box=y_box
		gro_data%z_box=z_box
		gro_data%koord_unit='nm'
		gro_data%has_side_chains=.true. 

END SUBROUTINE read_grofile_data
!!!! END READ DATA FROM GROFILE

!! Writes the data in gro_data to the filename 
!! Data is stored in gro_data, adapts the units for the koordinates if it is necessary. See key: gro_data%koord_unit
subroutine write_gro_data_to_file(gro_data,grofilename)
	use small_functions
	implicit none
	type(gro_data_t) ,intent(in)   :: gro_data
	character(len=500) ,intent(in) :: grofilename
	real    :: change_unit
	logical :: Datei_vorhanden
	integer :: i,j,ierror

	if(check_filetermination(grofilename,'.gro')) then  ! check termination *.gro ?
		INQUIRE(file=TRIM(grofilename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
		IF(Datei_vorhanden) THEN 
			WRITE(*,*) 'Error: The file already exits: ',TRIM(grofilename)
			WRITE(*,*) 'Rename the file, so it is not overwritten. '
			CALL EXIT(1)
		ELSE
			OPEN(UNIT=19,FILE=TRIM(grofilename),STATUS='REPLACE',IOSTAT=ierror)
		ENDIF
	endif ! check termination *.gro ?
	
	if( TRIM(ADJUSTL(gro_data%koord_unit)) == 'Ang' ) then
		change_unit = 10.0
	else if( TRIM(ADJUSTL(gro_data%koord_unit)) == 'nm' ) then
		change_unit = 1.0
	else if( TRIM(ADJUSTL(gro_data%koord_unit)) == 'mu' ) then
		change_unit = 1.0E-3
	else if( TRIM(ADJUSTL(gro_data%koord_unit)) == 'm' ) then
		change_unit = 1.0E-9
	else
		change_unit = 0
	endif
	
	WRITE(19,*) ''//TRIM(grofilename)
	WRITE(19,*) gro_data%N_Atoms
	DO i=1,gro_data%N_Resids
		DO j=gro_data%R_u_I(i,2),gro_data%R_u_I(i+1,2)-1 ! loop all index for atoms in molecule
			WRITE(19,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) gro_data%residue_numbers(j),&
				& gro_data%residue_names(j),&
				& adjustr(gro_data%atomsorte(j)),&
				& gro_data%atom_numbers(j),&
				& gro_data%koord(j,1) * change_unit, &
				& gro_data%koord(j,2) * change_unit, &
				& gro_data%koord(j,3) * change_unit, &
				& gro_data%vel(j,1),   gro_data%vel(j,2),   gro_data%vel(j,3)
				
				IF(ierror > 0) THEN
					WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(grofilename),' aufgetreten.'
				END IF !ierror
		END DO ! j 
	END DO ! i == Resids
					
	WRITE(19,'(3f8.3)',IOSTAT=ierror) gro_data%x_box * change_unit, gro_data%y_box * change_unit, gro_data%z_box * change_unit
	IF(ierror > 0) THEN
		WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(grofilename),' aufgetreten.'
		END IF
	WRITE(*,*) ' New gro file created: '//TRIM(grofilename)

end subroutine write_gro_data_to_file


!! Subroutine cuts the aliphatic side chains from DIPBI / P3HT 
subroutine cut_side_chains(gro_data)
	use small_functions
	implicit none
	type(gro_data_t), intent(inout) :: gro_data
	!!
	Character(5), allocatable, Dimension(:)        :: atomsorte_new,residue_names_new
	real, allocatable, Dimension(:,:)              :: koord_new,vel_new
	integer	                                       :: N_Atoms_new
	integer, allocatable, Dimension(:)             :: residue_numbers_new,atom_numbers_new
	integer, allocatable, Dimension(:,:)           :: R_u_I_new
	
	Character(len=500) ::grofilename
	integer:: N_Atoms, N_Resids
	integer, allocatable, Dimension(:,:)           :: R_u_I, S_u_E
	logical :: exit_loop
	integer :: N_Cycle
	integer :: terminalH
	integer :: startH,  endH
	character(len=5) :: lio
	integer::i,j,k,k_total
	logical::debug=.false.
	
	N_Resids=gro_data%N_Resids
	
	if( .not. allocated(R_u_I)) allocate(R_u_I(N_Resids+1,2))
	R_u_I = gro_data%R_u_I
	if( .not. allocated(R_u_I_new)) allocate(R_u_I_new(N_Resids+1,2))
	if( .not. allocated(S_u_E)) allocate(S_u_E(N_Resids,2))
	
	N_Atoms_new=0
	R_u_I_new=0
	terminalH = 0
	R_u_I_new(1,1) = R_u_I(1,1)
	R_u_I_new(1,2) = R_u_I(1,2)
	k_total =0
	!! Start und End H im Segment
	S_u_E =0
	do i=1, N_Resids
		if(  (TRIM(gro_data%residue_names(R_u_I(i,2))) == 'DIPBI') .OR. & 
			&(TRIM(gro_data%residue_names(R_u_I(i,2))) == 'DPBIK')) then
				N_Atoms_new =  N_Atoms_new + 74
		else if(  (gro_data%residue_names(R_u_I(i,2))(1:2) == 'PH') .OR. &
				& (gro_data%residue_names(R_u_I(i,2))(1:3) == 'THP')) then
				!! Zähle die Start und End-H-Atome im Polymer für PH oder PM
				startH=0
				endH=0
				if( (gro_data%residue_names(R_u_I(i,2))(5:5) == 'S') .or. &
						& 	( INDEX(gro_data%atomsorte(R_u_I(i,2)),'   H1') /= 0 ) )then
					startH=1
					endH=0
					if(   ( INDEX(gro_data%atomsorte(R_u_I(i+1,2)-4),'H') /= 0 ) )then 
						!! Bei einem Ende mit einem H Atom steht an der vierten Stelle ein H, sonst (wenn das Segment nicht mit einem H-Atom abgeschlossen wird) dann steht hier ein C auf das 3H Atome folgen aufgrund der Methylgruppe.
						endH=1
					else if(  (gro_data%residue_names(R_u_I(i,2))(5:5) == 'E') )then  !! PHxxE, PMxxE => ENDSTÜCK
						endH=1
					else if ( INDEX(gro_data%atomsorte(R_u_I(i+1,2)-4),'C') /= 0 )then 
						endH=0
					endif
				else if (gro_data%residue_names(R_u_I(i,2))(5:5) == 'E') then ! PHxxE, PMxxE  ==> Endstück mit End H Atom
					endH=1
				else if (gro_data%residue_names(R_u_I(i,2))(5:5) == 'A') then ! PHxxA, PMxxA ==> 32mer mit allen Elementen.
					startH=1
					endH=1
				else 
					startH=0
					endH=0
				endif 
				!! Übergabe des Start H und End H Atoms in der Thiophene-Kette.
				S_u_E(i,1) = startH
				S_u_E(i,2) = endH
				k = ( R_u_I(i+1,2) - R_u_I(i,2) )/25
				k_total = k_total + k
				if(debug) write(*,*) 'Anzahl der Ringe: ',k,' in ',TRIM(gro_data%residue_names(R_u_I(i,2)))
				if(debug) write(*,*) 'Anzahl Atome im kleineren System: ',N_Atoms_new,'  Atome für das Segments ',k*10+startH+endH
				N_Atoms_new =  N_Atoms_new + k * 9 + startH + endH
		else 
				N_Atoms_new =  N_Atoms_new + R_u_I(i+1,2) - R_u_I(i,2)  !! Normal
		endif
		
		R_u_I_new(i,1)   =  R_u_I(i,1)
		R_u_I_new(i+1,2) =  N_Atoms_new + 1
	enddo ! i ==> N_Resids in morphology
	
	write(*,*) 'N_Atoms_new: ',N_Atoms_new, ' Anzahl aller Thiophene-Ringsysteme: ',k_total  !!! Bsp 32 mer x 416 Ketten => 13312 Ringe  

	if( .not. allocated(atomsorte_new))       allocate(atomsorte_new(N_Atoms_new))
	if( .not. allocated(koord_new))           allocate(koord_new(N_Atoms_new,3))
	if( .not. allocated(vel_new))             allocate(vel_new(N_Atoms_new,3))
	if( .not. allocated(residue_numbers_new)) allocate(residue_numbers_new(N_Atoms_new))
	if( .not. allocated(residue_names_new))   allocate(residue_names_new(N_Atoms_new))
	if( .not. allocated(atom_numbers_new))    allocate(atom_numbers_new(N_Atoms_new))
	
	
	atomsorte_new="C"                  
	koord_new=0                       
	vel_new=0                           
	residue_numbers_new=0                             
	residue_names_new="Resnm"                         
	atom_numbers_new=0
	k=0
	exit_loop = .false.
	do i= 1, N_Resids
		N_Atoms = 0
		N_Cycle = 0
		startH=0
		endH=0
		exit_loop = .false.
		loop_j: do j= R_u_I(i,2), R_u_I(i+1,2)-1 ! loop all index for atoms in molecule
			if(   (TRIM(gro_data%residue_names(j)) == 'DIPBI') .or. & 
				& (TRIM(gro_data%residue_names(j)) == 'DPBIK')) then
					N_Atoms =  N_Atoms + 1 
					if( N_Atoms == 74 ) exit_loop = .true.
			else if(  (gro_data%residue_names(j)(1:2) == 'PH') .or. &
					& (gro_data%residue_names(j)(1:3) == 'THP')) then
					!!! Vorsicht -> Gibt keine Methylgruppen aus, sondern nur -CH2 Rest. => Sonst müsste das nächste C Atom in ein H umgewandelt werden und der Abstand verkürzt werden. 
					N_Atoms =  N_Atoms + 1 
					if( N_Cycle > 0 ) then
						if( N_Cycle == 1 ) then
							N_Atoms = 0
							N_Cycle = 0
							cycle loop_j
						endif
						N_Cycle = N_Cycle - 1
						if(debug) write(*,*) 'N_Cycle: ',N_Cycle
						cycle loop_j
					endif
					
					
					if( N_Atoms == 9 + S_u_E(i,1)) then ! 9 + StartH 
						N_Cycle = 16 
						S_u_E(i,1) = 0
					endif
					
					!! Find End segment => 1 H mehr drucken! WENN S und H in der Atomliste benachbart sind
					if( (S_u_E(i,2) == 1) .and. (INDEX(gro_data%atomsorte(j),'S') /= 0 ) .and. (INDEX(gro_data%atomsorte(j-1),'H') /= 0 ))then
						!write(*,*) 'END FOUND'
						N_Atoms = N_Atoms -1
					endif
			endif
			
			k=k+1
			residue_names_new(k) = gro_data%residue_names(j)
			atomsorte_new(k) =  adjustr(gro_data%atomsorte(j))
			residue_numbers_new(k) = gro_data%residue_numbers(j)
			atom_numbers_new(k) = gro_data%atom_numbers(j)
			koord_new(k,1:3)    = gro_data%koord(j,1:3) 
			vel_new(k,1:3)      = gro_data%vel(j,1:3)
			if(debug) then
				if( i > 1246 .and. i < 1260 ) then
					write(*,*) residue_numbers_new(k),TRIM(residue_names_new(k)),TRIM(atomsorte_new(k)),atom_numbers_new(k),&
					&       koord_new(k,1:3),vel_new(k,1:3) 
				endif
			endif
			if(exit_loop) exit loop_j
		enddo loop_j ! j => atoms in loop molecule

	enddo ! i
	
	write(*,*) 'Anzahl der hinzugefügten Atome: ',k,' erwartete Anzahl ',N_Atoms_new
	
	if(  allocated(gro_data%atomsorte))       deallocate(gro_data%atomsorte)
	if(  allocated(gro_data%koord))           deallocate(gro_data%koord)
	if(  allocated(gro_data%vel))             deallocate(gro_data%vel)
	if(  allocated(gro_data%residue_numbers)) deallocate(gro_data%residue_numbers)
	if(  allocated(gro_data%residue_names))   deallocate(gro_data%residue_names)
	if(  allocated(gro_data%atom_numbers))    deallocate(gro_data%atom_numbers)
	
	
	
	if( .not. allocated(gro_data%atomsorte))       allocate(gro_data%atomsorte(N_Atoms_new))
	if( .not. allocated(gro_data%koord))           allocate(gro_data%koord(N_Atoms_new,3))
	if( .not. allocated(gro_data%vel))             allocate(gro_data%vel(N_Atoms_new,3))
	if( .not. allocated(gro_data%residue_numbers)) allocate(gro_data%residue_numbers(N_Atoms_new))
	if( .not. allocated(gro_data%residue_names))   allocate(gro_data%residue_names(N_Atoms_new))
	if( .not. allocated(gro_data%atom_numbers))    allocate(gro_data%atom_numbers(N_Atoms_new))
	
	
	gro_data%N_Resids = N_Resids
	gro_data%N_Atoms = N_Atoms_new
	gro_data%R_u_I = R_u_I_new
	gro_data%atomsorte =  atomsorte_new
	do i= 1, N_Atoms_new
		gro_data%koord(i,1:3)  = koord_new(i,1:3)            
		gro_data%vel(i,1:3)    = vel_new(i,1:3)   
	enddo            
	gro_data%residue_numbers = residue_numbers_new
	gro_data%residue_names  = residue_names_new
	gro_data%atom_numbers  = atom_numbers_new
	
	gro_data%has_side_chains=.false. 
	
	if(.true.) then
		lio=TRIM(make_lio())
		grofilename='tmp_complete_grofile_'//TRIM(lio)//'_'//TRIM(str(KMC_setup%set_seed))//'.gro'
		write(*,*) 'write_gro_data_to_file tmp '//trim(grofilename)
		call write_gro_data_to_file(gro_data,grofilename)
	endif
	write(*,*) 'cut_side_chains(gro_data) done.'
	
	if(debug) then
		write(*,*) '--- debug R_u_I 1 bis 10 ---'
		do i=1,10
			write(*,*) gro_data%R_u_I(i,1),' ',gro_data%R_u_I(i,2), trim(gro_data%residue_names(gro_data%R_u_I(i,2)))
		enddo
		write(*,*) '--- debug R_u_I 1 bis 10 ---'
		do i=gro_data%N_Resids-10,  gro_data%N_Resids
			write(*,*) gro_data%R_u_I(i,1),' ',gro_data%R_u_I(i,2), trim(gro_data%residue_names(gro_data%R_u_I(i,2)))
		enddo
		write(*,*) '--- debug R_u_I  Ende ---'
	endif ! debug

end subroutine cut_side_chains 



!! reading read_total_occupation_file 
!! with the format from sql file: id,occPh
!! Replace "|" with "whitespace" beforehand; Take the index shift between votca and my_kmc into account!  
!! sqlite3 statefile.sql " SELECT id,occPh FROM segments " >> tot_occ_DIPBI_P3HT.dat
!! sed -i 's/|/   /g' -i tot_occ_DIPBI_P3HT.dat 
SUBROUTINE read_total_occupation_file(tot_occ_filename,id_tot_occ,tot_occ_data,N_tot_occ_lines)
		use small_functions
		implicit none
		!! filename to read tot_occ data 
		CHARACTER(500), INTENT(IN) :: tot_occ_filename
		!! Array for hole tot_occ_h           tot_occ_data(i,1)   ; neutral  tot_occ_data(i,2)    and    electron tot_occ_e  tot_occ_data(i,3)
		REAL, ALLOCATABLE, DIMENSION(:)    , INTENT(OUT) :: tot_occ_data 
		!! Resids of molecule id in segments
		INTEGER, ALLOCATABLE, DIMENSION(:) , INTENT(OUT) :: id_tot_occ
		INTEGER, INTENT(OUT)::N_tot_occ_lines
		CHARACTER(50) ::dummy_str
		INTEGER:: ierror,i,N_skip_line,N_lines
		LOGICAL:: DEBUG=.false.
		LOGICAL:: Datei_vorhanden

	INQUIRE(file=TRIM(tot_occ_filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
	IF( .NOT. Datei_vorhanden) THEN
				WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(tot_occ_filename)
				WRITE(*,*) ' ENDE'
				CALL EXIT (1)
	END IF ! Datei-file vorhanden 
	WRITE(*,*) 'Reading data from: ',TRIM(tot_occ_filename)


	N_lines=Read_rows_file2(tot_occ_filename)
	OPEN(UNIT=29,FILE=TRIM(tot_occ_filename),STATUS='OLD',IOSTAT=ierror)
	!WRITE(*,*) 'Read tot_occ file data from file: '//TRIM(tot_occ_filename)
	ierror=0
	N_skip_line=0
	N_lines=0
	DO WHILE ( ierror == 0 )
		Read(29,*,IOSTAT=ierror) dummy_str
		IF(ierror < 0) EXIT
		IF(ierror > 0) THEN
			WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(tot_occ_filename),' aufgetreten.'
			WRITE(*,*) 'Beende Einlesen !'
			CALL EXIT (1)
		END IF
		if ( dummy_str(1:1) == '#' ) THEN ! Check ob erster Buchstabe ein #-Zeichen ist, um kommentare zu lesen
			N_skip_line=N_skip_line+1
			N_lines=N_lines+1
		ELSE
			N_lines=N_lines+1
		END IF
	END DO
	CLOSE(29)
	WRITE(*,*) 'N_lines: ',N_lines,' N_skip_line: ',N_skip_line


	IF(file_exists(tot_occ_filename)) THEN 
		OPEN(UNIT=35,FILE=TRIM(tot_occ_filename),STATUS='OLD',IOSTAT=ierror)
	ENDIF
	IF (N_skip_line > 0 ) THEN ! Auslassen der Zeilen mit '#'
		DO i =1,N_skip_line
			Read(35,*,IOSTAT=ierror) dummy_str
		END DO
	END IF
	N_tot_occ_lines=N_lines-N_skip_line
	ALLOCATE(id_tot_occ(N_tot_occ_lines))
	ALLOCATE(tot_occ_data(N_tot_occ_lines))

	id_tot_occ=0
	tot_occ_data=0

	DO i=1,N_tot_occ_lines
		!!!! read                    id_occ          occPh
		READ(35,*,IOSTAT=ierror) id_tot_occ(i),tot_occ_data(i)
		IF(ierror < 0) EXIT
		IF(ierror > 0) THEN
			WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(tot_occ_filename),' aufgetreten.'
			WRITE(*,*) 'Beende Einlesen !'
			CALL EXIT (1)
		END IF
	END DO ! Read Data
	CLOSE(35)
	IF (DEBUG) THEN
		WRITE(*,*) 'tot_occ from file: '//TRIM(tot_occ_filename)
		WRITE(*,*) '      id_occ          occPh '
		DO i=1,N_tot_occ_lines
			WRITE(*,*) id_tot_occ(i),tot_occ_data(i)
		END DO 
		WRITE(*,*) 'Ende tot_occ_file'
	END IF

END SUBROUTINE read_total_occupation_file   







 
end module KMC_class
!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!!   END module with kmc programm
!!! ------------------------------------------------------------------------------------------------------------------- !!!



!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!!     gro_to_DIPRO
!!! ------------------------------------------------------------------------------------------------------------------- !!!
module gro_to_DIPRO
!! keys: 'DIPRO'              Reads the input arguments from the command line
!!       'DIPRO_pair'         Reads the data from an options.xml file   
!!       'DIPRO_xyz'          Reads the data from *.xyz file.' 
!!       'lambda_out_dE_out'  Calculate the outer-sphere reorganization energies and electrostratic contributions based on the distribution of partial charges as a sum.
!!       'lambda_out'         outer-sphere reorganization energy
!!       'lambda_in'          Calculate the internal reorganization energy for a charge transfer complex 
!!       'lambda_in_oniom'    Calculate the internal reorganization energy (lambda_in) inside a fixed cavity of neighbouring molecules.
!!
!! Program  gro_to_DIPRO_P3HT_DIPBI_PPDI_V2 to extract a molecule from GROMACS file 'gro_inputfile.gro' to
!!   Version: 15.05.17
!! 1) create xyz-files of monomeres molA.xyz and molB.xyz in Angstroem.
!! 2) substitute carbon-chains by -CH3 groups // logicals: P3HT,P3HT,DIPBI,DIPBI_KETTE
!! 3) construct input files and folders via the mol_all_setup_kankra.sh script for the DIPRO method with g09
!! 4) Calculates the distance centre of masses COM / COM_H (with H-Atoms added)
!! 5) Calculates the minimal distance of two molecules MA (Minimalabstand)
!! 6) Calculates the MMA (Mittlerer Minimalabstand)
!! 7) Calculates for angle between two DIPBI: theta
!! 
!! V1) PPDI can be used as well, H, CH3-CH-CH3 (Propyl), and long chains (PPDI_KETTE) may be added.
!! V2) PPDT-S1 can be used, HDI and HDI_K can be used h_cut_chain_HDI (cuts the chains and terminates wiet CH3-groups)
!!  
!! !!!!!!! INPUT !!!!!!!
!!  gro_inputfile.gro Residue 1 Residue 2 functional/basisset GeoSteo Number sub-g09
!!  Example: DIPRO equi_2000ps_500k_DIPBI.gro 12 15 B3LYP/6-31G* 1 2 true/false
!!    
!!  1) gro_inputfile.gro file
!!  2) Residue number of molecule 1     (residue_number_1)
!!  3) Residue number of molecule 2     (residue_number_2)
!!  4) Calculation_method used to identify the folder name
!!  5) Step/Frame number takes into account the Geometry / Gromacs morphology.          (integer)
!!  6) Number for a calculation with DIPRO_setup.                                       (integer)
!!  7) sub_g09 logical for submission to queue via sub-myg09-Kankra-DIPRO               (sub_g09 = true / false)
!!  8) Inputline used to specify the gaussian calculations
!!  9) Kette_1 , Kette_2 choses if the side chain is used to calculate the COM_S_MA
!!  Version 7 
!!  - Erweiterung der lambda_out routine die nun fur r_cut=0 dazu genutzt werden kann, um Lambda und E_ij_out mit allen Nachbarn in der Box zu verwenden.
!!    Dazu wird der Schwerpunkt von Resid 1 in das Boxzentrum verschoben und die anderen Molekuele werden drumherum gruppiert (Minimum-Image-Convention).
!!  - lambda_in_oniom moeglich
!!  Version 8
!!  - Anpassung an multigeo Rechnungen mit trajstep zum zaehlen der Geometriesteps _G
!!  - Anpassung, dass mit lambda_in und lambda_in_oniom auch Resids in einem Molekuel u. benachbarte Resids berechnet werden koennen
!!  (25.1.17)
!!  Version 9
!!  - Verarbeitung von PPDI und PBDT_TS1
!!  Version 10
!!  - Anpassung fuer dftb+ DIPRO-Rechnungen auswahl mit: sub_g09=sub_dftb+ (fuer Erstellung und submittierung) oder sub_g09=dftb+
!!  (fuer die Erstellung der Ordnerstruktur) [Anmerkung: DIPRO mit dftb+ wird nicht nicht mit mol_all_setup.sh erstellt]
!!  dftb_plus_SKF_path=' ' ! Slater-Koster-file Pfad fuer dftb+ muss hier im skript gesetzt werden 
!!  g09_SKF_path=" " ! Slater-Koster-file Pfad fuer DFTB mit MIO-1-1 mit g09 
!!  Version 11
!!  - Alq3 aus votca tutorial ist auch berechenbar.
!!  Version 12
!!  - Einlesen der Optionen fuer das Setup aus einer options.xml Datei.
!!  - DIPRO_pair mit options.xml kann auch für *.xyz dateien genutzt werden. (Dann wird keine Modifizierung der H-Atome durchgefuehrt).
!!
!!  Hauptroutine zum STARTEN: gro_to_DIPRO_P3HT_DIPBI_PPDI()

CONTAINS 
SUBROUTINE gro_to_DIPRO_P3HT_DIPBI_PPDI()
	use small_functions
	use KMC_class
	IMPLICIT NONE
	type(KMC_setup_t) ::setup !!! options from options.xml 
	Integer :: i,k,ierror1,ierror2,int_dummy
	INTEGER :: residue_number_1,residue_number_2,Num,trajstep,N_neighbours_partial_charges
	INTEGER ::NCPUS,NODE,TIME,MEM,NAtoms,NAtoms1H,NAtoms2H
	Real ::theta,COM,COM_H,MA,MMA,COM_S_MA,r_cut,real_dummy
	REAL ::x_box,y_box,z_box
	Character(500)  ::Molname,MolnameA,dimer,molA,molB,method,gro_inputfile,QUEUE,partial_charge_methode,foldername
	Character(500)  ::foldername_DIPRO,DIPRO_Datenfile,calculation_method
	Character(500)  ::g09inputline,lio,g09_SKF_path,dftb_plus_SKF_path,dftb_plus_path,HOSTNAME
	Character(500)  ::lambda_in_foldername,lambda_in_calculation_method,lambda_in_inputline
	Character(500)  ::result_DIPRO_dftb_plus
	CHARACTER(10000)::bashline,Geo_data_info
	Character(50000)  ::results_traegheitstensor
	Character(500)   ::type1,type2
	Character(3)   ::charge_name
	Character(10)  ::resid1,resid2,dummy1,dummy2,dummy3,dummy4
	Character(500) ::sub_g09ok,CURDIR
	Real, ALLOCATABLE, Dimension(:,:) :: koord,koord1H,koord2H
	INTEGER, ALLOCATABLE, Dimension(:)::Resid_list
	!! Verbindungsvektoren der dimere  
	REAL, Dimension(3) :: d_MA, d_MMA, d_RCOM
	REAL, Dimension(3) :: schwerpunkt1,schwerpunkt2,schwerpunkt1K,schwerpunkt2K
	Character(5), ALLOCATABLE, Dimension(:) :: atomsorte,atomsorte1H,atomsorte2H
	LOGICAL::P3HT,DIPBI,P3MT,DIPBI_KETTE,PPDI,PPDI_KETTE,PPDI_Propyl,PBDT_TS1,HDI_KETTE,sub_g09,use_g09,g09_charged,DIPRO
	LOGICAL::folder_vorhanden,Datei_vorhanden,lambda_in_on_the_fly,lambda_in_oniom,lambda_out
	LOGICAL::read_xyz_from_gro,use_dftb_plus=.false.,sub_dftb_plus=.false.,run_local_dftb_plus=.false.
	LOGICAL:: read_lambda_in_gro=.false.
	LOGICAL:: read_lambda_in_xyz=.false.
	LOGICAL:: extra_SP_lambda_in=.false.
	LOGICAL::run_DIPRO_local_dftb_plus
	LOGICAL::calculate_traegheitstensor=.false.
	LOGICAL::KETTE_1,KETTE_2
	!!! options.xml variables
	LOGICAL:: read_DIPRO_xyz,read_options_from_xml
	Character(500)   :: input_options_filename_xml,monomerAxyz,monomerBxyz,dummyname
	LOGICAL:: DEBUG=.false.
	
	
	! Auswahl der H-Anlagerung P3MT=.false. == P3HT
	P3MT=.false.
	DIPBI_KETTE=.false.
	! Defaut ist h_PPDI, wenn PPDI_KETTE=false und PPDI_Propyl=false
	PPDI_KETTE=.false.
	PPDI_Propyl=.False.
	HDI_KETTE=.false.

	! Startsetzungen
	P3HT=.false.     ! Nicht aendern
	DIPBI=.false.    ! Nicht aendern
	PPDI=.false.     ! Nicht aendern
	PBDT_TS1=.false. ! Nicht aendern
	
	!! Defaults
	DIPRO=.false.    ! Nicht aendern
	lambda_in_on_the_fly=.false.  ! Nicht aendern
	lambda_out=.false.            ! Nicht aendern
	lambda_in_oniom=.false.       ! Nicht aendern
	calculate_traegheitstensor=.false. ! Nicht aendern
	read_options_from_xml=.false.      ! Nicht aendern
	read_DIPRO_xyz=.false.
	g09_charged=.false. ! for SCF calculations.
	sub_g09ok='false'
	sub_g09=.false.
	use_g09=.false.
	sub_dftb_plus=.false.
	use_dftb_plus=.false.	
	run_local_dftb_plus=.false.
	run_DIPRO_local_dftb_plus=.false.
	result_DIPRO_dftb_plus=''
	read_lambda_in_gro=.false.
	read_lambda_in_xyz=.false.
	extra_SP_lambda_in=.false.
	
	trajstep=0
	Num=0
	NCPUS=8
	NODE=1
	MEM=8!GB
	QUEUE='default'
	TIME=1
	!! current directory
	CURDIR="."
	
	! Boxgroeßen festlegen - nur fuer periodische Randbedingungen wichtig.
	x_box=106.4451   ! boxsize in Angstroenm
	y_box=103.5850   ! boxsize in Angstroenm
	z_box=105.4510   ! boxsize in Angstroenm
	! Einlesen der Boxgroesse aus dem *.gro (ignoriert die Angaben oben, wenn Geometrien eingelesen werden!)
	read_xyz_from_gro=.false.

	! default g09 MIO-1-1
	g09_SKF_path='.'   
	! default dftb+ 
	dftb_plus_SKF_path='.'       ! Slater-Koster-file path for dftb+ files 
	dftb_plus_path='.' ! path to dftb+ 
	HOSTNAME=''

!!! Set platform dependent variables
IF ( hostnm(HOSTNAME) .ne. 0 ) THEN ! get the Hostname
	WRITE(*,*) 'Error: The HOSTNAME could not be determined'
	STOP
END IF


	!! Writes out the input line
	bashline=" "
	DO i=1,command_argument_count()
		CALL get_command_argument(i,dummyname)
		bashline=TRIM(bashline)//'  '//TRIM(adjustl(dummyname))
	END DO
	
	
	IF( LEN_TRIM(bashline) > 0 ) THEN
		WRITE(*,*) 'INPUT:'
		WRITE(*,*) TRIM(bashline)
	ELSE
		CALL print_DIPRO_startscreen()
		CALL EXIT(1)
	ENDIF


	CALL get_command_argument(1,method)
	IF( (method == 'DIPRO') .or. (method == 'DIPRO_pair') .or. (method == 'DIPRO_xyz')) THEN
		DIPRO=.true.
	ELSE IF( (method == 'lambda_in') .or. (method == 'lambda_in_pair') )THEN
		lambda_in_on_the_fly=.true.
	ELSE IF (method == 'lambda_out') THEN
		lambda_out=.true.
	ELSE IF (method == 'lambda_in_oniom') THEN    
		lambda_in_oniom=.true.
	ELSE IF (method == 'lambda_out_dE_out') THEN
		CALL lambda_out_dE_out()
	ENDIF
	
	DO i=2,command_argument_count()
				CALL get_command_argument(i,dummyname)
				IF (check_filetermination_and_continue(dummyname,'.xml')) THEN
					input_options_filename_xml=dummyname
					inquire(file=TRIM(input_options_filename_xml),exist=Datei_vorhanden) 
					IF( .not. Datei_vorhanden) THEN 
						WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(input_options_filename_xml)
						CALL EXIT (1)
					ELSE 
						WRITE(*,*) 'Use options: ',TRIM(input_options_filename_xml)
						read_options_from_xml=.true.
					END IF ! input_options_filename_xml   vorhanden. 
				END IF !!! suche *.xml file
	ENDDO


	!! read the input parameters from an options.xml file
IF( read_options_from_xml .and. file_exists_and_continue(input_options_filename_xml) .and. &
		& check_filetermination_and_continue(input_options_filename_xml,'.xml')) THEN
		write(*,*) 'Start reading options from  input_options_filename_xml. '//TRIM(input_options_filename_xml)
		call set_defaults_KMC_setup(setup)
		if(DIPRO) then
			call read_votca_optionsfile(input_options_filename_xml,setup,"DIPRO dipro DIPRO_pair DIPROpair system")
		else if(lambda_in_on_the_fly) then
			call read_votca_optionsfile(input_options_filename_xml,setup,"DIPRO lambda_in_pair system ")
		else 
			call read_votca_optionsfile(input_options_filename_xml,setup," all ")
		endif
		!!! Use data from setup in options.xml file.
		DEBUG            = setup%debug 
		NCPUS            = setup%NCPUS               
		NODE             = setup%NODE              
		MEM              = setup%MEM               
		QUEUE            = setup%QUEUE             
		TIME             = setup%TIME              
		sub_g09ok = trim(setup%sub)   
		g09_SKF_path = setup%g09_SKF_path           
		dftb_plus_SKF_path = setup%dftb_plus_SKF_path          
		dftb_plus_path = setup%dftb_plus_path      
		if(setup%read_DIPRO_gro)then
			read_xyz_from_gro = setup%read_DIPRO_gro 
		else if(setup%read_lambda_in_gro) then 
			read_xyz_from_gro = setup%read_lambda_in_gro
		else 
			read_xyz_from_gro=.false.
		endif
		residue_number_1 = setup%residA 
		resid1           = adjustl(int2str(setup%residA))          
		type1            = setup%typeA             
		residue_number_2 = setup%residB  
		resid2           = adjustl(int2str(setup%residB))       
		type2            = setup%typeB             
		calculation_method   = setup%calculation_method
		g09inputline = setup%g09inputline     
		trajstep         = setup%trajstep          
		Num              = setup%Num               
		read_DIPRO_xyz = setup%read_DIPRO_xyz    
		read_lambda_in_xyz = setup%read_lambda_in_xyz  
		read_lambda_in_gro = setup%read_lambda_in_gro
		extra_SP_lambda_in=setup%extra_SP_lambda_in
		
		monomerAxyz= setup%monomerAxyz       
		monomerBxyz= setup%monomerBxyz 
		calculate_traegheitstensor = setup%moment_of_inertia_tensor 
		if( read_DIPRO_xyz .and. read_xyz_from_gro ) then
			write(*,*) 'Error: Can not read the coordinates from *.gro and *.xyz at the same time.'
			write(*,*) 'Select only one option read_DIPRO_gro  or read_DIPRO_xyz.'
			call exit(1)
		else if ( read_lambda_in_xyz .and. read_xyz_from_gro ) then
			write(*,*) 'Error: Can not read the coordinates from *.gro and *.xyz at the same time.'
			write(*,*) 'Select only one option read_lambda_in_gro  or read_lambda_in_xyz.'
			call exit(1)
		endif
		
		write(*,*) "DEBUG             : ", setup%debug 
		write(*,*) "MEM               : ", setup%MEM               
		write(*,*) "QUEUE             : ", trim(setup%QUEUE)             
		write(*,*) "TIME              : ", setup%TIME              
		write(*,*) "sub_g09ok         : ", trim(setup%sub)          
		write(*,*) "g09_SKF_path      : ", trim(setup%dftb_plus_SKF_path)    
		write(*,*) "dftb_plus_SKF_path: ", trim(setup%dftb_plus_SKF_path)          
		write(*,*) "dftb_plus_path    : ", trim(setup%dftb_plus_path) 
		    
		write(*,*) "read_DIPRO_gro    : ", setup%read_DIPRO_gro
		write(*,*) "read_DIPRO_xyz    : ", setup%read_DIPRO_xyz    
		write(*,*) "read_lambda_in_gro: ", setup%read_lambda_in_gro
		write(*,*) "read_lambda_in_xyz: ", setup%read_lambda_in_xyz   
		if(read_xyz_from_gro .or. read_lambda_in_gro) then
			gro_inputfile= trim(setup%gro_inputfile)
			write(*,*) "gro_inputfile     : ",trim(gro_inputfile)
		else if(read_DIPRO_xyz .or. read_lambda_in_gro) then
			write(*,*) "monomerAxyz: ", trim(setup%monomerAxyz)      
			write(*,*) "monomerBxyz: ", trim(setup%monomerBxyz)
		endif
		if(read_xyz_from_gro .or. read_DIPRO_xyz .or. read_lambda_in_xyz) then
			write(*,*) "residue_number_1  : ", setup%residA 
			write(*,*) "resid1            : ", trim(adjustl(int2str(setup%residA)))           
			write(*,*) "type1             : ", trim(setup%typeA)             
			write(*,*) "residue_number_2  : ", setup%residB  
			write(*,*) "resid2            : ", trim(adjustl(int2str(setup%residB)))       
			write(*,*) "type2             : ", trim(setup%typeB)             
			write(*,*) "calculation_method: ", trim(setup%calculation_method)
			write(*,*) "g09inputline     : ", trim(setup%g09inputline)     
			write(*,*) "trajstep          : ", setup%trajstep          
			write(*,*) "Num               : ", setup%Num                 
		endif 
		write(*,*) "moment_of_inertia_tensor : ",calculate_traegheitstensor   
		
ELSE IF (index(HOSTNAME,'edoras') .ne. 0) THEN
	NCPUS=1
	NODE=1
	MEM=1 !GB
	QUEUE='default'
	TIME=1
	g09_SKF_path='/opt/files/DFTB_skf_files/mio-1-1'
	dftb_plus_SKF_path='/home/t/t_koch08/dftb+/3ob-3-1/'   ! Slater-Koster-file path for dftb+ files auf edoras
	! dftb_plus_SKF_path='/home/t/t_koch08/dftb+/mio-1-1/'   ! dftb_plus_SKF_path auf edoras
	dftb_plus_path='/home/t/t_koch08/dftb+/dftbplus-17.1.x86_64-linux/bin/' ! edoras
ELSE IF ( (index(HOSTNAME,'balrog') .ne. 0) .OR.  (index(HOSTNAME,'kankra') .ne. 0) ) THEN
	NCPUS=8
	NODE=1
	MEM=12 !GB
	QUEUE='default'
	TIME=12
	dftb_plus_SKF_path='/opt/files/dftb+/3ob-3-1/'         ! gondor
	!dftb_plus_SKF_path='/opt/files/dftb+/mio-1-1/'         ! gondor 
	dftb_plus_path=' export PYTHONPATH=/opt/vmd-1.9.3-python_framework/vmd-1.9.3/python:'//&
		&'/opt/files/dftb+/dftbplus-17.1.x86_64-linux/lib/python2.7/site-packages && /opt/files/dftb+/dftbplus-17.1.x86_64-linux/bin/'
        !write(bashline,*) "export PYTHONPATH=/opt/vmd-1.9.3-python_framework/vmd-1.9.3/python:/opt/files/dftb+/dftbplus-17.1.x86_64-linux/lib/python2.7/site-packages"
        !CALL execute_command_line(TRIM(bashline)) 
	! python path fuer balrog/kankra
ELSE IF (index(HOSTNAME,'palma') .ne. 0) THEN
	NCPUS=12
	NODE=1
	MEM=12 !GB
	QUEUE='default'
	TIME=12
	dftb_plus_SKF_path='/home/t/t_koch08/dftb+/3ob-3-1/'    !palma
	!dftb_plus_SKF_path='/home/t/t_koch08/dftb+/mio-1-1'        !palma
	dftb_plus_path='/home/t/t_koch08/dftb+/dftbplus-17.1.x86_64-linux/bin/'
ELSE IF (index(HOSTNAME,'sl') .ne. 0) THEN ! phi
	NCPUS=24
	NODE=1
	MEM=64 !GB
	QUEUE='default'
	TIME=12
	dftb_plus_SKF_path='/home/t/t_koch08/dftb+/3ob-3-1/'    !phi
	!dftb_plus_SKF_path='/home/t/t_koch08/dftb+/mio-1-1'        !phi
	dftb_plus_path='/home/t/t_koch08/dftb+/dftbplus-17.1.x86_64-linux/bin/'
ELSE IF (index(HOSTNAME,'morgoth') .ne. 0) THEN ! hpc
	NCPUS=40
	NODE=1
	MEM=48 !GB
	QUEUE='default'
	TIME=12
	dftb_plus_SKF_path='/opt/files/dftb+/3ob-3-1/'         ! gondor
	!dftb_plus_SKF_path='/opt/files/dftb+/mio-1-1/'         ! gondor 
	dftb_plus_path=' export PYTHONPATH=/opt/vmd-1.9.3-python_framework/vmd-1.9.3/python:'//&
		&'/opt/files/dftb+/dftbplus-17.1.x86_64-linux/lib/python2.7/site-packages && /opt/files/dftb+/dftbplus-17.1.x86_64-linux/bin/'
END IF ! Select HOSTNAME
        
IF (command_argument_count() > 0 ) THEN
            CALL get_command_argument(1,method)
            IF (method == 'lambda_out_dE_out') THEN   
                lambda_out=.true.                       
                CALL lambda_out_dE_out()
                STOP
            END IF
END IF 

IF( (TRIM(method) == 'DIPRO_pair') .and. read_options_from_xml ) THEN

	DIPRO=.true.
	write(*,*) 'Use options from: ',TRIM(input_options_filename_xml)
ELSE IF( (TRIM(method) == 'lambda_in_pair') .and. read_options_from_xml ) THEN
	lambda_in_on_the_fly=.true.
	write(*,*) 'Use options from: ',TRIM(input_options_filename_xml)
ELSE IF( (TRIM(method) == 'DIPRO_xyz') .or. (TRIM(method) == 'lambda_in_xyz') ) THEN
		DIPRO=.true.
		IF(command_argument_count() == 12) THEN 
			CALL get_command_argument(2,monomerAxyz)
			CALL get_command_argument(3,resid1)
			CALL get_command_argument(4,type1)
			CALL get_command_argument(5,monomerBxyz)
			CALL get_command_argument(6,resid2)
			CALL get_command_argument(7,type2)
			CALL get_command_argument(8,calculation_method)
			CALL get_command_argument(9,dummy1)
			CALL get_command_argument(10,dummy2)
			CALL get_command_argument(11,sub_g09ok)
			CALL get_command_argument(12,g09inputline)
		ELSE
			WRITE(*,*) 'Error: [DIPRO_xyz/lambda_in_xyz] need 12 arguments in the command line.'
			Write(*,*) ' DIPRO_xyz  monomerA.xyz residA typeA   monomerB.xyz residB typeB  '//& 
						&'calculation_method  GeoStep Number sub_g09  g09inputline'
		ENDIF
        
		IF (check_filetermination(monomerAxyz,'.xyz') .and. file_exists(monomerAxyz) .and. &
			check_filetermination(monomerBxyz,'.xyz') .and. file_exists(monomerBxyz) ) THEN 
			read_DIPRO_xyz=.true.
		END IF
		
		READ(resid1,'(I10)') residue_number_1  !Residuum 1 
        READ(resid2,'(I10)') residue_number_2  !Residuum 2
        READ(dummy1,'(I10)') trajstep  ! Auswahl des Schrittes der Geometrie in gro-file
        READ(dummy2,'(I10)') Num       ! Durchzaehlen der Ordnungsrechnungsnummer 
		
		
		
ELSE IF(command_argument_count() > 4) THEN         !Einlesen der Flags
        !CALL get_command_argument(1,method)
        CALL get_command_argument(2,gro_inputfile)
		IF (check_filetermination(gro_inputfile,'.gro')) THEN
				inquire(file=TRIM(gro_inputfile),exist=Datei_vorhanden) ! Abfrage ob gro-Datei vorhanden ist.
				IF( .NOT. Datei_vorhanden) THEN 
						WRITE(*,*) ' Fehler: Die_gro_Datei_ist_nicht_vorhanden. '//TRIM(gro_inputfile)
						WRITE(*,*) ' ENDE'
						STOP
				ELSE
					read_xyz_from_gro =.true.
				END IF ! gro-file vorhanden  
		END IF ! check if *.gro
        CALL get_command_argument(3,resid1)
        CALL get_command_argument(4,type1)
        CALL get_command_argument(5,resid2)
        CALL get_command_argument(6,type2)
        CALL get_command_argument(7,calculation_method)
        CALL get_command_argument(8,dummy1)
        CALL get_command_argument(9,dummy2)
        CALL get_command_argument(10,sub_g09ok)
        CALL get_command_argument(11,g09inputline)

        READ(resid1,'(I10)') residue_number_1  !Residuum 1 
        READ(resid2,'(I10)') residue_number_2  !Residuum 2
        READ(dummy1,'(I10)') trajstep  ! Auswahl des Schrittes der Geometrie in gro-file
        READ(dummy2,'(I10)') Num       ! Durchzaehlen der Ordnungsrechnungsnummer 
        
        IF( (method == 'DIPRO') .or. (method == 'DIPRO_pair') .or. (method == 'DIPRO_xyz')) THEN
            DIPRO=.true.
        ELSE IF(method == 'lambda_in') THEN
            lambda_in_on_the_fly=.true.
        ELSE IF (method == 'lambda_out') THEN
            lambda_out=.true.
        ELSE IF (method == 'lambda_in_oniom') THEN    
            lambda_in_oniom=.true.
        ELSE IF (method == 'lambda_out_dE_out') THEN
		CALL lambda_out_dE_out()   
            STOP
        ELSE
            WRITE(*,*) 'Select a method: DIPRO, lambda_in, lambda_out or lambda_in_oniom'
            STOP
        END IF
        
        IF( TRIM(adjustl(type1(1:3))) == 'THP') THEN
                type1='P3MT'
        ELSE IF (.NOT. (TRIM(adjustl(type1))=='DIPBI' .OR. TRIM(adjustl(type1))=='DIPBI_KETTE' &
                &.OR. TRIM(adjustl(type1))=='P3MT' .OR. TRIM(adjustl(type1))=='P3HT')) THEN
                type1=''
        END IF

        IF( type2(1:3) == 'THP') THEN
            type2='P3MT'
        ELSE IF (.NOT. (TRIM(adjustl(type2))=='DIPBI' .OR. TRIM(adjustl(type2))=='DIPBI_KETTE' &
                &.OR. TRIM(adjustl(type2))=='P3MT' .OR. TRIM(adjustl(type2))=='P3HT')) THEN
            type2=''
        END IF
        
        IF(read_xyz_from_gro) THEN
            CALL RANDOM_NUMBER(real_dummy)
            int_dummy=int(100*real_dummy)
            lio='_'//TRIM(resid1)//'_'//TRIM(resid2)//'_'//TRIM(str(int_dummy))
            CALL  Read_boxsize_from_gro(gro_inputfile,x_box,y_box,z_box,lio)
        ELSE
            WRITE(*,*) 'use boxsize (Ang):',x_box,y_box,z_box
        END IF
        
        IF(command_argument_count() > 11) THEN
            CALL get_command_argument(12,partial_charge_methode)  
            CALL get_command_argument(13,charge_name)
                  
            IF(lambda_out) THEN
                CALL get_command_argument(14,dummy3)
                READ(dummy3,'(1F12.4)') r_cut
                CALL get_command_argument(15,dummy4)
                READ(dummy4,'(I10)')  N_neighbours_partial_charges
            END IF
          
            IF(lambda_out) THEN
                k=2 ! k_gibt die Anzahl der Resids zusaetzlich zu den Nachbarn an k=2 fuer Resid1 und Resid2, ist ein Resid ein Teil einer Kette, muss dieser Zus
                IF( TRIM(adjustl(type1))=='P3HT' .OR. TRIM(adjustl(type1))=='P3MT') THEN
                    k=k+1
                END IF 
                IF( TRIM(adjustl(type2))=='P3HT' .OR. TRIM(adjustl(type2))=='P3MT') THEN
                    k=k+1
                END IF 
                
                ALLOCATE(Resid_list(N_neighbours_partial_charges+k))
                    Resid_list(1)=residue_number_1
                    Resid_list(2)=residue_number_2
                    k=2
                    IF( TRIM(adjustl(type1))=='P3HT' .OR. TRIM(adjustl(type1))=='P3MT') THEN
                        k=k+1
                        Resid_list(k)=residue_number_1
                    END IF 
                    IF( TRIM(adjustl(type2))=='P3HT' .OR. TRIM(adjustl(type2))=='P3MT') THEN
                        k=k+1
                        Resid_list(k)=residue_number_2
                    END IF 
                                    
                DO i=1,N_neighbours_partial_charges,1
                        CALL get_command_argument(i+15,dummy3)
                        READ(dummy3,'(I10)') Resid_list(i+k)
                END DO
                
                call make_lambda_out_entire_box(gro_inputfile,residue_number_1,type1,residue_number_2,type2,calculation_method,&
                &trajstep,Num,charge_name,x_box,y_box,z_box,Resid_list,N_neighbours_partial_charges,k,partial_charge_methode,&
                &r_cut,DIPBI_KETTE,P3MT)
                STOP
            ELSE IF (lambda_in_Oniom) THEN
                CALL get_command_argument(12,partial_charge_methode)  
                CALL get_command_argument(13,charge_name)
                CALL get_command_argument(14,dummy4)
                READ(dummy4,'(I10)')  N_neighbours_partial_charges
            
                    ALLOCATE(Resid_list(N_neighbours_partial_charges+2))
                    Resid_list(1)=residue_number_1
                    Resid_list(2)=residue_number_2
                DO i=1,N_neighbours_partial_charges,1
                        CALL get_command_argument(i+14,dummy3)
                        READ(dummy3,'(I10)') Resid_list(i+2)
                END DO
					WRITE(*,*) 'Berechne lambda_in_Oniom'
					CALL make_lambda_in_Oniom(gro_inputfile,residue_number_1,type1,residue_number_2,type2,&
						&calculation_method,trajstep,Num,g09inputline,&
            &partial_charge_methode,x_box,y_box,z_box,Resid_list,N_neighbours_partial_charges,DIPBI_KETTE,P3MT,sub_g09)
                STOP
            END IF
        END IF
ELSE
		CALL print_DIPRO_startscreen()
		CALL EXIT(1)
        !Read(*,*) gro_inputfile,resid1,resid2,calculation_method,dummy1,dummy2,sub-g09ok
END IF


write(*,*) 'sub_g09ok: ',trim(sub_g09ok)      
IF( TRIM(adjustl(sub_g09ok))=='run_local_dftb_plus') then
    sub_g09=.false.
    use_g09=.false.
    sub_dftb_plus=.false.
    use_dftb_plus=.true.
    run_local_dftb_plus=.true.
    run_DIPRO_local_dftb_plus=.true.
ELSE IF (TRIM(adjustl(sub_g09ok))=='true' .OR. TRIM(adjustl(sub_g09ok))=='sub_g09' ) THEN !Submitierung mit sub-myg09-Kankra-DIPRO
    sub_g09=.true.
    use_g09=.true.
    sub_dftb_plus=.false.
    use_dftb_plus=.false.
ELSE IF (( TRIM(adjustl(sub_g09ok))=='sub_dftb+') .OR. (TRIM(adjustl(sub_g09ok))=='sub_dftb_plus') .OR. &
	&  (TRIM(adjustl(sub_g09ok))=='sub_dftb' )) THEN
    sub_g09=.false.
    use_g09=.false.
    sub_dftb_plus=.true.
    use_dftb_plus=.true.
ELSE IF ( (TRIM(adjustl(sub_g09ok))=='dftb+') .OR. (TRIM(adjustl(sub_g09ok))=='dftb_plus')) THEN
    sub_g09=.false.    
    use_g09=.false.
    sub_dftb_plus=.false.
    use_dftb_plus=.true.
ELSE
    sub_g09=.false.
    use_g09=.true.
    use_dftb_plus=.false.
    sub_dftb_plus=.false.
END IF

IF(use_dftb_plus) THEN
	write(*,*) 'use_dftb_plus: ',use_dftb_plus,'  sub_dftb_plus: ',sub_dftb_plus,' run_local_dftb_plus: ',run_local_dftb_plus 
else
	write(*,*) 'use_g09: ',use_g09,' sub_g09: ',sub_g09
endif

!!!! SECTION TO CALCULATE DIPRO DATA !!!!

IF(DIPRO) THEN
	WRITE(*,*) '--- start DIPRO ---'
	WRITE(*,*) 'Resid1:',residue_number_1,'Resid2:',residue_number_2
ELSE IF(lambda_in_on_the_fly) THEN
	WRITE(*,*) '--- start lambda in ---'
	WRITE(*,*) 'Resid1:',residue_number_1,'Resid2:',residue_number_2
ELSE
	WRITE(*,*) 'Error: Reading the DIPRO input data. '
	CALL EXIT(1)
END IF

IF(read_xyz_from_gro) THEN
		CALL read_coord_from_gro_resid(gro_inputfile,residue_number_1,atomsorte,koord,NAtoms,Molname,&
										&DIPBI,DIPBI_KETTE,P3HT,P3MT,PPDI,PPDI_KETTE,PBDT_TS1)
		molA=TRIM(Molname)//'_'//TRIM(str(residue_number_1))
ELSE IF(read_DIPRO_xyz) THEN
	CALL Read_coord_from_xyz(atomsorte,koord,monomerAxyz)
	NAtoms=size(atomsorte)
	molA=TRIM(type1)//'_'//TRIM(str(residue_number_1))
	Molname=TRIM(type1)
ELSE
	WRITE(*,*) 'Error: Select one method: read_DIPRO_gro  or  read_DIPRO_xyz.'
	CALL EXIT(1)
ENDIF

MolnameA=Molname

IF ( (DIPBI .AND. DIPBI_KETTE) .or. (P3HT .AND. .NOT. P3MT) .or. (PPDI .AND. PPDI_KETTE) ) THEN
        KETTE_1=.true.
ELSE
        KETTE_1=.false.
END IF

call Massenschwerpunkt(atomsorte,koord,NAtoms,schwerpunkt1K,KETTE_1)

WRITE(*,*) 'molA: ',TRIM(molA),' PBDT_TS1:',PBDT_TS1,' PPDI:',PPDI,' DIPBI:',DIPBI,' P3HT:',P3HT

IF(DIPBI) THEN
    IF(DIPBI_KETTE) THEN
        call h_diPBI_kette(atomsorte,koord,atomsorte1H,koord1H,NAtoms,molA)
    ELSE
        call h_diPBI(atomsorte,koord,atomsorte1H,koord1H,NAtoms,molA)
    END IF
    DEALLOCATE(koord)
    DEALLOCATE(atomsorte)
ELSE IF (P3HT) THEN
    IF(P3MT) THEN
        CALL h_P3MT(atomsorte,koord,atomsorte1H,koord1H,NAtoms,molA)
    ELSE
        CALL h_P3HT(atomsorte,koord,atomsorte1H,koord1H,NAtoms,molA)   
    END IF
    DEALLOCATE(koord)
    DEALLOCATE(atomsorte)
ELSE IF (PPDI) THEN
    IF(PPDI_KETTE) THEN
        CALL h_PPDI_kette(atomsorte,koord,atomsorte1H,koord1H,NAtoms,molA)
    ELSE IF (PPDI_Propyl) THEN    
        CALL h_PPDI_propyl(atomsorte,koord,atomsorte1H,koord1H,NAtoms,molA)
    ELSE
        !DO i=1,NAtoms
        !    WRITE(*,*) atomsorte(i),koord(i,:)
        !END DO
        CALL h_PPDI(atomsorte,koord,atomsorte1H,koord1H,NAtoms,molA)   
    END IF
    DEALLOCATE(koord)
    DEALLOCATE(atomsorte)
ELSE IF(PBDT_TS1) THEN
    !DO i=1,NAtoms
    !    WRITE(*,*) atomsorte(i),koord(i,:)
    !END DO
    CALL h_PBDT_TS1(atomsorte,koord,atomsorte1H,koord1H,NAtoms,molA)    
    DEALLOCATE(koord)
    DEALLOCATE(atomsorte)
ELSE IF( (.NOT. HDI_KETTE) .AND. (TRIM(Molname) =='HDI' .OR. TRIM(Molname) =='HDI_K' .OR. TRIM(Molname) =='HDI_KETTE')) THEN
    !DO i=1,NAtoms
        !WRITE(*,*) atomsorte(i),koord(i,:)
    !END DO
    CALL h_cut_chain_HDI(atomsorte,koord,NAtoms,atomsorte1H,koord1H,molA)
    DEALLOCATE(koord)
    DEALLOCATE(atomsorte)
ELSE IF (index(TRIM(Molname),'Alq') .ne. 0) THEN ! H-Atoms are not changed
    CALL alq3_rename_elements(atomsorte,koord,NAtoms,atomsorte1H,koord1H,molA)
    DEALLOCATE(koord)
    DEALLOCATE(atomsorte)
ELSE
    
    ! Uebergabe ohne Bearbeitung der H-Atome
    ALLOCATE(koord1H(NAtoms,3))
    ALLOCATE(atomsorte1H(NAtoms))
    DO i=1,NAtoms
	koord1H(i,:)=koord(i,:)
	atomsorte1H(i)=atomsorte(i)
    END DO    
    WRITE(*,*) ' Keine Bearbeitung der H-Atome'
END IF

IF (DEBUG) THEN
    WRITE(*,*) 'Koordinaten molA: atomsorte1H,koord1H(i,:)'
    DO i=1,size(atomsorte1H)
        WRITE(*,*) atomsorte1H(i),koord1H(i,:)
    END DO
END IF
NAtoms1H=size(atomsorte1H)
!!IF(g09_charged) THEN ! Berechnung der Partialladung
!!  call  make_coord_to_g09_charged(atomsorte1H,koord1H,size(atomsorte1H),calculation_method
!!          &,g09inputline,molA,trajstep,Numcharged,charge,NCPUS,MEM)
!!    STOP
!!END IF
! Molekuel 2
DIPBI=.FALSE.    ! Nicht aendern
P3HT=.FALSE.     ! Nicht aendern
PPDI=.false.     ! Nicht aendern
PBDT_TS1=.false. ! Nicht aendern
NAtoms=0

IF(read_xyz_from_gro) THEN
	CALL read_coord_from_gro_resid(gro_inputfile,residue_number_2,atomsorte,koord,NAtoms,Molname,&
                                &DIPBI,DIPBI_KETTE,P3HT,P3MT,PPDI,PPDI_KETTE,PBDT_TS1)
		
		molB=TRIM(Molname)//'_'//TRIM(str(residue_number_2))
ELSE IF(read_DIPRO_xyz) THEN
	CALL Read_coord_from_xyz(atomsorte,koord,monomerBxyz)
	NAtoms=size(atomsorte)
	molB=TRIM(type2)//'_'//TRIM(str(residue_number_2))
	Molname=TRIM(type2)
ELSE
	WRITE(*,*) 'Error: Select one method: read_xyz_from_gro  or  read_DIPRO_xyz'
	CALL EXIT(1)
ENDIF

dimer='Dim_'//TRIM(MolnameA)//'_'//TRIM(Molname)//'_'//TRIM(str(residue_number_1))//'_'//TRIM(str(residue_number_2))


IF ((DIPBI .AND. DIPBI_KETTE) .OR. (P3HT .AND. .NOT. P3MT)) THEN
        KETTE_2=.true.
ELSE
        KETTE_2=.false.
END IF  

call Massenschwerpunkt(atomsorte,koord,NAtoms,schwerpunkt2K,KETTE_2)
WRITE(*,*) 'molB: ',TRIM(molB),' PBDT_TS1:',PBDT_TS1,' PPDI:',PPDI,' DIPBI:',DIPBI,' P3HT:',P3HT

IF(DIPBI) THEN
    IF(DIPBI_KETTE) THEN
        call h_diPBI_kette(atomsorte,koord,atomsorte2H,koord2H,NAtoms,molB)
    ELSE
        call h_diPBI(atomsorte,koord,atomsorte2H,koord2H,NAtoms,molB) 
    END IF
    DEALLOCATE(koord)
    DEALLOCATE(atomsorte)
ELSE IF (P3HT) THEN
    IF(P3MT) THEN
        CALL h_P3MT(atomsorte,koord,atomsorte2H,koord2H,NAtoms,molB)
    ELSE
        CALL h_P3HT(atomsorte,koord,atomsorte2H,koord2H,NAtoms,molB)  
    END IF
    DEALLOCATE(koord)
    DEALLOCATE(atomsorte)
ELSE IF(PPDI) THEN
    IF(PPDI_KETTE) THEN
        CALL h_PPDI_KETTE(atomsorte,koord,atomsorte2H,koord2H,NAtoms,molB)
    ELSE IF (PPDI_Propyl) THEN    
        CALL h_PPDI_propyl(atomsorte,koord,atomsorte2H,koord2H,NAtoms,molB)
    ELSE
        CALL h_PPDI(atomsorte,koord,atomsorte2H,koord2H,NAtoms,molB)   
    END IF
    DEALLOCATE(koord)
    DEALLOCATE(atomsorte)     
ELSE IF(PBDT_TS1) THEN
    !DO i=1,NAtoms
    !    WRITE(*,*) atomsorte(i),koord(i,:)
    !END DO
    CALL h_PBDT_TS1(atomsorte,koord,atomsorte2H,koord2H,NAtoms,molB)    
    DEALLOCATE(koord)
    DEALLOCATE(atomsorte)
ELSE IF( (.NOT. HDI_KETTE) .AND. (TRIM(Molname) =='HDI' .OR. TRIM(Molname) =='HDI_K' .OR. TRIM(Molname) =='HDI_KETTE')) THEN
    !DO i=1,NAtoms
        !WRITE(*,*) atomsorte(i),koord(i,:)
    !END DO
    CALL h_cut_chain_HDI(atomsorte,koord,NAtoms,atomsorte2H,koord2H,molB)
    DEALLOCATE(koord)
    DEALLOCATE(atomsorte) 
ELSE IF (index(TRIM(Molname),'Alq') .ne. 0) THEN ! H-Atoms are not changed
    CALL alq3_rename_elements(atomsorte,koord,NAtoms,atomsorte2H,koord2H,molB)
    DEALLOCATE(koord)
    DEALLOCATE(atomsorte)   
ELSE
    ! Uebergabe ohne Bearbeitung    
    ALLOCATE(koord2H(NAtoms,3))
    ALLOCATE(atomsorte2H(NAtoms))
    DO i=1,NAtoms
	koord2H(i,:)=koord(i,:)
	atomsorte2H(i)=atomsorte(i)
    END DO
    WRITE(*,*) ' Keine Bearbeitung der H-Atome'
END IF
NAtoms2H=size(atomsorte2H)

IF (DEBUG) THEN
    WRITE(*,*) 'Koordinaten molB: atomsorte2H,koord2H(i,:)'
    DO i=1,NAtoms2H
        WRITE(*,*) atomsorte2H(i),koord2H(i,:)
    END DO
END IF

        foldername=TRIM(dimer)//'_'//TRIM(ADJUSTL(calculation_method))//'_G'//TRIM(str(trajstep))//'_N'//TRIM(str(Num))
! Beginn Auswertungsteil

call calc_min_dist_MA_dimer(atomsorte1H,koord1H,NAtoms1H,atomsorte2H,koord2H,NAtoms2H,MA,d_MA)
IF( MA > 35.0) THEN
      call set_mol_box(atomsorte1H,koord1H,NAtoms1H,atomsorte2H,koord2H,NAtoms2H,x_box,y_box,z_box,&
              & OR(KETTE_1,KETTE_2))
      call calc_min_dist_MA_dimer(atomsorte1H,koord1H,NAtoms1H,atomsorte2H,koord2H,NAtoms2H,MA,d_MA)
END IF

IF(DIPBI .AND. NAtoms1H==86 .AND.  NAtoms2H==86 ) THEN
        !call winkelkriterium_DiPBI(koord1H,koord2H,NAtoms1H,theta)
        call winkelkriterium_DiPBI_2(koord1H,koord2H,NAtoms1H,theta)
END IF
	

    call Massenschwerpunkt(atomsorte1H,koord1H,NAtoms1H,schwerpunkt1,KETTE_1)
    call Massenschwerpunkt(atomsorte2H,koord2H,NAtoms2H,schwerpunkt2,KETTE_2)
    COM_H=norm(schwerpunkt2-schwerpunkt1)
    COM=norm(schwerpunkt2K-schwerpunkt1K)
    CALL calc_mittlerer_minimal_Abstand_MMA_dimer(koord1H,NAtoms1H,koord2H,NAtoms2H,MMA,d_MMA)

WRITE(*,*) 'Mol A : ',TRIM(molA), ' Mol B : ',TRIM(molB)
WRITE(*,*) 'Atomanzahl MolA',NAtoms1H,'Atomanzahl MolB',NAtoms2H
WRITE(*,*) residue_number_1,residue_number_2,COM,COM_H,MA,MMA,theta,TRIM(foldername)

IF(lambda_in_on_the_fly) THEN !lambda_in_on_the_fly ausfuehren
    !lambda_in_calculation_method='UFF'
    !lambda_in_inputline=' UFF(QEq) '
    lambda_in_calculation_method=calculation_method
    lambda_in_inputline=g09inputline
    lambda_in_foldername='./lambda_in/'//TRIM(dimer)//'_'//TRIM(lambda_in_calculation_method)//'_G'//TRIM(str(trajstep))//&
                                                                                            &'_N'//TRIM(str(Num))//'_lam'
    CALL lambda_in(molA,molB,trajstep,lambda_in_inputline,sub_g09,atomsorte1H,& 
                    &koord1H,NAtoms1H,atomsorte2H,koord2H,NAtoms2H,lambda_in_foldername,&
                    & NCPUS,mem,CURDIR,g09_SKF_path,extra_SP_lambda_in)
END IF !lambda_in_on_the_fly ausfuehren

	DIPRO_Datenfile='Datenauswertung_SAB_H_H0_Jab_H0_H0_SAB_L0_L0_Jab_L0_L0_G'//TRIM(str(trajstep))//'.dat'
	OPEN(UNIT=24,FILE='res1_res2_COM_COM_H_MA_MMA_theta_G'//TRIM(str(trajstep))//'.dat',&
                    &STATUS='unknown',IOSTAT=ierror1,action='write',position="append")
	OPEN(UNIT=25,FILE='res1_res2_COM_COM_H_MA_MMA_theta_raus_G'//TRIM(str(trajstep))//'.dat',&
                    &STATUS='unknown',IOSTAT=ierror2,action='write',position="append")
	OPEN(UNIT=26,FILE=TRIM(DIPRO_Datenfile)&
                    &,STATUS='unknown',IOSTAT=ierror2,action='write',position="append")

IF ( MA < 45.0 .AND. MA > 1.5) THEN ! sonst MA < 45
        !Erstelle Ordner
        foldername_DIPRO='DIPRO/'//TRIM(foldername)
        ! calculate minimal Distance without chains, with reference to the COMs of the rings in A and B 
        COM_S_MA=0.0
        call calc_COM_S_MA(atomsorte1H,koord1H,NAtoms1H,atomsorte2H,koord2H,NAtoms2H,COM_S_MA,d_RCOM) !!AND(KETTE_1,KETTE_2)
        results_traegheitstensor=' '
        IF(calculate_traegheitstensor) THEN
                call traegheitstensor_analysis(atomsorte1H,koord1H,NAtoms1H,atomsorte2H,koord2H,NAtoms2H,&
                & Kette_1,results_traegheitstensor)
        END IF
        Geo_data_info=' Resid1: '//TRIM(str(residue_number_1))//' Resid2: '//TRIM(str(residue_number_2))//&
                &' COM: '//TRIM(Real2str(COM))//' COM_H: '//&
        &TRIM(Real2str(COM_H))//' MA: '//TRIM(Real2str(MA))//' MMA: '//TRIM(Real2str(MMA))//' theta: '//TRIM(Real2str(theta))//&
        &' COM_S_MA: '//TRIM(Real2str(COM_S_MA))//'  '//TRIM(results_traegheitstensor)//'   '//TRIM(foldername_DIPRO)        
        WRITE(*,*)   TRIM(Geo_data_info)
	WRITE(24,*)  TRIM(Geo_data_info)

        IF(use_dftb_plus) THEN
    		CALL DIPRO_setup_dftb_plus(atomsorte1H,koord1H,NAtoms1H,molA,atomsorte2H,koord2H,NAtoms2H,molB,dimer,&
			& foldername_DIPRO,dftb_plus_SKF_path,dftb_plus_path,run_local_dftb_plus,run_DIPRO_local_dftb_plus, &
			& result_DIPRO_dftb_plus,DEBUG)
			!!! write data to file 
			if( LEN_TRIM(result_DIPRO_dftb_plus) > 10 ) then
				result_DIPRO_dftb_plus=TRIM(result_DIPRO_dftb_plus)//'  '//trim(foldername)//'  '//trim(Geo_data_info)
				if(file_exists_and_continue(DIPRO_Datenfile))then
					write(26,*) trim(result_DIPRO_dftb_plus)
					write(*,*) trim(result_DIPRO_dftb_plus)
				endif
			endif
        ELSE IF (use_g09) THEN ! g09
                inquire(file=TRIM(foldername_DIPRO),exist=folder_vorhanden)               
                if (.NOT. folder_vorhanden) THEN
                        write(bashline,*) 'mkdir '//TRIM(foldername_DIPRO)
                        CALL execute_command_line(TRIM(bashline)) 
                end if ! folder 
                call make_coord_to_xyz_in_dir(atomsorte1H,koord1H,NAtoms1H,molA,foldername_DIPRO)
                call make_coord_to_xyz_in_dir(atomsorte2H,koord2H,NAtoms2H,molB,foldername_DIPRO)      
        
                call DIPRO_setup(molA,molB,dimer,g09inputline,calculation_method,foldername,Geo_data_info,&
                     & atomsorte1H,koord1H,NAtoms1H,atomsorte2H,koord2H,NAtoms2H,&
                     & NCPUS,MEM,g09_SKF_path) 
                     
         END IF !dftb+ or g09
        WRITE(24,*) residue_number_1,residue_number_2,COM,COM_H,MA,MMA,theta,TRIM(foldername_DIPRO)
        IF(sub_g09) THEN
            CALL sub_g09_DIPRO(foldername,DIPRO_Datenfile,Geo_data_info)
        ELSE IF (sub_dftb_plus) THEN
            CALL sub_dftb_plus_DIPRO(foldername,DIPRO_Datenfile,Geo_data_info)
        END IF
ELSE
    write(*,*)  'Fehler: Das Paar wurde fuer DIPRO aussortiert MA_>_45_Ang'
    write(26,*) 'Fehler: Das_Paar_wurde_fuer_DIPRO_aussortiert_MA_>_45_Ang_ '//TRIM(foldername)
    WRITE(25,*) residue_number_1,residue_number_2,COM,COM_H,MA,MMA,theta,TRIM(foldername)
END IF

DEALLOCATE(koord1H,koord2H)
DEALLOCATE(atomsorte1H,atomsorte2H)

CLOSE(26)
CLOSE(25)
CLOSE(24)

END SUBROUTINE gro_to_DIPRO_P3HT_DIPBI_PPDI


SUBROUTINE print_DIPRO_startscreen()
		IMPLICIT NONE

        Write(*,*) '!!! ------------------------------------------------------------------------------------------------------- !!!'
        Write(*,*) '!! method:  DIPRO              Creates the input files for a charge transfer integral evaluation using the     ' 
		Write(*,*) '!!                             DImer PROjection Method (DIPRO).'
        Write(*,*) '!!          DIPRO              Reads the input from the command line and the coordinates from gro_inputfile.gro'
        Write(*,*) '!!          DIPRO_pair         Reads the data from an options.xml file.'   
        Write(*,*) '!!          DIPRO_xyz          Reads the data from *.xyz file.' 
        Write(*,*) '!!          lambda_out_dE_out  Calculate the outer-sphere reorganization energies and '//&
                                            &' electrostratic contributions based on the distribution of partial charges as a sum.'
        Write(*,*) '!!          lambda_out         outer-sphere reorganization energy'
        Write(*,*) '!!          lambda_in          Calculate the internal reorganization energy for a charge transfer complex.' 
        Write(*,*) '!!          lambda_in_oniom    Calculate the internal reorganization energy inside a fixed cavity of molecules.'
        WRITE(*,*) '!! '
        WRITE(*,*) '!! '
        WRITE(*,*) '!!  DIPRO and DIPRO_pair      [sub_g09=true/sub_g09, selects g09]'
        WRITE(*,*) '!!                            [       =sub_dftb+ selects submission for DIPRO via dftb+ programm package]'
        WRITE(*,*) '!!                            [       =dftb+ creates dftb+ file system without submission ]'
        WRITE(*,*) '!! '
        WRITE(*,*) '!! '
        Write(*,*) '!! Use:     method   gro_inputfile.gro    resid1    type1  resid2 type2 calculation_method  GeoStep Number '//&
                               &'[sub_g09/sub_dftb+]         g09inputline'
        Write(*,*) '!! Examples: DIPRO    equi_2000ps_500k_DIPBI.gro 38 DIPBI     449 DIPBI     B3LYP-6-31Gs        1       2 '//&
        &'     false       " B3LYP/6-31G* SCF(XQC,MaxConventionalCycles=400,MaxCycle=800) "'

        WRITE(*,*) '!! '
        WRITE(*,*) '!! DIPRO_pair    options.xml '
        WRITE(*,*) '!! '

        Write(*,*) '!!  Use:       DIPRO_xyz   monomerA.xyz  residA  typeA   monomerB.xyz   residB  typeB  '//& 
						&'calculation_method  GeoStep Number sub_g09  g09inputline'
        Write(*,*) '!!  Examples:  DIPRO_xyz    DIPBI_A.xyz    38     DIPBI    DIPBI_B.xyz    449   DIPBI   '//& 
						&'  PBE0_6_31Gs        1       1    false    " PBE0/6-31G* "  '  
        WRITE(*,*) '!! '
        WRITE(*,*) '!! '
        WRITE(*,*) '!! lambda_in    equi_2000ps_500k.gro 38 DIPBI 449 DIPBI UFF 1 1 true "UFF(QEq)" '
        WRITE(*,*) '!! '
        WRITE(*,*) '!! lambda_in_oniom  equi_2000ps_500k.gro 38 DIPBI 449 DIPBI PBE0_6-31Gs_UFF  1 1 true  '//& 
				&'  "  oniom(PBE0/6-31G*:UFF(QEq)) Opt(Tight,MaxMicroiterations=50000)"  6-31G#_CHelpG  el    6 45 43 50 638 752 1104  '
        WRITE(*,*) '!! '
        WRITE(*,*) '!! '
        WRITE(*,*) '!!  Use:     lambda_out_dE_out  grofilename.gro    neighbourlistfile    Resid1   Resid2 '//& 
						&'partial_charge_methode  Num trajstep'
		WRITE(*,*) '!! Examples: lambda_out_dE_out    alq3_G0.gro  sorted_neighbours_alq3_G0.ngh 0    449    PBE0_6-31Gs_CHelpG   '//&
				&'   0     0   '
        WRITE(*,*) '!! '
        WRITE(*,*) '!! '
        WRITE(*,*) '!! lambda_out old implementation only for DIPBI/P3HT/P3MT ' 
        Write(*,*) '!!  Use:       lambda_out ................................................  chargemethod '//&
						&' charge     r_cut(Ang)   Number_neighbours   Resid_list_neighbours'
        Write(*,*) '!!  Examples:  lambda_out indexed.gro 38 DIPBI 449 DIPBI PM3 3 3 false "PM3"  PBE0_6-31Gs_CHelpG  '//& 
						&'    el       15.00         6                  45 43 50 638 752 1104'
        WRITE(*,*) '!! '
        
        !WRITE(*,*) '!! If the molecule type is unknown type 0'
        Write(*,*) '!!! ------------------------------------------------------------------------------------------------------- !!!'
 END SUBROUTINE print_DIPRO_startscreen
 

SUBROUTINE DIPRO_setup(monomerA,monomerB,dimer,g09inputline,calculation_method,foldername,Geo_data_info,&
			& atomsorteA,koordA,NAtomsA,atomsorteB,koordB,NAtomsB,&
		    & NCPUS,MEM,g09_SKF_path) 
		use small_functions
       ! subroutine creates filesystem via a bash skript mol_all_setup.sh
	IMPLICIT NONE
	CHARACTER (len=500),   INTENT(IN) :: monomerA,monomerB,dimer
	CHARACTER (len=1024), INTENT(IN)  :: Geo_data_info
	CHARACTER (len=500),  INTENT(IN)  :: g09inputline,calculation_method,foldername,g09_SKF_path 

	Integer, INTENT (IN):: NAtomsA,NAtomsB
	Real, Dimension(NAtomsA,3), INTENT (IN) :: koordA
	Character(5), Dimension(NAtomsA), INTENT(IN) :: atomsorteA
	Real, Dimension(NAtomsB,3), INTENT (IN) :: koordB
	Character(5), Dimension(NAtomsB), INTENT(IN) :: atomsorteB
	INTEGER, INTENT (IN) ::NCPUS,MEM
	Character(5), allocatable, Dimension(:) :: atomsorte_dim
	Real, allocatable, Dimension(:,:) :: koord_dim
	
	CHARACTER (len=500) :: g09filename,xyzfilename,tmp_foldername,DIPRO_foldername
	LOGICAL ::folder_vorhanden
	CHARACTER (len=10024)::bashline
	INTEGER ::i,ierror
	LOGICAL ::debug=.false.
		
		
		
	IF (file_exists_and_continue('./DIPRO/mol_all_setup_kankra.sh')) THEN
				write(bashline,*) './DIPRO/mol_all_setup_kankra.sh '//TRIM(monomerA)//'.xyz '//TRIM(monomerB)//'.xyz '//TRIM(dimer)&
				&//'  "'//TRIM(g09inputline)//'" '//TRIM(foldername)//'  " '//TRIM(Geo_data_info)//' "'   
				write (*,*) TRIM(bashline) 
				CALL execute_command_line(TRIM(bashline))
	ELSE 
			!!! Erstelle die DIPRO g09.inp files
			! erstelle DIPRO Ordnersystem
			
			inquire(file='./DIPRO/',exist=folder_vorhanden) ! Erstelle Ordner, wenn er noch nicht existiert
			if (.NOT. folder_vorhanden) THEN
					write(bashline,*) 'mkdir ./DIPRO/'
					CALL execute_command_line(TRIM(bashline)) 
				IF (debug) THEN
							WRITE(*,*) TRIM(bashline)
				END IF ! debug
			END IF ! folder_vorhanden
			DIPRO_foldername='./DIPRO/'//TRIM(foldername)
			write(*,*) '      foldername: ',TRIM(foldername)
			write(*,*) 'DIPRO_foldername: ',TRIM(DIPRO_foldername)
			inquire(file=TRIM(DIPRO_foldername),exist=folder_vorhanden) ! Erstelle Ordner, wenn er noch nicht existiert
			if (.NOT. folder_vorhanden) THEN
					write(bashline,*) 'mkdir '//TRIM(DIPRO_foldername)
					CALL execute_command_line(TRIM(bashline)) 
				IF (debug) THEN
							WRITE(*,*) TRIM(bashline)
				END IF ! debug
			END IF ! folder_vorhanden
			! erstelle DIPRO Ordnersystem
			inquire(file=TRIM(DIPRO_foldername)//'/dim/',exist=folder_vorhanden) ! Erstelle Ordner, wenn er noch nicht existiert
			IF (.NOT. folder_vorhanden) THEN
					write(bashline,*) 'mkdir '//TRIM(DIPRO_foldername)//'/dim/'
					CALL execute_command_line(TRIM(bashline))
					IF (debug) THEN
							WRITE(*,*) TRIM(bashline)
					END IF ! debug
			END IF
			INQUIRE(file=TRIM(DIPRO_foldername)//'/molA/',exist=folder_vorhanden) ! Erstelle Ordner, wenn er noch nicht existiert
			IF (.NOT. folder_vorhanden) THEN
					 write(bashline,*) 'mkdir '//TRIM(DIPRO_foldername)//'/molA/'
					 CALL execute_command_line(TRIM(bashline))
				 IF (debug) THEN
							WRITE(*,*) TRIM(bashline)
				 END IF ! debug
			END IF

			INQUIRE(file=TRIM(DIPRO_foldername)//'/molB/',exist=folder_vorhanden) ! Erstelle Ordner, wenn er noch nicht existiert
			IF (.NOT. folder_vorhanden) THEN
				WRITE(bashline,*) 'mkdir '//TRIM(DIPRO_foldername)//'/molB/'
				CALL execute_command_line(TRIM(bashline))
				IF (debug) THEN
								WRITE(*,*) TRIM(bashline)
				END IF ! debug
			END IF ! Ende Erstellung des DIPRO Ordnersystems
			
			g09filename='molA/monomer.inp'
			OPEN(UNIT=90,FILE=TRIM(DIPRO_foldername)//'/'//TRIM(g09filename),STATUS='REPLACE',IOSTAT=ierror)
			IF(check_ierror(TRIM(DIPRO_foldername)//'/'//TRIM(g09filename),ierror)) THEN
				write(90,*)  "%NProcShared="//TRIM(ADJUSTL(int2str(NCPUS)))
				write(90,*)  "%Mem="//TRIM(ADJUSTL(int2str(MEM)))//"GB"  
				write(90,*)  "# pop=minimal nosymm  IOp(3/33=1) punch=mo  "//TRIM(ADJUSTL(g09inputline))
				write(90,*)  " "  
				write(90,*)  " "//TRIM(monomerA)//"  "//TRIM(calculation_method)//"  with "//TRIM(Geo_data_info) 
				write(90,*)  "  "  
				write(90,*)  "0 1"   
				DO i= 1, NAtomsB
					write(90,'(10X,A3,1X,3F16.6)',IOSTAT=ierror) TRIM(adjustl(atomsorteA(i))),koordA(i,1),koordA(i,2),koordA(i,3)
					if( .not. check_ierror(TRIM(DIPRO_foldername)//'/'//TRIM(g09filename),ierror)) CALL EXIT(1)
				END DO
				write(90,*)  " "  
				CLOSE(90)
				IF( (INDEX(calculation_method,'DFTB') /= 0) ) THEN
					CALL g09_DFTB_SKF_Anhang(atomsorteA,NAtomsA,TRIM(DIPRO_foldername)//'/'//TRIM(g09filename),g09_SKF_path) 
				ENDIF
			ENDIF
			
			
			g09filename='molB/monomer.inp'
			OPEN(UNIT=90,FILE=TRIM(DIPRO_foldername)//'/'//TRIM(g09filename),STATUS='REPLACE',IOSTAT=ierror)
			IF(check_ierror(TRIM(DIPRO_foldername)//'/'//TRIM(g09filename),ierror)) THEN
				write(90,*)  "%NProcShared="//TRIM(ADJUSTL(int2str(NCPUS)))
				write(90,*)  "%Mem="//TRIM(ADJUSTL(int2str(MEM)))//"GB"  
				write(90,*)  "# pop=minimal nosymm  IOp(3/33=1) punch=mo  "//TRIM(ADJUSTL(g09inputline))
				write(90,*)  " "  
				write(90,*)  " "//TRIM(monomerB)//"  "//TRIM(calculation_method)//" with "//TRIM(Geo_data_info) 
				write(90,*)  "  "  
				write(90,*)  "0 1"   
				DO i= 1, NAtomsB
					write(90,'(10X,A3,1X,3F16.6)',IOSTAT=ierror) TRIM(adjustl(atomsorteB(i))),koordB(i,1),koordB(i,2),koordB(i,3)
					if( .not. check_ierror(TRIM(DIPRO_foldername)//'/'//TRIM(g09filename),ierror)) CALL EXIT(1)
				END DO
				write(90,*)  " "  
				CLOSE(90)
				IF( (INDEX(calculation_method,'DFTB') /= 0) ) THEN
					CALL g09_DFTB_SKF_Anhang(atomsorteB,NAtomsB,TRIM(DIPRO_foldername)//'/'//TRIM(g09filename),g09_SKF_path) 
				ENDIF
			ENDIF
			
			g09filename='dim/dimer.inp'
			OPEN(UNIT=90,FILE=TRIM(DIPRO_foldername)//'/'//TRIM(g09filename),STATUS='REPLACE',IOSTAT=ierror)
			IF(check_ierror(TRIM(DIPRO_foldername)//'/'//TRIM(g09filename),ierror)) THEN
				write(90,*)  "%NProcShared="//TRIM(ADJUSTL(int2str(NCPUS)))
				write(90,*)  "%Mem="//TRIM(ADJUSTL(int2str(MEM)))//"GB"  
				write(90,*)  "# pop=minimal nosymm  IOp(3/33=1) punch=mo  "//TRIM(ADJUSTL(g09inputline))
				write(90,*)  " "  
				write(90,*)  " dimer "//TRIM(dimer)//" from "//TRIM(monomerA)//" and "//TRIM(monomerB)//"  "//&
								&TRIM(calculation_method)//" with "//TRIM(Geo_data_info) 
				write(90,*)  "  "  
				write(90,*)  "0 1"  
				DO i= 1, NAtomsA
					write(90,'(10X,A3,1X,3F16.6)',IOSTAT=ierror) TRIM(adjustl(atomsorteA(i))),koordA(i,1),koordA(i,2),koordA(i,3)
					if( .not. check_ierror(TRIM(DIPRO_foldername)//'/'//TRIM(g09filename),ierror)) CALL EXIT(1)
				END DO
				DO i= 1, NAtomsB
					write(90,'(10X,A3,1X,3F16.6)',IOSTAT=ierror) TRIM(adjustl(atomsorteB(i))),koordB(i,1),koordB(i,2),koordB(i,3)
					if( .not. check_ierror(TRIM(DIPRO_foldername)//'/'//TRIM(g09filename),ierror)) CALL EXIT(1)
				END DO
				write(90,*)  " "  
				CLOSE(90)
				IF( (INDEX(calculation_method,'DFTB') /= 0) ) THEN
					IF ( Allocated(atomsorte_dim))  Deallocate(atomsorte_dim)
					ALLOCATE(atomsorte_dim(NAtomsA+NAtomsB))
					atomsorte_dim(1:NAtomsA)=atomsorteA(1:NAtomsA)
					atomsorte_dim(NAtomsA+1:NAtomsA+NAtomsB)=atomsorteB(1:NAtomsB)
					CALL g09_DFTB_SKF_Anhang(atomsorte_dim,NAtomsA+NAtomsB,TRIM(DIPRO_foldername)//'/'//TRIM(g09filename),g09_SKF_path) 
					DEALLOCATE(atomsorte_dim)
				ENDIF
				
				!! Geometrien 
				xyzfilename=TRIM(DIPRO_foldername)//'/'//TRIM(monomerA)//'.xyz'
				if( file_exists_and_continue(xyzfilename) .and. & 
					& (.not. file_exists_and_continue(TRIM(DIPRO_foldername)//'/molA/'//TRIM(monomerA)//'.xyz'))) then
					write(bashline,*) 'mv '//TRIM(xyzfilename)//'  '//TRIM(DIPRO_foldername)//'/molA/'
					CALL execute_command_line(TRIM(bashline))
					if(debug) write(*,*) trim(bashline)
				else
					tmp_foldername=TRIM(DIPRO_foldername)//'/molA'
					 call make_coord_to_xyz_in_dir(atomsorteA,koordA,NAtomsA,monomerA,tmp_foldername)
				endif
				
				!! Geometrien 
				xyzfilename=TRIM(DIPRO_foldername)//'/'//TRIM(monomerB)//'.xyz'
				if( file_exists_and_continue(xyzfilename) .and. & 
					&( .not. file_exists_and_continue(TRIM(DIPRO_foldername)//'/molB/'//TRIM(monomerB)//'.xyz'))) then
					write(bashline,*) 'mv '//TRIM(xyzfilename)//'  '//TRIM(DIPRO_foldername)//'/molB/'
					CALL execute_command_line(TRIM(bashline))
					if(debug) write(*,*) trim(bashline)
				else
					tmp_foldername=TRIM(DIPRO_foldername)//'/molB'
					 call make_coord_to_xyz_in_dir(atomsorteB,koordB,NAtomsB,monomerB,tmp_foldername)
				endif
				
				!! Geometrien 
				xyzfilename=TRIM(DIPRO_foldername)//'/dim/'//TRIM(dimer)//'.xyz'
				if( .not. file_exists_and_continue(xyzfilename)) then
					IF ( Allocated(atomsorte_dim))  Deallocate(atomsorte_dim)
					ALLOCATE(atomsorte_dim(NAtomsA+NAtomsB))
					atomsorte_dim(1:NAtomsA)=atomsorteA(1:NAtomsA)
					atomsorte_dim(NAtomsA+1:NAtomsA+NAtomsB)=atomsorteB(1:NAtomsB)
					IF ( Allocated(koord_dim))  Deallocate(koord_dim)
					ALLOCATE(koord_dim(NAtomsA+NAtomsB,3))
					DO i=1,3
						koord_dim(1:NAtomsA,i)=koordA(1:NAtomsA,i)
					ENDDO
					DO i=1,3
						koord_dim(NAtomsA+1:NAtomsA+NAtomsB,i)=koordB(1:NAtomsB,i)
					ENDDO
					tmp_foldername=TRIM(DIPRO_foldername)//'/dim'
					call make_coord_to_xyz_in_dir(atomsorte_dim,koord_dim,NAtomsA+NAtomsB,dimer,tmp_foldername)
				endif
				write(*,*) ' DIPRO_setup done for ',TRIM(monomerA),'  ',TRIM(monomerB),'  ',TRIM(dimer)
			ENDIF
			
			
			
			
	END IF ! mol_all_setup_kankra.sh  .OR.   DIPRO_setup  
  
END SUBROUTINE DIPRO_setup       

SUBROUTINE g09_DFTB_SKF_Anhang(atomsorteA,NAtomsA,g09filename,g09_SKF_path) 
	use small_functions
	IMPLICIT NONE 
	Integer, INTENT (IN):: NAtomsA
	Character(5), Dimension(NAtomsA), INTENT(IN) :: atomsorteA
	Character(Len=*) :: g09filename,g09_SKF_path
	integer::i,j,ierror
	logical,dimension(5)       :: mio_elements_da
	Character(1) ,dimension(5) :: mio_elements
	
	mio_elements_da=.false.
	mio_elements = (/'H','C','O','N','S'/)
	DO i=1,NAtomsA
		SELECT CASE (TRIM(adjustl(atomsorteA(i))))
			 CASE('H')  
					mio_elements_da(1)=.true.
			 CASE('C') 
					mio_elements_da(2)=.true.
			 CASE('O')
					mio_elements_da(3)=.true.
			 CASE('N')
					mio_elements_da(4)=.true.
			 CASE('S')
					mio_elements_da(5)=.true.
			 CASE DEFAULT
				WRITE(*,*) '####################################################################################'
				WRITE(*,*) 'Warning: Element is not parametrized in g09 MIO-1-1. ',TRIM(ADJUSTL(atomsorteA(i)))
				WRITE(*,*) '####################################################################################'
		END SELECT
	ENDDO
	
	!!!g09_SKF_path='/opt/files/DFTB_skf_files/mio-1-1'
	!write(91,*) '@'//TRIM(adjustl(g09_SKF_path))//'/H-C.skf/N'
    !write(91,*) '@'//TRIM(adjustl(g09_SKF_path))//'/C-H.skf/N'
    !write(91,*) '@'//TRIM(adjustl(g09_SKF_path))//'/C-C.skf/N'
    !write(91,*) '@'//TRIM(adjustl(g09_SKF_path))//'/H-H.skf/N'
    !write(91,*) '@'//TRIM(adjustl(g09_SKF_path))//'/S-S.skf/N'
    !write(91,*) '@'//TRIM(adjustl(g09_SKF_path))//'/C-S.skf/N'
    !write(91,*) '@'//TRIM(adjustl(g09_SKF_path))//'/O-O.skf/N'
	!write(91,*) '@'//TRIM(adjustl(g09_SKF_path))//'/N-N.skf/N'

	
	OPEN(UNIT=91,FILE=TRIM(g09filename),STATUS='unknown',IOSTAT=ierror,action='write',position="append")
	IF(check_ierror(TRIM(g09filename),ierror)) THEN
		DO i=1,5
			DO j=i,5
				if( mio_elements_da(i) .AND. mio_elements_da(j) ) THEN
					write(91,*,IOSTAT=ierror)'@'//TRIM(adjustl(g09_SKF_path))//'/'//mio_elements(i)//'-'//mio_elements(j)//'.skf/N'
					if( i /= j ) then
					 write(91,*,IOSTAT=ierror)'@'//TRIM(adjustl(g09_SKF_path))//'/'//mio_elements(j)//'-'//mio_elements(i)//'.skf/N'
					endif
				endif
			ENDDO
		ENDDO
		write(91,*) ' '
		close(91)
	ENDIF

END SUBROUTINE g09_DFTB_SKF_Anhang


SUBROUTINE DIPRO_setup_dftb_plus(atomsorteA,koordA,NAtomsA,molA,atomsorteB,koordB,NAtomsB,molB,dimer,foldername,&
				& dftb_plus_SKF_path,dftb_plus_path,run_local_dftb_plus,run_DIPRO_local_dftb_plus,&
				& result_DIPRO_dftb_plus,debug)
	!! Subroutine  dftb+ DIPRO-Rechnungen zu initialisieren.
	use small_functions
		IMPLICIT NONE
		Integer, INTENT (IN):: NAtomsA,NAtomsB
		Real, Dimension(NAtomsA,3), INTENT (IN) :: koordA
		Character(5), Dimension(NAtomsA), INTENT(INOUT) :: atomsorteA
		Real, Dimension(NAtomsB,3), INTENT (IN) :: koordB
		Character(5), Dimension(NAtomsB), INTENT(INOUT) :: atomsorteB
		Character(500), INTENT (IN) :: molA,molB,dimer,dftb_plus_path
		Character(500), INTENT (IN) :: foldername,dftb_plus_SKF_path !  path to the Slater-Koster-files 
		LOGICAL, INTENT(IN) :: run_local_dftb_plus,run_DIPRO_local_dftb_plus
		Character(500), INTENT (INOUT) :: result_DIPRO_dftb_plus
		LOGICAL:: debug
		Character(500) :: fmol, tmp_foldername, filename_dftb_plus
		Character(500) :: results_filename, JAB_filename
		Character(500) :: eigenvectorfile, detailedfile, eigenvec_molX
		Character(10000) ::bashline
		Character(5), Dimension((NAtomsA+NAtomsB)) :: atomsorte_dim
		Character(5) :: mol
		Integer :: i,ierror,NAtoms_dim,N_lines
		LOGICAL :: folder_vorhanden,Datei_vorhanden
		integer :: count_eigenvec_ok=0
		!! split input line
		character(len=50000) ::line
		integer :: n_fields
		integer, parameter:: max_fields=100 
		character(len=500), dimension(max_fields) :: fields


		debug=.false.
		! erstelle DIPRO Ordnersystem
		inquire(file=TRIM(foldername),exist=folder_vorhanden) ! Erstelle Ordner, wenn er noch nicht existiert
		IF (.NOT. folder_vorhanden) THEN
			WRITE(bashline,*) 'mkdir '//TRIM(foldername)
			CALL execute_command_line(TRIM(bashline)) 
			IF (debug) THEN
						WRITE(*,*) TRIM(bashline)
			END IF ! debug
		END IF ! folder_vorhanden
		! erstelle DIPRO Ordnersystem
		inquire(file=TRIM(foldername)//'/dim/',exist=folder_vorhanden) ! Erstelle Ordner, wenn er noch nicht existiert
		IF (.NOT. folder_vorhanden) THEN
				WRITE(bashline,*) 'mkdir '//TRIM(foldername)//'/dim/'
				CALL execute_command_line(TRIM(bashline))
				IF (debug) THEN
						WRITE(*,*) TRIM(bashline)
				END IF ! debug
		END IF
		INQUIRE(file=TRIM(foldername)//'/molA/',exist=folder_vorhanden) ! Erstelle Ordner, wenn er noch nicht existiert
		IF (.NOT. folder_vorhanden) THEN
				 WRITE(bashline,*) 'mkdir '//TRIM(foldername)//'/molA/'
				 CALL execute_command_line(TRIM(bashline))
			 IF (debug) THEN
						WRITE(*,*) TRIM(bashline)
			 END IF ! debug
		END IF

		INQUIRE(file=TRIM(foldername)//'/molB/',exist=folder_vorhanden) ! Erstelle Ordner, wenn er noch nicht existiert
		IF (.NOT. folder_vorhanden) THEN
			WRITE(bashline,*) 'mkdir '//TRIM(foldername)//'/molB/'
			CALL execute_command_line(TRIM(bashline))
			IF (debug) THEN
							WRITE(*,*) TRIM(bashline)
			END IF ! debug
		END IF ! Ende Erstellung des DIPRO Ordnersystems

		!! Entferne nummern aus *.gro Koordinaten 
		DO i=1,NAtomsA
			atomsorteA(i)=TRIM(ADJUSTL(delete_numbers_from_string(atomsorteA(i))))
		ENDDO
		!! Entferne nummern aus *.gro Koordinaten 
		DO i=1,NAtomsB
			atomsorteB(i)=TRIM(ADJUSTL(delete_numbers_from_string(atomsorteB(i))))
		ENDDO
		
		!Erstelle xyz-files in DIPRO Ordnern
		tmp_foldername=TRIM(foldername)//'/molA'
		call make_coord_to_xyz_in_dir(atomsorteA,koordA,NAtomsA,molA,tmp_foldername)
		INQUIRE(file=TRIM(tmp_foldername)//'/'//TRIM(molA)//'.gen',exist=folder_vorhanden) ! Erstelle Ordner, wenn er noch nicht existiert
		IF (.NOT. folder_vorhanden) THEN
			 WRITE(bashline,*) TRIM(dftb_plus_path)//'xyz2gen '//TRIM(tmp_foldername)//'/'//TRIM(molA)//'.xyz'
			 CALL execute_command_line(TRIM(bashline))
			 IF (debug) THEN
							WRITE(*,*) TRIM(bashline)
			 END IF ! debug
			 filename_dftb_plus='dftb_in.hsd'
			 CALL make_dftb_plus_hsd(atomsorteA,NAtomsA,molA,filename_dftb_plus,tmp_foldername,dftb_plus_SKF_path,debug)
		END IF ! Erstellung molA.gen

		tmp_foldername=TRIM(foldername)//'/molB'
		call make_coord_to_xyz_in_dir(atomsorteB,koordB,NAtomsB,molB,tmp_foldername)
		INQUIRE(file=TRIM(tmp_foldername)//'/'//TRIM(molB)//'.gen',exist=folder_vorhanden) ! Erstelle Ordner, wenn er noch nicht existiert
		IF (.NOT. folder_vorhanden) THEN
			  WRITE(bashline,*) TRIM(dftb_plus_path)//'xyz2gen '//TRIM(tmp_foldername)//'/'//TRIM(molB)//'.xyz'
			  CALL execute_command_line(TRIM(bashline))
			  IF (debug) THEN
							WRITE(*,*) TRIM(bashline)
			  END IF ! debug    
			 filename_dftb_plus='dftb_in.hsd'
			 CALL make_dftb_plus_hsd(atomsorteB,NAtomsB,molB,filename_dftb_plus,tmp_foldername,dftb_plus_SKF_path,debug)
		END IF ! Erstellung molB.gen

		tmp_foldername=TRIM(foldername)//'/dim'
		OPEN(UNIT=77,FILE=TRIM(tmp_foldername)//'/'//TRIM(dimer)//'.xyz',STATUS='REPLACE',IOSTAT=ierror)
		NAtoms_dim=(NAtomsA+NAtomsB) ! Number of Atoms in the dimer
		WRITE(77,'(I8,/,"  genarated by ")') NAtoms_dim
		DO i= 1, NAtomsA, 1
			WRITE(77,'(2X,A3,1X,3F16.6)') atomsorteA(i),koordA(i,1),koordA(i,2),koordA(i,3)
		END DO
		DO i= 1, NAtomsB, 1
			WRITE(77,'(2X,A3,1X,3F16.6)') atomsorteB(i),koordB(i,1),koordB(i,2),koordB(i,3)
		END DO
		ClOSE(77)
		
		INQUIRE(file=TRIM(tmp_foldername)//'/'//TRIM(dimer)//'.gen',exist=Datei_vorhanden) ! Erstelle Datei, wenn er noch nicht existiert
		IF (.NOT. Datei_vorhanden) THEN
			 WRITE(bashline,*) TRIM(dftb_plus_path)//'xyz2gen '//TRIM(tmp_foldername)//'/'//TRIM(dimer)//'.xyz'
			 CALL execute_command_line(TRIM(bashline))
			 IF (debug) THEN
							WRITE(*,*) TRIM(bashline)
			 END IF ! debug
		END IF ! Erstellung dimer.gen
	   ! Ende Erstellung der Koordinaten-Dateien fuer dftb+ DIPRO rechnungen
		
		filename_dftb_plus='dftb_in.hsd'
		INQUIRE(file=TRIM(tmp_foldername)//'/'//TRIM(filename_dftb_plus),exist=Datei_vorhanden) ! Erstelle Datei, wenn er noch nicht existiert
		IF (.NOT. Datei_vorhanden) THEN
			atomsorte_dim(1:NAtomsA)=atomsorteA(1:NAtomsA)
			atomsorte_dim((NAtomsA+1):NAtoms_dim)=atomsorteB(1:NAtomsB)
			CALL make_dftb_plus_hsd(atomsorte_dim,NAtoms_dim,dimer,filename_dftb_plus,tmp_foldername,dftb_plus_SKF_path,debug)
		END IF
		
		IF(run_local_dftb_plus)then
			write(*,*) '--- start local dftb+ ---'
			count_eigenvec_ok=0
			
			fmol=TRIM(foldername)//'/dim'
			!! check if the overlap matrix for the dimer exists
			if( file_exists_and_continue(trim(fmol)//'/overreal.dat')) then
				count_eigenvec_ok = count_eigenvec_ok + 1 
			else
				if(file_exists(trim(fmol)//'/dftb_in.hsd')) then
						bashline=" sed -i 's/WriteRealHS = No/WriteRealHS = Yes/g'  "//trim(fmol)//"/dftb_in.hsd"
						CALL execute_command_line(TRIM(bashline)) 
						IF (debug) THEN
										WRITE(*,*) TRIM(bashline)
						END IF ! debug
						
						if( file_exists_and_continue(dftb_plus_path)) then
							bashline=" cd "//trim(fmol)//"  ;  "//&
							&TRIM(dftb_plus_path)//"/dftb+  dftb_in.hsd   >  ./dim_dftb_plus_overlap.log  ; cd ../../ "
							CALL execute_command_line(TRIM(bashline)) 
							IF (debug) THEN
										WRITE(*,*) TRIM(bashline)
							END IF ! debug
						else
							bashline=" cd "//trim(fmol)//"  ; dftb+  dftb_in.hsd  > ./dim_dftb_plus_overlap.log ; cd ../../ "
							CALL execute_command_line(TRIM(bashline)) 
							IF (debug) THEN
										WRITE(*,*) TRIM(bashline)
							END IF ! debug
							
						endif ! dftb_plus_path ?
						
						bashline=" sed -i 's/WriteRealHS = Yes/WriteRealHS = No/g'  "//trim(fmol)//"/dftb_in.hsd"
						CALL execute_command_line(TRIM(bashline)) 
						IF (debug) THEN
										WRITE(*,*) TRIM(bashline)
						END IF ! debug
						
						if( file_exists(trim(fmol)//'/overreal.dat')) then
							write(*,*) 'DFTB overlapp S_AB generated: ',trim(fmol)//'/overreal.dat'
							count_eigenvec_ok = count_eigenvec_ok + 1 
						endif ! overreal.dat produced?
				endif
			endif ! overreal.dat ? 
			
			!!! loop  dim, molA, molB => Start dftb+ local.
    		do i=1,3
				if(i==1) mol='dim'
				if(i==2) mol='molA'
				if(i==3) mol='molB'
				fmol=TRIM(foldername)//'/'//TRIM(mol)
				eigenvec_molX='./'//Trim(fmol)//'/eigenvec_'//TRIM(mol)//'.dat'
				if( .not. file_exists_and_continue(eigenvec_molX)) then
					if( file_exists(TRIM(fmol)//'/dftb_in.hsd'))then
						if( file_exists_and_continue(dftb_plus_path)) then
							bashline=' cd '//trim(fmol)//'  ;  '//&
									&TRIM(dftb_plus_path)//'/dftb+ > '//Trim(mol)//'_dftb_plus.log  ; cd ../../ '
							
							IF (debug) THEN
										WRITE(*,*) TRIM(bashline)
							END IF ! debug
							CALL execute_command_line(TRIM(bashline)) 
						else
							bashline=' cd '//trim(fmol)//'  ;  '//&
							&' dftb+ >  ./'//Trim(mol)//'_dftb_plus.log  ; cd ../../ '
							IF (debug) THEN
										WRITE(*,*) TRIM(bashline)
							END IF ! debug
							CALL execute_command_line(TRIM(bashline)) 
							
						endif ! dftb_plus_path ?
						eigenvectorfile=trim(fmol)//'/eigenvec.out'
						detailedfile=trim(fmol)//'/detailed.out'
						eigenvec_molX=trim(fmol)//'/eigenvec_'//Trim(mol)//'.dat'
						CALL eigenvDFTB_plus_2DIPRO(eigenvectorfile,detailedfile,eigenvec_molX)
						if(file_exists_and_continue(eigenvec_molX))then
							count_eigenvec_ok= count_eigenvec_ok + 1
						endif
					endif ! dftb_in.hsd ?
				else
					count_eigenvec_ok = count_eigenvec_ok + 1
				endif ! .not. eigenvec_molX
			enddo
			
			if(count_eigenvec_ok ==4) then
				write(*,*) 'All dftb+ eigenvector files produced  and  overreal.dat '
			endif
			
			
			
			!!!--------------------- Start DIPRO calculation ----------------------------!
			if(run_DIPRO_local_dftb_plus .and. (count_eigenvec_ok ==4) )then
				mol='dim'
				if(file_exists_and_continue('DIPRO-nMO-V11'))then
					fmol=TRIM(foldername)//'/dim'
					if( file_exists(fmol)) then
								bashline=' cd '//trim(fmol)//'  ;  '//&
								&' ../../DIPRO-nMO-V11 dftb+ >  ./DIPRO_'//'_'//trim(dimer)//'_dftb_plus.log  ; cd ../../../ '
								IF (debug) THEN
											WRITE(*,*) TRIM(bashline)
								END IF ! debug
								CALL execute_command_line(TRIM(bashline)) 
					endif ! fmol?
				else if(file_exists_and_continue('charge_transport_package'))then
					fmol=TRIM(foldername)//'/dim'
					if( file_exists(fmol)) then
								bashline=' cd '//trim(fmol)//'  ;  '//&
								&' ../../../charge_transport_package  DIPRO_nMO  dftb+ > '//& 
								&' DIPRO_'//'_'//trim(dimer)//'_dftb_plus.log  ; cd ../../../ '
								IF (debug) THEN
											WRITE(*,*) TRIM(bashline)
								END IF ! debug
								CALL execute_command_line(TRIM(bashline)) 
					endif ! fmol?
				endif ! DIPRO-nMO-V11  or charge_transport_package
				
				fmol=TRIM(foldername)//'/dim'
				JAB_filename='Datenauswertung_SAB_H_H0_Jab_H0_H0_SAB_L0_L0_Jab_L0_L0_G0.dat'
				results_filename=trim(fmol)//'/'//trim(JAB_filename)
				if( file_exists(results_filename)) then
					N_lines=Read_rows_file2(results_filename)
					write(*,*) 'N_lines: ',N_lines
					if( N_lines > 0 ) then
						OPEN(Unit=23, File=results_filename, Status='old', action='read', IOSTAT=ierror)
						Do i=1,N_lines-1
							read(23,*)
						enddo
						read( 23, "(a)",IOSTAT=ierror) line
						if(ierror > 0) then
							write(*,*) 'Error: Reading the file: ',trim(results_filename)
							call exit(1)
						endif
						if(debug) write(*,*) trim(line)
						Call split_string_to_array( line, fields, n_fields, max_fields )
							endif !N_lines ?
						endif ! results_filename?
						if( n_fields >= 4) then
							write(*,*) ( ' '//trim(fields(i)),i=1,n_fields)
							result_DIPRO_dftb_plus=trim(line)
						endif
						
			endif ! run_DIPRO_local_dftb_plus
			
			
		ENDIF ! run_local_dftb_plus
		
END SUBROUTINE DIPRO_setup_dftb_plus

SUBROUTINE make_dftb_plus_hsd(atomsorte,NAtoms,mol,filename,foldername,dftb_plus_SKF_path,debug)
		use small_functions
		IMPLICIT NONE
		Character(500), INTENT (IN) :: mol,foldername,dftb_plus_SKF_path !  path to the Slater-Koster-files
		CHARACTER(500) ::filename
		Integer, INTENT (IN):: NAtoms
		CHARACTER (5), Dimension(NAtoms), INTENT (IN) :: atomsorte
		CHARACTER (5), Dimension(NAtoms) :: tmp_atomsorte
		LOGICAL, INTENT(IN) :: debug
		LOGICAL::Datei_vorhanden,string_in_array=.false.
		INTEGER::i,j,j_max,ierror
		CHARACTER(1)::l_max ! maximum angular momentum

		INQUIRE(file=TRIM(foldername)//'/'//TRIM(filename),exist=Datei_vorhanden) ! Erstelle Ordner, wenn er noch nicht existiert
		IF (Datei_vorhanden) THEN  
			WRITE(*,*) 'File is replaced:'//TRIM(foldername)//'/'//TRIM(filename)
		END IF
		OPEN(UNIT=50,FILE=TRIM(foldername)//'/'//TRIM(filename),STATUS='REPLACE',IOSTAT=ierror)

		WRITE(50,*) 'Geometry = GenFormat {'
		WRITE(50,*) ' <<< "'//TRIM(mol)//'.gen"'
		WRITE(50,*) '}'
		WRITE(50,*) 'Driver = {}'
		WRITE(50,*) ' '
		WRITE(50,*) 'Hamiltonian = DFTB {'
		WRITE(50,*) '  SCC = Yes'
		WRITE(50,*) '  SCCTolerance = 1.0E-07'
		WRITE(50,*) '  MaxSCCIterations = 1000'
		WRITE(50,*) '  Mixer = Broyden {}'
		WRITE(50,*) '  MaxAngularMomentum = {'
		! get list of all elements to calc the maximum angular momentum
		j_max=0
		tmp_atomsorte=' '
		DO i=1,NAtoms  ! loop to get an array: tmp_atomsorte with all element names listed once.
			string_in_array=.false.
			DO j=1,j_max
				IF ( TRIM(atomsorte(i)) == TRIM(tmp_atomsorte(j)) )THEN
					string_in_array=.true.
					EXIT
				ELSE 
					CYCLE
				END IF
			END Do !
				IF (string_in_array) THEN
				   CYCLE
				ELSE
					! add element
					j_max=j_max+1
					tmp_atomsorte(j_max)=atomsorte(i)
				IF(debug) THEN
							WRITE(*,*) tmp_atomsorte(j_max)
				END IF ! debug
				END IF ! string_in_array
		END DO !i

		DO i=1,j_max
			l_max=get_max_angular_momentum(tmp_atomsorte(i))
			WRITE(50,*) '   '//TRIM(tmp_atomsorte(i))//' = "'//TRIM(l_max)//'"'
			IF(debug) THEN
				WRITE(*,*) 'Element(p): ',tmp_atomsorte(i),TRIM(l_max)
			END IF ! debug
		END DO !i

		WRITE(50,*) '  }'
		WRITE(50,*) ' Filling = Fermi {'
		WRITE(50,*) '    Temperature [Kelvin] = 300.0 '
		WRITE(50,*) '  }'
		WRITE(50,*) ' SlaterKosterFiles = Type2Filenames {'
		WRITE(50,*) '    Prefix = "'//TRIM(dftb_plus_SKF_path)//'"'
		WRITE(50,*) '    Separator = "-"'
		WRITE(50,*) '    Suffix = ".skf"'
		WRITE(50,*) '  }'
		WRITE(50,*) '  ReadInitialCharges = No'
		WRITE(50,*) '}'

		WRITE(50,*) 'Options = {'
		WRITE(50,*) '  WriteAutotestTag = Yes'

		IF((index(TRIM(mol) ,'Dim_') .ne. 0) .or. (index(TRIM(mol) ,'dim_') .ne. 0))then ! get overlap for dimer as the molname for a dimer shoul start with Dim_
				WRITE(50,*)' WriteRealHS = No '
		END IF ! get overlap matrix in dftb+
		WRITE(50,*) '}'

		WRITE(50,*) 'ParserOptions = {'
		WRITE(50,*) '  ParserVersion = 3'
		WRITE(50,*) '}'
		WRITE(50,*) ' '
		WRITE(50,*) 'Analysis = {'
		WRITE(50,*) '  WriteEigenvectors = Yes'
		WRITE(50,*) '  EigenvectorsAsTxt = Yes'
		WRITE(50,*) '  AtomResolvedEnergies = Yes'
		WRITE(50,*) '  CalculateForces = Yes'
		WRITE(50,*) ' }'

		WRITE(*,*) 'Datei erstellt: '//TRIM(foldername)//'/'//TRIM(filename)
		CLOSE(50)


END SUBROUTINE make_dftb_plus_hsd


SUBROUTINE sub_g09_DIPRO(foldername,DIPRO_Datenfile,Geo_data_info)
        !! subroutine DIPRO files to Queue via the bash skript: sub-myg09-Palma-DIPRO-Repair
        !! DIPRO_Datenfile: filename to write DIPRO-Output data
        use small_functions
        IMPLICIT NONE
        !INTEGER, INTENT (IN) ::NCPUS,NODE,TIME,JOBNUMBER
        !CHARACTER (len=50),  INTENT (IN)::QUEUE 
        CHARACTER (len=500), INTENT (IN)::foldername,DIPRO_Datenfile
        
        CHARACTER (len=500)::foldername_DIPRO  
        CHARACTER (len=1024) ::bashline,Geo_data_info
        LOGICAL::exist_foldername
        !INPUTFOLDER/ 
        foldername_DIPRO='./DIPRO/'//TRIM(foldername)
        inquire(file=TRIM(foldername_DIPRO),exist=exist_foldername)
        IF(exist_foldername) THEN
            write(bashline,*) "cd ./DIPRO ; ./sub-g09-dftb+-Kankra-DIPRO "//TRIM(foldername)//' sub_g09 '//&
            &TRIM(DIPRO_Datenfile)//' " '//TRIM(Geo_data_info) //' "  ; cd ../ '!//"/ "//TRIM(str(NCPUS))//" "//TRIM(str(NODE))//&
                                            !&" "//TRIM(QUEUE)//" "//TRIM(str(TIME))//" "//TRIM(str(JOBNUMBER))      
        ELSE 
            WRITE(*,*) 'Fehler: Der_folgende_Ordner_existiert nicht. ',TRIM(foldername_DIPRO)
        END IF
        write (*,*) TRIM(bashline) 
        CALL execute_command_line(TRIM(bashline)) 
  
END SUBROUTINE sub_g09_DIPRO

SUBROUTINE sub_dftb_plus_DIPRO(foldername,DIPRO_Datenfile,Geo_data_info)
        ! subroutine DIPRO files to Queue via the bash skript: sub-myg09-Palma-DIPRO-Repair
        ! DIPRO_Datenfile: filename to write DIPRO-Output data
        IMPLICIT NONE
        !INTEGER, INTENT (IN) ::NCPUS,NODE,TIME,JOBNUMBER
        CHARACTER (len=500), INTENT (IN)::foldername,DIPRO_Datenfile
        !CHARACTER (len=50),  INTENT (IN)::QUEUE 
        CHARACTER (len=500)::foldername_DIPRO  
        CHARACTER (len=1024) ::bashline,Geo_data_info
        LOGICAL::exist_foldername
        !INPUTFOLDER/ 
        foldername_DIPRO='./DIPRO/'//TRIM(foldername)
        inquire(file=TRIM(foldername_DIPRO),exist=exist_foldername)
        IF(exist_foldername) THEN
          write(bashline,*) "cd ./DIPRO ; ./sub-g09-dftb+-Kankra-DIPRO "//TRIM(foldername)//' sub_dftb_plus '//&
          &TRIM(DIPRO_Datenfile)//' " '//TRIM(Geo_data_info) //' "  ; cd ../ '!//"/ "//TRIM(str(NCPUS))//" "//TRIM(str(NODE))//&
                                            !&" "//TRIM(QUEUE)//" "//TRIM(str(TIME))//" "//TRIM(str(JOBNUMBER))      
        ELSE 
            WRITE(*,*) 'Fehler: Der_folgende_Ordner_existiert nicht. ',TRIM(foldername_DIPRO)
        END IF


        write (*,*) TRIM(bashline) 
        CALL execute_command_line(TRIM(bashline)) 
  
END SUBROUTINE sub_dftb_plus_DIPRO

!! Convert the eigenvector format from  dftb+  to g09  input format.
subroutine eigenvDFTB_plus_2DIPRO(eigenvectorfile,detailedfile,eigenvec_molX)
	!! Subroutine to convert the eigenvalue file from dftb+ to an eigentvalue file, that can be read by the DIPRO programm
	!! =>  eigenvDFTB_plus_2DIPRO  eigenvec.out detailed.out > eigenvec_${molX}.dat
	use small_functions
	implicit none
	character(len=500) , intent(in):: eigenvectorfile,detailedfile,eigenvec_molX
	integer :: fcount,EV_count_on,EV_count,count_orbs
	integer :: HOMO,LUMO
	real    :: occupation,small_contaminations_cutoff
	!! split input line
	character(len=50000) ::line
	integer :: n_fields, n_lines_detailed, n_lines_eigenvectorfile
	integer, parameter:: max_fields=30 
	character(len=500), dimension(max_fields) :: fields
	integer :: l,ierror,ierror1
	logical:: debug=.false.
	
	small_contaminations_cutoff=0.0005  !  cutoff to ignore small contaminations
	
	if( file_exists_and_continue(eigenvec_molX)) then
		write(*,*) 'The file already exists: ',trim(eigenvec_molX)
	else if(file_exists(eigenvectorfile) .and. file_exists(detailedfile) ) then
		n_lines_eigenvectorfile=Read_rows_file2(eigenvectorfile)
		if( n_lines_eigenvectorfile < 2) then
			write(*,*) 'Error: Small data file: ',trim(eigenvectorfile)
			call exit(1)
		endif
		n_lines_detailed = Read_rows_file2(detailedfile)
		if(n_lines_detailed < 2) then
			write(*,*) 'Error: Small data file: ',trim(detailedfile)
			call exit(1)
		endif

		if(debug) write(*,*) 'start reading: ',trim(detailedfile)
		Open(Unit=16, File=trim(eigenvec_molX), Status='unknown',action='write', IOSTAT=ierror)
		Open(Unit=17, File=trim(detailedfile), Status='OLD',action='read',IOSTAT=ierror)
        fcount=0       ! switch, if Filling section starts
        EV_count_on=0
        EV_count=0
        count_orbs=0   ! counts the number of orbitals to get the LUMO and HOMO index number
        do l=1,n_lines_detailed
                READ( 17, "(a)",IOSTAT=ierror) line
                if(ierror < 0) exit
                if(ierror > 0) then
					write(*,*) 'Error: Reading the file: ',trim(detailedfile)
					call exit(1)
				endif
				if(debug) write(*,*) trim(line)
				Call split_string_to_array( line, fields, n_fields, max_fields )
				if( n_fields == 0 ) then
					cycle
				endif
				!write(*,*) TRIM(fields(1)),' ',TRIM(fields(2))
				if( (index(fields(1),'Eigenvalues') .ne. 0) .and. (index(fields(2),'eV') .ne. 0) )then
					EV_count_on=0  ! turn off, as we count the eigenvalues in Hartree list			
				end if
				if ( EV_count_on == 1 ) then
					EV_count=EV_count+1
					if(n_fields > 0) write(16,*) TRIM(adjustl(fields(1)))
				endif
				if( (index(fields(1),'Eigenvalues') .ne. 0) .and. (index(fields(2),'H') .ne. 0) )then
					EV_count_on=1  ! turn on, as we count the eigenvalues in Hartree list
					if(n_fields > 0) write(16,*) trim(adjustl(fields(1))),' [a.u.]'  ! THE FORMAT WITH [a.u.] is read from the DIPRO file as \H is not read in Fortran90
				end if
				
				! counts the fillings to get the HOMO-level index
				if (fcount == 1 ) then
					count_orbs=count_orbs+1 
					occupation=str2real(fields(1))
					if (occupation < small_contaminations_cutoff ) then   !!! cutoff to ignore small contaminations
						LUMO=count_orbs
						HOMO=count_orbs-1
						fcount=0
					endif
				endif
				
				if(index(fields(1),'Fillings') .ne. 0) then
					fcount=1 
				endif
        end do ! read detailedfile
		write(16,*) "NBasis=",EV_count
		write(16,*) "HOMO= ",HOMO
		write(16,*) "LUMO= ",LUMO
		if( (HOMO < 1) .or. (LUMO < 1) .or. (EV_count < 1)) then
			write(*,*) "Error: NBasis=",EV_count,"HOMO= ",HOMO,"LUMO= ",LUMO
			call exit(1)
		endif
		if(debug) write(*,*) "NBasis=",EV_count,"HOMO= ",HOMO,"LUMO= ",LUMO
		
		Open(Unit=18, File=trim(eigenvectorfile), Status='OLD', IOSTAT=ierror1)
		
        do l=1,n_lines_eigenvectorfile
			READ( 18, "(a)",IOSTAT=ierror1) line
			IF(ierror1 < 0) EXIT
			IF(ierror1 > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(eigenvectorfile),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				STOP
			END IF
			Call split_string_to_array( line, fields, n_fields, max_fields )
			if( (index(fields(1),'Eigenvector:') .ne. 0) .and. (n_fields > 1)) then
				if(n_fields >= 3) write(16,*, IOSTAT=ierror) TRIM(adjustl(fields(1)))," ",TRIM(adjustl(fields(2)))," ",TRIM(adjustl(fields(3)))
				if(n_fields == 2) write(16,*, IOSTAT=ierror) TRIM(adjustl(fields(1)))," ",TRIM(adjustl(fields(2)))
			else if ( n_fields == 0 ) then
				cycle 
				!WRITE(*,*) "comment line: "//TRIM(line)
			else if(n_fields==3) then
				write(16,'(F10.6)', IOSTAT=ierror) str2real(TRIM(adjustl(fields(2))))   
			else if (n_fields==5) then      
				write(16,'(F10.6)', IOSTAT=ierror) str2real(TRIM(adjustl(fields(4)))) 
			endif
		
		enddo ! read eigenvectorfile
		CLOSE(18)
		CLOSE(17)
		CLOSE(16)
		write(*,*) 'DFTB eigenvectors stored in: ',trim(eigenvec_molX)
	endif ! file exists?   eigenvectorfile  and detailedfile

end subroutine eigenvDFTB_plus_2DIPRO







!!=========================!!  
!!    LAMBDA_IN_ONIOM      !!
!!=========================!! 
Subroutine make_lambda_in_Oniom(gro_inputfile,residue_number_1,type1,residue_number_2,type2,calculation_method,trajstep,Num,&
&lambda_in_oniom_inputline,partial_charge_methode,x_box,y_box,z_box,Resid_list,N_neighbours,DIPBI_KETTE,P3MT,sub_g09)
use small_functions
IMPLICIT NONE
INTEGER, INTENT(IN)::residue_number_1,residue_number_2,N_neighbours,trajstep,Num
Character(500),   INTENT(IN) ::type1,type2
Character(500), INTENT(IN) ::gro_inputfile,partial_charge_methode
Character(500), INTENT(IN) ::calculation_method,lambda_in_oniom_inputline
LOGICAL, INTENT(INOUT) ::sub_g09,DIPBI_KETTE,P3MT
REAL, INTENT(INOUT) ::x_box,y_box,z_box 
Character(800)  :: l_in_oniom_foldername,zielfile,q_file_n,q_file_el_1,q_file_el_2,q_file_lo_1,q_file_lo_2
Character(10000)  :: xyz_N_file_A_n,xyz_N_file_A_el,xyz_N_file_A_lo,xyz_N_file_B_n,xyz_N_file_B_el,xyz_N_file_B_lo,sting800
INTEGER, Dimension(N_neighbours+2), INTENT(INOUT) ::Resid_list
INTEGER::i,j,k,l,n,i_min,i_max,k_max,int_dummy,ierror1,MAXATM_A,MAXATM_B,MAXATM_H,MAXATM_All
INTEGER::i_1,i_2,N_Schwefel,Counter_Oniom_xyz_namelist
LOGICAL::xyz_N_vorhanden_A,xyz_N_vorhanden_B,folder_vorhanden,DIPBI,P3HT,SAVE_OLD,istart
LOGICAL::Resid_1_da,Resid_2_da,ende_1,ende_2,Resids_in_same_mol,Freeze,UFF_calc,Read_partial_charges
LOGICAL::KETTE_1,KETTE_2
Character(5), ALLOCATABLE, Dimension(:) :: atomsorte,atomsorteA,atomsorteB,atomsorte1H
Character(500), ALLOCATABLE, Dimension(:) :: Oniom_xyz_namelist
INTEGER, ALLOCATABLE, Dimension(:,:)::Data_collect,NSchwefel_P3HT
Real, ALLOCATABLE, Dimension(:,:) :: koord,koordA,koordB,koord1H,linkatoms
Real,ALLOCATABLE,Dimension(:)::partial_charges_n,partial_charges_el_1,partial_charges_lo_1
Real,ALLOCATABLE,Dimension(:)::partial_charges_el_2,partial_charges_lo_2
Real,Dimension(3):: dummy_koord_start_1,dummy_koord_ende_1,dummy_koord_start_2,dummy_koord_ende_2,schwerpunkt_1
Character(500)::dummyname,run_lambda_in,Molname,molA,molB,molX,dimer,string
Character(1000000)::Bashline
Character(4)::S_Ringe
Character(5)::atom,residue_name,last_residue_name
INTEGER::ierror,lastresid,residue_number,atom_number,MAXATM,Gesamtanzahl,count_atoms_in_mol,q_index_1,q_index_2
REAL::x,y,z,v_x,v_y,v_z
Character(len=*), PARAMETER::form1='(2X,A5,1X,A2,1X,3F16.6,1X,A2)',form2='(2X,A15,1X,A2,1X,3F16.6,1X,A2)'
LOGICAL::PPDI,PPDI_KETTE,PBDT_TS1,HDI_KETTE=.false.,DEBUG=.false.


	write(*,*) "!!=========================!!"
	write(*,*) "!!    LAMBDA_IN_ONIOM      !!"
	write(*,*) "!!=========================!!"
	
	write(*,*) 'Start subroutine make_lambda_in_Oniom'
	WRITE(*,*) 'Resid_1',residue_number_1,'Resid_2 ',residue_number_2

	! Setzen der Ausgabedaten 
	dimer='Dim_'//TRIM(type1)//'_'//TRIM(type2)//'_'//TRIM(str(residue_number_1))//'_'//TRIM(str(residue_number_2))
	l_in_oniom_foldername='./Oniom/'//TRIM(dimer)//'_'//TRIM(calculation_method)//'_G'//TRIM(str(trajstep))//'_N'//TRIM(str(Num))&
								&//'_lambda_in_oniom'
	zielfile='results_lambda_in_Oniom_G'//TRIM(str(trajstep))//'.dat'
	run_lambda_in='run_lambda_in_V3.sh'



	IF( INDEX(l_in_oniom_foldername,'UFF')== 0 ) THEN !UFF nicht im Ordnerstring, dann false; UFF als Oniom-Methode, da die Nomenklatur geaendert werden muss
			UFF_calc=.false.
			Read_partial_charges=.false.  
	ELSE
			UFF_calc=.true.
			Read_partial_charges=.true.
	END IF
	!lambda_in_oniom_inputline=' oniom(UFF(QEq):UFF(QEq)) '


	inquire(file=TRIM(l_in_oniom_foldername),exist=folder_vorhanden)    !Erstelle Ordner
	IF( .NOT. folder_vorhanden) THEN     
			write(bashline,*) 'mkdir '//TRIM(l_in_oniom_foldername)
			CALL execute_command_line(TRIM(bashline)) 
	END IF 
!ELSE 
    !WRITE(*,*) 'Error: Der Ordner existiert bereits',TRIM(l_in_oniom_foldername)
    !WRITE(*,*) 'ENDE'
    !STOP 
!END IF ! l_in_oniom_foldername_vorhanden   
    
       
    
    

	! Sortiert das Array der Nachbarn der Residgroeße nach
	! Selection Sort
	k_max=N_neighbours+2
	do j=1,k_max-1     
		i_min=j
			DO i=j+1,k_max         
				IF( Resid_list(i) < Resid_list(i_min) ) THEN
				   i_min=i
				END IF
			END DO    
			IF( i_min /= j ) THEN ! tauschen
				   int_dummy=Resid_list(j)
				   Resid_list(j)=Resid_list(i_min)
				   Resid_list(i_min)=int_dummy
			END IF           
	END DO 
	DO i=1,size(Resid_list)
		WRITE(*,*) Resid_list(i)
	END DO
	WRITE(*,*) 'k_max=',k_max

    OPEN(UNIT=78,FILE=TRIM(gro_inputfile),STATUS='OLD',IOSTAT=ierror)
    Read(78,*) dummyname                             !Einlesen des Infokopfes im File
    Read(78,*) Gesamtanzahl                          !Einlesen der Atomanzahl im File
    write(*,*) 'Anzahl der Atome in .gro Datei ', Gesamtanzahl
    
    DIPBI=.FALSE.
    P3HT=.FALSE.
    SAVE_OLD=.FALSE.
    istart=.FALSE.

    OPEN(UNIT=30,FILE=zielfile,STATUS='unknown',IOSTAT=ierror1,action='write',position="append")
        ! Erstelle die Matrix Data_collect, um die Nachbarschaftsliste der Resids zu ordnen und mehrer P3HT-Abschnitte zu einem Molekuel zusammenzufassen, die dann mit H-Atomen/C5H13-Ketten (DIPBI_KETTE=.true.) abgesaettigt werden 
        !                1  2  3
        ! Data_collect:  l, i  k k+1 k+2 ...
        !
    ALLOCATE(Data_collect(N_neighbours+2,34))
    Data_collect=0 !(Anzahl der Residuen pro Molekuel, Anzahl Atome, Resid-Liste)     
         
    k=1  !Durchgehen der Resids in der Resid_liste von 1 bis N_neighbours+2
    i=0  !Ermittelt Anzahl der Atome im Molekuel bzw. in den zusammenhaengenden Teilabschnitten
    l=1  ! Anzahl der Residues pro Molekuel l= Anzahl(k k+1 k+2 ...) 
    n=1  ! Durchzaehlen der Molekuele in Data_collect in der ersten Spalte; Am Ende ergibt sich die Molekuelanzahl 
    last_residue_name=''
    DO j=1,Gesamtanzahl ! Durchgehen der Zeilen in der .gro Datei
        Read(78,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) residue_number,residue_name,atom,atom_number,x,y,z,v_x,v_y,v_z
        IF(ierror < 0) EXIT
        IF(ierror > 0) THEN
            WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(gro_inputfile),' aufgetreten.'
            WRITE(30,*)'Error: Fehler_beim_Einlesen_von_',TRIM(gro_inputfile),' aufgetreten. '//TRIM(l_in_oniom_foldername)
            WRITE(*,*) 'Beende Einlesen !'
            STOP
        END IF
        
        if ( residue_number == Resid_list(k) ) THEN ! Treffer
            i=i+1
            IF(i==1) THEN
                IF ('THP'==TRIM(residue_name(1:3))) THEN        
                    P3HT=.TRUE.
                    Molname="P3HT"
                    IF(P3MT) Molname="P3MT"
                END IF
                
                IF( TRIM(residue_name)=='DIPBI' ) THEN
                    DIPBI=.TRUE.
                    Molname="DIPBI"
                    IF(DIPBI_KETTE) Molname="DIPBI_KETTE"
                END IF                    
            END IF
            IF(istart) THEN ! Noch einmal Hochzaehlen von i, da es im vorherigen Durchlauf nicht durchgefuehrt wurde.
                i=i+1
                istart=.false.
            END IF
        ELSE IF ( residue_number == Resid_list(k+1) ) THEN ! Treffer neue Resid
            
            IF(i==0) THEN
                IF ('THP'==TRIM(residue_name(1:3))) THEN        
                    P3HT=.TRUE.
                    Molname="P3HT"
                    IF(P3MT) Molname="P3MT"
                END IF
                
                IF( TRIM(residue_name)=='DIPBI' ) THEN
                    DIPBI=.TRUE.
                    Molname="DIPBI"
                    IF(DIPBI_KETTE) Molname="DIPBI_KETTE" 
            	ELSE IF ( 'HDI__'==TRIM(residue_name(1:5)) ) THEN
                	Molname='HDI'          
                ELSE IF ( 'HDI_K'==TRIM(residue_name(1:5)) ) THEN
                	Molname='HDI_K' 
                    IF(HDI_KETTE) Molname="HDI_KETTE"
            	ELSE IF ( 'TDI__'==TRIM(residue_name(1:5)) ) THEN
                	Molname='TDI'
            	ELSE IF ( 'K1K__'==TRIM(residue_name(1:5)) .OR. 'PtK1K'==TRIM(residue_name(1:5)) ) THEN
                	Molname='PtK1K'                      
            	ELSE IF ( 'K2K__'==TRIM(residue_name(1:5)) .OR. 'PtK2K'==TRIM(residue_name(1:5)) ) THEN
                	Molname='PtK2K'                   
            	ELSE IF ( 'K3K__'==TRIM(residue_name(1:5)) .OR. 'PtK3K'==TRIM(residue_name(1:5)) ) THEN
                	Molname='PtK3K'
            	ELSE IF ( 'K4K__'==TRIM(residue_name(1:5)) .OR. 'PtK4K'==TRIM(residue_name(1:5)) ) THEN
                	Molname='PtK4K' 
            	ELSE IF ( 'mCP__'==TRIM(residue_name(1:5)) ) THEN
                	Molname='mCP'        
            	ELSE IF ( 'NPB__'==TRIM(residue_name(1:5)) ) THEN
                	Molname='NPB'
            	ELSE
                	Molname=TRIM(residue_name)
		END IF ! DIPBI
                  
            END IF ! i==0
            
            IF(DIPBI) THEN
                !WRITE(*,*) 'DIPBI: l=',l,'i=',i,'k=',k,'Resid_list(k)',Resid_list(k)
                SAVE_OLD=.true.
                istart=.true.
            ELSE IF (P3HT) THEN
            WRITE(*,*) last_residue_name,' ',residue_name
                IF ((last_residue_name=='THP32') .AND. (residue_name=='THP1A')) THEN
                    SAVE_OLD=.true.
                    istart=.true.
		    IF(DEBUG) THEN
                    WRITE(*,*) 'P3HT ENDE -Molekuel: l=',l,'i=',i,'k=',k,'Resid_list(k)',Resid_list(k)
	            END IF ! DEBUG
                ELSE !IF( .NOT.((residue_number-1 == residue_number_1) .OR. (residue_number-1 == residue_number_2) .OR.  &
                     !        & (residue_number == residue_number_1) .OR. (residue_number == residue_number_2) ))THEN      ! Isoliert einzelne Resid 1 und Resid 2                       
                    Data_collect(n,2+l)=Resid_list(k)
                    !WRITE(*,*) 'P3HT laenger: l=',l,'i=',i,'k=',k,'Resid_list(k)',Resid_list(k)
                    i=i+1
                    k=k+1
                    l=l+1
                !ELSE
                !    SAVE_OLD=.true.
                !    istart=.true.
                    !WRITE(*,*) 'P3HT: l=',l,'i=',i,'k=',k,'Resid_list(k)',Resid_list(k)
                END IF
            ELSE
                WRITE(*,*) 'Fehler: Keine Atomsorte ausgewaehlt DIPBI/P3HT'
                STOP
            END IF
        ELSE IF ( residue_number == Resid_list(k)+1 .AND. i/=0) THEN
	    IF(DEBUG) THEN
            WRITE(*,*) 'UNTEN: l=',l,'i=',i,'k=',k,'Resid_list(k)',Resid_list(k)
	    END IF ! DEBUG
            SAVE_OLD=.true.        
        ELSE 
            SAVE_OLD=.false.
        END IF
        
        IF(k==(k_max+1) .AND. (residue_number > residue_number_2 .AND. residue_number > residue_number_1 ) ) EXIT  !IF(k==(k_max+1)) EXIT
        IF(j == Gesamtanzahl) THEN
            SAVE_OLD=.true.
        END IF 
        
        IF(SAVE_OLD) THEN! (DIPBI .AND. (residue_number == lastresid+1)) .OR. (P3HT .AND. (residue_number .NE. Resid_list(k))) .OR. &
                                !&  ) THEN ! Neues Molekuel+Speichern
            Data_collect(n,1)=l !Anzahl der Residues pro Molekuel
            Data_collect(n,2)=i !Anzahl der Atome im Molekuel
            Data_collect(n,2+l)=Resid_list(k)
	    IF(DEBUG) THEN
            	WRITE(*,*) 'SAVE: l=',l,'i=',i,'k=',k,'Resid_list(k)',Resid_list(k)
            	WRITE(*,*) (Data_collect(n,k_max),k_max=1,l+2) 
            END IF ! DEBUG
            k=k+1
            n=n+1
            l=1
            i=0
            
            DIPBI=.FALSE.
            P3HT=.FALSE.
            SAVE_OLD=.FALSE.
        END IF
        last_residue_name=residue_name
        lastresid=residue_number

        
        IF (n==1 .and. j==Gesamtanzahl ) THEN
            write(*,*) ' Error: Es ist ein Fehler beim Einlesen ausgetreten'
            write(*,*) ' Fehler: Fehler_beim_Einlesen_ausgetreten '//TRIM(l_in_oniom_foldername)
            write(*,*) ' Vermutlich wurde nicht die entsprechende Resid-Nr gefunden',Resid_list(k)
            write(*,*) ' ENDE '
            STOP
        END IF  
    END DO
    CLOSE(78)
IF(DEBUG) THEN    
	WRITE(*,*) 'ENDE SCHLEIFE START'
END IF
     
    

! Ermittelt Anzahl der Molekuele
i_max=0
DO i =1,k_max
    IF( Data_collect(i,1)==0) THEN
        i_max=i-1
    END IF
    IF(i_max .NE. 0) EXIT 
    IF(i .EQ. k_max) i_max=k_max ! Wenn nur DIPBI dabei sind
END DO    
WRITE(*,*) 'Anzahl der Molekuele i_max=',i_max ! Anzahl der Molekuele/Molekuelfiles
  DO i=1,i_max
        WRITE(*,*) (Data_collect(i,j),j=1,Data_collect(i,1)+2)
  END DO 

! Test ob 2 Resids im gleichen Molekuel vorkommen,-> dann Abbrunch!
    i_1=0
    i_2=0
  DO i=1,i_max
        DO j=1,(Data_collect(i,1)+2),1
            IF( Data_collect(i,j) == residue_number_1) THEN
                i_1=i
            END IF
            IF( Data_collect(i,j) == residue_number_2) THEN
                i_2=i
            END IF
        END DO !j
  END DO !i
  
  IF( i_1 == i_2) THEN
    WRITE(*,*) ' Fehler: Die beiden Molekuele Resid_1 und Resid_2 liegen im gleichen Molekuel:',residue_number_1,residue_number_2
    WRITE(30,*) ' Fehler: Die_beiden_Molekuele_Resid_1_und_Resid_2_liegen_im_gleichen_Molekuel:',residue_number_1,residue_number_2
    WRITE(*,*) ' Beende make_lambda_in_Oniom'
    !STOP
  END IF
  



!!**************************************!! 
!! Erstelle Output fuer lambda_in_oniom !! 
!!**************************************!!  
Resids_in_same_mol=.FALSE.
IF( i_1 == i_2) THEN ! Beide in einem Molekuel
        Resids_in_same_mol=.TRUE.
        ALLOCATE(Oniom_xyz_namelist(i_max+1))
ELSE
        Resids_in_same_mol=.FALSE.
        ALLOCATE(Oniom_xyz_namelist(i_max))
END IF 
Oniom_xyz_namelist(:)=' '
ALLOCATE(linkatoms(4,5))
linkatoms=0
ALLOCATE(NSchwefel_P3HT(2,4)) ! Array zum Zaehlen der Ringe/S-Atome in den Abschnitten (i= molA=1, molB 2) ; (j=  vorne=1, mitte=2, hinten=3) (mitte = Abschnitt mit Resid !
NSchwefel_P3HT=0

MAXATM_All=0
Counter_Oniom_xyz_namelist=0
   ! Erstelle xyz_N_file Namen
xyz_N_file_A_el='./Oniom/xyz_N_'//TRIM(calculation_method)//'_Oniom_'//TRIM(str(residue_number_1))//'_'//&
                               &TRIM(str(residue_number_2))//'_molA_el.xyz'
xyz_N_file_A_lo='./Oniom/xyz_N_'//TRIM(calculation_method)//'_Oniom_'//TRIM(str(residue_number_1))//'_'//&
                               &TRIM(str(residue_number_2))//'_molA_lo.xyz'
xyz_N_file_A_n='./Oniom/xyz_N_'//TRIM(calculation_method)//'_Oniom_'//TRIM(str(residue_number_1))//'_'//&
                               &TRIM(str(residue_number_2))//'_molA_n.xyz'
xyz_N_file_B_el='./Oniom/xyz_N_'//TRIM(calculation_method)//'_Oniom_'//TRIM(str(residue_number_1))//'_'//&
                               &TRIM(str(residue_number_2))//'_molB_el.xyz'
xyz_N_file_B_lo='./Oniom/xyz_N_'//TRIM(calculation_method)//'_Oniom_'//TRIM(str(residue_number_1))//'_'//&
                               &TRIM(str(residue_number_2))//'_molB_lo.xyz'
xyz_N_file_B_n='./Oniom/xyz_N_'//TRIM(calculation_method)//'_Oniom_'//TRIM(str(residue_number_1))//'_'//&
                               &TRIM(str(residue_number_2))//'_molB_n.xyz'                                
                               
    !inquire(file=TRIM(xyz_N_file_A),exist=xyz_N_vorhanden_A)
    !inquire(file=TRIM(xyz_N_file_B),exist=xyz_N_vorhanden_B)
    xyz_N_vorhanden_A=.false.
    xyz_N_vorhanden_B=.false.
    
    ! Referenzgeometrie um in die Boxmitte zu schieben.

    CALL read_coord_from_gro_resid(gro_inputfile,residue_number_1,atomsorte,koord,MAXATM,Molname,&
                                    &DIPBI,DIPBI_KETTE,P3HT,P3MT,PPDI,PPDI_KETTE,PBDT_TS1)
    WRITE(*,*) TRIM(gro_inputfile),Data_collect(1,3),MAXATM,TRIM(Molname),DIPBI,DIPBI_KETTE,P3HT,P3MT
    ALLOCATE(koordB(MAXATM,3))
    ALLOCATE(atomsorteB(MAXATM))
    koordB=koord
    atomsorteB=atomsorte
    MAXATM_B=MAXATM
    
          !DO j=1,MAXATM
          !    WRITE(*,*) atomsorte(j),koord(j,1),koord(j,2),koord(j,3)
          ! END DO 
    IF ((DIPBI .AND. DIPBI_KETTE) .OR. (P3HT .AND. .NOT. P3MT)) THEN
        KETTE_1=.true.
    ELSE
        KETTE_1=.false.
    END IF  

    CALL Massenschwerpunkt(atomsorteB,koordB,MAXATM_B,schwerpunkt_1,KETTE_1)
    MAXATM=0
    WRITE(*,*) 'Schwerpunkt Referrenzgeometrie', schwerpunkt_1(1),schwerpunkt_1(2),schwerpunkt_1(3)

    
DO i=1,i_max  ! Schleife ueber die Anzahl der Molekuele
    Resid_1_da=.false.
    Resid_2_da=.false.
    ende_1=.false.
    ende_2=.false.
   ! IF( (.NOT. xyz_N_vorhanden_A) .OR. (.NOT. xyz_N_vorhanden_B) .OR. i==1 ) THEN ! Existiert Datei noch nicht oder i=1 (Referenzgeometrie zu haben, fuer Verschiebung mit Set_mol_box ! Erstelle neues File
        DIPBI=.false.
        P3HT=.false.
        WRITE(*,*) 'Anzahl der zu allokierten Atome', Data_collect(i,2)
        ALLOCATE(atomsorteA(Data_collect(i,2)))
        ALLOCATE(koordA(Data_collect(i,2),3))
        k=0
        molX=''
        count_atoms_in_mol=0
        MAXATM_All=0
        DO l=1,Data_collect(i,1) ! Einlesen und Zusammenfassen der Resids in atomsorteA koordA
            CALL read_coord_from_gro_resid(gro_inputfile,Data_collect(i,l+2),atomsorte,koord,MAXATM,Molname,&
                                            &DIPBI,DIPBI_KETTE,P3HT,P3MT,PPDI,PPDI_KETTE,PBDT_TS1)
            !Check 
            molX=TRIM(molX)//'_'//TRIM(str(Data_collect(i,l+2)))
            IF ((DIPBI .AND. DIPBI_KETTE) .OR. (P3HT .AND. .NOT. P3MT)) THEN
                 KETTE_2=.true.
            ELSE
                 KETTE_2=.false.
            END IF     

            CALL Set_mol_box_2(atom,schwerpunkt_1,1,atomsorte,koord,MAXATM,x_box,y_box,z_box,OR(KETTE_1,KETTE_2))
            !WRITE(*,*) 'koord1 first 1) ',koord(1,:)
            !WRITE(*,*) 'koord1 last  2) ',koord(MAXATM,:)
            atom='COM'
            
            WRITE(*,*) Data_collect(i,l+2),residue_number_1,residue_number_2
            IF (Data_collect(i,l+2)==residue_number_1) THEN ! Test ob Resid 1 in der Data_collect an der Stelle i vorkommen.
                Resid_1_da=.true.
                dummy_koord_start_1(:)= koord(1,:)
		IF ( l == Data_collect(i,1) ) THEN ! Hole Koordinaten des letzten Atomes im Molekuel als startatom heraus, wenn Resid_1 das Molekuelende ist
			!dummy_koord_ende_1(:)=koord(MAXATM,:) 
			ende_1=.true.
			!WRITE(*,*) 'Resid1 Ende: ',dummy_koord_ende_1(1),dummy_koord_ende_1(2),dummy_koord_ende_1(3)
		END IF ! Resid_1_da und neues Molekuel
                
		!CALL Set_mol_box_vector_2(schwerpunkt_1,dummy_koord_start_1,x_box,y_box,z_box)
                WRITE(*,*) 'Resid1 Start: ',dummy_koord_start_1(1),dummy_koord_start_1(2),dummy_koord_start_1(3)
            ELSE IF(Resid_1_da .AND. .NOT. ende_1 ) THEN ! Resid_1 da 
			IF( Data_collect(i,l+2)==residue_number_1+1 ) THEN ! Hole Koordinaten des naechsten Startatoms heraus
				dummy_koord_ende_1(:)=koord(1,:)
				WRITE(*,*) 'Resid1 Ende: ',dummy_koord_ende_1(1),dummy_koord_ende_1(2),dummy_koord_ende_1(3)
			END IF
                !CALL Set_mol_box_vector_2(schwerpunkt_1,dummy_koord_ende_1,x_box,y_box,z_box)
            END IF
            
            IF(Data_collect(i,l+2)==residue_number_2) THEN  ! Test ob Resid 3 in der Data_collect an der Stelle i vorkommen. 
                Resid_2_da=.true.
                dummy_koord_start_2=koord(1,:)
                !CALL Set_mol_box_vector_2(schwerpunkt_1,dummy_koord_start_2,x_box,y_box,z_box)
                WRITE(*,*) 'Resid2 Start: ',dummy_koord_start_2(1),dummy_koord_start_2(2),dummy_koord_start_2(3)
		WRITE(*,*) 'l=',l,'Data_col',Data_collect(i,1)
		IF ( l == Data_collect(i,1) ) THEN ! Hole das letzte Atom im Molekuel als Startatom heraus, wenn Resid_2 das Molekuelende ist		
			ende_2=.true.
		END IF ! Resid_2_da und neues Molekuel
            ELSE IF(Resid_2_da .AND. .NOT. ende_2) THEN
			IF( Data_collect(i,l+2)==residue_number_2+1) THEN ! Hole Koordinaten des naechsten Startatoms heraus
				dummy_koord_ende_2(:)=koord(1,:)
                		WRITE(*,*) 'Resid2 Ende: ',dummy_koord_ende_2(1),dummy_koord_ende_2(2),dummy_koord_ende_2(3)
			END IF
			!CALL Set_mol_box_vector_2(schwerpunkt_1,dummy_koord_ende_2,x_box,y_box,z_box)
            END IF

            DO j=1,MAXATM
                atomsorteA(k+j)=atomsorte(j)
                koordA(k+j,:)=koord(j,:)
            END DO
            k=k+MAXATM
            MAXATM_All=MAXATM_All+MAXATM
            DEALLOCATE(koord)
            DEALLOCATE(atomsorte)
        END DO
        molX=TRIM(Molname)//TRIM(molX)
        !WRITE(*,*) 'molX=',TRIM(molX)
        !WRITE(*,*) 'MAXATM_All= ',MAXATM_All,' = ',Data_collect(i,2)
        IF(DIPBI) THEN ! Anfuegen der H-Atome 
            IF(DIPBI_KETTE) THEN
                call h_diPBI_kette(atomsorteA,koordA,atomsorte1H,koord1H,MAXATM_All,molA)
            ELSE
                !WRITE(*,*) 'h_DIPBI'
                call h_diPBI(atomsorteA,koordA,atomsorte1H,koord1H,MAXATM_All,molA)
            END IF

        ELSE IF (P3HT) THEN
            IF(P3MT) THEN
                CALL h_P3MT(atomsorteA,koordA,atomsorte1H,koord1H,MAXATM_All,molA)
            ELSE
                CALL h_P3HT(atomsorteA,koordA,atomsorte1H,koord1H,MAXATM_All,molA)   
            END IF
            ! Korrektur, falls resid1 oder resid2 am Start der Kette sind, dann muss das H-Atom den Start definieren
            IF ( Data_collect(i,3)==residue_number_1) THEN
                dummy_koord_start_1(:)= koord1H(1,:)
            ELSE IF (Data_collect(i,3)==residue_number_2) THEN
                dummy_koord_start_2(:)= koord1H(1,:)
            END IF
	    
	    IF( ende_1) THEN
			dummy_koord_ende_1(:)=koord1H(size(atomsorte1H),:)
	    		WRITE(*,*) 'Resid1 Ende: ',dummy_koord_ende_1(1),dummy_koord_ende_1(2),dummy_koord_ende_1(3)
	    ELSE IF( ende_2) THEN
			dummy_koord_ende_2(:)=koord1H(size(atomsorte1H),:)
	    		WRITE(*,*) 'Resid2 Ende: ',dummy_koord_ende_2(1),dummy_koord_ende_2(2),dummy_koord_ende_2(3)
	    END IF ! Korrektur, wenn Resid1 oder Resid2 am Ende liegen dann muss das H-Atom verwendet werden.
        ELSE    
            write(*,*) 'Fehler: Keine Bearbeitung der H-Atome'
            STOP
        END IF
        DEALLOCATE(koordA)
        DEALLOCATE(atomsorteA)
        MAXATM_H=size(atomsorte1H)
              
        IF(UFF_calc) THEN ! Macht aus Elementsymbolen die Abkuerzungen fuer die UFF-Rechnungen /kann auch fuer DFT so eingelesen werden.
            call Element_array_to_UFF_symbol(atomsorte1H,MAXATM_H,P3HT,DIPBI,P3MT,DIPBI_KETTE)
        END IF
        
        S_Ringe=''
        IF(P3HT) THEN ! Zaehle Anzahl der Schwefelatome in NSchwefel_P3HT(i,j) im Bereich  i 1=molA, 2=molB //j 1=vorne, 2=mitte, 3=hinten, 4=gesamt
            N_Schwefel=0
            DO j=1,MAXATM_H
                if (TRIM(adjustl(atomsorte1H(j)))=='S') N_Schwefel=N_Schwefel+1
                if (TRIM(adjustl(atomsorte1H(j)))=='S-S_R') N_Schwefel=N_Schwefel+1
                
                IF(Resid_1_da) THEN
                    !WRITE(*,*) 'atomsorte1H(j):',j,atomsorte1H(j)
                    IF( getDistance(dummy_koord_start_1(:),koord1H(j,:)) < 1.0E-3 ) THEN
                        NSchwefel_P3HT(1,1)=N_Schwefel
                    ELSE IF ( getDistance(dummy_koord_ende_1(:),koord1H(j,:)) < 1.0E-3) THEN
                        NSchwefel_P3HT(1,2)=N_Schwefel-NSchwefel_P3HT(1,1)
                    END IF
                    IF ( j==MAXATM_H) THEN
                        IF( ende_1 ) THEN ! Wenn Ende des Moekueles/der ges Kette, da dummy_koord_ende leer ist, wenn kein weiteres Kettenglied folgt
                            NSchwefel_P3HT(1,2)=N_Schwefel-NSchwefel_P3HT(1,1)
                            NSchwefel_P3HT(1,3)=0
                            NSchwefel_P3HT(1,4)=NSchwefel_P3HT(1,2)+NSchwefel_P3HT(1,1)
                        ELSE
                            NSchwefel_P3HT(1,3)=N_Schwefel-NSchwefel_P3HT(1,2)-NSchwefel_P3HT(1,1)
                            NSchwefel_P3HT(1,4)=N_Schwefel
                        END IF
                    END IF
                END IF !Resid_1_da
                
                
                IF(Resid_2_da) THEN
                    IF( getDistance(dummy_koord_start_2(:),koord1H(j,:)) < 1.0E-3) THEN
                        NSchwefel_P3HT(2,1)=N_Schwefel
                    ELSE IF (getDistance(dummy_koord_ende_2(:),koord1H(j,:)) < 1.0E-3) THEN
                        NSchwefel_P3HT(2,2)=N_Schwefel-NSchwefel_P3HT(2,1)
                    END IF
                    IF ( j==MAXATM_H) THEN
                        IF( ende_2 ) THEN ! Wenn Ende des Moekueles/der ges Kette
                            NSchwefel_P3HT(2,2)=N_Schwefel-NSchwefel_P3HT(2,1) !Endwert
                            NSchwefel_P3HT(2,3)=0
                            NSchwefel_P3HT(2,4)=NSchwefel_P3HT(2,2)+NSchwefel_P3HT(2,1)
                        ELSE
                            NSchwefel_P3HT(2,3)=N_Schwefel-NSchwefel_P3HT(2,2)-NSchwefel_P3HT(2,1)
                            NSchwefel_P3HT(2,4)=N_Schwefel
                        END IF
                    END IF
                END IF !Resid_2_da
            END DO
            S_Ringe='_R'//TRIM(str(N_Schwefel))
            WRITE(*,*) 'N_Schwefel:',N_Schwefel          
        END IF 
        
        IF(Resid_1_da .OR. Resid_2_da) THEN
            WRITE(*,*) ' Koordinaten fuer Begrenzung des Molekuelabschnittes'
            WRITE(*,*) 'dummy_koord_start_1(:)=',dummy_koord_start_1(:)
            WRITE(*,*) 'dummy_koord_ende_1(:)=',dummy_koord_ende_1(:)
            WRITE(*,*) 'dummy_koord_start_2(:)=',dummy_koord_start_2(:)
            WRITE(*,*) 'dummy_koord_ende_2(:)=',dummy_koord_ende_2(:)        
        END IF
        
        IF(P3HT .AND. (Resid_1_da .OR. Resid_2_da)) THEN 
            WRITE(*,*) ' Anzahl der Schwefelringe j=( 1=molA,  2=molB ) // k=( 1=vorne, 2=mitte, 3=hinten, 4=gesamt )'
            DO k=1,4
                    WRITE(*,*) (NSchwefel_P3HT(j,k),j=1,2)
            END DO  
        END IF

        !WRITE(*,*) 'molX=',TRIM(molX)
        !WRITE(*,*) 'MAXATM_H=',MAXATM_H
        !WRITE(*,*) 'Read_partial_charges',Read_partial_charges
        IF(Read_partial_charges) THEN !Einlesen der Partailladungen
            IF(DIPBI) THEN 
             WRITE(*,*) 'MAXATM_H=',MAXATM_H
                ALLOCATE(partial_charges_n(MAXATM_H)) ! DIPBI holt Partialladungen fuer das gesamte Molekuel
                q_file_n= './partial_charges/q_'//TRIM(partial_charge_methode)//'_n_'//TRIM(Molname)//'.dat'
                CALL Read_part_charges_q_file(q_file_n,partial_charges_n,MAXATM_H,trajstep,zielfile,l_in_oniom_foldername)
                IF(Resid_1_da) THEN
                 ALLOCATE(partial_charges_el_1(MAXATM_H),partial_charges_lo_1(MAXATM_H))
                 q_file_el_1= './partial_charges/q_'//TRIM(partial_charge_methode)//'_el_'//TRIM(Molname)//'.dat'
                 CALL Read_part_charges_q_file(q_file_el_1,partial_charges_el_1,MAXATM_H,trajstep,zielfile,l_in_oniom_foldername)
                 q_file_lo_1= './partial_charges/q_'//TRIM(partial_charge_methode)//'_lo_'//TRIM(Molname)//'.dat'
                 CALL Read_part_charges_q_file(q_file_lo_1,partial_charges_lo_1,MAXATM_H,trajstep,zielfile,l_in_oniom_foldername)
                 MAXATM_A=MAXATM_H
                END IF 
                IF(Resid_2_da) THEN
                 ALLOCATE(partial_charges_el_2(MAXATM_H),partial_charges_lo_2(MAXATM_H))
                 q_file_el_2= './partial_charges/q_'//TRIM(partial_charge_methode)//'_el_'//TRIM(Molname)//'.dat'
                 CALL Read_part_charges_q_file(q_file_el_2,partial_charges_el_2,MAXATM_H,trajstep,zielfile,l_in_oniom_foldername)
                 q_file_lo_2= './partial_charges/q_'//TRIM(partial_charge_methode)//'_lo_'//TRIM(Molname)//'.dat'
                 CALL Read_part_charges_q_file(q_file_lo_2,partial_charges_lo_2,MAXATM_H,trajstep,zielfile,l_in_oniom_foldername)
                 MAXATM_B=MAXATM_H
                END IF 
                WRITE(*,*) 'Ende Partial charges DIPBI'
            ELSE IF(P3HT) THEN
                IF( ALLOCATED(partial_charges_n) ) THEN
                    DEALLOCATE(partial_charges_n)
                END IF
                ALLOCATE(partial_charges_n(MAXATM_H)) ! Partialladungen im neutralen Zustand fuer das gesamte Molekuel, bei vorhandener Resid im Molekuel, werden an der entsprechenden Stelle die Partialladungen fuer das geladenen Molekuel eingefuegt
                q_file_n= './partial_charges/q_'//TRIM(partial_charge_methode)//'_n_'//TRIM(Molname)//TRIM(S_Ringe)//'.dat'
                CALL Read_part_charges_q_file(q_file_n,partial_charges_n,MAXATM_H,trajstep,zielfile,l_in_oniom_foldername)
                
                IF(Resid_1_da) THEN
                 S_Ringe='_R'//TRIM(str(NSchwefel_P3HT(1,2))) ! Anzal der Ringe R mit Schwefeln waehlt das File fuer die Partialladungen aus.
                 IF(P3MT) THEN
                     MAXATM_A=NSchwefel_P3HT(1,2)*10+2   ! Anzahl der Atome im Teilabschnitt von molA
                 ELSE IF(P3HT) THEN
                     MAXATM_A=NSchwefel_P3HT(1,2)*25+2   ! Anzahl der Atome im Teilabschnitt von molA
                 END IF
                 ALLOCATE(partial_charges_el_1(MAXATM_A),partial_charges_lo_1(MAXATM_A))
                 q_file_el_1= './partial_charges/q_'//TRIM(partial_charge_methode)//'_el_'//TRIM(Molname)//TRIM(S_Ringe)//'.dat'
                 CALL Read_part_charges_q_file(q_file_el_1,partial_charges_el_1,MAXATM_A,trajstep,zielfile,l_in_oniom_foldername)
                 q_file_lo_1= './partial_charges/q_'//TRIM(partial_charge_methode)//'_lo_'//TRIM(Molname)//TRIM(S_Ringe)//'.dat'
                 CALL Read_part_charges_q_file(q_file_lo_1,partial_charges_lo_1,MAXATM_A,trajstep,zielfile,l_in_oniom_foldername)
                END IF 
                IF(Resid_2_da) THEN
                 S_Ringe='_R'//TRIM(str(NSchwefel_P3HT(2,2)))
                 IF(P3MT) THEN
                    MAXATM_B=NSchwefel_P3HT(2,2)*10+2   ! Anzahl der Atome im Teilabschnitt von molB
                 ELSE IF(P3HT) THEN
                    MAXATM_B=NSchwefel_P3HT(2,2)*25+2   ! Anzahl der Atome im Teilabschnitt von molB
                 END IF
                 ALLOCATE(partial_charges_el_2(MAXATM_B),partial_charges_lo_2(MAXATM_B))
                 q_file_el_2= './partial_charges/q_'//TRIM(partial_charge_methode)//'_el_'//TRIM(Molname)//TRIM(S_Ringe)//'.dat'
                 CALL Read_part_charges_q_file(q_file_el_2,partial_charges_el_2,MAXATM_B,trajstep,zielfile,l_in_oniom_foldername)
                 q_file_lo_2= './partial_charges/q_'//TRIM(partial_charge_methode)//'_lo_'//TRIM(Molname)//TRIM(S_Ringe)//'.dat'
                 CALL Read_part_charges_q_file(q_file_lo_2,partial_charges_lo_2,MAXATM_B,trajstep,zielfile,l_in_oniom_foldername)
                END IF 

            END IF !Molekuel DIPBI/P3HT
        END IF ! Read_partial_charges
        
        !!OPEN(UNIT=50,FILE=TRIM(l_in_oniom_foldername)//'/'//TRIM(molA)//'_n.xyz',STATUS='unknown',IOSTAT=ierror)
        !!DO j=1,MAXATM_H
        !!    IF(Read_partial_charges) THEN
        !!        WRITE(50,*) atomsorte1H(j),koord1H(j,1),koord1H(j,2),koord1H(j,3),partial_charges_n(j)
        !!        WRITE(*,*) 'Partial charges mol A: ',TRIM(molA)
        !!        WRITE(*,*) partial_charges_n(1)!,partial_charges_el_1(1),partial_charges_lo_1(1)
        !!    ELSE 
        !!        WRITE(50,*) atomsorte1H(j),koord1H(j,1),koord1H(j,2),koord1H(j,3)
        !!    END IF   
        !!END DO 
        !!CLOSE(50)

        !!WRITE(*,*) partial_charges_n(MAXATM_A),partial_charges_el_1(MAXATM_A),partial_charges_lo_1(MAXATM_A)
        
        WRITE(*,*) 'Partial charges mol B'
        WRITE(*,*) partial_charges_n(1),partial_charges_el_2(1),partial_charges_lo_2(1)
        WRITE(*,*) partial_charges_n(MAXATM_B),partial_charges_el_2(MAXATM_B),partial_charges_lo_2(MAXATM_B)
        
        q_index_1=0
        q_index_2=0
        IF(Resid_1_da) THEN
            !WRITE(*,*) 'dummy_koord_start_1(:)=',dummy_koord_start_1(:)
            !WRITE(*,*) 'dummy_koord_ende_1(:)=',dummy_koord_ende_1(:)
            Freeze=.true.
            molA=TRIM(molX)//'_molA'
            Oniom_xyz_namelist(1)=molA
            OPEN(UNIT=77,FILE=TRIM(l_in_oniom_foldername)//'/'//TRIM(molA)//'_n.xyz',STATUS='REPLACE',IOSTAT=ierror)
            OPEN(UNIT=78,FILE=TRIM(l_in_oniom_foldername)//'/'//TRIM(molA)//'_el.xyz',STATUS='REPLACE',IOSTAT=ierror)
            OPEN(UNIT=79,FILE=TRIM(l_in_oniom_foldername)//'/'//TRIM(molA)//'_lo.xyz',STATUS='REPLACE',IOSTAT=ierror)
            OPEN(UNIT=80,FILE=TRIM(l_in_oniom_foldername)//'/'//TRIM(molA)//'_n_L.xyz',STATUS='REPLACE',IOSTAT=ierror) ! neutral low-Level Optimierung
            Write(77,'(I8,/,"  genarated by ")') MAXATM_H
            Write(78,'(I8,/,"  genarated by ")') MAXATM_H
            Write(79,'(I8,/,"  genarated by ")') MAXATM_H
            Write(80,'(I8,/,"  genarated by ")') MAXATM_H
            DO j=1,MAXATM_H,1
                count_atoms_in_mol=count_atoms_in_mol+1
                IF( getDistance(dummy_koord_start_1(:),koord1H(j,:)) < 1.0E-3) THEN
                    Freeze=.false. ! Start Molekuel 1
                    IF(Read_partial_charges) THEN ! Save Linkatom-Daten
                            IF(count_atoms_in_mol==1) THEN !H-Atom an erster Stelle
                                linkatoms(1,2)=partial_charges_el_1(1)
                                linkatoms(1,3)=partial_charges_lo_1(1)
                                linkatoms(1,4)=0
                                linkatoms(1,4)=0
                                q_index_1=1
                            ELSE 
                                linkatoms(1,2)=partial_charges_el_1(1)
                                linkatoms(1,3)=partial_charges_lo_1(1)
                                linkatoms(1,4)=count_atoms_in_mol   ! An dieses C wird angebaut
                                linkatoms(1,5)=count_atoms_in_mol-6 ! Save intex letztes C-Atom / wird durch H ersetzt
                                q_index_1=2
                            END IF
                    END IF
                    
                END IF
                IF( getDistance(dummy_koord_ende_1(:),koord1H(j,:)) < 1.0E-3) THEN
                    Freeze=.true.
                    IF( ende_1 .AND. j==MAXATM_H) THEN ! letztes Atom im Molekuel wird so nicht eingefroren, wenn die Kette weitergeht 
                        Freeze=.false.
                    ELSE
                        q_index_1=0
                    END IF
                    IF(Read_partial_charges) THEN ! Save Linkatom-Daten
                        linkatoms(2,2)=partial_charges_el_1(MAXATM_A)
                        linkatoms(2,3)=partial_charges_lo_1(MAXATM_A)
                        linkatoms(2,4)=count_atoms_in_mol-6  ! C zu dem gebundne wird
                        linkatoms(2,5)=count_atoms_in_mol  ! dummy_koord_ende_1 enthaelt erstes C des neuen Molekueles und wird durch H ersetzt              
                    END IF
                END IF
                
                IF(Freeze) THEN ! Festhalten der Atome die nicht im Molekuel mit Resid 1 sind
                    IF(Read_partial_charges) THEN
                     string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_n(j)))
                     write(77,form2) TRIM(adjustl(string)),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                     string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_n(j)))
                     write(78,form2) TRIM(adjustl(string)),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                     string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_n(j)))
                     write(79,form2) TRIM(adjustl(string)),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                     string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_n(j)))
                     write(80,form2) TRIM(adjustl(string)),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                    ELSE !ohne Partialladungen
                     write(77,form1) atomsorte1H(j),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                     write(78,form1) atomsorte1H(j),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                     write(79,form1) atomsorte1H(j),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                     write(80,form1) atomsorte1H(j),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                    END IF
                ELSE
                    IF(Read_partial_charges) THEN
                     linkatoms(1,1)=linkatoms(1,1)+partial_charges_n(j) ! Summieren aller neutralen Ladungen fuer freie Atome
                     string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_n(j)))
                     write(77,form2) TRIM(adjustl(string)),' 0',koord1H(j,1),koord1H(j,2),koord1H(j,3),' H'
                     string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_el_1(q_index_1)))
                     write(78,form2) TRIM(adjustl(string)),' 0',koord1H(j,1),koord1H(j,2),koord1H(j,3),' H'
                     string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_lo_1(q_index_1)))
                     write(79,form2) TRIM(adjustl(string)),' 0',koord1H(j,1),koord1H(j,2),koord1H(j,3),' H'
                     q_index_1=q_index_1+1
                    string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_n(j)))
                     write(80,form2) TRIM(adjustl(string)),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                    ELSE !ohne Partialladungen
                     write(77,form1) atomsorte1H(j),' 0',koord1H(j,1),koord1H(j,2),koord1H(j,3),' H'
                     write(78,form1) atomsorte1H(j),' 0',koord1H(j,1),koord1H(j,2),koord1H(j,3),' H'
                     write(79,form1) atomsorte1H(j),' 0',koord1H(j,1),koord1H(j,2),koord1H(j,3),' H'
                     write(80,form1) atomsorte1H(j),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                    END IF
                END IF
            END DO
            Freeze=.true.
            
            IF(P3HT) THEN ! P3HT--Berechnen H-Partialladung fuer High-Level-Linkatome bei Neutralitaet
                IF( NSchwefel_P3HT(1,1)==0 .AND. NSchwefel_P3HT(1,3)==0 ) THEN !Einzelnes Molekuel = keine Linkatome = Ladung 0.0
                        ! Auskommentierung des zusammenziehens der Ladungen an einem H (25.01.17), da der Sinn unklar war. -> Alle
                        ! Faelle werden nun gleich behandelt.
                    !linkatoms(1,1)=0.0
                    !linkatoms(2,1)=0.0
                    linkatoms(1,1)=-0.5*linkatoms(1,1)
                    linkatoms(2,1)=linkatoms(1,1)
                    linkatoms(1,5)=0                 ! Kein Linkatom am Kettenanfang
                    linkatoms(2,5)=0                 ! Kein Linkatom am Kettenende
                ELSE IF(NSchwefel_P3HT(1,1)==0) THEN ! Nur letztes H wird geladen
                    !linkatoms(2,1)=-1.0*linkatoms(1,1)                    
                    !linkatoms(1,1)=0.0
                    linkatoms(1,1)=-0.5*linkatoms(1,1)
                    linkatoms(2,1)=linkatoms(1,1)
                    linkatoms(1,5)=0            ! Kein Linkatom, am Kettenanfang
                ELSE IF(NSchwefel_P3HT(1,3)==0) THEN ! Nur erstes H wird geladen
                    !linkatoms(1,1)=-1.0*linkatoms(1,1)
                    !linkatoms(2,1)=0.0
                    linkatoms(1,1)=-0.5*linkatoms(1,1)
                    linkatoms(2,1)=linkatoms(1,1)
                    linkatoms(2,5)=0            !Kein Linkatom, am Kettenende. 
                ELSE ! Beide H- erhalen die Haelfte der Restladung
                    linkatoms(1,1)=-0.5*linkatoms(1,1)
                    linkatoms(2,1)=linkatoms(1,1)
                END IF ! 
            END IF  ! P3HT -- Berechnen H-Partialladung fuer High-Level-Linkatome bei Neutralitaet
            
            CLOSE(80)
            CLOSE(79)
            CLOSE(78)
            CLOSE(77)
        END IF !Resid_1_da
        
        
            WRITE(*,*) 'MOLEKueL Resid_2_da',Resid_2_da
            !DO j=1,MAXATM_H
            !    WRITE(*,*) atomsorte1H(j),koord1H(j,1),koord1H(j,2),koord1H(j,3),partial_charges_n(j)
            !END DO 
            !WRITE(*,*) 'molA: ',TRIM(molA)
            
            
        count_atoms_in_mol=0
        q_index_2=0
        IF(Resid_2_da) THEN
            !WRITE(*,*) 'dummy_koord_start_2(:)=',dummy_koord_start_2(:)
            !WRITE(*,*) 'dummy_koord_ende_2(:)=',dummy_koord_ende_2(:)
            Freeze=.true.
            molB=TRIM(molX)//'_molB'
            Oniom_xyz_namelist(2)=molB
            OPEN(UNIT=77,FILE=TRIM(l_in_oniom_foldername)//'/'//TRIM(molB)//'_n.xyz',STATUS='REPLACE',IOSTAT=ierror)
            OPEN(UNIT=78,FILE=TRIM(l_in_oniom_foldername)//'/'//TRIM(molB)//'_el.xyz',STATUS='REPLACE',IOSTAT=ierror)
            OPEN(UNIT=79,FILE=TRIM(l_in_oniom_foldername)//'/'//TRIM(molB)//'_lo.xyz',STATUS='REPLACE',IOSTAT=ierror)
            OPEN(UNIT=80,FILE=TRIM(l_in_oniom_foldername)//'/'//TRIM(molB)//'_n_L.xyz',STATUS='REPLACE',IOSTAT=ierror)
        
            Write(77,'(I8,/,"  genarated by ")') MAXATM_H
            Write(78,'(I8,/,"  genarated by ")') MAXATM_H
            Write(79,'(I8,/,"  genarated by ")') MAXATM_H
            Write(80,'(I8,/,"  genarated by ")') MAXATM_H
            
            DO j=1,MAXATM_H,1
                count_atoms_in_mol=count_atoms_in_mol+1
                IF( getDistance(dummy_koord_start_2(:),koord1H(j,:)) < 1.0E-3) THEN
                    Freeze=.false. ! Start Molekuel 2
                    IF(Read_partial_charges) THEN ! Save Linkatom-Daten
                        IF(count_atoms_in_mol==1) THEN !H-Atom an erster Stelle
                            linkatoms(3,2)=partial_charges_el_2(1)
                            linkatoms(3,3)=partial_charges_lo_2(1)
                            linkatoms(3,4)=0
                            linkatoms(3,4)=0
                            q_index_2=1
                        ELSE 
                            linkatoms(3,2)=partial_charges_el_2(1)
                            linkatoms(3,3)=partial_charges_lo_2(1)
                            linkatoms(3,4)=count_atoms_in_mol   
                            linkatoms(3,5)=count_atoms_in_mol-6
                            q_index_2=2
                        END IF
                    END IF !Read_partial_charges       
                END IF
                IF( getDistance(dummy_koord_ende_2(:),koord1H(j,:)) < 1.0E-3) THEN
                    Freeze=.true.
                    IF( ende_2 .AND. j==MAXATM_H) THEN ! letztes Atom im Molekuel wird so nicht eingefroren, wenn die Kette weitergeht 
                        Freeze=.false.
                    ELSE
                        q_index_2=0
                    END IF
                    IF(Read_partial_charges) THEN ! Save Linkatom-Daten
                        linkatoms(4,2)=partial_charges_el_2(MAXATM_B)
                        linkatoms(4,3)=partial_charges_lo_2(MAXATM_B)
                        linkatoms(4,4)=count_atoms_in_mol-6 ! An dieses C wird das neue H gebunden  
                        linkatoms(4,5)=count_atoms_in_mol   ! Dieses C des neuen Abschnittes wird durch H-Atom ersetzt 
                    END IF
                END IF
                IF(Freeze) THEN ! Festhalten der Atome die nicht im Molekuel mit Resid 2 sind
                    IF(Read_partial_charges) THEN
                        string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_n(j)))
                        write(77,form2) TRIM(adjustl(string)),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                        string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_n(j)))
                        write(78,form2) TRIM(adjustl(string)),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                        string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_n(j)))
                        write(79,form2) TRIM(adjustl(string)),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                        string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_n(j)))
                        write(80,form2) TRIM(adjustl(string)),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                    ELSE !ohne Partialladungen
                        write(77,form1) atomsorte1H(j),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                        write(78,form1) atomsorte1H(j),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                        write(79,form1) atomsorte1H(j),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                        write(80,form1) atomsorte1H(j),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                    END IF
                ELSE
                    IF(Read_partial_charges) THEN
                        linkatoms(3,1)=linkatoms(3,1)+partial_charges_n(j) !Summe der neutralen Ladungen 
                        string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_n(j)))
                        write(77,form2) TRIM(adjustl(string)),' 0',koord1H(j,1),koord1H(j,2),koord1H(j,3),' H'
                        string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_el_2(q_index_2)))
                        write(78,form2) TRIM(adjustl(string)),' 0',koord1H(j,1),koord1H(j,2),koord1H(j,3),' H'
                        string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_lo_2(q_index_2))) 
                        write(79,form2) TRIM(adjustl(string)),' 0',koord1H(j,1),koord1H(j,2),koord1H(j,3),' H'
!WRITE(*,*) atomsorte1H(j),j,partial_charges_n(j),q_index_2,partial_charges_el_2(q_index_2),partial_charges_lo_2(q_index_2)
                        q_index_2=q_index_2+1
                        string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_n(j)))
                        write(80,form2) TRIM(adjustl(string)),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                    ELSE !ohne Partialladungen
                        write(77,form1) atomsorte1H(j),' 0',koord1H(j,1),koord1H(j,2),koord1H(j,3),' H'
                        write(78,form1) atomsorte1H(j),' 0',koord1H(j,1),koord1H(j,2),koord1H(j,3),' H'
                        write(79,form1) atomsorte1H(j),' 0',koord1H(j,1),koord1H(j,2),koord1H(j,3),' H'
                        write(80,form1) atomsorte1H(j),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                    END IF
                END IF
            END DO !j-Schleife
            CLOSE(80)
            CLOSE(79)
            CLOSE(78)
            CLOSE(77)
            Freeze=.true.
            IF(P3HT) THEN ! P3HT--Berechnen H-Partialladung fuer High-Level-Linkatome bei Neutralitaet
                IF( NSchwefel_P3HT(2,1)==0 .AND. NSchwefel_P3HT(2,3)==0 ) THEN !Einzelnes Molekuel = keine Linkatome = Ladung 0.0
                    !linkatoms(3,1)=0.0
                    !linkatoms(4,1)=0.0
                    linkatoms(3,1)=-0.5*linkatoms(3,1)
                    linkatoms(4,1)=linkatoms(3,1)
                    linkatoms(3,5)=0   ! Kein Linkatom am Kettenstart
                    linkatoms(4,5)=0     ! Kein Linkatom am Kettenende
                ELSE IF(NSchwefel_P3HT(2,1)==0) THEN ! Nur letztes H wird geladen
                    !linkatoms(4,1)=-1.0*linkatoms(3,1)
                    !linkatoms(3,1)=0.0
                    linkatoms(3,1)=-0.5*linkatoms(3,1)
                    linkatoms(4,1)=linkatoms(3,1)
                    linkatoms(3,5)=0   ! Kein Linkatom am Kettenstart
                ELSE IF(NSchwefel_P3HT(2,3)==0) THEN ! Nur erstes H wird geladen
                    !linkatoms(3,1)=-1.0*linkatoms(3,1)
                    !linkatoms(4,1)=0.0
                    linkatoms(3,1)=-0.5*linkatoms(3,1)
                    linkatoms(4,1)=linkatoms(3,1)
                    linkatoms(4,5)=0     ! Kein Linkatom am Kettenende
                ELSE ! Beide H- erhalen die Haelfte der Restladung
                    linkatoms(3,1)=-0.5*linkatoms(3,1)
                    linkatoms(4,1)=linkatoms(3,1)
                END IF ! 
            END IF  ! P3HT -- Berechnen H-Partialladung fuer High-Level-Linkatome bei Neutralitaet
        END IF
        

        !WRITE(*,*) 'Nachbarn:  RESID 1 da: ',Resid_1_da,' RESID 2 da ',Resid_2_da
        IF( (.NOT. Resid_1_da) .AND. (.NOT. Resid_2_da)) THEN !else zu IF Resid_2_da  ! Neutraler Nachbar!
            !DO j=1,MAXATM_H
            !        WRITE(*,*) atomsorte1H(j),koord1H(j,1),koord1H(j,2),koord1H(j,3),partial_charges_n(j)
            !END DO 
            Counter_Oniom_xyz_namelist=Counter_Oniom_xyz_namelist+1
            Oniom_xyz_namelist(Counter_Oniom_xyz_namelist+2)=TRIM(molX)

            OPEN(UNIT=50,FILE=TRIM(l_in_oniom_foldername)//'/'//TRIM(molX)//'_n.xyz',STATUS='unknown',IOSTAT=ierror)
            Write(50,'(I8,/,"  genarated by ")') MAXATM_H
            WRITE(*,*) ' Nachbarn '
            DO j=1,MAXATM_H,1
                count_atoms_in_mol=count_atoms_in_mol+1
                IF(Read_partial_charges) THEN
                    string=TRIM(atomsorte1H(j))//'-'//TRIM(Real2str(partial_charges_n(j)))
                    !write(*,*) TRIM(adjustl(string)),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                    write(50,form2) TRIM(adjustl(string)),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                ELSE !ohne Partialladungen  
                    write(50,form1) atomsorte1H(j),'-1',koord1H(j,1),koord1H(j,2),koord1H(j,3),' L'
                END IF
            END DO
             WRITE(*,*) 'Koordinaten in ',TRIM(l_in_oniom_foldername)//'/'//TRIM(molX)//'_n.xyz geschrieben'
            ClOSE(50)
        END IF !end Resid_2_da
        
        IF(Read_partial_charges) THEN
            DEALLOCATE(partial_charges_n)
            IF( Resid_1_da) THEN
                DEALLOCATE(partial_charges_el_1,partial_charges_lo_1)
            END IF
            IF( Resid_2_da) THEN
                DEALLOCATE(partial_charges_el_2,partial_charges_lo_2)
            END IF
        END IF

        DEALLOCATE(atomsorte1H,koord1H)
   ! END IF ! xyz_N_file nicht vorhanden
END DO
DEALLOCATE(atomsorteB,koordB)
DO i=1,size(Oniom_xyz_namelist)
    WRITE(*,*) TRIM(Oniom_xyz_namelist(i))
END DO

! Anfuegen der Linkatoms in Datei 
WRITE(*,*) 'Linkatomdaten'
        !!!                         neutral        negativ         positiv    H-Linkposition  Linkatomzeile C-Atom                           
        WRITE(*,*) 'mol A Start', linkatoms(1,1),linkatoms(1,2),linkatoms(1,3),linkatoms(1,4),linkatoms(1,5) 
        WRITE(*,*) 'mol A Ende ', linkatoms(2,1),linkatoms(2,2),linkatoms(2,3),linkatoms(2,4),linkatoms(2,5)
        WRITE(*,*) 'mol B Start', linkatoms(3,1),linkatoms(3,2),linkatoms(3,3),linkatoms(3,4),linkatoms(3,5) 
        WRITE(*,*) 'mol B Ende ', linkatoms(4,1),linkatoms(4,2),linkatoms(4,3),linkatoms(4,4),linkatoms(4,5)  
    sting800=TRIM(l_in_oniom_foldername)//'/'//TRIM(Oniom_xyz_namelist(1))//'_n.xyz'
    CALL add_linkatoms_to_file(linkatoms,1,1,sting800)  ! molA Start neutral
    sting800=TRIM(l_in_oniom_foldername)//'/'//TRIM(Oniom_xyz_namelist(1))//'_n.xyz'
    CALL add_linkatoms_to_file(linkatoms,2,1,sting800)  ! molA Ende neutral
    sting800=TRIM(l_in_oniom_foldername)//'/'//TRIM(Oniom_xyz_namelist(1))//'_el.xyz'
    CALL add_linkatoms_to_file(linkatoms,1,2,sting800) ! molA Start negativ
    sting800=TRIM(l_in_oniom_foldername)//'/'//TRIM(Oniom_xyz_namelist(1))//'_el.xyz'
    CALL add_linkatoms_to_file(linkatoms,2,2,sting800) ! molA Ende negativ  
    sting800=TRIM(l_in_oniom_foldername)//'/'//TRIM(Oniom_xyz_namelist(1))//'_lo.xyz'
    CALL add_linkatoms_to_file(linkatoms,1,3,sting800) ! molA Start positiv
    sting800=TRIM(l_in_oniom_foldername)//'/'//TRIM(Oniom_xyz_namelist(1))//'_lo.xyz'
    CALL add_linkatoms_to_file(linkatoms,2,3,sting800) ! molA Ende positiv  
                                                                   
                                                                   
    sting800=TRIM(l_in_oniom_foldername)//'/'//TRIM(Oniom_xyz_namelist(2))//'_n.xyz'                                                              
    CALL add_linkatoms_to_file(linkatoms,3,1,sting800)  ! molB Start neutral
    sting800=TRIM(l_in_oniom_foldername)//'/'//TRIM(Oniom_xyz_namelist(2))//'_n.xyz'
    CALL add_linkatoms_to_file(linkatoms,4,1,sting800)  ! molB Ende neutral
    sting800=TRIM(l_in_oniom_foldername)//'/'//TRIM(Oniom_xyz_namelist(2))//'_el.xyz'
    CALL add_linkatoms_to_file(linkatoms,3,2,sting800) ! molB Start negativ
    sting800=TRIM(l_in_oniom_foldername)//'/'//TRIM(Oniom_xyz_namelist(2))//'_el.xyz'
    CALL add_linkatoms_to_file(linkatoms,4,2,sting800) ! molB Ende negativ  
    sting800=TRIM(l_in_oniom_foldername)//'/'//TRIM(Oniom_xyz_namelist(2))//'_lo.xyz'
    CALL add_linkatoms_to_file(linkatoms,3,3,sting800) ! molB Start positiv
    sting800=TRIM(l_in_oniom_foldername)//'/'//TRIM(Oniom_xyz_namelist(2))//'_lo.xyz'
    CALL add_linkatoms_to_file(linkatoms,4,3,sting800) ! molB Ende positiv 

    
!! Erstelle xyz_N_Oniom files aus den Oniom Geometrien
    call make_Oniom_xyz_N_file(Oniom_xyz_namelist,i_max,xyz_N_file_A_n,'_n  ','_n_L',l_in_oniom_foldername,Resids_in_same_mol)
    call make_Oniom_xyz_N_file(Oniom_xyz_namelist,i_max,xyz_N_file_A_el,'_el ','_n_L',l_in_oniom_foldername,Resids_in_same_mol)
    call make_Oniom_xyz_N_file(Oniom_xyz_namelist,i_max,xyz_N_file_A_lo,'_lo ','_n_L',l_in_oniom_foldername,Resids_in_same_mol)

    call make_Oniom_xyz_N_file(Oniom_xyz_namelist,i_max,xyz_N_file_B_n,'_n_L','_n  ',l_in_oniom_foldername,Resids_in_same_mol)
    call make_Oniom_xyz_N_file(Oniom_xyz_namelist,i_max,xyz_N_file_B_el,'_n_L','_el ',l_in_oniom_foldername,Resids_in_same_mol)
    call make_Oniom_xyz_N_file(Oniom_xyz_namelist,i_max,xyz_N_file_B_lo,'_n_L','_lo ',l_in_oniom_foldername,Resids_in_same_mol)

!! Erstelle Freeze Dateien um fixierte Atome zu uebergeben
    CALL make_Oniom_Freezelist(xyz_N_file_A_n,'molA','n ',l_in_oniom_foldername)
    CALL make_Oniom_Freezelist(xyz_N_file_A_el,'molA','el',l_in_oniom_foldername)
    CALL make_Oniom_Freezelist(xyz_N_file_A_lo,'molA','lo',l_in_oniom_foldername)
    
    CALL make_Oniom_Freezelist(xyz_N_file_B_n,'molB','n ',l_in_oniom_foldername)
    CALL make_Oniom_Freezelist(xyz_N_file_B_el,'molB','el',l_in_oniom_foldername)
    CALL make_Oniom_Freezelist(xyz_N_file_B_lo,'molB','lo',l_in_oniom_foldername)

        !call make_coord_to_xyz_in_dir(atomsorte1H,koord1H,size(atomsorte1H),molA,l_in_oniom_foldername)
        !call make_coord_to_xyz_in_dir(atomsorte2H,koord2H,size(atomsorte2H),molB,l_in_oniom_foldername)
        
    CLOSE(30) !zielfile zur Angabe von Fehlern

    IF (sub_g09) THEN
        Bashline=' ./Oniom/lambda_in_setup_on_the_fly_oniom.sh '//TRIM(xyz_N_file_A_n)//' '//TRIM(xyz_N_file_B_n)//' "'//&
                &TRIM(lambda_in_oniom_inputline)//'" '//TRIM(l_in_oniom_foldername)//' '//TRIM(zielfile)//&
                &' ./Oniom/'//TRIM(run_lambda_in)//' true oniom '//TRIM(xyz_N_file_A_el)//' '//TRIM(xyz_N_file_A_lo)//&
                &' '//TRIM(xyz_N_file_B_el)//' '//TRIM(xyz_N_file_B_lo)
        CALL execute_command_line(TRIM(Bashline)) 
    ELSE
        Bashline=' ./Oniom/lambda_in_setup_on_the_fly_oniom.sh '//TRIM(xyz_N_file_A_n)//' '//TRIM(xyz_N_file_B_n)//' "'//&
                &TRIM(lambda_in_oniom_inputline)//'" '//TRIM(l_in_oniom_foldername)//' '//TRIM(zielfile)//&
                &' ./Oniom/'//TRIM(run_lambda_in)//' false oniom '//TRIM(xyz_N_file_A_el)//' '//TRIM(xyz_N_file_A_lo)//&
                &' '//TRIM(xyz_N_file_B_el)//' '//TRIM(xyz_N_file_B_lo)
    END IF    
    WRITE(*,*) TRIM(Bashline)


WRITE(*,*) 'ENDE make_LAMBDA_IN_ONIOM'
END Subroutine ! make_LAMBDA_IN_ONIOM


Subroutine add_linkatoms_to_file(linkatoms,i,j,xyz_N_file_A)
! Subroutine zum Anfuegen der Linkatomszeile(i,j) an Zeile in der Datei xyz_N_file_A; 
! Bsp:  H-H_-0.110683 12
!Elementsymbol-Partialladung Index Nachbar
! linkatoms:4x4Matrix       j=1                  j=2                j=3                j=4                 j=5
! i=1  molAStart      partial_charge_n     partial_charge_el    partial_charge_lo    Zeile H-Atom   Zeile-linkatom(C-Atom)
! i=2  molAEnde
! i=3  molBStart
! i=4  molAEnde
use small_functions
IMPLICIT NONE
REAL, DIMENSION(4,5), INTENT(IN)::linkatoms
INTEGER, INTENT(IN)::i,j
Character(800), INTENT(IN)::xyz_N_file_A
INTEGER::zeile
CHARACTER(800)::linktext
Character(5024)::Bashline

!sed '88s/$/ myalias/' DIPBI_630.xyz > tmp.xyz ; cat tmp.xyz > DIPBI_630.xyz ; rm tmp.xyz   !!!Imitierte Bashzeile
    IF( INT(linkatoms(i,5)) > 0 .AND. abs(linkatoms(i,j)) > 1.0E-6 ) THEN
        zeile=INT(linkatoms(i,5)+2.0)                   ! Zeile +2 da das xyz-file Format ab der dritten Zeile beginnt
        linktext='H-H_-'//TRIM(Real2str(linkatoms(i,j)))//' '//TRIM(str(INT(linkatoms(i,4))))
        Bashline="sed '"//TRIM(str(zeile))//"s/$/ "//TRIM(linktext)//"/' "//TRIM(xyz_N_file_A)//&
                &" > tmp.xyz ; cat tmp.xyz > "//TRIM(xyz_N_file_A)//"; rm tmp.xyz"
        CALL execute_command_line(TRIM(Bashline))
        
        ! Setze -1 auf 0 fuer Linkatome Bsp: sed '24s/ -1 /  0 /' P3MT_300_301_molB_lo.xyz
        Bashline="sed '"//TRIM(str(zeile))//"s/ -1 /  0 /' "//TRIM(xyz_N_file_A)//&
                &" > tmp.xyz ; cat tmp.xyz > "//TRIM(xyz_N_file_A)//"; rm tmp.xyz"

        CALL execute_command_line(TRIM(Bashline))
    END IF
END Subroutine add_linkatoms_to_file


SUBROUTINE make_Oniom_Freezelist(xyz_N_file_A,molA,charge,l_in_oniom_foldername)
	use small_functions
IMPLICIT NONE
Character(800), INTENT(INOUT)  ::l_in_oniom_foldername,xyz_N_file_A
CHARACTER(LEN=4), INTENT(IN)::molA
CHARACTER(LEN=2), INTENT(IN)::charge
Character(800)::Freeze_list
Character(5024)::Bashline
INTEGER::i_start
   Freeze_list='Freeze_list_'//TRIM(molA)//'_'//TRIM(charge)//'.dat'
   
   !Bashline='tail -n +3 '//TRIM(xyz_N_file_A)//' | awk '//"'{print $2"//'" "$6'//"}' > "//TRIM(Freeze_list) ! Old line   
 Bashline='tail -n +3 '//TRIM(xyz_N_file_A)//' | awk '//"'{print $1"//' " " $2 " " $6 " " $7 " " $8 }'//"' > "//TRIM(Freeze_list) 
 CALL execute_command_line(TRIM(Bashline)) 
   
 Bashline='mv '//TRIM(xyz_N_file_A)//' '//TRIM(Freeze_list)//' '//TRIM(l_in_oniom_foldername)//'/'
 CALL execute_command_line(TRIM(Bashline)) 
  
  !! Insert foldername in xyz_N_file_A, as the file was moved to an other folder
  !!i_start=INDEX(xyz_N_file_A,'xyz_N_', .false.)  ! get fist starting position
  !!xyz_N_file_A=TRIM(l_in_oniom_foldername)//'/'//xyz_N_file_A(i_start:)

  i_start=INDEX(xyz_N_file_A,'xyz_N_', .false.)  ! get fist starting position
  xyz_N_file_A=xyz_N_file_A(i_start:)
  
END SUBROUTINE make_Oniom_Freezelist


Subroutine make_Oniom_xyz_N_file(list,i_max,xyz_N_file_A,str1,str2,l_in_oniom_foldername,Resids_in_same_mol)
! Subroutine to create the xyz_N_files_for Oniom input.
! Oniom_xyz_namelist should be read: list==Oniom_xyz_namelist !!!
! You need to adapt str1 to specify molA and str2 to specify molB; possible choices: str={_n;_n_L;_el;_lo}
use small_functions
IMPLICIT NONE
INTEGER, INTENT(IN)::i_max
Character(500), Dimension(i_max), INTENT(IN)::list !=Oniom_xyz_namelist
Character(800)  ::l_in_oniom_foldername,xyz_N_file_A
CHARACTER(LEN=4), INTENT(IN)::str1,str2
Character(5024)::Bashline
INTEGER::i
LOGICAL::Resids_in_same_mol
        

IF( .NOT. Resids_in_same_mol) THEN
    IF( TRIM(str2)=='_n_L') THEN ! molA dann molB
        Bashline='tail -n +3 '//TRIM(l_in_oniom_foldername)//'/'//TRIM(list(1))//TRIM(str1)//'.xyz >> '//TRIM(xyz_N_file_A)
        CALL execute_command_line(TRIM(Bashline)) 
        Bashline='tail -n +3 '//TRIM(l_in_oniom_foldername)//'/'//TRIM(list(2))//TRIM(str2)//'.xyz >> '//TRIM(xyz_N_file_A)
        CALL execute_command_line(TRIM(Bashline)) 
    ELSE 
        Bashline='tail -n +3 '//TRIM(l_in_oniom_foldername)//'/'//TRIM(list(2))//TRIM(str2)//'.xyz >> '//TRIM(xyz_N_file_A)
        CALL execute_command_line(TRIM(Bashline)) 
        Bashline='tail -n +3 '//TRIM(l_in_oniom_foldername)//'/'//TRIM(list(1))//TRIM(str1)//'.xyz >> '//TRIM(xyz_N_file_A)
        CALL execute_command_line(TRIM(Bashline)) 
    END IF
    DO i=3,i_max
        Bashline='tail -n +3 '//TRIM(l_in_oniom_foldername)//'/'//TRIM(list(i))//'_n.xyz >> '//TRIM(xyz_N_file_A)
        CALL execute_command_line(TRIM(Bashline)) 
    END DO
ELSE IF( Resids_in_same_mol) THEN ! molA und molB im gleichen Molekuel - sollen nicht doppelt in die Datei geschrieben werden.
    IF( TRIM(str2)=='_n_L') THEN ! molA dann molB
        Bashline='tail -n +3 '//TRIM(l_in_oniom_foldername)//'/'//TRIM(list(1))//TRIM(str1)//'.xyz >> '//TRIM(xyz_N_file_A)
        CALL execute_command_line(TRIM(Bashline)) 
    ELSE 
        Bashline='tail -n +3 '//TRIM(l_in_oniom_foldername)//'/'//TRIM(list(2))//TRIM(str2)//'.xyz >> '//TRIM(xyz_N_file_A)
        CALL execute_command_line(TRIM(Bashline)) 
    END IF
    DO i=3,i_max+1 ! Schleife ueber neutrale extramolekuele
        Bashline='tail -n +3 '//TRIM(l_in_oniom_foldername)//'/'//TRIM(list(i))//'_n.xyz >> '//TRIM(xyz_N_file_A)
        CALL execute_command_line(TRIM(Bashline)) 
    END DO
END IF ! Resids_in_same_mol ?
! Anfuegen der Anzahl der Molekuele um xyz-Qniom-Format zu erstellen.
    Bashline='i='//TRIM(xyz_N_file_A)//' ; cat $i > Q1.xyz ; lines=$(wc -l $i) ; echo ${lines% *} > $i ; echo " " >> $i ;&
                                        & cat Q1.xyz >> $i ; rm Q1.xyz'
   CALL execute_command_line(TRIM(Bashline)) 
    
END Subroutine make_Oniom_xyz_N_file 



Subroutine Element_array_to_UFF_symbol(atomsorte,NAtoms,P3HT,DIPBI,P3MT,DIPBI_KETTE)
!Subroutine um die Elementsymbole in UFF-Symbole umzuwandeln fuer P3HT,DIPBI,P3MT,DIPBI_KETTE
INTEGER, INTENT(IN)::NAtoms
Character (Len=5), Dimension(NAtoms), INTENT(INOUT)  ::atomsorte
LOGICAL, INTENT(IN) ::P3HT,DIPBI,P3MT,DIPBI_KETTE
INTEGER::j,N_Schwefel

IF( DIPBI .AND. .NOT. DIPBI_KETTE .AND. NAtoms==86 ) THEN
atomsorte=(/ 'C-C_3', 'N-N_R','O-O_2','O-O_2','C-C_R','C-C_R',&
  &'C-C_R','C-C_R','C-C_R','C-C_R','C-C_R','H-H_ ','C-C_R',&
  &'H-H_ ','C-C_R','Cl-Cl','C-C_R','C-C_R','C-C_R','C-C_R','C-C_R','C-C_R','Cl-Cl','C-C_R','C-C_R','C-C_R','C-C_R',&
  &'H-H_ ','C-C_R','C-C_R','C-C_R','C-C_R','C-C_R','O-O_2','N-N_R','O-O_2','C-C_3','C-C_3','N-N_R','O-O_2','O-O_2',&
  &'C-C_R','C-C_R','C-C_R','C-C_R','C-C_R','C-C_R','C-C_R','H-H_ ','C-C_R','C-C_R','Cl-Cl','C-C_R','C-C_R','C-C_R',&
  &'C-C_R','C-C_R','C-C_R','Cl-Cl','C-C_R','C-C_R','C-C_R','C-C_R','H-H_ ','C-C_R','H-H_ ','C-C_R','C-C_R','C-C_R',&
  &'C-C_R','O-O_2','N-N_R','O-O_2','C-C_3','H-H_ ','H-H_ ','H-H_ ','H-H_ ','H-H_ ','H-H_ ','H-H_ ','H-H_ ','H-H_ ',&
  &'H-H_ ','H-H_ ','H-H_ ' /)

ELSE IF (DIPBI .AND. DIPBI_KETTE .AND. NAtoms==218) THEN
atomsorte=(/'C-C_3','N-N_R','O-O_2','O-O_2','C-C_R','C-C_R','C-C_R','C-C_R',&
    &'C-C_R','C-C_R','C-C_R','H-H_ ','C-C_R','H-H_ ','C-C_R','Cl-Cl','C-C_R','C-C_R','C-C_R','C-C_R','C-C_R','C-C_R','Cl-Cl',&
    &'C-C_R','C-C_R','C-C_R','C-C_R','H-H_ ','C-C_R','C-C_R','C-C_R','C-C_R','C-C_R','O-O_2','N-N_R','O-O_2','C-C_3','C-C_3',&
    &'N-N_R','O-O_2','O-O_2','C-C_R','C-C_R','C-C_R','C-C_R','C-C_R','C-C_R','C-C_R','H-H_ ','C-C_R','C-C_R','Cl-Cl','C-C_R',&
    &'C-C_R','C-C_R','C-C_R','C-C_R','C-C_R','Cl-Cl','C-C_R','C-C_R','C-C_R','C-C_R','H-H_ ','C-C_R','H-H_ ','C-C_R','C-C_R',&
    &'C-C_R','C-C_R','O-O_2','N-N_R','O-O_2','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3',&
    &'H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3',&
    &'H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','H-H_ ','H-H_ ','H-H_ ','C-C_3',&
    &'H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3',&
    &'H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3',&
    &'H-H_ ','H-H_ ','H-H_ ','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3',&
    &'H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3',&
    &'H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','H-H_ ','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3',&
    &'H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3',&
    &'H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','H-H_ ' /)
ELSE IF (P3HT) THEN
    N_Schwefel=0
    DO j=1,NAtoms
        if (TRIM(adjustl(atomsorte(j)))=='S') N_Schwefel=N_Schwefel+1
    END DO
    atomsorte(1)='H-H_ ' ! Festlegen erstes und letztes H Atom
    atomsorte(NAtoms)='H-H_ '
    IF(P3MT) THEN
        DO j=1,N_Schwefel 
            IF( j==N_Schwefel) THEN ! Test ob letztes Element in der Kette, da hier die Reihenfolge vertauscht ist.
                IF( TRIM(adjustl(atomsorte(NAtoms-4)))=='S' ) THEN ! Test ob Ende des 32mers. 
        atomsorte(2+(j-1)*10:2+j*10)=(/'C-C_R','C-C_R','H-H_ ','C-C_R','C-C_R','H-H_ ','S-S_R','C-C_3','H-H_ ','H-H_ ','H-H_ ' /)
                ELSE
                atomsorte(2+(j-1)*10:1+j*10)=(/'C-C_R','C-C_R','H-H_ ','C-C_R','C-C_R','S-S_R','C-C_3','H-H_ ','H-H_ ','H-H_ ' /)
                END IF 
            ELSE  !Fuer gewoehnliche Kettenglieder
                atomsorte(2+(j-1)*10:1+j*10)=(/'C-C_R','C-C_R','H-H_ ','C-C_R','C-C_R','S-S_R','C-C_3','H-H_ ','H-H_ ','H-H_ ' /)
            END IF
        END DO !j ueber N_schwefel -Kettenlaenge
    ELSE ! P3HT 
        DO j=1,N_Schwefel 
            IF( j==N_Schwefel) THEN ! Test ob letztes Element in der Kette, da hier die Reihenfolge vertauscht ist.
                IF( TRIM(adjustl(atomsorte(NAtoms-20)))=='S' ) THEN ! Test ob Ende des 32mers. 
            atomsorte(2+(j-1)*25:2+j*25)=(/'C-C_R','C-C_R','H-H_ ','C-C_R','C-C_R','H-H_ ','S-S_R','C-C_3','H-H_ ','H-H_ ',&
            &'C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ '&
            &,'H-H_ ','H-H_ ' /) 
                ELSE
            atomsorte(2+(j-1)*25:1+j*25)=(/'C-C_R','C-C_R','H-H_ ','C-C_R','C-C_R','S-S_R','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ '&
            &,'H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','H-H_ ' /) 
                END IF 
            ELSE! Fuer gewoehnliche Kettengieder
            atomsorte(2+(j-1)*25:1+j*25)=(/'C-C_R','C-C_R','H-H_ ','C-C_R','C-C_R','S-S_R','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ '&
            &,'H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','C-C_3','H-H_ ','H-H_ ','H-H_ ' /) 
            END IF
        END DO 
    END IF
ELSE 
    WRITE(*,*) 'Fehler: Kein_Molekuel_fuer_UFF_ausgewaehlt_in:_Element_array_to_UFF_symbol___ENDE'
    STOP
END IF ! DIPBI/P3MT/P3HT
END Subroutine ! Element_array_to_UFF_symbol

!!!=========================!!!  
!!!       LAMBDA_IN         !!!
!!!=========================!!! 
	SUBROUTINE lambda_in(molA,molB,trajstep,lambda_in_inputline,sub_g09,atomsorteA,& 
                    & koordA,NAtomsA,atomsorteB,koordB,NAtomsB,lambda_in_foldername,&
                    & nproc,mem,CURDIR,g09_SKF_path,extra_SP_lambda_in)
	use small_functions
	IMPLICIT NONE
		Character(500), INTENT(IN) ::molA,molB
		INTEGER, INTENT(IN)::NAtomsA,NAtomsB,trajstep
		Character (Len=3), Dimension(NAtomsA), INTENT(IN) ::atomsorteA
		Character (Len=3), Dimension(NAtomsB), INTENT(IN) ::atomsorteB
		Real, Dimension(NAtomsA,3), INTENT(IN) ::koordA
		Real, Dimension(NAtomsB,3), INTENT(IN) ::koordB
		Character(500), INTENT(IN) ::lambda_in_inputline,lambda_in_foldername
		LOGICAL, INTENT(IN) :: sub_g09
		Integer,    intent(in)         ::  nproc 
		Integer,     intent(in)        ::  mem 
		Character(len=500), intent(in) ::  CURDIR     
		Character(500), INTENT(IN)     ::  g09_SKF_path
		logical                        ::  DFTB_ok=.false.
		LOGICAL, INTENT(IN) ::extra_SP_lambda_in
		Character(5024)::bashline
		CHARACTER(500)::lambda_in_zieldatei,run_lambda_in
		LOGICAL::lam_in_folder_vorhanden,file_vorhanden
		
		write(*,*) "!!*****************!!"  
		write(*,*) "!!    LAMBDA_IN    !!"
		write(*,*) "!!*****************!!"
		
		lambda_in_zieldatei='results_lambda_in_G'//TRIM(str(trajstep))//'.dat'
		run_lambda_in='run_lambda_in_V3.sh'

		
		if(sub_g09) then
			inquire(file='./lambda_in/'//TRIM(run_lambda_in),exist=file_vorhanden)
			IF(.NOT. file_vorhanden) THEN
				WRITE(*,*) 'Fehler: Datei_nicht_gefunden_'//'./lambda_in/'//TRIM(run_lambda_in) 
				STOP
			END IF
					
			inquire(file='./lambda_in/sub-myg09-lambda_in_Kankra.sh',exist=file_vorhanden)
			IF(.NOT. file_vorhanden) THEN
				WRITE(*,*) 'Fehler: Datei_nicht_gefunden_in_./lambda_in/sub-myg09-lambda_in_Kankra.sh'
				STOP
			END IF
		endif !sub_g09 
		
		if(file_exists_and_continue('./lambda_in/lambda_in_setup_on_the_fly.sh')) then
				!Erstelle Ordner
				inquire(file=TRIM(lambda_in_foldername),exist=lam_in_folder_vorhanden)
				IF( .NOT. lam_in_folder_vorhanden) THEN
					write(bashline,*) 'mkdir '//TRIM(lambda_in_foldername)
					CALL execute_command_line(TRIM(bashline)) 
				END IF
				call make_coord_to_xyz_in_dir(atomsorteA,koordA,NAtomsA,molA,lambda_in_foldername)
				call make_coord_to_xyz_in_dir(atomsorteB,koordB,NAtomsB,molB,lambda_in_foldername)
				IF (sub_g09) THEN
					bashline=' ./lambda_in/lambda_in_setup_on_the_fly.sh '//TRIM(molA)//'.xyz '//TRIM(molB)//'.xyz "'//&
							&TRIM(lambda_in_inputline)//'" '//TRIM(lambda_in_foldername)//' '//TRIM(lambda_in_zieldatei)//&
							&' ./lambda_in/'//TRIM(run_lambda_in)//' true ' 
				ELSE
					bashline=' ./lambda_in/lambda_in_setup_on_the_fly.sh '//TRIM(molA)//'.xyz '//TRIM(molB)//'.xyz "'//&
							&TRIM(lambda_in_inputline)//'" '//TRIM(lambda_in_foldername)//' '//TRIM(lambda_in_zieldatei)//&
							&' ./lambda_in/'//TRIM(run_lambda_in)//' false '
				END IF    
				WRITE(*,*) TRIM(bashline)
				CALL execute_command_line(TRIM(bashline)) 
				WRITE(*,*) 'LAMBDA IN ENDE'
				STOP
		ELSE
		
		if( (index(lambda_in_inputline,'DFTB') /= 0 ) .or. (index(lambda_in_inputline,'dftb') /= 0 ) ) then 
			DFTB_ok=.true.
		else
			DFTB_ok=.false.
		endif
		
		!! Create a local file system for g09 *.inp  lambda_in calculations
		CALL lambda_in_setup(lambda_in_inputline,molA,molB,lambda_in_foldername,nproc,mem,CURDIR,DFTB_ok,lambda_in_zieldatei,&
		   & NAtomsA,atomsorteA,koordA,NAtomsB,atomsorteB,koordB,g09_SKF_path,extra_SP_lambda_in)
		END IF ! lam_in_folder_vorhanden
	end subroutine LAMBDA_IN ! LAMBDA_IN 

	!! Create a local file system for g09 lambda_in calculations
	subroutine lambda_in_setup(g09inputline,molA,molB,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,&
		   & NAtomsA,atomsorteA,koordA,NAtomsB,atomsorteB,koordB,g09_SKF_path,extra_SP_lambda_in)
		  use small_functions
		  implicit none
		  Character(LEN=500), intent(in) ::  molA,molB
		  Character(len=500), intent(in) ::  g09inputline 
		  Character(len=500), intent(in) ::  foldername   
		  Integer,    intent(in)         ::  nproc 
		  Integer,     intent(in)        ::  mem 
		  Character(len=500), intent(in) ::  CURDIR     
		  logical,    intent(in)         ::  DFTB_ok  
		  Character(len=500),intent(in)  ::  ziel 
		  Integer, INTENT (IN):: NAtomsA,NAtomsB
		  Character (Len=3), Dimension(NAtomsA), INTENT(IN) ::atomsorteA
		  Character (Len=3), Dimension(NAtomsB), INTENT(IN) ::atomsorteB
		  Real, Dimension(NAtomsA,3), INTENT(IN) ::koordA
		  Real, Dimension(NAtomsB,3), INTENT(IN) ::koordB
		  Character(len=500),intent(in)  ::  g09_SKF_path
		  logical,    intent(in)         ::  extra_SP_lambda_in
		Character(LEN=500), Dimension(20) :: R ! Rechnungen
		Character(Len=4) :: molX
		Character(Len=500) :: dir
		Character(Len=5000) ::bashline
		logical :: debug
		integer ::n_extra_SP_lambda_in
		integer ::i
		
		debug=.false.
		
		!! structure for folder and g09 input filenames
		R=''
		!!! Create file structure for Optimization
		R(1)='OptS0_n_'//trim(adjustl(molA))
		R(2)='OptS0_el_'//trim(adjustl(molA))
		R(3)='OptS0_lo_'//trim(adjustl(molA))
		R(4)='OptS0_n_'//trim(adjustl(molB))
		R(5)='OptS0_el_'//trim(adjustl(molB))
		R(6)='OptS0_lo_'//trim(adjustl(molB))

		!!! Create file structure for SCF-Calculations molA
		R(7)='SCF_el_OptS0_n_'//trim(adjustl(molA))
		R(8)='SCF_lo_OptS0_n_'//trim(adjustl(molA))
		R(9)='SCF_n_OptS0_el_'//trim(adjustl(molA))
		R(10)='SCF_n_OptS0_lo_'//trim(adjustl(molA))
		!!! SCF file structure for molB
		R(11)='SCF_el_OptS0_n_'//trim(adjustl(molB))
		R(12)='SCF_lo_OptS0_n_'//trim(adjustl(molB))
		R(13)='SCF_n_OptS0_el_'//trim(adjustl(molB))
		R(14)='SCF_n_OptS0_lo_'//trim(adjustl(molB))
		 
		if (extra_SP_lambda_in) then
			R(15)='SCF_n_OptS0_n_'//trim(adjustl(molA))
			R(16)='SCF_el_OptS0_el_'//trim(adjustl(molA))
			R(17)='SCF_lo_OptS0_lo_'//trim(adjustl(molA))
		
			R(18)='SCF_n_OptS0_n_'//trim(adjustl(molB))
			R(19)='SCF_el_OptS0_el_'//trim(adjustl(molB))
			R(20)='SCF_lo_OptS0_lo_'//trim(adjustl(molB))
			n_extra_SP_lambda_in=6
		else
			n_extra_SP_lambda_in=0
		endif


	!! Make folder system, if it is not available
	do i=-3,14+n_extra_SP_lambda_in,1
		if(   (i==1) .or. (i==2) .or. (i==3) .or. &
			& (i==7) .or. (i==8) .or. (i==9) .or. (i== 10) .or. &
			& (i==15) .or. (i==16) .or. (i==17)) then
			molX='molA'
		else 
			molX='molB'
		endif
		
		if( i == -3) then
			dir='./lambda_in'
		else if( i == -2) then
			dir=trim(foldername)
		else if(i == -1) then
			dir=trim(foldername)//'/molA/'
		else if(i == 0) then
			dir=trim(foldername)//'/molB/'
		else
			dir=trim(foldername)//'/'//trim(molX)//'/'//trim(adjustl(R(i)))
		endif
		
		! write(*,*) ' mkdir ',trim(dir)
		if(file_exists_and_continue(dir)) then
			write(*,*) 'Der Ordner existier bereits: ',trim(dir)
			continue
		else
			bashline=' mkdir '//trim(dir)
			if(debug) write(*,*) trim(bashline)
			CALL execute_command_line(TRIM(bashline)) 
			if(file_exists(dir)) then
				continue
			endif ! Check if folder was created successfully.
		endif
	enddo
	if(debug) write(*,*) 'Folders creadted for lambda_in.'
	
	CALL makeOpt(R(1),'molA',g09inputline, 0,1,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteA,NAtomsA,koordA,g09_SKF_path)
	CALL makeOpt(R(2),'molA',g09inputline,-1,2,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteA,NAtomsA,koordA,g09_SKF_path)
	CALL makeOpt(R(3),'molA',g09inputline,+1,2,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteA,NAtomsA,koordA,g09_SKF_path)
	
	CALL makeOpt(R(4),'molB',g09inputline, 0,1,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteB,NAtomsB,koordB,g09_SKF_path)
	CALL makeOpt(R(5),'molB',g09inputline,-1,2,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteB,NAtomsB,koordB,g09_SKF_path)
	CALL makeOpt(R(6),'molB',g09inputline,+1,2,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteB,NAtomsB,koordB,g09_SKF_path)
	
	
	
	CALL makeSCF(R(1),R(7) ,'molA',g09inputline,-1,2,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteA,NAtomsA,g09_SKF_path)
	CALL makeSCF(R(1),R(8) ,'molA',g09inputline,+1,2,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteA,NAtomsA,g09_SKF_path)
	CALL makeSCF(R(2),R(9) ,'molA',g09inputline, 0,1,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteA,NAtomsA,g09_SKF_path)
	CALL makeSCF(R(3),R(10),'molA',g09inputline, 0,1,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteA,NAtomsA,g09_SKF_path)
																								 
	CALL makeSCF(R(4),R(11),'molB',g09inputline,-1,2,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteB,NAtomsB,g09_SKF_path)
	CALL makeSCF(R(4),R(12),'molB',g09inputline,+1,2,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteB,NAtomsB,g09_SKF_path)
	CALL makeSCF(R(5),R(13),'molB',g09inputline, 0,1,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteB,NAtomsB,g09_SKF_path)
	CALL makeSCF(R(6),R(14),'molB',g09inputline, 0,1,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteB,NAtomsB,g09_SKF_path)

	if (extra_SP_lambda_in) then
		CALL makeSCF(R(1) ,R(15),'molA',g09inputline, 0,1,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteA,NAtomsA,g09_SKF_path)
		CALL makeSCF(R(2) ,R(16),'molA',g09inputline,-1,2,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteA,NAtomsA,g09_SKF_path)
		CALL makeSCF(R(3) ,R(17),'molA',g09inputline,+1,2,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteA,NAtomsA,g09_SKF_path)
		             
		CALL makeSCF(R(4) ,R(18),'molB',g09inputline, 0,1,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteB,NAtomsB,g09_SKF_path)
		CALL makeSCF(R(5) ,R(19),'molB',g09inputline,-1,2,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteB,NAtomsB,g09_SKF_path)
		CALL makeSCF(R(6) ,R(20),'molB',g09inputline,+1,2,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,atomsorteB,NAtomsB,g09_SKF_path)
	endif
		
		write(*,*) 'lambda_in_setup done.'
		call exit(1)
	end subroutine lambda_in_setup

       !! Erstellt SCF Input files mit Parametern
       !! makeSCF Optimierung        SCF        molX   Methode Ladung  Multiplizitaet Ordnername $nproc $mem ${CURDIR} DFTB_ok
       !!             1              2           3       4         5             6            7           8        9      10       11     
       !! makeSCF ${Optfilename} ${SCFfilename} ${molX} ${input} ${charge} ${multiplizity} ${foldername} ${nproc} ${mem} ${CURDIR} ${DFTB_ok}
subroutine makeSCF(Optfilename,SCFfilename,molX,g09inputline,charge,multiplizity,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,& 
			&atomsorte,NAtoms,g09_SKF_path)
	  use small_functions
	  implicit none
	  Character(len=500), intent(in) ::  Optfilename   
	  Character(len=500), intent(in) ::  SCFfilename 
	  Character(len=4),   intent(in) ::  molX 
	  Character(len=500), intent(in) ::  g09inputline 
	  Integer,    intent(in)         ::  charge 
	  Integer,    intent(in)         ::  multiplizity 
	  Character(len=500), intent(in) ::  foldername   
	  Integer,    intent(in)         ::  nproc 
	  Integer,     intent(in)        ::  mem 
	  Character(len=500), intent(in) ::  CURDIR     
	  logical,    intent(in)         ::  DFTB_ok  
	  Character(len=500),intent(in)  ::  ziel 
	  Integer, INTENT (IN) :: NAtoms
	  Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
	  Character(Len=500) :: g09_SKF_path
	  Character(len=5000)::bashline
	  Character(len=500) :: newg09file
	  integer ::ierror
	  logical :: debug=.false.
	  
	newg09file=trim(adjustl(CURDIR))//"/"//trim(adjustl(foldername))//"/"//trim(adjustl(molX))//"/"//&
		& trim(adjustl(SCFfilename))//"/"//trim(adjustl(SCFfilename))//".inp"
	if ( file_exists_and_continue(trim(adjustl(CURDIR))//"/"//trim(adjustl(foldername))//"/"//trim(adjustl(molX))//"/"//&
		& trim(adjustl(SCFfilename))//"/"//trim(adjustl(SCFfilename))//".log"))then
		  write(*,*) " Die Datei existiert bereits: "//trim(adjustl(SCFfilename))//".log "
	else                        
		if ( file_exists_and_continue(newg09file))then
				write(*,*) " Die Datei existiert bereits: "//trim(adjustl(SCFfilename))//".inp "
		else ! SCF_${charge} ${SCFfilename}.inp file for "//trim(adjustl(molX))//"
			if ( file_exists_and_continue(trim(adjustl(CURDIR))//"/"//trim(adjustl(foldername))//"/"//trim(adjustl(molX))//"/"&
				&//trim(adjustl(SCFfilename))//"/"))then
				if(debug) write(*,*) "Der Ordner existiert bereits: "//trim(adjustl(foldername))//"/"//trim(adjustl(molX))//"/"&
							&//trim(adjustl(SCFfilename))//"/ "
			else
				bashline=" mkdir "//trim(adjustl(CURDIR))//"/"//trim(adjustl(foldername))//"/"//trim(adjustl(molX))//"/"&
				&//trim(adjustl(SCFfilename))//"/"
				CALL execute_command_line(TRIM(bashline))
				if(debug) write(*,*) trim(bashline)
            endif ! Ordner existiert
            !!! Erstelle SCF-Inputfile

            OPEN(UNIT=29,FILE=TRIM(newg09file),STATUS='replace',action='write',IOSTAT=ierror)
            write(29,*) "%NProcShared="//trim(adjustl(int2str(nproc)))
            write(29,*) "%Mem="//trim(adjustl(int2str(mem)))//"GB"  
            write(29,*) "%Chk="//trim(adjustl(SCFfilename))//".chk"  
            write(29,*) "#P "//trim(adjustl(g09inputline))//" NoSymm "  
            write(29,*) "# GFINPUT IOP(6/7=3) 6D 10F "  
            write(29,*) " "  
            write(29,*) trim(adjustl(SCFfilename))//"   "//trim(adjustl(g09inputline))//"  monomer "//trim(adjustl(molX))//&
						&" nach Optimierung in "//trim(adjustl(Optfilename))//" generated with charge_transport_package."  
            write(29,*) " "  
            write(29,'(I2,A2,I2)') charge,"  ",multiplizity                          
            !!!write(29,*) "XYZoptimierteGeometrie "  
            !!!write(29,*) ""  
            close(29)
            if(.false. .and. DFTB_ok)then ! Deaktiviert!
                CALL g09_DFTB_SKF_Anhang(atomsorte,NAtoms,newg09file,g09_SKF_path)
            endif !DFTB
            
            if ( file_exists_and_continue(newg09file)) then 
                write(*,*) " Datei "//trim(adjustl(SCFfilename))//".inp erstellt. "
            else
                write(*,*) "Fehler: Datei "//trim(adjustl(SCFfilename))//".inp wurde nicht erstellt!"
                OPEN(UNIT=89,FILE=TRIM(ziel),STATUS='unknown',IOSTAT=ierror,action='write',position="append")
                write(89,*) "Fehler: Datei_"//trim(adjustl(SCFfilename))//".inp_wurde_nicht_erstellt  "//trim(adjustl(foldername)) 
                close(89)
                call exit(1)
            endif
        endif ! Existiert *.inp
    endif !Existiert *.log     
    return

end subroutine makeSCF

       !! makeOpt Optimierung           molX   Methode Ladung  Multiplizitaet Ordnername $nproc $mem ${CURDIR} DFTB_ok
       !!             1                 2       3         4             5            6    7       8        9      10       11     
       !! makeOpt ${Optfilename}       ${molX} ${input} ${charge} ${multiplizity} ${foldername} ${nproc} ${mem} ${CURDIR} ${DFTB_ok}
subroutine makeOpt(Optfilename,molX,g09inputline,charge,multiplizity,foldername,nproc,mem,CURDIR,DFTB_ok,ziel,& 
			&atomsorte,NAtoms,koord,g09_SKF_path)
	  use small_functions
	  implicit none
	  Character(len=500), intent(in) ::  Optfilename   
	  Character(len=4),   intent(in) ::  molX 
	  Character(len=500), intent(in) ::  g09inputline 
	  Integer,    intent(in)         ::  charge 
	  Integer,    intent(in)         ::  multiplizity 
	  Character(len=500), intent(in) ::  foldername   
	  Integer,    intent(in)         ::  nproc 
	  Integer,     intent(in)        ::  mem 
	  Character(len=500), intent(in) ::  CURDIR     
	  logical,    intent(in)         ::  DFTB_ok  
	  Character(len=500),intent(in)  ::  ziel 
	  Integer, INTENT (IN):: NAtoms
	  Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
	  real,      Dimension(NAtoms,3),  INTENT(IN) :: koord
	  Character(Len=500) :: g09_SKF_path
	  Character(len=5000)::bashline
	  Character(len=500) :: newg09file
	  integer ::i,ierror
	  logical :: debug=.false.
	  
	newg09file=trim(adjustl(CURDIR))//"/"//trim(adjustl(foldername))//"/"//trim(adjustl(molX))//"/"//&
		& trim(adjustl(Optfilename))//"/"//trim(adjustl(Optfilename))//".inp"
	if ( file_exists_and_continue(trim(adjustl(CURDIR))//"/"//trim(adjustl(foldername))//"/"//trim(adjustl(molX))//"/"//&
		& trim(adjustl(Optfilename))//"/"//trim(adjustl(Optfilename))//".log"))then
		  write(*,*) " Die Datei existiert bereits: "//trim(adjustl(Optfilename))//".log"
	else                        
		if ( file_exists_and_continue(newg09file))then
				write(*,*) " Die Datei existiert bereits: "//trim(adjustl(Optfilename))//".inp "
		else ! SCF_${charge} ${Optfilename}.inp file for "//trim(adjustl(molX))//"
			if ( file_exists_and_continue(trim(adjustl(CURDIR))//"/"//trim(adjustl(foldername))//"/"//trim(adjustl(molX))//"/"&
				&//trim(adjustl(Optfilename))//"/"))then
				if(debug) write(*,*) "Der Ordner existiert bereits: "//trim(adjustl(foldername))//"/"//trim(adjustl(molX))//"/"&
							&//trim(adjustl(Optfilename))//"/ "
			else
				bashline=" mkdir "//trim(adjustl(CURDIR))//"/"//trim(adjustl(foldername))//"/"//trim(adjustl(molX))//"/"&
				&//trim(adjustl(Optfilename))//"/"
				CALL execute_command_line(TRIM(bashline))
				if(debug) write(*,*) trim(bashline)
            endif ! Ordner existiert
            !!! Erstelle SCF-Inputfile

            OPEN(UNIT=29,FILE=TRIM(newg09file),STATUS='replace',action='write',IOSTAT=ierror)
            write(29,*) "%NProcShared="//trim(adjustl(int2str(nproc)))
            write(29,*) "%Mem="//trim(adjustl(int2str(mem)))//"GB"  
            write(29,*) "%Chk="//trim(adjustl(Optfilename))//".chk"  
            write(29,*) "#P "//trim(adjustl(g09inputline))//" NoSymm "  
            write(29,*) "# GFINPUT IOP(6/7=3) 6D 10F "  
            write(29,*) " "  
            write(29,*) trim(adjustl(Optfilename))//"   "//trim(adjustl(g09inputline))//"  monomer "//trim(adjustl(molX))//&
						&" generated with charge_transport_package."  
            write(29,*) " "  
            write(29,'(I2,A2,I2)') charge,"  ",multiplizity 
			DO i=1,NAtoms
					WRITE(29,'(A10,3F16.4)',IOSTAT=ierror) atomsorte(i),koord(i,1),koord(i,2),koord(i,3)
			ENDDO
			write(29,*) " " 
            !!!write(29,*) "XYZoptimierteGeometrie "  
            !!!write(29,*) ""  
            close(29)
            if(DFTB_ok)then
                CALL g09_DFTB_SKF_Anhang(atomsorte,NAtoms,newg09file,g09_SKF_path)
            endif !DFTB
            
            if ( file_exists_and_continue(newg09file)) then 
                write(*,*) " Datei "//trim(adjustl(Optfilename))//".inp erstellt. "
            else
                write(*,*) "Fehler: Datei "//trim(adjustl(Optfilename))//".inp wurde nicht erstellt!"
                OPEN(UNIT=89,FILE=TRIM(ziel),STATUS='unknown',IOSTAT=ierror,action='write',position="append")
                write(89,*) "Fehler: Datei_"//trim(adjustl(Optfilename))//".inp_wurde_nicht_erstellt  "//trim(adjustl(foldername)) 
                close(89)
                call exit(1)
            endif
        endif ! Existiert *.inp
    endif !Existiert *.log     
    return

end subroutine makeOpt



Subroutine Read_part_charges_q_file(q_file,partial_charges,MAXATM,trajstep,zielfile,foldername)
	use small_functions
	IMPLICIT NONE
	Character(len=*),INTENT(IN) :: q_file,zielfile
	Character(len=*),INTENT(IN) :: foldername
	Real, Dimension(MAXATM) ,INTENT(INOUT):: partial_charges
	INTEGER, INTENT(IN)::MAXATM,trajstep
	INTEGER::j,ierror1,Num
	CHARACTER(5)::Element
	LOGICAL::q_file_vorhanden
	REAL::Abweichung

		OPEN(UNIT=30,FILE=zielfile,STATUS='unknown',IOSTAT=ierror1,action='write',position="append")
		inquire(file=TRIM(q_file),exist=q_file_vorhanden)
		IF (q_file_vorhanden) THEN
			OPEN(UNIT=17,FILE=TRIM(q_file),STATUS='OLD',IOSTAT=ierror1)
			! Einlesen der Daten aus q_file_vorhanden
			DO j=1,MAXATM
				READ(17,*,IOSTAT=ierror1) Num,Element,partial_charges(j),Abweichung !Format von Jim
				!READ(17,*,IOSTAT=ierror1) partial_charges(j) !Nur eine Spalte
				IF(ierror1 < 0) EXIT
				IF(ierror1 > 0) THEN
					WRITE(*,*) 'Fehler: Es ist ein Fehler beim Einlesen von ',TRIM(q_file),' aufgetreten.'
					WRITE(30,*) 'Fehler: Es_ist_ein_Fehler_beim_Einlesen_von_',TRIM(q_file),'_aufgetreten_ '//TRIM(foldername)
					WRITE(*,*) 'Beende Einlesen !'
					STOP
				END IF
			END DO
			CLOSE(17)
		ELSE 
			WRITE(*,*) 'Fehler:  Das q-File existiert nicht: ',TRIM(q_file)
			WRITE(30,*) 'Fehler: Das_q_File_existiert_nicht:_',TRIM(q_file),'_ERROR_G'//TRIM(str(trajstep))//' '//TRIM(foldername) 
			STOP
		END IF
		CLOSE(30)
END Subroutine ! Read_partial_charges_from_q_file



!!!==================================================!!
!!!       MAKE_LAMBDA_OUT_entire_box                 !! 
!!!==================================================!!
Subroutine make_lambda_out_entire_box(gro_inputfile,residue_number_1,type1,residue_number_2,type2,calculation_method,trajstep,Num,&
    &charge_name,x_box,y_box,z_box,Resid_list,N_neighbours_partial_charges,k,partial_charge_methode,r_cut,DIPBI_KETTE,P3MT)
	use small_functions
	IMPLICIT NONE
INTEGER, INTENT(IN)::residue_number_1,residue_number_2,N_neighbours_partial_charges,trajstep,Num
Character(3),   INTENT(IN) ::charge_name
Character(500), INTENT(IN) ::type1,type2
Character(500), INTENT(IN) ::gro_inputfile,partial_charge_methode
Character(500), INTENT(IN) ::calculation_method
LOGICAL, INTENT(INOUT) ::DIPBI_KETTE,P3MT
REAL, INTENT(INOUT) ::x_box,y_box,z_box,r_cut
Character(10000)  :: xyz_q_file,xyz_q_file_charged,q_file_n,q_file_charge,foldername,zielfile
!INTEGER, Dimension(N_neighbours_partial_charges+k), INTENT(INOUT) ::Resid_list
INTEGER,ALLOCATABLE, Dimension(:), INTENT(INOUT) ::Resid_list
INTEGER::int_dummy,lastresid,residue_number,atom_number,Gesamtanzahl,ierror1,NAtomsA,MAXATM_H,MAXATM_All,N_Schwefel
INTEGER::i,i_old_1,i_old_2,j,j_start,j_ende,k,l,n,m,k_max,i_min,i_max,i_1,i_2,counter,N_Mol,N_DIPBI,N_P3HT,Gesamtanzahl_H
INTEGER::N_Molekuele,ind,end_index,start_index,N_Atoms_mol,residue_number_old
LOGICAL::xyz_q_vorhanden,q_file_vorhanden,vorhanden,DIPBI,P3HT,SAVE_OLD,istart,print_xyz_q_1,print_xyz_q_2
LOGICAL::KETTE_1
Character(5), ALLOCATABLE, Dimension(:) :: atomsorteA,atomsorte1H  !,atomsorteB
Real, ALLOCATABLE, Dimension(:)   :: partial_charges,partial_charges_n
Real, ALLOCATABLE, Dimension(:,:) :: xyz_box_all,xyz_box_all_H,koord,koordA,koord1H
Character(500)::Molname,molA,dimer,dummyname,ziel,xyz_q_pfad,lio
Character(1000000)::Bashline,xyz_Bashline
Character(4)::S_Ringe
INTEGER, ALLOCATABLE, Dimension(:,:)::Data_collect,NSchwefel_P3HT,i_s_e,i_s_e_H
Character(5), ALLOCATABLE, Dimension(:)::atomsorte,atomsorte_all,atomsorte_box_all_H
Character(5)::residue_name,last_residue_name
Character(5),DIMENSION(4)::THP
!REAL::x,y,z,
REAL::v_x,v_y,v_z
Real,Dimension(3):: dummy_koord_start_1,dummy_koord_ende_1,dummy_koord_start_2,dummy_koord_ende_2,schwerpunkt_1
LOGICAL::Resid_1,Resid_2,read_entire_box,entire_box_H_to_xyz
Character(26):: form1='(2X,A3,1X,3F16.6,1F12.5)'
LOGICAL::PPDI,PPDI_KETTE,PBDT_TS1,DEBUG=.false.
	
	write(*,*) "!!!=============================!!!"
	write(*,*) "!!! MAKE_LAMBDA_OUT_entire_box  !!!" 
	write(*,*) "!!!=============================!!!"
	
	!! Setzen der Ausgabedaten 
	dimer='Dim_'//TRIM(type1)//'_'//TRIM(type2)//'_'//TRIM(str(residue_number_1))//'_'//TRIM(str(residue_number_2))
	foldername=TRIM(dimer)//'_'//TRIM(calculation_method)//'_'//TRIM(charge_name)//'_r_cut_'//TRIM(str(INT(r_cut)))//'_G'//&
                                &TRIM(str(trajstep))//'_N'//TRIM(str(Num))//'_lam_out'
    zielfile='results_lambda_out_'//TRIM(charge_name)//'_G'//TRIM(str(trajstep))//'.dat'
    ziel=TRIM(dimer)//'_entire_box'
    xyz_q_pfad='./xyz_q_Dateien' 
    lio=TRIM(foldername)  ! Parameter_um erstellte temporaere Dateien oder Ordner einzigartig zu benennen.
    
    inquire(file=TRIM(xyz_q_pfad),exist=vorhanden)
    IF ( .NOT. vorhanden) THEN
			CALL execute_command_line(' mkdir '//TRIM(xyz_q_pfad)) 
			!IF(DEBUG) THEN
				Write(*,*) ' mkdir '//TRIM(xyz_q_pfad)
			!END IF !DEBUG
    END IF 
    
    xyz_q_pfad=TRIM(xyz_q_pfad)//'/xyz_q_G'//TRIM(str(trajstep))//'_N'//TRIM(str(Num))//'/'
    inquire(file=TRIM(xyz_q_pfad),exist=vorhanden)
    IF ( .NOT. vorhanden) THEN
			CALL execute_command_line(' mkdir '//TRIM(xyz_q_pfad)) 
			!IF(DEBUG) THEN
				Write(*,*) ' mkdir '//TRIM(xyz_q_pfad)
			!END IF !DEBUG
    END IF 
    entire_box_H_to_xyz=.false. !Berechnung aller Koordinaten um Zentrum H als .xyz Datei // Fuer lambda_out so nicht erforderlich
  


!!! Auswahl der Berechnung mit der ganzen Box oder mit Cutoff_Radius=r_cut fuer die Kugel der Nachbaratome
    IF( abs(r_cut) < 1.0E-3) THEN ! Wenn r_cut=0.0
        read_entire_box=.TRUE.
    ELSE
        read_entire_box=.FALSE.
    END iF
    !! Einlesen der Anzahl der Resids=N_Mol aus gro-file
    Bashline="start_index=$(sed -n '3p' "//TRIM(gro_inputfile)//' | cut -c 1-5) ; end_index=$(tail -2 '//TRIM(gro_inputfile)//&
    &' | head -1 | cut -c 1-5) ; echo ${start_index}  ${end_index} >> s2e_'//TRIM(lio)//'.dat'  ! start 2 end 
    CALL execute_command_line(TRIM(Bashline)) 
    OPEN(UNIT=31,FILE='s2e_'//TRIM(lio)//'.dat',STATUS='unknown',IOSTAT=ierror1,action='read')
    READ(31,*) start_index,end_index
    CLOSE(31)
    Bashline=' rm s2e_'//TRIM(lio)//'.dat '
    CALL execute_command_line(TRIM(Bashline)) 

    N_Mol=end_index-start_index+1
    WRITE(*,*)' N_mol= ',N_mol,' in ',TRIM(gro_inputfile)  

IF( read_entire_box ) THEN
    if ( allocated(Resid_list)) Deallocate(Resid_list) 
    if ( .NOT. allocated(Resid_list)) allocate(Resid_list(N_Mol-2+k)) 

    Resid_list(1)=residue_number_1
    Resid_list(2)=residue_number_2
    k=0
    IF( TRIM(adjustl(type1))=='P3HT' .OR. TRIM(adjustl(type1))=='P3MT') THEN
        k=k+1
        !Resid_list(k)=residue_number_1
    END IF 
    IF( TRIM(adjustl(type2))=='P3HT' .OR. TRIM(adjustl(type2))=='P3MT') THEN
        k=k+1
        !Resid_list(k)=residue_number_2
    END IF 
    j=1
    DO i=start_index,end_index,1
        IF( i==residue_number_1 .OR. i==residue_number_2) THEN
            IF( i==residue_number_1 .AND. (TRIM(adjustl(type1))=='P3HT' .OR. TRIM(adjustl(type1))=='P3MT')) THEN
                Resid_list(j+2)=i
                j=j+1
            ELSE IF (i==residue_number_2  .AND. (TRIM(adjustl(type2))=='P3HT' .OR. TRIM(adjustl(type2))=='P3MT')) THEN
                Resid_list(j+2)=i
                j=j+1
            END IF
        ELSE ! Sonstige werde hochgezaehlt
            Resid_list(j+2)=i
            j=j+1
        END IF ! Abfrage residue_number_1 .OR. i==residue_number_2
    END DO
    WRITE(*,*) ' Calculate entire Box' 
    k_max=N_Mol+k !!!  N_Mol+k

   IF(DEBUG) THEN
    WRITE(*,*) 'kmax=',k_max
    WRITE(*,*) 'Resid_list(1 to 5,k_max),',Resid_list(1),Resid_list(2),Resid_list(3),Resid_list(4),Resid_list(5),Resid_list(k_max)
    !WRITE(*,*) Resid_list(residue_number_2),Resid_list(residue_number_2+1),Resid_list(residue_number_2+2)
    !WRITE(*,*) Resid_list(residue_number_2+3),Resid_list(residue_number_2+4),Resid_list(residue_number_2+5)
   END IF ! DEBUG
ELSE ! read_entire_box
    ! Sortiert das Array der Nachbarn der Residgroesse nach
    ! Selection Sort
    k_max=N_neighbours_partial_charges+k
    do j=3,k_max-1     ! Neutrale Resids + Nachbarn werden sortiert
        i_min=j
            DO i=j+1,k_max         
                IF( Resid_list(i) < Resid_list(i_min) ) THEN
                i_min=i
                END IF
            END DO    
            IF( i_min /= j ) THEN ! tauschen
                int_dummy=Resid_list(j)
                Resid_list(j)=Resid_list(i_min)
                Resid_list(i_min)=int_dummy
            END IF           
    END DO 
    
    DO i=3,k_max-1
        WRITE(*,*) Resid_list(i)
	IF ( Resid_list(i) == Resid_list(i+1) ) THEN
		WRITE(*,*) ' Fehler: Eine Resid darf nicht zweimal in der Nachbarschaftsliste auftreten!',Resid_list(i)
		WRITE(*,*) ' Pruefe die Eingabe. EXIT'
		STOP
	END IF
    END DO
END IF ! read_entire_box

    OPEN(UNIT=78,FILE=TRIM(gro_inputfile),STATUS='OLD',IOSTAT=ierror1)
    Read(78,*) dummyname                             !Einlesen des Infokopfes im File
    Read(78,*) Gesamtanzahl                          !Einlesen der Atomanzahl im File

    IF(DEBUG) THEN
    	write(*,*) 'Anzahl der Atome in .gro Datei ', Gesamtanzahl
    END IF
    ALLOCATE(xyz_box_all(Gesamtanzahl,3)) 
    ALLOCATE(atomsorte_all(Gesamtanzahl))

    DIPBI=.FALSE.
    P3HT=.FALSE.
    SAVE_OLD=.FALSE.
    istart=.FALSE.
    
    OPEN(UNIT=30,FILE=zielfile,STATUS='unknown',IOSTAT=ierror1,action='write',position="append")
    !Auswahl der Resid Start und Ende
    Resid_1=.false.
    dummy_koord_start_1(:)=0.0
    dummy_koord_ende_1(:)=0.0
    Resid_2=.false.
    dummy_koord_start_2(:)=0.0
    dummy_koord_ende_2(:)=0.0
    
    
        ! Erstelle die Matrix Data_collect, um die Nachbarschaftsliste der Resids zu ordnen und mehrer P3HT-Abschnitte zu einem MolekÃ¼l zusammenzufassen, die dann mit H-Atomen/C5H13-Ketten (DIPBI_KETTE=.true.) abgesÃ¤ttigt werden 
        !                1  2  3
        ! Data_collect:  l, i  k k+1 k+2 ...
        !
    ALLOCATE(Data_collect(k_max,34)) !N_neighbours_partial_charges+4 maximal k_max
    Data_collect=0 !(Anzahl der Residuen pro Molekuel, Anzahl Atome, Resid-Liste)     

    ALLOCATE(i_s_e(N_Mol,3)) ! Start und Endindex fuer Molekuele
    i_s_e(:,:)=0
    ALLOCATE(i_s_e_H(N_Mol,3)) ! Start und Endindex fuer Molekuele
    i_s_e_H(:,:)=0
    
    N_DIPBI=0
    N_P3HT=0
    N_Schwefel=0
      
    k=3  !k=...  Durchgehen der Resids in der Resid_liste von k bis k_max ! 1und 2 bleiben unverÃ¤ndert
    i=0  !Ermittelt Anzahl der Atome im Molekuel bzw. in den zusammenhaengenden Teilabschnitten
    l=1  ! Anzahl der Residues pro Molekuel l= Anzahl(k k+1 k+2 ...) 
    n=3  ! Durchzaehlen der Molekuele in Data_collect in der ersten Spalte; Am Ende ergibt sich die Molekuelanzahl
    i_old_1=0 ! Altes i um nur fuer Resid1 und Resid2 die Anzahl der Atome zu bestimmen.
    i_old_2=0
    last_residue_name=''
    N_Mol=0
    residue_number_old=0
    DO j=1,Gesamtanzahl ! Durchgehen der Zeilen in der .gro Datei
        Read(78,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror1) residue_number,residue_name,atomsorte_all(j),atom_number,&
                                                &xyz_box_all(j,1),xyz_box_all(j,2),xyz_box_all(j,3),v_x,v_y,v_z
        IF(ierror1 < 0) EXIT
        IF(ierror1 > 0) THEN
            WRITE(*,*) 'Fehler: Es ist eine Fehler beim Einlesen von ',TRIM(gro_inputfile),' aufgetreten.'
            WRITE(*,*) 'Fehler: Es_ist_eine_Fehler_beim_Einlesen_von ',TRIM(gro_inputfile),'_aufgetreten. '//TRIM(zielfile)
            WRITE(*,*) 'Beende Einlesen !'
            STOP
        END IF
        
        IF( residue_number==residue_number_old+1) THEN
            i_s_e(N_Mol,2)=j-1
            IF ( last_residue_name=='DIPBI') THEN
                i_s_e(N_Mol,3)=33
                N_DIPBI=N_DIPBI+1
                N_Schwefel=0
            ELSE
                i_s_e(N_Mol,3)=N_Schwefel
                N_Schwefel=0
                N_P3HT=N_P3HT+1
            END IF 
            N_Mol=N_Mol+1
            i_s_e(N_Mol,1)=j
            residue_number_old=residue_number
        ELSE IF (j==1) THEN
            i_s_e(1,1)=1
            N_Mol=N_Mol+1
            IF ( last_residue_name=='DIPBI') THEN
                i_s_e(1,3)=33
                N_DIPBI=N_DIPBI+1
            ELSE
                i_s_e(1,3)=N_Schwefel
                N_P3HT=N_P3HT+1
            END IF 
            residue_number_old=residue_number
        ELSE IF( j== Gesamtanzahl) THEN
            i_s_e(N_Mol,2)=Gesamtanzahl
            IF ( last_residue_name=='DIPBI') THEN
                i_s_e(N_Mol,3)=33
            ELSE
                i_s_e(N_Mol,3)=N_Schwefel
            END IF 
        END IF
        ! Schwefelatome zaehlen
        if (TRIM(adjustl(atomsorte_all(j)))=='S') N_Schwefel=N_Schwefel+1
        if (TRIM(adjustl(atomsorte_all(j)))=='S-S_R') N_Schwefel=N_Schwefel+1
        
      
        IF( (.NOT. Resid_1) .AND. residue_number == residue_number_1) THEN  ! Ende Abspeichern der Start- und End-Koordinaten fuer Resid1 und Resid2
            dummy_koord_start_1(:)=xyz_box_all(j,:)*10.0                      ! so lange bis Resid1 dabei war, wird geschaut, um start und Endkoordinaten zu erhalten
            THP(1)=residue_name ! Merken des residue Typs
            IF(last_residue_name=='THP32') THEN! Kettenanfang
                i_old_1=0
            ELSE ! Standard
                i_old_1=i
            END IF
            Resid_1=.true.
        ELSE IF( Resid_1 .AND. (residue_number == (residue_number_1+1) .OR.  j == Gesamtanzahl) ) THEN ! Naechste Resid => Ende ; j= Gesamtanzahl schreibt in Array, falls die Resid_1 die letzte Resid in der gro-file ist.
            dummy_koord_ende_1(:)=xyz_box_all(j,:)*10.0
            THP(3)=last_residue_name
            Data_collect(1,1)=1 ! Eine Resid fuer Molekuel
            IF( THP(3) == 'DIPBI') THEN
                Data_collect(1,2)=118 !DIPBI
            ELSE
                Data_collect(1,2)=i-i_old_1 !Anzahl der Atome im Molekuel P3HT
            END IF 
            Data_collect(1,3)=residue_number_1
            i_old_1=0
            Resid_1=.false.
	    IF(DEBUG) THEN
            	WRITE(*,*) 'Save Resid 1 :',Data_collect(1,1),Data_collect(1,2),Data_collect(1,3)
	    END IF ! DEBUG
	END IF ! Resid_1

        IF( (.NOT. Resid_2) .AND. residue_number == residue_number_2) THEN ! so lange bis Resid2 dabei war, wird geschaut, um start und Endkoordinaten zu erhalten
            dummy_koord_start_2(:)=xyz_box_all(j,:)*10.0 
            THP(2)=residue_name ! Merken des residue Typs
            IF(last_residue_name=='THP32') THEN! Kettenanfang
                i_old_2=0
            ELSE ! Standard
                i_old_2=i
            END IF
            Resid_2=.true.
        ELSE IF( Resid_2 .AND. ( residue_number == (residue_number_2+1)  .OR.  j == Gesamtanzahl) ) THEN ! Naechste Resid => Ende  j= Gesamtanzahl schreibt in Array, falls die Resid_2 die letzte Resid in der gro-file ist.
            dummy_koord_ende_2(:)=xyz_box_all(j,:)*10.0 
            THP(4)=last_residue_name ! Merken des residue Typs letztes
            Data_collect(2,1)=1 ! Eine Resid fuer Molekuel
            IF( THP(4) == 'DIPBI') THEN
                Data_collect(2,2)=118 !DIPBI
            ELSE
                Data_collect(2,2)=i-i_old_2 !Anzahl der Atome im Molekuel
            END IF 
            Data_collect(2,3)=residue_number_2
            
            i_old_2=0
            Resid_2=.false.
	    IF(DEBUG) THEN
            	WRITE(*,*) 'Save Resid 2 :',Data_collect(2,1),Data_collect(2,2),Data_collect(2,3)
	    END IF

        END IF ! Ende Abspeichern der Start- und End-Koordinaten fuer Resid1 und Resid2


        if ( residue_number == Resid_list(k) ) THEN ! Treffer
            i=i+1
            IF(i==1) THEN
                IF ('THP'==TRIM(residue_name(1:3))) THEN        
                    P3HT=.TRUE.
                    Molname="P3HT"
                    IF(P3MT) Molname="P3MT"
                END IF
                
                IF( TRIM(residue_name)=='DIPBI' ) THEN
                    DIPBI=.TRUE.
                    Molname="DIPBI"
                    IF(DIPBI_KETTE) Molname="DIPBI_KETTE"
                END IF                    
            END IF
            IF(istart) THEN ! Noch einmal Hochzaehlen von i, da es im vorherigen Durchlauf nicht durchgefÃ¼hrt wurde.
                i=i+1
                istart=.false.
            END IF
        ELSE IF ( residue_number == Resid_list(k+1) ) THEN ! Treffer neue Resid
            
            IF(i==0) THEN
                IF ('THP'==TRIM(residue_name(1:3))) THEN        
                    P3HT=.TRUE.
                    Molname="P3HT"
                    IF(P3MT) Molname="P3MT"
                END IF
                
                IF( TRIM(residue_name)=='DIPBI' ) THEN
                    DIPBI=.TRUE.
                    Molname="DIPBI"
                    IF(DIPBI_KETTE) Molname="DIPBI_KETTE"
                END IF                    
            END IF
            
            IF(DIPBI) THEN
		IF(DEBUG) THEN
                	WRITE(*,*) 'DIPBI: l=',l,'i=',i,'k=',k,'Resid_list(k)',Resid_list(k)
		END IF 
                SAVE_OLD=.true.
                istart=.true.
            ELSE IF (P3HT) THEN
		IF(DEBUG) THEN
            	WRITE(*,*) last_residue_name,' ',residue_name
		END IF ! DEBUG
                IF ((last_residue_name=='THP32') .AND. (residue_name=='THP1A')) THEN
                    SAVE_OLD=.true.
                    istart=.true.
		    IF(DEBUG) THEN
                    	WRITE(*,*) 'P3HT ENDE -Molekuel: l=',l,'i=',i,'k=',k,'Resid_list(k)',Resid_list(k)
		    END IF
                ELSE !IF( .NOT.((residue_number-1 == residue_number_1) .OR. (residue_number-1 == residue_number_2) .OR.  &
                     !        & (residue_number == residue_number_1) .OR. (residue_number == residue_number_2) ))THEN      ! Isoliert einzelne Resid 1 und Resid 2                       
                    Data_collect(n,2+l)=Resid_list(k)
		    IF(DEBUG) THEN
                    	WRITE(*,*) 'P3HT laenger: l=',l,'i=',i,'k=',k,'Resid_list(k)',Resid_list(k)
		    END IF
                    i=i+1
                    k=k+1
                    l=l+1
                END IF
            ELSE
                WRITE(*,*) 'Fehler: Keine Atomsorte ausgewaehlt DIPBI/P3HT/P3MT'
                WRITE(*,*) ' Andere Molekueltypen werden in der Implementierung momentan nicht unterstuetzt.'
                WRITE(30,*) 'Fehler: Keine_Atomsorte_ausgewaehlt_DIPBI/P3HT/P3MT '//TRIM(zielfile)
                STOP
            END IF
        ELSE IF ( residue_number == Resid_list(k)+1 .AND. i/=0) THEN
	    IF(DEBUG) THEN
            	WRITE(*,*) 'UNTEN: l=',l,'i=',i,'k=',k,'Resid_list(k)',Resid_list(k)
	    END IF
            SAVE_OLD=.true.        
        ELSE 
            SAVE_OLD=.false.
        END IF
        
        IF(j == Gesamtanzahl .AND. k < (k_max+1) ) THEN ! Speichern bei letztem Element
            SAVE_OLD=.true.         
        END IF 
        
        
        !!IF(k==(k_max+1) .AND. (residue_number > residue_number_2 .AND. residue_number > residue_number_1 ) ) EXIT
        
        IF(SAVE_OLD) THEN! (DIPBI .AND. (residue_number == lastresid+1)) .OR. (P3HT .AND. (residue_number .NE. Resid_list(k))) .OR. &
                                !&  ) THEN ! Neues Molekuel+Speichern
            Data_collect(n,1)=l !Anzahl der Residues pro Molekuel
            Data_collect(n,2)=i !Anzahl der Atome im Molekuel
            Data_collect(n,2+l)=Resid_list(k)
	    IF(DEBUG) THEN
            	WRITE(*,*) 'SAVE: l=',l,'i=',i,'k=',k,'Resid_list(k)',Resid_list(k)
		WRITE(*,*) (Data_collect(n,m),m=1,l+2)
	    END IF
             
                
            k=k+1
            n=n+1
            l=1
            i=0
            
            DIPBI=.FALSE.
            P3HT=.FALSE.
            SAVE_OLD=.FALSE.
        END IF
        last_residue_name=residue_name
        lastresid=residue_number
        IF (n==1 .and. j==Gesamtanzahl ) THEN
            write(*,*) ' Error: Es ist ein Fehler beim Einlesen ausgetreten'
            write(*,*) ' Fehler: Es_ist_ein_Fehler_beim_Einlesen_ausgetreten'//TRIM(zielfile)
            write(*,*) ' Vermutlich wurde nicht die entsprechende Resid-Nr gefunden',Resid_list(k)
            write(*,*) ' ENDE '
            STOP
        END IF  
    END DO
    CLOSE(78)
    

IF(DEBUG) THEN
 WRITE(*,*) 'ENDE SCHLEIFE START'
 WRITE(*,*) 'j=',j,N_Mol
 WRITE(*,*) 'k_max=',k_max
END IF 
  !DO i=1,k_max
  !     WRITE(*,*) (Data_collect(i,j),j=1,Data_collect(i,1)+2)
  !END DO      
    

! Ermittelt Anzahl der Molekuele
i_max=0
DO i =1,k_max
    IF( Data_collect(i,1)==0) THEN
        i_max=i-1
    END IF
    IF(i_max .NE. 0) EXIT 
    IF(i .EQ. k_max) i_max=k_max ! Wenn nur DIPBI dabei sind
END DO    
WRITE(*,*) 'Anzahl der Molekuele i_max=',i_max ! Anzahl der MolekÃ¼le/MolekÃ¼lfiles

IF( read_entire_box .eqv. .FALSE.) THEN
    DO i=1,i_max
        WRITE(*,*) (Data_collect(i,j),j=1,Data_collect(i,1)+2)
    END DO 
END IF  
  
! Test ob 2 Resids im gleichen Molekuel vorkommen!
    i_1=0
    i_2=0
  DO i=1,i_max
        DO j=1,(Data_collect(i,1)+2),1
            IF( Data_collect(i,j) == residue_number_1) THEN
                i_1=i
            END IF
            IF( Data_collect(i,j) == residue_number_2) THEN
                i_2=i
            END IF
        END DO !j
  END DO !i
  
  IF( i_1 == i_2) THEN !Abbruch, wenn Resid_1 und Resid_2 im gleichen Molekuell sind.
    WRITE(*,*) ' Resid_1 und Resid_2 sind im gleichen MolekÃ¼l.'
    WRITE(*,*) ' Fehler: Die beiden Molekuele Resid_1 und Resid_2 liegen im gleichen Molekuel:',residue_number_1,residue_number_2
    WRITE(*,*) ' Beende make_lambda_out'
  !  STOP
  END IF

IF(DEBUG) THEN
	! Dummy-Atome Start und Ende
	WRITE(*,*) ' Start und Ende Resid 1 / Resid 2 '
	WRITE(*,*) 'Resid1 Start: ',dummy_koord_start_1(:)
	WRITE(*,*) 'Resid1 Ende : ',dummy_koord_ende_1(:)
	WRITE(*,*) 'Resid2 Start: ',dummy_koord_start_2(:)
	WRITE(*,*) 'Resid2 Ende : ',dummy_koord_ende_2(:)
END IF

xyz_box_all=xyz_box_all*10.0  ! Umrechnung nm (.gro) to Ang (.xyz)

!! Set Resid 1 in das Boxzentrum
    
CALL read_coord_from_gro_resid(gro_inputfile,residue_number_1,atomsorteA,koordA,NAtomsA,Molname,&
                                &DIPBI,DIPBI_KETTE,P3HT,P3MT,PPDI,PPDI_KETTE,PBDT_TS1)
                                
IF ((DIPBI .AND. DIPBI_KETTE) .OR. (P3HT .AND. .NOT. P3MT)) THEN
        KETTE_1=.true.
ELSE
        KETTE_1=.false.
END IF  

CALL Massenschwerpunkt(atomsorteA,koordA,NAtomsA,schwerpunkt_1,KETTE_1)   
! Set Vektors
   CALL Set_mol_box_vector_2(schwerpunkt_1,dummy_koord_start_1,x_box,y_box,z_box)
   IF(DEBUG) THEN
   	WRITE(*,*) 'Resid1 Start: ',dummy_koord_start_1(1),dummy_koord_start_1(2),dummy_koord_start_1(3)
   END IF
   CALL Set_mol_box_vector_2(schwerpunkt_1,dummy_koord_ende_1,x_box,y_box,z_box)
   IF(DEBUG) THEN
   	WRITE(*,*) 'Resid1 Ende: ',dummy_koord_ende_1(1),dummy_koord_ende_1(2),dummy_koord_ende_1(3)  
   END IF
   CALL Set_mol_box_vector_2(schwerpunkt_1,dummy_koord_start_2,x_box,y_box,z_box)
   IF(DEBUG) THEN   
	WRITE(*,*) 'Resid2 Start: ',dummy_koord_start_2(1),dummy_koord_start_2(2),dummy_koord_start_2(3)
   END IF
   CALL Set_mol_box_vector_2(schwerpunkt_1,dummy_koord_ende_2,x_box,y_box,z_box)
   IF(DEBUG) THEN
   	WRITE(*,*) 'Resid2 Ende: ',dummy_koord_ende_2(1),dummy_koord_ende_2(2),dummy_koord_ende_2(3) 
 
   ! Verschiebe Koordinaten der ganzen Box 
   WRITE(*,*) ' Verschiebung der Molekuele so, dass alle Molekuele um schwerpunkt_1 als Zentrum der Box verschoben werden.'
   WRITE(*,*) ' schwerpunkt_1= ',schwerpunkt_1(:)
   END IF ! DEBUG
DO i=1,N_mol
    m=(i_s_e(i,2)-i_s_e(i,1)+1)! Anzahl der Atome in Molekuel
    CALL Set_mol_box_2(atomsorteA(1),schwerpunkt_1,1,atomsorte_all(i_s_e(i,1):i_s_e(i,2)),&
                        &xyz_box_all(i_s_e(i,1):i_s_e(i,2),1:3),m,x_box,y_box,z_box,KETTE_1) 
END DO


    IF ( Allocated(atomsorteA))  deallocate(atomsorteA)
    IF ( Allocated(koordA))  deallocate(koordA)
 IF(DEBUG) THEN
    WRITE(*,*) ' ***** '
    WRITE(*,*) 'First:', atomsorte_all(1),xyz_box_all(1,:)
    WRITE(*,*) 'i_s_e(1,:): ',i_s_e(1,:)
    WRITE(*,*) 'i_s_e(2,:): ',i_s_e(2,:)
    WRITE(*,*) 'i_s_e(3,:): ',i_s_e(3,:)
    WRITE(*,*) 'Last :', atomsorte_all(Gesamtanzahl),xyz_box_all(Gesamtanzahl,:)
    WRITE(*,*) 'i_s_e(last/2,:): ',i_s_e((N_Mol/2),:)
    WRITE(*,*) 'i_s_e(last-1,:): ',i_s_e(N_Mol-1,:)
    WRITE(*,*) 'i_s_e(last,:): ',i_s_e(N_Mol,:)
    WRITE(*,*) 'N_mol: ',N_mol
    WRITE(*,*) 'k_max: ',k_max
    WRITE(*,*) 'i_max: ',i_max
    WRITE(*,*) '  Data_collect(i_max-2,1) :',Data_collect(i_max-2,1),Data_collect(i_max-2,2),Data_collect(i_max-2,3)
    WRITE(*,*) '  Data_collect(i_max-1,1) :',Data_collect(i_max-1,1),Data_collect(i_max-1,2),Data_collect(i_max-1,3)
    WRITE(*,*) '  Data_collect(i_max,1) :',Data_collect(i_max,1),Data_collect(i_max,2),Data_collect(i_max,3)
    WRITE(*,*) '  Data_collect(i_max+1,1) :',Data_collect(i_max+1,1)


   !CALL make_coord_to_xyz(atomsorte_all,xyz_box_all,Gesamtanzahl,ziel) ! Erstelle xyz-file - Array atomsorte_all ist hier noch mit den alten Abkuerzungen
    
    WRITE(*,*) 'N_DIPBI:',N_DIPBI
    WRITE(*,*) 'N_P3HT:',N_P3HT
    WRITE(*,*) 'Gesamtanzahl',Gesamtanzahl
    WRITE(*,*) ' ****DIPBI****'
    i=1
    WRITE(*,*) 'i=',i,i_s_e(i,1),i_s_e(i,2),i_s_e(i,3)
    WRITE(*,*) 'i=',i,atomsorte_all(i_s_e(i,1)),xyz_box_all(i_s_e(i,1),:)
    WRITE(*,*) 'i=',i,atomsorte_all(i_s_e(i,2)),xyz_box_all(i_s_e(i,2),:)
    
    WRITE(*,*) ' ** last DIPBI **'
    i=1248
    WRITE(*,*) 'i=',i,i_s_e(i,1),i_s_e(i,2),i_s_e(i,3)
    WRITE(*,*) 'i=',i,atomsorte_all(i_s_e(i,1)),xyz_box_all(i_s_e(i,1),:)
    WRITE(*,*) 'i=',i,atomsorte_all(i_s_e(i,2)),xyz_box_all(i_s_e(i,2),:)
    
    WRITE(*,*) ' ****P3HT****'
    i=1249
    WRITE(*,*) 'i=',i,i_s_e(i,1),i_s_e(i,2),i_s_e(i,3)
    WRITE(*,*) 'i=',i,atomsorte_all(i_s_e(i,1)),xyz_box_all(i_s_e(i,1),:)
    WRITE(*,*) 'i=',i,atomsorte_all(i_s_e(i,2)),xyz_box_all(i_s_e(i,2),:)
 END IF ! DEBUG   
    
! Berechnungen fuer ganze Box mit Anfuergen der H-Atome 
IF( read_entire_box .and. entire_box_H_to_xyz ) THEN
    ! Bestimmer die Anzahl der Atome mit H-Atomen
    Gesamtanzahl_H=0

    IF( read_entire_box ) THEN ! Wenn in der gro nur DIPBI mit 32mern sind.
        IF(DIPBI_KETTE) THEN
            Gesamtanzahl_H=Gesamtanzahl_H+N_DIPBI*218
        ELSE
            Gesamtanzahl_H=Gesamtanzahl_H+N_DIPBI*86 ! Anzahl mit Methylgruppen
        END IF
    
        IF(P3MT) THEN
            Gesamtanzahl_H=Gesamtanzahl_H+N_P3HT*322  ! 32mer mit Methylgruppen
        ELSE
            Gesamtanzahl_H=Gesamtanzahl_H+N_P3HT*802 ! Komplette Ketten
        END IF
    ELSE ! Abhaengigkeit von der Kettenlaenge der Segmente
            IF(DIPBI_KETTE) THEN
                Gesamtanzahl_H=Gesamtanzahl_H+N_DIPBI*218
            ELSE
                Gesamtanzahl_H=Gesamtanzahl_H+N_DIPBI*86 ! Anzahl mit Methylgruppen
            END IF
            
            IF(P3MT) THEN
                DO i=(N_DIPBI+1),N_Mol
                    Gesamtanzahl_H=Gesamtanzahl_H+i_s_e(i,3)*10+2  
                END DO 
            ELSE
                DO i=(N_DIPBI+1),N_Mol
                    Gesamtanzahl_H=Gesamtanzahl_H+i_s_e(i,3)*25+2 ! Komplette Ketten
                END DO
            END IF
    END IF ! read_entire_box - Anzahl der Atome mit H bestimmen
    
    WRITE(*,*) 'Gesamtanzahl_H:',Gesamtanzahl_H
    ALLOCATE(xyz_box_all_H(Gesamtanzahl_H,4))
    ALLOCATE(atomsorte_box_all_H(Gesamtanzahl_H))
    !!i_s_e(N_Molekuele,2)     !! Array i_Start_Ende:: N_Molekuele  //1=startindex 2=endindex(letzter_vom_molekueel) 3=Typ  zum Speichern der Start und Endindizes
    
    N_Molekuele=N_DIPBI+N_P3HT
    WRITE(*,*) 'N_Molekuele:',N_Molekuele
    k=0
    DO i=1,N_Molekuele 
        ! DIPBI-P3HT Auswahl
        DIPBI=.false.
        P3HT=.false.
        
        IF( i_s_e(i,3)==33) THEN
            DIPBI=.true.
        ELSE IF (i_s_e(i,3) < 33) THEN
            P3HT=.true.
        END IF
    
    
        IF(DIPBI) THEN ! H-Anfuegen
            IF(DIPBI_KETTE) THEN
                    !WRITE(*,*) 'vor h_diPBI_kette'
                    !WRITE(*,*) 'i=',i,i_s_e(i,1),i_s_e(i,2)
                   ! WRITE(*,*) 'i=',i,atomsorte_all(i_s_e(i,1)),xyz_box_all(i_s_e(i,1),:)
                call h_diPBI_kette(atomsorte_all(i_s_e(i,1):i_s_e(i,2)),xyz_box_all(i_s_e(i,1):i_s_e(i,2),1:3),atomsorte1H,&
                                   &koord1H,(i_s_e(i,2)-i_s_e(i,1)+1),molA)
                      !WRITE(*,*) 'Nach i=',i,atomsorte(i_s_e(i,1)),xyz_box_all(i_s_e(i,1),:)
            ELSE
                !WRITE(*,*) 'vor h_diPBI'
                call h_diPBI(atomsorte_all(i_s_e(i,1):i_s_e(i,2)),xyz_box_all(i_s_e(i,1):i_s_e(i,2),1:3),atomsorte1H,&
                             &koord1H,(i_s_e(i,2)-i_s_e(i,1)+1),molA)
                !WRITE(*,*) 'vor nach h_diPBI'
            END IF
        ELSE IF (P3HT) THEN
            IF(P3MT) THEN
		IF(DEBUG) THEN
                        WRITE(*,*) 'vor h_P3MT',i,i_s_e(i,1),i_s_e(i,2),i_s_e(i,3)
		END IF ! DEBUG
                CALL h_P3MT(atomsorte_all(i_s_e(i,1):i_s_e(i,2)),xyz_box_all(i_s_e(i,1):i_s_e(i,2),1:3),atomsorte1H,&
                            &koord1H,(i_s_e(i,2)-i_s_e(i,1)+1),molA)
		IF(DEBUG) THEN
                         WRITE(*,*) 'nach h_P3MT'
		END IF
            ELSE
                !WRITE(*,*) 'vor h_P3HT'
                    !WRITE(*,*) 'i=',i,i_s_e(i,1),i_s_e(i,2)
                    !WRITE(*,*) 'i=',i,atomsorte_all(i_s_e(i,1)),xyz_box_all(i_s_e(i,1),:)
                CALL h_P3HT(atomsorte_all(i_s_e(i,1):i_s_e(i,2)),xyz_box_all(i_s_e(i,1):i_s_e(i,2),1:3),atomsorte1H,&
                            &koord1H,(i_s_e(i,2)-i_s_e(i,1)+1),molA) 
            END IF
        ELSE    
            write(*,*) 'Error: Keine Bearbeitung der H-Atome'
            STOP
        END IF
        MAXATM_H=size(atomsorte1H)
 
        DO j=1,MAXATM_H ! Uebergabe der H-bestueckten Atome 

            atomsorte_box_all_H(k+j)=atomsorte1H(j)
            xyz_box_all_H(k+j,1:3)=koord1H(j,1:3)
        END DO
            !IF( i < 1251 .OR. i==N_Molekuele .OR.i==N_Molekuele-1  ) THEN  
            !    WRITE(*,*) k+1, atomsorte_box_all_H(k+1),xyz_box_all_H(k+1,:)
            !END IF
            DEALLOCATE(atomsorte1H,koord1H)
            i_s_e_h(j,1)=k ! Start_Molekuelindex_mit_H-Atomen
            k=k+MAXATM_H
            i_s_e_h(j,2)=k ! Ende_Molekuelindex_mit_H-Atomen
            i_s_e_h(j,3)=i_s_e(j,3) ! Anzahl Schwefel in Kette - 33=DIPBI
    END DO ! i ueber alle Molekuele 

    !DEALLOCATE(xyz_box_all)
    !DEALLOCATE(atomsorte_all)
    k=0
    WRITE(*,*) atomsorte_box_all_H(k+1),xyz_box_all_H(k+1,:)
    k=1
    WRITE(*,*) atomsorte_box_all_H(k+1),xyz_box_all_H(k+1,:)
    k=2
    WRITE(*,*) atomsorte_box_all_H(k+1),xyz_box_all_H(k+1,:)
    
    
    
    ziel=TRIM(ziel)//'_H'
    CALL make_coord_to_xyz(atomsorte_box_all_H,xyz_box_all_H(:,1:3),Gesamtanzahl_H,ziel)
    STOP 
END IF ! Calculate entire Box mit H-Atomen zu xyz -- wird fuer lambda_out_berechnung uebersprungen
 



!!
!! Start partial charges
!! mit Umgebung aus den Resids der Nachbarn!
!!
ALLOCATE(NSchwefel_P3HT(2,4))
NSchwefel_P3HT(:,:)=0

Bashline='/bin/cat ' ! String fuer die AusfÃ¼hrung 
!!xyz_Bashline=    TRIM(xyz_Bashline)//' tail -n +3 '//TRIM(l_in_oniom_foldername)//'/'//TRIM(list(i))//'.xyz >> '//TRIM(xyz_file)//' ;'

! Konvention 1.) Resid_1 geladen 
! Konvention 2.) Resid_2 geladen
! Konvention 1.) Resid_1 neutral
! Konvention 2.) Resid_2 neutral
        xyz_q_file_charged=TRIM(xyz_q_pfad)//'xyz_q_'//TRIM(partial_charge_methode)//'_'//TRIM(charge_name)//&
                &'_'//TRIM(type1)//'_'//TRIM(str(Resid_list(1)))//'_G'//TRIM(str(trajstep))//'.xyz'
        Bashline=TRIM(Bashline)//' '//TRIM(xyz_q_file_charged)
        xyz_q_file_charged=TRIM(xyz_q_pfad)//'xyz_q_'//TRIM(partial_charge_methode)//'_'//TRIM(charge_name)//&
                &'_'//TRIM(type2)//'_'//TRIM(str(Resid_list(2)))//'_G'//TRIM(str(trajstep))//'.xyz'
        Bashline=TRIM(Bashline)//' '//TRIM(xyz_q_file_charged) 
! Resid_1 und Resid_2 neutral        
        xyz_q_file=TRIM(xyz_q_pfad)//'xyz_q_'//TRIM(partial_charge_methode)//'_n'//&
                &'_'//TRIM(type1)//'_'//TRIM(str(Resid_list(1)))//'_G'//TRIM(str(trajstep))//'.xyz'
        Bashline=TRIM(Bashline)//' '//TRIM(xyz_q_file)  
        xyz_q_file=TRIM(xyz_q_pfad)//'xyz_q_'//TRIM(partial_charge_methode)//'_n'//&
                &'_'//TRIM(type2)//'_'//TRIM(str(Resid_list(2)))//'_G'//TRIM(str(trajstep))//'.xyz' 
        Bashline=TRIM(Bashline)//' '//TRIM(xyz_q_file)  

MAXATM_All=0
DO i=1,i_max !Anzahl der Molekuele in Data_collect
    IF( i == 1) THEN ! geladen 
        xyz_q_file=TRIM(xyz_q_pfad)//'xyz_q_'//TRIM(partial_charge_methode)//'_n'//&
                &'_'//TRIM(type1)//'_'//TRIM(str(Resid_list(1)))//'_G'//TRIM(str(trajstep))//'.xyz'
        xyz_q_file_charged=TRIM(xyz_q_pfad)//'xyz_q_'//TRIM(partial_charge_methode)//'_'//TRIM(charge_name)//&
                &'_'//TRIM(type1)//'_'//TRIM(str(Resid_list(1)))//'_G'//TRIM(str(trajstep))//'.xyz'
    ELSE IF( i==2 ) THEN !Resid_2 geladen
        xyz_q_file=TRIM(xyz_q_pfad)//'xyz_q_'//TRIM(partial_charge_methode)//'_n'//&
                &'_'//TRIM(type2)//'_'//TRIM(str(Resid_list(2)))//'_G'//TRIM(str(trajstep))//'.xyz' 
        xyz_q_file_charged=TRIM(xyz_q_pfad)//'xyz_q_'//TRIM(partial_charge_methode)//'_'//TRIM(charge_name)//&
                &'_'//TRIM(type2)//'_'//TRIM(str(Resid_list(2)))//'_G'//TRIM(str(trajstep))//'.xyz'
    ELSE !neutral
        dummyname=''
        DO j=1,Data_collect(i,1)
            IF( Data_collect(i,j+2)==residue_number_1) THEN
                dummyname=TRIM(dummyname)//'_ohne'//str(Data_collect(i,j+2))
            ELSE IF( Data_collect(i,j+2)==residue_number_2) THEN
                dummyname=TRIM(dummyname)//'_ohne'//str(Data_collect(i,j+2))
            ELSE
                dummyname=TRIM(dummyname)//'_'//str(Data_collect(i,j+2))
            END IF
        END DO 
        xyz_q_file=TRIM(xyz_q_pfad)//'xyz_q_'//TRIM(partial_charge_methode)//'_n'//&
                    &TRIM(dummyname)//'_G'//TRIM(str(trajstep))//'.xyz'  
        Bashline=TRIM(Bashline)//' '//TRIM(xyz_q_file)                    
    END IF

    !inquire(file=TRIM(xyz_q_file),exist=xyz_q_vorhanden) ! Ausgeschaltet sodass immer neue Dateien erzeugt werden.
    xyz_q_vorhanden=.false.
    IF( .NOT. xyz_q_vorhanden .OR. i <= 2 ) THEN ! Existiert Datei noch nicht oder i=1 (Referenzgeometrie zu haben, fuer Verschiebung mit Set_mol_box
        DIPBI=.false.
        P3HT=.false.
        Resid_1=.false.
        Resid_2=.false.
        molA=''
        N_Atoms_mol=0
        ALLOCATE(koord(Data_collect(i,2),3)) ! Sammelarray fuer alle Koordinaten in einem MolekÃ¼l
        ALLOCATE(atomsorte(Data_collect(i,2)))
        !WRITE(*,*) i,Data_collect(i,3)
        !WRITE(*,*) i,Data_collect(i,1)
        DO l=1,Data_collect(i,1) ! Einlesen und Zusammenfassen der Resids in atomsorteA koordA
            

            ind=Data_collect(i,l+2)-start_index+1 ! +1 Verschiebt den Index ind passend fuer start_index=0
            !WRITE(*,*) 'ind=',ind,Data_collect(i,l+2),start_index,Data_collect(1,3)
            !WRITE(*,*) 'ind, i_s_e(ind,3), i_s_e(ind,2), i_s_e(ind,1), i_s_e(ind,2)-i_s_e(ind,1)+1'
            !WRITE(*,*) ind,i_s_e(ind,3),i_s_e(ind,2),i_s_e(ind,1),i_s_e(ind,2)-i_s_e(ind,1)+1
            NAtomsA=i_s_e(ind,2)-i_s_e(ind,1)+1
            ALLOCATE(atomsorteA(NAtomsA))
            ALLOCATE(koordA(NAtomsA,3))
            DO m=1,NAtomsA
                atomsorteA(m)=atomsorte_all(i_s_e(ind,1)+m-1)
                koordA(m,:)=xyz_box_all(i_s_e(ind,1)+m-1,:)
                !WRITE(*,*) atomsorteA(m),koordA(m,:)
            END DO

            !! Resid aus Data_collect(l+2,1) mit INDEX i_s_e zu atomsorteA,koordA
            !WRITE(*,*) ' i_s_e(ind,3)= ',i_s_e(ind,3)
            IF( i_s_e(ind,3)==33) THEN
                IF(DIPBI_KETTE) THEN
                    Molname="DIPBI_KETTE"
                    DIPBI=.true.
                ELSE
                    Molname='DIPBI'
                    DIPBI=.true.
                END IF
            ELSE
                IF(P3MT) THEN
                    Molname='P3MT'
                    P3HT=.true.
                ELSE
                    Molname='P3HT'
                    P3HT=.true.
                END IF
            END IF
            !WRITE(*,*) " 1 name ",TRIM(Molname)," DIPBI: ", DIPBI," P3HT: ",P3HT
            !CALL read_coord_from_gro_resid(gro_inputfile,Data_collect(i,l+2),atomsorteA,koordA,NAtomsA,&
                                            !&Molname,DIPBI,DIPBI_KETTE,P3HT,P3MT,PPDI,PPDI_KETTE,PBDT_TS1) 
            molA=TRIM(Molname)//'_'//TRIM(str(Data_collect(i,l+2)))
            DO j=1,NAtomsA
                atomsorte(N_Atoms_mol+j)=atomsorteA(j)
                koord(N_Atoms_mol+j,:)=koordA(j,:)
            END DO
            
            !WRITE(*,*) " 2 name ",TRIM(Molname)," DIPBI: ", DIPBI," P3HT: ",P3HT
            
            N_Atoms_mol=N_Atoms_mol+NAtomsA
            MAXATM_All=MAXATM_All+NAtomsA
            IF( Data_collect(i,l+2)==residue_number_1) THEN ! Resids dabei?
                Resid_1=.true.
            ELSE IF ( Data_collect(i,l+2)==residue_number_2) THEN 
                Resid_2=.true.
            END IF
            
            !WRITE(*,*) " 3 name ",TRIM(Molname)," DIPBI: ", DIPBI," P3HT: ",P3HT
            
            IF ( Allocated(atomsorteA))  deallocate(atomsorteA)
            IF ( Allocated(koordA))  deallocate(koordA)
            
            !WRITE(*,*) " 4 name",TRIM(Molname)," DIPBI: ", DIPBI," P3HT: ",P3HT
        END DO
        
        !WRITE(*,*) " 5 name ",TRIM(Molname)," DIPBI: ", DIPBI," P3HT: ",P3HT
        
        IF(DIPBI) THEN
            IF(DIPBI_KETTE) THEN
                call h_diPBI_kette(atomsorte,koord,atomsorte1H,koord1H,N_Atoms_mol,molA)
            ELSE
                call h_diPBI(atomsorte,koord,atomsorte1H,koord1H,N_Atoms_mol,molA)
            END IF
            DEALLOCATE(koord)
            DEALLOCATE(atomsorte)
        ELSE 
            IF (P3HT) THEN
               IF(P3MT) THEN
                  CALL h_P3MT(atomsorte,koord,atomsorte1H,koord1H,N_Atoms_mol,molA)
               ELSE
                  CALL h_P3HT(atomsorte,koord,atomsorte1H,koord1H,N_Atoms_mol,molA)   
               END IF
               DEALLOCATE(koord)
               DEALLOCATE(atomsorte)
            ELSE    
                write(*,*) 'Error: Keine Bearbeitung der H-Atome'
            END IF
        END IF
        MAXATM_H=size(atomsorte1H)

        !DO m=1,size(atomsorte1H)
         !   WRITE(*,*) 'Coord j=',j, atomsorte1H(m),koord1H(m,:)
        !END DO 

        S_Ringe=''
        IF(P3HT) THEN ! Zaehle Anzahl der Schwefelatome
            
            N_Schwefel=0
            ! Erstelle NSchwefel_P3HT
            DO j=1,MAXATM_H ! j-Schleife ueber Atome in koord1H 
                if (TRIM(adjustl(atomsorte1H(j)))=='S') N_Schwefel=N_Schwefel+1
                if (TRIM(adjustl(atomsorte1H(j)))=='S-S_R') N_Schwefel=N_Schwefel+1
                IF ( j==MAXATM_H) THEN
                    S_Ringe='_R'//TRIM(str(N_Schwefel))
                END IF
               !!IF(Resid_1) THEN
               !!    IF( getDistance(dummy_koord_start_1(:),koord1H(j,:)) < 1.0E-3 ) THEN
               !!        NSchwefel_P3HT(1,1)=N_Schwefel
               !!    ELSE IF ( getDistance(dummy_koord_ende_1(:),koord1H(j,:)) < 1.0E-3) THEN
               !!        NSchwefel_P3HT(1,2)=N_Schwefel-NSchwefel_P3HT(1,1)
               !!    END IF
               !!    IF ( j==MAXATM_H) THEN
               !!        IF( NSchwefel_P3HT(1,2) == 0 ) THEN ! Wenn Ende des Moekueles/der ges Kette, da dummy_koord_ende leer ist, wenn kein weiteres Kettenglied folgt
               !!            NSchwefel_P3HT(1,2)=N_Schwefel-NSchwefel_P3HT(1,1)
               !!            NSchwefel_P3HT(1,3)=0
               !!            NSchwefel_P3HT(1,4)=NSchwefel_P3HT(1,2)+NSchwefel_P3HT(1,1)
               !!        ELSE
               !!            NSchwefel_P3HT(1,3)=N_Schwefel-NSchwefel_P3HT(1,2)-NSchwefel_P3HT(1,1)
               !!            NSchwefel_P3HT(1,4)=N_Schwefel
               !!        END IF
               !!        S_Ringe='_R'//TRIM(str(NSchwefel_P3HT(1,2)))
               !!    END IF
               !!END IF !Resid_1_da
               !!                
               !!IF(Resid_2) THEN
               !!    IF( getDistance(dummy_koord_start_2(:),koord1H(j,:)) < 1.0E-3) THEN
               !!        NSchwefel_P3HT(2,1)=N_Schwefel
               !!    ELSE IF (getDistance(dummy_koord_ende_2(:),koord1H(j,:)) < 1.0E-3) THEN
               !!        NSchwefel_P3HT(2,2)=N_Schwefel-NSchwefel_P3HT(2,1)
               !!    END IF
               !!    IF ( j==MAXATM_H) THEN
               !!        IF( NSchwefel_P3HT(2,2)==0 ) THEN ! Wenn Ende des Moekueles/der ges Kette
               !!            NSchwefel_P3HT(2,2)=N_Schwefel-NSchwefel_P3HT(2,1) !Endwert
               !!            NSchwefel_P3HT(2,3)=0
               !!            NSchwefel_P3HT(2,4)=NSchwefel_P3HT(2,2)+NSchwefel_P3HT(2,1)
               !!        ELSE
               !!            NSchwefel_P3HT(2,3)=N_Schwefel-NSchwefel_P3HT(2,2)-NSchwefel_P3HT(2,1)
               !!            NSchwefel_P3HT(2,4)=N_Schwefel
               !!        END IF
               !!        S_Ringe='_R'//TRIM(str(NSchwefel_P3HT(2,2)))
               !!    END IF
               !!END IF !Resid_2_da
                
            END DO ! j-Schleife ueber Atome in koord1H
        !WRITE(*,*) 'N_Schwefel:',N_Schwefel,' von Mol:',TRIM(molA)  
            !WRITE(*,*) 'NSchwefel_P3HT'
            !DO k=1,4
            !        WRITE(*,*) (NSchwefel_P3HT(j,k),j=1,2)
            !END DO 
        END IF ! P3HT
        
        IF( i <= 2) THEN ! geladen  ! Hole Daten fuer die Partialladungen
            q_file_charge= './partial_charges/q_'//TRIM(partial_charge_methode)//'_'//TRIM(charge_name)//'_'//TRIM(Molname)& 
                    &//TRIM(S_Ringe)//'.dat'  
            ALLOCATE(partial_charges(MAXATM_H))
            CALL Read_part_charges_q_file(q_file_charge,partial_charges,MAXATM_H,trajstep,zielfile,foldername)
            
            q_file_n= './partial_charges/q_'//TRIM(partial_charge_methode)//'_n_'//TRIM(Molname)& 
                    &//TRIM(S_Ringe)//'.dat' 
            ALLOCATE(partial_charges_n(MAXATM_H))
            CALL Read_part_charges_q_file(q_file_n,partial_charges_n,MAXATM_H,trajstep,zielfile,foldername)
            !! Erstellen eines neuen xyz_q_files in den Ordner 


            IF(DIPBI) THEN ! Ohne Modifizierung  ! j_start und j_ende festlegen und sum_of_partial_charges_into_heavy_atoms
                j_start=1
                j_ende=MAXATM_H
            ELSE IF(THP(i) == 'THP1A' .AND. THP(i+2) == 'THP32') THEN 
                j_start=1
                j_ende=MAXATM_H
            ELSE IF(THP(i) == 'THP1A') THEN 
                j_start=1
                j_ende=MAXATM_H-1
                partial_charges(MAXATM_H-6)=partial_charges(MAXATM_H-6)+partial_charges(MAXATM_H) ! Sum H- partial charge into C-Atom
                partial_charges_n(MAXATM_H-6)=partial_charges_n(MAXATM_H-6)+partial_charges_n(MAXATM_H) ! Sum H- partial charge into C-Atom
            ELSE IF(THP(i+2) == 'THP32') THEN 
                j_start=2
                j_ende=MAXATM_H
                partial_charges(2)=partial_charges(2)+partial_charges(1)
                partial_charges_n(2)=partial_charges_n(2)+partial_charges_n(1)
            ELSE IF(P3HT) THEN ! Kettenmitte
                j_start=2
                j_ende=MAXATM_H-1                
                partial_charges(2)=partial_charges(2)+partial_charges(1)
                partial_charges(MAXATM_H-6)=partial_charges(MAXATM_H-6)+partial_charges(MAXATM_H)
                partial_charges_n(2)=partial_charges_n(2)+partial_charges_n(1)
                partial_charges_n(MAXATM_H-6)=partial_charges_n(MAXATM_H-6)+partial_charges_n(MAXATM_H)
            END IF ! j_start und j_ende festlegen und sum_of_partial_charges_into_heavy_atoms
            WRITE(*,*) 'Use:',TRIM(xyz_q_file_charged),' and ',TRIM(xyz_q_file)
            
            OPEN(UNIT=80,FILE=TRIM(xyz_q_file_charged),STATUS='REPLACE',IOSTAT=ierror1)
            Write(80,*) (j_ende-j_start+1)
            Write(80,*) 'Coordinates with '//TRIM(Molname)//' '//TRIM(S_Ringe)//' '//TRIM(molA)//' calculated '//&
                        & TRIM(partial_charge_methode)//' in '//TRIM(q_file_charge)
                        
            OPEN(UNIT=81,FILE=TRIM(xyz_q_file),STATUS='REPLACE',IOSTAT=ierror1)
            Write(81,*) (j_ende-j_start+1)
            Write(81,*) 'Coordinates with '//TRIM(Molname)//' '//TRIM(S_Ringe)//' '//TRIM(molA)//' calculated '//&
                        &' neutral in '//TRIM(q_file_n)
                        
            DO j= j_start,j_ende, 1 ! Print coordinates to file
             write(80,form1) ADJUSTL(atomsorte1H(j)),koord1H(j,1),koord1H(j,2),koord1H(j,3),partial_charges(j)
             write(81,form1) ADJUSTL(atomsorte1H(j)),koord1H(j,1),koord1H(j,2),koord1H(j,3),partial_charges_n(j)
            END DO
            CLOSE(81)
            CLOSE(80)
            DEALLOCATE(partial_charges,partial_charges_n)    
         
        ELSE ! i<2  ! Hole Daten fuer die Partialladungen fuer Resid 1 und Resid 2
        ! i > 2 -Alle neutralen MolekÃ¼le
        !neutral
            IF(P3HT .AND. (Resid_1 .OR. Resid_2) ) THEN 
                q_file_n= './partial_charges/q_'//TRIM(partial_charge_methode)//'_n_'//TRIM(Molname)//TRIM(S_Ringe)//'.dat'
                inquire(file=TRIM(q_file_n),exist=q_file_vorhanden)
                IF (q_file_vorhanden) THEN
                    ALLOCATE(partial_charges(MAXATM_H))
                    CALL Read_part_charges_q_file(q_file_n,partial_charges,MAXATM_H,trajstep,zielfile,foldername)
                    OPEN(UNIT=80,FILE=TRIM(xyz_q_file),STATUS='REPLACE',IOSTAT=ierror1)
                    Write(80,*) 'Anzahl_der_Atome'
                    Write(80,*) 'Coordinates with '//TRIM(Molname)//' '//TRIM(S_Ringe)//' '//TRIM(molA)//' calculated '//&
                                & 'neutral in '//TRIM(q_file_n)
                    print_xyz_q_1=.true.
		    print_xyz_q_2=.true.
                    counter=0 ! Anzahl der Atome
                    !WRITE(*,*) dummy_koord_start_1(:)
                    !WRITE(*,*) koord1H(j,:)
                    !WRITE(*,*) getDistance(dummy_koord_start_1(:),koord1H(j,:))
                    DO j= 1, MAXATM_H, 1 
                            IF( getDistance(dummy_koord_start_1(:),koord1H(j,:)) < 1.0E-3) print_xyz_q_1=.false.
                            IF( getDistance(dummy_koord_ende_1(:),koord1H(j,:)) < 1.0E-3) print_xyz_q_1=.true.
                            IF( getDistance(dummy_koord_start_2(:),koord1H(j,:)) < 1.0E-3) print_xyz_q_2=.false.
                            IF( getDistance(dummy_koord_ende_2(:),koord1H(j,:)) < 1.0E-3) print_xyz_q_2=.true.
                            IF(print_xyz_q_1 .AND. print_xyz_q_2) THEN
                     write(80,form1) ADJUSTL(atomsorte1H(j)),koord1H(j,1),koord1H(j,2),koord1H(j,3),partial_charges(j)
                                counter=counter+1
                            ELSE 
				IF(DEBUG) THEN
                                	WRITE(*,*) 'NICHT GEDRUCKT'
                    			write(*,form1) atomsorte1H(j),koord1H(j,1),koord1H(j,2),koord1H(j,3),partial_charges(j)
				END IF !DEBUG
                            END IF
                    END DO
                    dummyname='sed -i s/Anzahl_der_Atome/'//TRIM(str(counter))//'/g '//TRIM(xyz_q_file)
                    WRITE(*,*) TRIM(dummyname),'   NAtome: ',counter
                    CALL execute_command_line(TRIM(dummyname)) ! Anpassen der Atomanzahl in xyz_q_file
                    
                    CLOSE(80)
                    DEALLOCATE(partial_charges)
                END IF 
            ELSE
                q_file_n= './partial_charges/q_'//TRIM(partial_charge_methode)//'_n_'//TRIM(Molname)//TRIM(S_Ringe)//'.dat'
                inquire(file=TRIM(q_file_n),exist=q_file_vorhanden)
                IF (q_file_vorhanden) THEN
                    ALLOCATE(partial_charges(MAXATM_H))
                    CALL Read_part_charges_q_file(q_file_n,partial_charges,MAXATM_H,trajstep,zielfile,foldername)
        
                    !! Erstellen eines neuen xyz_q_files in den Ordner 
                    OPEN(UNIT=80,FILE=TRIM(xyz_q_file),STATUS='REPLACE',IOSTAT=ierror1)
                    Write(80,*) MAXATM_H
                    Write(80,*) 'Coordinates with '//TRIM(Molname)//' '//TRIM(S_Ringe)//' '//TRIM(molA)//' calculated '//&
                                & 'neutral in '//TRIM(q_file_n)
                    DO j= 1, MAXATM_H, 1
                     write(80,form1) ADJUSTL(atomsorte1H(j)),koord1H(j,1),koord1H(j,2),koord1H(j,3),partial_charges(j)
                    END DO
                    CLOSE(80)
                    
                    DEALLOCATE(partial_charges)
                ELSE
                    WRITE(*,*) 'Fehler: Die Datei mit Partialladungen (q_file) ist nicht vorhanden:',TRIM(q_file_n)
                    WRITE(30,*) 'Fehler: Partialladungen_(q_file)_nicht_vorhanden_',TRIM(q_file_n),' ',TRIM(foldername)
                    CLOSE(30)
                    WRITE(*,*) 'ENDE'
                    STOP
                END IF !q_file_vorhande
            END IF ! Resid1 oder Resid2 da
        END IF ! Auswahl i<2 und else neutrale mit i>2 
    END IF ! xyz_q nicht vorhanden
END DO


!call calc_lambda_out(r_cut,Anzahl_Geometrien,N_coord_ges,NAtoms_list,Start_index,pair_xyz_q)



WRITE(*,*)TRIM(foldername),' ',TRIM(zielfile)
! Ausfuehrung Berechnung von lambda
Bashline=TRIM(Bashline)//' > xyz_q_'//TRIM(partial_charge_methode)//'_'//TRIM(charge_name)//'_'//TRIM(str(Resid_list(1)))//&
                                        &'_'//TRIM(str(Resid_list(2)))//'_G'//TRIM(str(trajstep))//'.xyz '


!! Ausfuehrung des cat-Befehles indem der String aufgrund der Laenge in eine Datei geschrieben wird und dort ausgefuehrt wird.
OPEN(unit=90,file='line_to_be_executed_'//TRIM(lio),status="replace")
Write(90,*) TRIM(bashline)
CLOSE(90)
call execute_command_line("chmod +x line_to_be_executed_"//TRIM(lio))
bashline="./line_to_be_executed_"//TRIM(lio)
WRITE(*,*) TRIM(Bashline)
CALL execute_command_line(TRIM(Bashline),wait=.true.,exitstat=i,cmdstat=j,cmdmsg=q_file_n)
!write(*,*) "exitstat =", i
!write(*,*) "cmdstat =", j
!write(*,*) "cmdmsg = ", TRIM(q_file_n)
bashline="rm line_to_be_executed_"//TRIM(lio)
call execute_command_line(TRIM(bashline))


Bashline='./lambda_out_und_dE_out_aus_xyz_q_file xyz_q_'//TRIM(partial_charge_methode)//'_'//TRIM(charge_name)//'_'//&
        &TRIM(str(Resid_list(1)))//'_'//TRIM(str(Resid_list(2)))//'_G'//TRIM(str(trajstep))//'.xyz '//TRIM(str(i_max+2))//' '//&
        &TRIM(Real2str(r_cut))//' '//TRIM(foldername)//' '//TRIM(zielfile)
WRITE(*,*) TRIM(Bashline)
CALL execute_command_line(TRIM(Bashline))

!#### Ordner xyz_q_file => Ordner fuer xyz_q-Dateien
xyz_q_file='./xyz_q_Dateien/lambda_out_xyz_q_pairs/'
inquire(file=TRIM(xyz_q_file),exist=xyz_q_vorhanden)

IF(xyz_q_vorhanden) THEN ! Variable lio als dummy-Variable eingefuehrt, damit bei mehrfachem Aufruf nicht durch das andere Programm die Variable verwendet wird.
  xyz_Bashline='i=xyz_q_'//TRIM(partial_charge_methode)//'_'//TRIM(charge_name)//'_'//TRIM(str(Resid_list(1)))//'_'//&
  &TRIM(str(Resid_list(2)))//'_G'//TRIM(str(trajstep))//".xyz ; grep -v Coord $i | awk 'NF > 3'  > Q1_"//TRIM(lio)//&
  &".xyz ; lines=$(wc -l Q1_"//TRIM(lio)//'.xyz) ;  echo ${lines% *} > All_$i ; echo " " >> All_$i ; cat Q1_'//TRIM(lio)//&
  &'.xyz >> All_$i ; rm Q1_'//TRIM(lio)//'.xyz ; mv All_$i '//TRIM(xyz_q_file)
  CALL execute_command_line(TRIM(xyz_Bashline))
  WRITE(*,*) TRIM(xyz_Bashline)
  
  Bashline=' mv xyz_q_'//TRIM(partial_charge_methode)//'_'//TRIM(charge_name)//'_'//TRIM(str(Resid_list(1)))//'_'//&
                &TRIM(str(Resid_list(2)))//'_G'//TRIM(str(trajstep))//'.xyz '//TRIM(xyz_q_file)
  CALL execute_command_line(TRIM(Bashline))
  WRITE(*,*) TRIM(Bashline)
ELSE
    WRITE(*,*) 'Der Ordner existiert nicht: ',TRIM(xyz_q_file)
END IF

WRITE(*,*) 'ENDE lambda_out'
CLOSE(30)
DEALLOCATE(NSchwefel_P3HT)
 
END Subroutine ! make_lambda_out_entire_box


SUBROUTINE nearest_neighbours_to_pairlist(neighboursfile,untereGrenze,obereGrenze,residue_offset,Pair_list,sum_pairs)
	use small_functions
IMPLICIT NONE
CHARACTER(500), INTENT(IN) :: neighboursfile
REAL, INTENT(IN) :: obereGrenze,untereGrenze ! Auswahlgrenzen fuer den Abstand der Paare
INTEGER, INTENT(IN) ::residue_offset
INTEGER, ALLOCATABLE, Dimension(:,:), INTENT(OUT)::Pair_list
INTEGER :: sum_pairs
CHARACTER(50) :: form2,form3
REAL, ALLOCATABLE, DIMENSION(:,:)::Daten
REAL, DIMENSION(13)::dummyarray
INTEGER::i,j,k,NR,i_min,ierror1,N_COM,N_Zen,dummy,MolA,MolB
LOGICAL::New_pair
REAL::A3,A5,A7,A9,A11,A13

N_COM=Read_rows_file2(neighboursfile)/2 !Anzahl der Zentren der Ceter of Masses COM

ALLOCATE(Daten(N_COM,13))
ALLOCATE(Pair_list(2,N_COM*6)) !groeßere Anzahl
Daten=0
Pair_list=0
N_Zen=32

form2='(1X,1I6,1X,1I6,1X,7F15.12,2X)'
form3='(1X,1I6,1X,1I6,1X,7I6)'
! Einlesen der Daten aus neighboursfile

OPEN(UNIT=11,FILE=TRIM(neighboursfile),STATUS='OLD',IOSTAT=ierror1)

DO i=1,N_COM
   READ(11,*,IOSTAT=ierror1) NR,dummy,A3,A5,A7,A9,A11,A13
   IF(ierror1 < 0) EXIT
   IF(ierror1 > 0) THEN
        WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(neighboursfile),' aufgetreten.'
        WRITE(*,*) 'Beende Einlesen !'
        STOP
    END IF
         ! Beginnen mit 1 anstatt mit 0
    Daten(i,1)=NR+residue_offset
    Daten(i,3)=A3
    Daten(i,5)=A5
    Daten(i,7)=A7
    Daten(i,9)=A9
    Daten(i,11)=A11
    Daten(i,13)=A13
    READ(11,*,IOSTAT=ierror1) dummy,dummy,Daten(i,2),Daten(i,4),Daten(i,6),Daten(i,8),Daten(i,10),Daten(i,12)
    IF(ierror1 < 0) EXIT
    IF(ierror1 > 0) THEN
        WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(neighboursfile),' aufgetreten.'
        WRITE(*,*) 'Beende Einlesen !'
        STOP
    END IF
    Daten(i,2)=Daten(i,2)+residue_offset
    Daten(i,4)=Daten(i,4)+residue_offset
    Daten(i,6)=Daten(i,6)+residue_offset
    Daten(i,8)=Daten(i,8)+residue_offset
    Daten(i,10)=Daten(i,10)+residue_offset
    Daten(i,12)=Daten(i,12)+residue_offset
 
END DO
CLOSE(11)

WRITE(*,*) ' Erste Daten'
NR=1 
Write(*,*) INT(Daten(NR,1)),dummy,Daten(NR,3),Daten(NR,5),Daten(NR,7),Daten(NR,9),Daten(NR,11),Daten(NR,13)
WRITE(*,*) INT(Daten(NR,1)),INT(Daten(NR,1)),INT(Daten(NR,2)),INT(Daten(NR,4)),INT(Daten(NR,6)), & 
         & INT(Daten(NR,8)),INT(Daten(NR,10)),INT(Daten(NR,12))

do j=1,N_COM-1 ! Sortierung: Durchgehen der Atome in Molekuel     
    i_min=j
        DO i=j+1,N_COM ! Durchgehen von B          
           IF( Daten(i,1) < Daten(i_min,1) ) THEN
               i_min=i
           END IF
        END DO    
        IF( i_min /= j ) THEN ! tauschen
               dummyarray(:)=Daten(j,:) 
               Daten(j,:)=Daten(i_min,:) 
               Daten(i_min,:)=dummyarray(:)
        END IF           
END DO

sum_pairs=0

write(*,*) 'N_Zen', N_Zen
write(*,*) 'untereGrenze =',untereGrenze
write(*,*) 'obereGrenze =',obereGrenze
!OPEN(UNIT=12,FILE=TRIM(ziel)//'.dat',STATUS='REPLACE',IOSTAT=ierror1)
!write(*,*) ' Erzeugte Datei:',TRIM(ziel),'.dat'
do i=1,N_COM
    
    DO j=1,6
        if( untereGrenze <= Daten(i,2*j+1) .AND. Daten(i,2*j+1) <= obereGrenze ) THEN    
            MolA=Daten(i,1)/N_Zen
            MolB=Daten(i,2*j)/N_Zen
                     !
             IF( (abs(MolA) .NE. abs(MolB))) THEN 
                                             !Sortierung der Groeße nach; doppelte Paare und Nachbarn im gleichen Ring werden nicht mit beruecksichtigt
                                             ! Naechste Nachbarn mit +/-1 index werden write(*,*) Daten(i,2*j),MolA,MolB    auch aussortiert
             
             New_pair=.true.
             If(sum_pairs > 0) THEN
                 DO k=1,sum_pairs
                     IF(Pair_list(1,k)==MolA .AND. Pair_list(2,k)==MolB) THEN 
                         New_pair=.false.  
                     END IF
                     IF(Pair_list(1,k)==MolB .AND. Pair_list(2,k)==MolA) THEn
                         New_pair=.false.
                     END IF
                 END DO
             END IF
             
             IF( New_pair ) THEN
                 !WRITE(*,*) New_pair,molA,molB!,Pair_list(k,4),Pair_list(k,5)    
                 sum_pairs=sum_pairs+1
                 Pair_list(1,sum_pairs)=MolA
                 Pair_list(2,sum_pairs)=MolB 
                    write(*,*) Daten(i,2*j),MolA,Pair_list(1,sum_pairs),MolB,Pair_list(2,sum_pairs)
             END IF    
          
             IF( sum_pairs == N_COM*10-1) THEN
                     Write(*,*) 'Error: Zu wenig Speicher allokiert fuer Array Pair_list: ENDE'
                     STOP
             END iF
            END iF
        END IF
    END DO
EnD DO

DO k=1,sum_pairs
    Write(*,*) Pair_list(1,k),Pair_list(2,k)
END DO

DEALLOCATE(Daten)
END SUBROUTINE nearest_neighbours_to_pairlist

SUBROUTINE nearest_neighbours_to_pairlist_mixed_DIBPI_P3HT(gro_inputfile,neighboursfile,&
                        untereGrenze,obereGrenze,residue_offset,Pair_list,sum_pairs)
use small_functions
IMPLICIT NONE
CHARACTER(500), INTENT(IN) :: gro_inputfile,neighboursfile
REAL, INTENT(IN) :: obereGrenze,untereGrenze ! Auswahlgrenzen fuer den Abstand der Paare
INTEGER, INTENT(IN) ::residue_offset
INTEGER, ALLOCATABLE, Dimension(:,:), INTENT(OUT)::Pair_list
INTEGER :: sum_pairs
CHARACTER(500) ::ziel
CHARACTER(50) :: form2,form3
REAL, ALLOCATABLE, DIMENSION(:,:)::Daten
REAL, DIMENSION(13)::dummyarray
INTEGER::i,j,k,NR,i_min,ierror1,N_COM,N_Zen,dummy,MolA,MolB,DiPBI_offset
LOGICAL::New_pair,DIPBI_1,DIPBI_2,P3HT_1,P3HT_2
REAL::A3,A5,A7,A9,A11,A13

N_COM=Read_rows_file2(neighboursfile)/2 !Anzahl der Zentren der Ceter of Masses COM

ALLOCATE(Daten(N_COM,13))
ALLOCATE(Pair_list(2,N_COM*6)) !groeßere Anzahl
Daten=0
Pair_list=0
N_Zen=32          ! Anzahl der COM-Zentren pro P3HT-Kette
DiPBI_offset=1280 !Anzahl bis zum letzent DIPBI
ziel='pairlist_'//TRIM(gro_inputfile)

form2='(1X,1I6,1X,1I6,1X,7F15.12,2X)'
form3='(1X,1I6,1X,1I6,1X,7I6)'
! Einlesen der Daten aus neighboursfile

OPEN(UNIT=11,FILE=TRIM(neighboursfile),STATUS='OLD',IOSTAT=ierror1)

DO i=1,N_COM
   READ(11,*,IOSTAT=ierror1) NR,dummy,A3,A5,A7,A9,A11,A13
   IF(ierror1 < 0) EXIT
   IF(ierror1 > 0) THEN
        WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(neighboursfile),' aufgetreten.'
        WRITE(*,*) 'Beende Einlesen !'
        STOP
    END IF
         ! Beginnen mit 1 anstatt mit 0
    Daten(i,1)=NR+residue_offset
    Daten(i,3)=A3
    Daten(i,5)=A5
    Daten(i,7)=A7
    Daten(i,9)=A9
    Daten(i,11)=A11
    Daten(i,13)=A13
    READ(11,*,IOSTAT=ierror1) dummy,dummy,Daten(i,2),Daten(i,4),Daten(i,6),Daten(i,8),Daten(i,10),Daten(i,12)
    IF(ierror1 < 0) EXIT
    IF(ierror1 > 0) THEN
        WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(neighboursfile),' aufgetreten.'
        WRITE(*,*) 'Beende Einlesen !'
        STOP
    END IF
    Daten(i,2)=Daten(i,2)+residue_offset
    Daten(i,4)=Daten(i,4)+residue_offset
    Daten(i,6)=Daten(i,6)+residue_offset
    Daten(i,8)=Daten(i,8)+residue_offset
    Daten(i,10)=Daten(i,10)+residue_offset
    Daten(i,12)=Daten(i,12)+residue_offset
 
END DO
CLOSE(11)

WRITE(*,*) ' Erste Daten'
NR=1 
Write(*,*) INT(Daten(NR,1)),dummy,Daten(NR,3),Daten(NR,5),Daten(NR,7),Daten(NR,9),Daten(NR,11),Daten(NR,13)
WRITE(*,*) INT(Daten(NR,1)),INT(Daten(NR,1)),INT(Daten(NR,2)),INT(Daten(NR,4)),INT(Daten(NR,6)), & 
         & INT(Daten(NR,8)),INT(Daten(NR,10)),INT(Daten(NR,12))

do j=1,N_COM-1 ! Sortierung: Durchgehen der Atome in Molekuel     
    i_min=j
        DO i=j+1,N_COM ! Durchgehen von B          
           IF( Daten(i,1) < Daten(i_min,1) ) THEN
               i_min=i
           END IF
        END DO    
        IF( i_min /= j ) THEN ! tauschen
               dummyarray(:)=Daten(j,:) 
               Daten(j,:)=Daten(i_min,:) 
               Daten(i_min,:)=dummyarray(:)
        END IF           
END DO

sum_pairs=0

write(*,*) 'N_Zen', N_Zen
write(*,*) 'untereGrenze =',untereGrenze
write(*,*) 'obereGrenze =',obereGrenze
write(*,*) 'residue_offset =',residue_offset
write(*,*)  'DiPBI_offset',  DiPBI_offset
OPEN(UNIT=125,FILE=TRIM(ziel)//'.dat',STATUS='REPLACE',IOSTAT=ierror1)
write(*,*) ' Erzeugte Datei:',TRIM(ziel),'.dat'
do i=1,N_COM
    
    DO j=1,6
        DIPBI_1=.false.
        DIPBI_2=.false.
        P3HT_1=.false.
        P3HT_2=.false.
        if( untereGrenze <= Daten(i,2*j+1) .AND. Daten(i,2*j+1) <= obereGrenze ) THEN    
            IF( Daten(i,1) > DiPBI_offset ) THEN !P3HT
                MolA=(INT(Daten(i,1))-DiPBI_offset)/N_Zen+DiPBI_offset+1
                P3HT_1=.true.
            ELSE !DIPBI
                MolA=INT(Daten(i,1))
                DIPBI_1=.true.
            END IF
            
            IF( Daten(i,2*j) > DiPBI_offset ) THEN !P3HT
                MolB=(Daten(i,2*j)-DiPBI_offset)/N_Zen+DiPBI_offset+1
                P3HT_2=.true.
            ELSE
                MolB=Daten(i,2*j)
                DIPBI_2=.true.
            END IF 
            
            IF( (abs(MolA) .NE. abs(MolB))) THEN 
                                             !Sortierung der Groeße nach; doppelte Paare und Nachbarn im gleichen Ring werden nicht mit beruecksichtigt
                                             ! Naechste Nachbarn mit +/-1 index werden write(*,*) Daten(i,2*j),MolA,MolB    auch aussortiert
                !IF( (P3HT_1 .AND. DIPBI_2) .OR. (DIPBI_1 .AND. P3HT_2) ) THEN! Auswahl mixed Pair
                IF( DIPBI_1 .AND. DIPBI_2 ) THEN ! Auswahl nur DIPBI  
                    New_pair=.true.
                    If(sum_pairs > 0) THEN
                        DO k=1,sum_pairs
                            IF(Pair_list(1,k)==MolA .AND. Pair_list(2,k)==MolB) THEN 
                                New_pair=.false.  
                            END IF
                            IF(Pair_list(1,k)==MolB .AND. Pair_list(2,k)==MolA) THEn
                                New_pair=.false.
                            END IF
                        END DO
                    END IF
                    
                    IF( New_pair ) THEN
                        sum_pairs=sum_pairs+1
                        Pair_list(1,sum_pairs)=MolA
                        Pair_list(2,sum_pairs)=MolB                         
                    END IF    
                
                    IF( sum_pairs == N_COM*10-1) THEN
                            Write(*,*) 'Zu wenig Speicher allokiert fuer Array Pair_list: ENDE'
                            STOP
                    END iF
                END IF
            END iF
        END IF
    END DO
EnD DO

 WRITE(*,*) 'Die Anzahl der DIPBI-P3HT-Paare ist',sum_pairs
DO k=1,sum_pairs
    Write(125,*) Pair_list(1,k),Pair_list(2,k)
END DO

CLOSE(125)
DEALLOCATE(Daten)   
END SUBROUTINE nearest_neighbours_to_pairlist_mixed_DIBPI_P3HT



SUBROUTINE read_coord_from_gro_resid(gro_inputfile,resid,atomsorteA,koordA,MAXATM,Molname,&
                                &DIPBI,DIPBI_KETTE,P3HT,P3MT,PPDI,PPDI_KETTE,PBDT_TS1)
! SUBROUTINE zum Einlesen von Molekuelkoordinaten aus einer gro-Datei
! bei gegebener der resid
		use small_functions
		IMPLICIT NONE
		INTEGER, INTENT(OUT)::MAXATM
		Real, ALLOCATABLE, Dimension(:,:), INTENT(INOUT) :: koordA
		Character(5), ALLOCATABLE, Dimension(:), INTENT(INOUT) :: atomsorteA
		Character(500), INTENT (OUT) :: Molname
		Character(500), INTENT (IN) :: gro_inputfile
		INTEGER,       INTENT (IN) :: resid
		LOGICAL, INTENT (INOUT) ::DIPBI,DIPBI_KETTE,P3HT,P3MT,PPDI,PPDI_KETTE,PBDT_TS1
		LOGICAL :: PBDT_TS1_KETTE=.false.,HDI_KETTE=.false.
		Character(500)             ::dummyname
		Character(5) :: residue_name
		Character(5) :: atom
		INTEGER::i,j,ierror,residue_number,atom_number,Gesamtanzahl
		REAL::x,y,z,v_x,v_y,v_z

		IF (file_exists(gro_inputfile)) THEN
			OPEN(UNIT=78,FILE=TRIM(gro_inputfile),STATUS='OLD',IOSTAT=ierror)
			Read(78,*) dummyname                             !Einlesen des Infokopfes im File
			Read(78,*) Gesamtanzahl                          !Einlesen der Atomanzahl im File
			!write(*,*) 'Anzahl der Atome in .gro Datei ', Gesamtanzahl
		ELSE
			WRITE(*,*) "Files *.gro does not exist: "//TRIM(gro_inputfile)
			STOP "EXIT"
		END IF


		i=0
		DO j=1,Gesamtanzahl
			Read(78,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) residue_number,residue_name,atom,atom_number,x,y,z,v_x,v_y,v_z
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(gro_inputfile),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				STOP
			END IF
			if ( residue_number == resid ) THEN
				!WRITE(*,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) residue_number,residue_name,atom,atom_number,x,y,z,v_x,v_y,v_z
				i=i+1
				IF(i==1) THEN
					IF ('THP'==TRIM(residue_name(1:3))) THEN        
						P3HT=.TRUE.
						Molname="P3HT"
						IF(P3MT) Molname="P3MT"
					ELSE IF ( TRIM(residue_name)=='DIPBI' ) THEN
						DIPBI=.TRUE.
						Molname="DIPBI"
						IF(DIPBI_KETTE) Molname="DIPBI_KETTE"
					ELSE IF ( 'PPDI'==TRIM(residue_name(1:4)) ) THEN
						PPDI=.TRUE.
						Molname='PPDI'
						if (PPDI_KETTE) Molname="PPDI_KETTE"
						WRITE(*,*) 'PPDI ist da'
					ELSE IF ( '8poly'==TRIM(residue_name(1:5)) ) THEN
						PBDT_TS1=.TRUE.
						Molname='PBDT-TS1'
						if (PBDT_TS1_KETTE) Molname="PBDT-TS1_KETTE"
						WRITE(*,*) 'PBDT-TS1 ist da'
					ELSE IF ( 'HDI__'==TRIM(residue_name(1:5)) ) THEN
						Molname='HDI'
					ELSE IF ( 'HDI_K'==TRIM(residue_name(1:5)) ) THEN
						Molname='HDI'
						if (HDI_KETTE) Molname="HDI_KETTE"
					ELSE IF ( 'TDI__'==TRIM(residue_name(1:5)) ) THEN
						Molname='TDI'
					ELSE IF ( 'PtK2K'==TRIM(residue_name(1:5)) ) THEN
						Molname='PtK2K'  
					ELSE IF ( 'PtK3K'==TRIM(residue_name(1:5)) ) THEN
						Molname='PtK3K'
					ELSE IF ( 'mCP__'==TRIM(residue_name(1:5)) ) THEN
						Molname='mCP'                   
					ELSE IF ( 'NBP__'==TRIM(residue_name(1:5)) ) THEN
						Molname='NBP'
					ELSE
						Molname=TRIM(residue_name)             
					END IF
				END IF
			END IF
			IF (i==0 .and. j==Gesamtanzahl ) THEN
			   write(*,*) ' Error: Es ist ein Fehler beim Einlesen ausgetreten'
			   write(*,*) ' Vermutlich wurde nicht die entsprechende Resid-Nr gefunden',resid
			   write(*,*) ' ENDE '
			   STOP
			END IF  
		END DO
		CLOSE(78)

		MAXATM=i !Anzahl der Atomzentren in gro mit der resid

		CALL read_coord_from_gro_resid_to_array(atomsorteA,koordA,MAXATM,gro_inputfile,resid)

END SUBROUTINE read_coord_from_gro_resid

SUBROUTINE read_coord_from_gro_resid_to_array(atomsorteA,koordA,MAXATM,gro_inputfile,resid)
	!! Einlesen aus der .gro Datei und Umrechnung in .xyz Format (Ang)
	INTEGER, INTENT (IN) :: MAXATM,resid
	Character(5), ALLOCATABLE, Dimension(:), INTENT(OUT) :: atomsorteA
	Real, ALLOCATABLE, Dimension(:,:), INTENT(OUT) :: koordA
	Character(500), INTENT (IN) :: gro_inputfile
	Character(500)              ::dummyname
	Character(5) :: residue_name
	Character(5) :: atom
	INTEGER::i,j,ierror,residue_number,atom_number,Gesamtanzahl
	REAL::x,y,z,v_x,v_y,v_z

	! Einlesen
	OPEN(UNIT=79,FILE=TRIM(gro_inputfile),STATUS='OLD',IOSTAT=ierror)
	READ(79,*) dummyname                             !Einlesen des Infokopfes im File
	READ(79,*) Gesamtanzahl                          !Einlesen der Atomanzahl im File

	ALLOCATE(atomsorteA(MAXATM))
	ALLOCATE(koordA(MAXATM,3))
	i=0
	DO j=1,Gesamtanzahl
		READ(79,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) residue_number,residue_name,atom,atom_number,x,y,z,v_x,v_y,v_z
		IF(ierror < 0) EXIT
		IF(ierror > 0) THEN
			WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(gro_inputfile),' aufgetreten.'
			WRITE(*,*) 'Beende Einlesen !'
			STOP
		END IF
		IF (residue_number == resid ) THEN
			i=i+1
			atomsorteA(i)=atom
			koordA(i,1)=x
			koordA(i,2)=y
			koordA(i,3)=z
		END IF
		IF( i == MAXATM ) EXIT
		IF (i==0 .and. j==Gesamtanzahl ) THEN
		   WRITE(*,*) ' Error: Es ist ein Fehler beim Einlesen ausgetreten'
		   WRITE(*,*) ' Vermutlich wurde nicht die entsprechende Resid-Nr gefunden',resid
		   WRITE(*,*) ' ENDE '
		   STOP
	   END IF  
	END DO
	CLOSE(79)

	koordA(:,:)=koordA(:,:)*10.0 ! Umrechnung von nm (.gro-Format) nach Angstroem (.xyz-Format)

END SUBROUTINE read_coord_from_gro_resid_to_array


SUBROUTINE Set_mol_box(atomsorteA,koordA,NAtomsA,atomsorteB,koordB,NAtomsB,x_box,y_box,z_box,KETTE)
	!! Subroutine um Koordinaten zusammenzulegen, indem der Schwerpunkt beider Molekuele berechnet wird, und bei Bedarf um die Boxgroeße zurueckgespiegelt wird.
	use small_functions
	IMPLICIT NONE
	Integer, INTENT (IN):: NAtomsA,NAtomsB
	REAL,    INTENT (IN):: x_box,y_box,z_box
	Real, Dimension(NAtomsA,3), INTENT (INOUT)   :: koordA
	Real, Dimension(NAtomsB,3), INTENT (INOUT)   :: koordB
	Character(5), Dimension(NAtomsA), INTENT(IN) :: atomsorteA
	Character(5), Dimension(NAtomsB), INTENT(IN) :: atomsorteB
	Integer :: i
	Real, Dimension(3)::schwerpunktA,schwerpunktB
	LOGICAL::KETTE

	CALL Massenschwerpunkt(atomsorteA,koordA,NAtomsA,schwerpunktA,KETTE) 
	CALL Massenschwerpunkt(atomsorteB,koordB,NAtomsB,schwerpunktB,KETTE) 

	! Ruecktrafo, wenn die Schwerpunkte weiter getrennt liegen, als die halbe Boxlaenge.
		IF( schwerpunktB(1)-schwerpunktA(1) .GE. x_box/2) THEN
			DO i=1,NAtomsB
				koordB(i,1)=koordB(i,1)-x_box
			END DO
		ELSE IF ( schwerpunktB(1)-schwerpunktA(1) .LE. -x_box/2) THEN
			DO i=1,NAtomsB
				koordB(i,1)=koordB(i,1)+x_box
			END DO   
		END IF
		
		IF( schwerpunktB(2)-schwerpunktA(2) .GE. y_box/2) THEN
			DO i=1,NAtomsB
				koordB(i,2)=koordB(i,2)-y_box
			END DO
		ELSE IF( schwerpunktB(2)-schwerpunktA(2) .LE. -y_box/2) THEN
			DO i=1,NAtomsB
				koordB(i,2)=koordB(i,2)+y_box
			END DO 
		END IF    
		
		IF( schwerpunktB(3)-schwerpunktA(3) .GE. z_box/2) THEN
			DO i=1,NAtomsB
				koordB(i,3)=koordB(i,3)-z_box
			END DO
		ELSE IF( schwerpunktB(3)-schwerpunktA(3) .LE. -z_box/2) THEN
			DO i=1,NAtomsB
				koordB(i,3)=koordB(i,3)+z_box
			END DO   
		END IF

	CALL Massenschwerpunkt(atomsorteB,koordB,NAtomsB,schwerpunktB,KETTE)

	IF( abs(getDistance(schwerpunktA,schwerpunktB)) .GE. abs(x_box+y_box+z_box)/6 ) THEN
		WRITE(*,*) ' Fehler in Set_mol_box: Die Schwerpunkte der beiden Molekuele liegen wahrscheinlich zu'
		WRITE(*,*) ' weit voneinander entfernt!  '
		!WRITE(*,*) 'Das Programm wird beendet'
		!STOP
	END IF

END SUBROUTINE Set_mol_box


SUBROUTINE Set_mol_box_vector(koordA,koordB,x_box,y_box,z_box)
	!! Subroutine um Koordinaten zusammenzulegen, indem dem KoordA das Zentrum angibt, und wenn der Abstand zu koordB zu groß ist,
	!! So wird koordB in der jeweiligen Richtung (x,y,z) um eine Boxlaenge(x_box,y_box,z_box) verschoben.
	!! Zentrum: koordA
	!! verschiebbare Atome: koordB
	!! Dummyarray: koordC
	use small_functions
	IMPLICIT NONE
	REAL,    INTENT (IN):: x_box,y_box,z_box
	Real, Dimension(3), INTENT (IN)   :: koordA
	Real, Dimension(3), INTENT (INOUT)   :: koordB
	Real, Dimension(3)::koordC

	koordC=koordB

	! Ruecktrafo, wenn die Schwerpunkte weiter getrennt liegen, als die halbe Boxlaenge.
		IF( koordB(1)-koordA(1) .GE. x_box/2) THEN
				koordB(1)=koordB(1)-x_box
		ELSE IF ( koordB(1)-koordA(1) .LE. -x_box/2) THEN
				koordB(1)=koordB(1)+x_box
		END IF
		
		IF( koordB(2)-koordA(2) .GE. y_box/2) THEN
				koordB(2)=koordB(2)-y_box
		ELSE IF( koordB(2)-koordA(2) .LE. -y_box/2) THEN
				koordB(2)=koordB(2)+y_box
		END IF    
		
		IF( koordB(3)-koordA(3) .GE. z_box/2) THEN
				koordB(3)=koordB(3)-z_box
		ELSE IF( koordB(3)-koordA(3) .LE. -z_box/2) THEN
				koordB(3)=koordB(3)+z_box 
		END IF


	IF( abs(getDistance(koordA,koordB)) .GE. abs(x_box+y_box+z_box)/6 ) THEN
		WRITE(*,*) ' Fehler in Set_mol_box_vector: Die Koordinaten der beiden Molekuele liegen wahrscheinlich zu'
		WRITE(*,*) ' weit voneinander entfernt! Nach Verschiebung  '
		WRITE(*,*) ' Koordinaten 1. Vektor :',koordA(1),koordA(2),koordA(3)
		WRITE(*,*) ' Koordinaten 2. Vektor :',koordB(1),koordB(2),koordB(3)
		WRITE(*,*) ' Koordinaten vor Verschiebung 2. Vektor :',koordC(1),koordC(2),koordC(3)
		!WRITE(*,*) 'Das Programm wird beendet'
		!STOP
	END IF

END SUBROUTINE Set_mol_box_vector


SUBROUTINE Set_mol_box_2(atomsorteA,koordA,NAtomsA,atomsorteB,koordB,NAtomsB,x_box,y_box,z_box,KETTE)
		!! Subroutine um Koordinaten zu verschieben, sodass die Box um den Schwerpunkt von A an der Postition 
		!! von x_box/2 y_box/2 z_box/2 verschoben wird 
		!! A gilt als Referenz, dessen Schwerpunkt genommen wird
		!! B wird verschoben.
		!! Um das Molekuel A zu verschieben, muessen koordB=koordA gesetzt sein.
		use small_functions
		IMPLICIT NONE
		Integer, INTENT (IN):: NAtomsA,NAtomsB
		REAL,    INTENT (IN):: x_box,y_box,z_box
		Real, Dimension(NAtomsA,3), INTENT (INOUT)   :: koordA
		Real, Dimension(NAtomsB,3), INTENT (INOUT)   :: koordB
		Character(5), Dimension(NAtomsA), INTENT(IN) :: atomsorteA
		Character(5), Dimension(NAtomsB), INTENT(IN) :: atomsorteB
		Integer :: i
		Real, Dimension(3)::schwerpunktA,schwerpunktB,DeltaX
		LOGICAL,INTENT(IN)::KETTE
		IF ( NAtomsA > 1) THEN
			CALL Massenschwerpunkt(atomsorteA,koordA,NAtomsA,schwerpunktA,KETTE) 
		ELSE IF (NAtomsA == 1) THEN
			schwerpunktA(:)=koordA(1,:)
		END IF
		CALL Massenschwerpunkt(atomsorteB,koordB,NAtomsB,schwerpunktB,KETTE)

			DeltaX(1)=x_box*0.5-schwerpunktA(1)
			DeltaX(2)=y_box*0.5-schwerpunktA(2)
			DeltaX(3)=z_box*0.5-schwerpunktA(3)

		!WRITE(*,*) 'DeltaX', DeltaX(:)
		!WRITE(*,*) 'Schwerpunkt A', schwerpunktA(:)
		!WRITE(*,*) 'Schwerpunkt B', schwerpunktB(:)

		! Ruecktrafo, wenn die Schwerpunkte weiter getrennt liegen, als die halbe Boxlaenge.
			IF( schwerpunktB(1)+DeltaX(1) .GE. x_box) THEN
				DO i=1,NAtomsB
					koordB(i,1)=koordB(i,1)+DeltaX(1)-x_box
				END DO
			ELSE IF ( schwerpunktB(1)+DeltaX(1) .LE. 0) THEN
				do i=1,NAtomsB
					koordB(i,1)=koordB(i,1)+DeltaX(1)+x_box
				END DO   
			ELSE
				do i=1,NAtomsB
					koordB(i,1)=koordB(i,1)+DeltaX(1)
				END DO   
			END IF
			
			IF( schwerpunktB(2)+DeltaX(2) .GE. y_box) THEN
				do i=1,NAtomsB
					koordB(i,2)=koordB(i,2)+DeltaX(2)-y_box
				END DO
			ELSE IF ( schwerpunktB(2)+DeltaX(2) .LE. 0) THEN
				do i=1,NAtomsB
					koordB(i,2)=koordB(i,2)+DeltaX(2)+y_box
				END DO   
			ELSE
				do i=1,NAtomsB
					koordB(i,2)=koordB(i,2)+DeltaX(2)
				END DO   
			END IF
		 
			IF( schwerpunktB(3)+DeltaX(3) .GE. z_box) THEN
				do i=1,NAtomsB
					koordB(i,3)=koordB(i,3)+DeltaX(3)-z_box
				END DO
			ELSE IF ( schwerpunktB(3)+DeltaX(3) .LE. 0) THEN
				do i=1,NAtomsB
					koordB(i,3)=koordB(i,3)+DeltaX(3)+z_box
				END DO   
			ELSE
				do i=1,NAtomsB
					koordB(i,3)=koordB(i,3)+DeltaX(3)
				END DO   
			END IF 
			
END SUBROUTINE Set_mol_box_2

SUBROUTINE Set_mol_box_vector_2(koordA,koordB,x_box,y_box,z_box)
! Subroutine um Koordinaten in der koordA, der Schwerpunkt des neuen Boxzentrums in den alten Koordinaten ist.
! koordB wird dann um DeltaX +-Boxlaengen verschoben
! Zentrum: koordA!(Schwerpunkt von Molekuel A)
! verschiebbare Atome: koordB
! Dummyarray: koordC
IMPLICIT NONE
REAL,    INTENT (IN):: x_box,y_box,z_box
Real, Dimension(3), INTENT (IN)   :: koordA
Real, Dimension(3), INTENT (INOUT)   :: koordB
Real, Dimension(3)::DeltaX

    DeltaX(1)=x_box*0.5-koordA(1)
    DeltaX(2)=y_box*0.5-koordA(2)
    DeltaX(3)=z_box*0.5-koordA(3)

!!IF( koordA(1) > x_box*0.5) THEN
!!    DeltaX(1)=koordA(1)-x_box*0.5
!!ELSE 
!!    DeltaX(1)=x_box*0.5-koordA(1)
!!END IF
!!
!!IF( koordA(2) > y_box*0.5) THEN
!!    DeltaX(2)=koordA(2)-y_box*0.5
!!ELSE
!!    DeltaX(2)=y_box*0.5-koordA(2)
!!END IF
!!
!!IF( koordA(3) > z_box*0.5) THEN
!!    DeltaX(3)=koordA(3)-z_box*0.5
!!ELSE
!!    DeltaX(3)=z_box*0.5-koordA(3)
!!END IF

!WRITE(*,*) 'DeltaX', DeltaX(:)
! Ruecktrafo, wenn die Schwerpunkte weiter getrennt liegen, als die halbe Boxlaenge.
    IF( koordB(1)+DeltaX(1) .GE. x_box) THEN
            koordB(1)=koordB(1)+DeltaX(1)-x_box
    ELSE IF ( koordB(1)+DeltaX(1) .LE. 0) THEN
            koordB(1)=koordB(1)+DeltaX(1)+x_box
    ELSE
            koordB(1)=koordB(1)+DeltaX(1) 
    END IF
    
    IF( koordB(2)+DeltaX(2) .GE. y_box) THEN
            koordB(2)=koordB(2)+DeltaX(2)-y_box
    ELSE IF ( koordB(2)+DeltaX(2) .LE. 0) THEN
            koordB(2)=koordB(2)+DeltaX(2)+y_box
    ELSE
            koordB(2)=koordB(2)+DeltaX(2)   
    END IF
 
    IF( koordB(3)+DeltaX(3) .GE. z_box) THEN
            koordB(3)=koordB(3)+DeltaX(3)-z_box
    ELSE IF ( koordB(3)+DeltaX(3) .LE. 0) THEN
            koordB(3)=koordB(3)+DeltaX(3)+z_box
    ELSE
            koordB(3)=koordB(3)+DeltaX(3)   
    END IF 


!IF( abs(getDistance(koordA,koordB)) .GE. abs(x_box+y_box+z_box)/6 ) THEN
!   write(*,*) ' Fehler in Set_mol_box_vector_2: Die Koordinaten der beiden Molekuele liegen wahrscheinlich zu'
!   write(*,*) ' weit voneinander entfernt! Nach Verschiebung  '
!   WRITE(*,*) ' Koordinaten 1. Vektor :',koordA(1),koordA(2),koordA(3)
!   WRITE(*,*) ' Koordinaten 2. Vektor :',koordB(1),koordB(2),koordB(3)
    !WRITE(*,*) 'Das Programm wird beendet'
    !STOP
!END IF

END SUBROUTINE Set_mol_box_vector_2


SUBROUTINE PBC_dist_vec(dist_vec,vec1,vec2,box)
	! IN: Vectors: vec1,vec2, box(xbox,ybox,zbox)
	! OUT: Distance vector: dist_vec, corrected via PBC
	! Calculate the distance vector with PBC conditions, make sure vec and box are in the same units! 
	IMPLICIT NONE
	REAL, DIMENSION(3), INTENT(IN) :: vec1,vec2,box
	REAL, DIMENSION(3), INTENT(OUT) :: dist_vec
	INTEGER:: i
	DO i=1,3,1 ! coordinates: x, y, z	
		dist_vec(i)=vec2(i)-vec1(i)
		dist_vec(i)=dist_vec(i)- nint(dist_vec(i)/box(i))*box(i)
	END DO
END SUBROUTINE PBC_dist_vec





SUBROUTINE make_coord_to_g09_charged(atomsorte,koord,NAtoms,calculation_method,&
                &g09inputline,molA,trajstep,Numcharged,charge,NCPUS,MEM)
    use small_functions
    IMPLICIT NONE
    Integer, INTENT (IN):: NAtoms,charge,trajstep,Numcharged,NCPUS,MEM
    Real, Dimension(NAtoms,3), INTENT (IN) :: koord
    Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
    Character(500), INTENT (IN) :: molA
    Character(500),INTENT (IN) :: calculation_method,g09inputline
    Character(500) ::foldername !!!,ziel
    Character(1024) ::bashline
    Character(2) ::charge_name
    Integer :: i,ierror,multiplicity
    logical::folder_vorhanden
			IF(charge < 0) THEN
				charge_name='e'
				multiplicity=2
			ELSE IF(charge == 0 ) THEN    
				charge_name='n'
				multiplicity=1
			ELSE
				charge_name='h'
				multiplicity=2
			END IF
			foldername='SCF_'//TRIM(molA)//'_'//TRIM(charge_name)//'_'//TRIM(calculation_method)&
						   &//'_G'//TRIM(str(trajstep))//'_N'//TRIM(str(Numcharged))
		
			inquire(file='lambda_out/'//TRIM(foldername),exist=folder_vorhanden)
			if (.NOT. folder_vorhanden) THEN
				write (bashline,*) "mkdir lambda_out/"//TRIM(foldername)
				write (*,*) TRIM(bashline) 
				CALL execute_command_line(TRIM(bashline)) 
			end if
			OPEN(UNIT=78,FILE='lambda_out/'//TRIM(foldername)//'/'//TRIM(foldername)//'.inp',STATUS='REPLACE',IOSTAT=ierror)
			  
			write(78,*) '%NProcShared='//str(NCPUS)
			write(78,*) '%Mem='//str(MEM)//'GB'
			write(78,*) '#P '//TRIM(g09inputline)//' NoSymm ' 
			write(78,*) '# GFINPUT IOP(6/7=3) 6D 10F' 
			write(78,*) ' '
			write(78,*) TRIM(foldername)//' calculate parcial charges' 
			write(78,*) ' '
			write(78,*) str(charge)//'  '//str(multiplicity)
			DO i=1,NAtoms
					write(78,'(2X,A3,1X,3F16.6)') atomsorte(i),koord(i,1),koord(i,2),koord(i,3)
			END DO 
	write(78,*) ' '

END SUBROUTINE make_coord_to_g09_charged 

SUBROUTINE winkelkriterium_DiPBI(koordA,koordB,MAXATM,theta)
			use small_functions
		IMPLICIT NONE
		Integer, INTENT(IN) :: MAXATM
		REAL, INTENT(OUT) ::theta
		Real, Dimension(MAXATM,3), INTENT(IN) :: koordA,koordB
		Real, Dimension(3) ::d1,d2,d3,d4,kreuzprodA,kreuzprodB


		d1(:)=koordA(72,:)-koordA(2,:)
		d2(:)=koordA(39,:)-koordA(35,:)

		call kreuzprodukt(d1,d2,kreuzprodA)
		kreuzprodA=kreuzprodA/norm(kreuzprodA)

		d3(:)=koordB(72,:)-koordB(2,:)
		d4(:)=koordB(39,:)-koordB(35,:)

		call kreuzprodukt(d3,d4,kreuzprodB)
		kreuzprodB=kreuzprodB/norm(kreuzprodB)
		theta=acos(DOT_PRODUCT(kreuzprodA,kreuzprodB)/(norm(kreuzprodA)*norm(kreuzprodB)))
		theta=360.0*theta/(8.0*atan(1.0)) ! Umrechnung vom Bogenmaß in Grad 

		write(*,*) 'd1=',d1 
		write(*,*) 'd2=',d2
		write(*,*) 'd3=',d3
		write(*,*) 'd4=',d4
		write(*,*) 'kreuzprodA=',kreuzprodA
		write(*,*) 'kreuzprodB=',kreuzprodB
		write(*,*) 'Winkel der DiPBI :',theta

END SUBROUTINE winkelkriterium_DiPBI

SUBROUTINE winkelkriterium_DiPBI_2(koordA,koordB,MAXATM,theta)
	use small_functions
		IMPLICIT NONE
		Integer, INTENT(IN) :: MAXATM
		Real, Dimension(MAXATM,3), INTENT(IN) :: koordA,koordB		
		REAL, INTENT(OUT) ::theta
		Real, Dimension(3) ::d1,d2,d3,d4,kreuzprodA,kreuzprodB

		d1(:)=koordA(72,:)-koordA(2,:)
		d2(:)=koordA(39,:)-koordA(35,:)

		call kreuzprodukt(d1,d2,kreuzprodA)
		kreuzprodA=kreuzprodA/norm(kreuzprodA)

		d3(:)=koordB(72,:)-koordB(2,:)
		d4(:)=koordB(39,:)-koordB(35,:)

		call kreuzprodukt(d3,d4,kreuzprodB)
		kreuzprodB=kreuzprodB/norm(kreuzprodB)

		theta=acos(DOT_PRODUCT(kreuzprodA,kreuzprodB)/(norm(kreuzprodA)*norm(kreuzprodB)))
		theta=360.0*theta/(8.0*atan(1.0)) ! Umrechnung vom Bogenmaß in Grad 
		IF( theta>90 ) THEN ! Fuer Multiplikation des Normalenvektors mit -1  
			theta=180-theta
		END IF

		!write(*,*) ' Molekuel ',TRIM(ziel)
		!write(*,*) 'd1=',d1 
		!write(*,*) 'd2=',d2
		!write(*,*) 'd3=',d3
		!write(*,*) 'd4=',d4
		!write(*,*) 'kreuzprodA=',kreuzprodA
		!write(*,*) 'kreuzprodB=',kreuzprodB
		!write(*,*) 'Winkel der DiPBI :',theta

END SUBROUTINE winkelkriterium_DiPBI_2


!!!!==================================================!!!!!!!!!!
!!!!  START:       lambda_out_dE_out                  !!!!!!!!!!
!!!!==================================================!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Abschnitt um, lambda_out und dE_out zu berechnen fuer viele moegliche Molekueltypen !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE lambda_out_dE_out() !gro_inputfile,neighbourlistfile,partial_charge_methode,resid1,resid2,N_neighbours,Num,trajstep)
use KMC_class
use small_functions
IMPLICIT NONE
type(KMC_setup_t) ::setup
!gro Daten
Character(500) :: gro_inputfile,neighbourlistfile
INTEGER ::resid1,resid2,N_neighbours,Num,trajstep
Character(10)  ::residname1,residname2 
Character(5), ALLOCATABLE, Dimension(:) :: atomsorte,atomsorteH,atomsorte1H,residue_names,residue_namesH
Real, ALLOCATABLE, Dimension(:,:)       :: koord,koordH,koord1H,vel,q_n_el_lo
INTEGER, ALLOCATABLE, Dimension(:,:)    :: RundI,RundI_H ! Resid,Index_fuer_molekuelstart
INTEGER, ALLOCATABLE, Dimension(:)      :: Neighbours
Character(800) :: lambda_out_filename_el,lambda_out_filename_lo,foldername,method

INTEGER ::N_Resids,Gesamtanzahl,GesamtanzahlH,GesamtanzahlH_precalc
Character(500)  ::dummyname,dimer
!CHARACTER(10000)::bashline
REAL::x_box,y_box,z_box,r_cut_lambda_out
INTEGER::i,j,k,ind1,ind2,i_offset,Nresid1,Nresid2,NAtoms1H
Character(500), ALLOCATABLE, Dimension(:) :: Molname 
! neighbour Liste data
INTEGER, ALLOCATABLE, Dimension(:,:) ::Neighbourlist ! (Resid, Number of nearest neighbours, NN1,NN2,NN..)
Real, ALLOCATABLE, Dimension(:,:)    ::Distances ! (Resid, Number of nearest neighbours, d_NN1,d_NN2,d_NNx..)
Character(500) ::calculation_method,partial_charge_methode,dummy
Character(3)  ::charge_name
Character(500)  ::type1,type2
Character(5)    ::lio
LOGICAL::Datei_vorhanden,KETTE=.true.,resid_found=.false.,modify_mol_h_atoms=.true.,print_coordH_to_xyz=.true.
! Abschnitt zur Schleife fuer die lambda_out Berechnung
INTEGER:: resid1_start,resid1_ende,residA,residB,NN_min,NN_max,N_NN_max
REAL::r_cut_NN
LOGICAL::calc_lambda_out_nearest_neighbours_list_NN_max,calc_lambda_out_nearest_neighbours_list_all,calc_lambda_out_r_cut_NN
LOGICAL::calc_lambda_out_single_pair,calc_lambda_out_entire_box
Real, Dimension(3) ::schwerpunktA,box
!!!! EMultipole !!!
LOGICAL :: calc_molpol
Character(500) :: select_calc_molpol
LOGICAL::PPDI_Propyl
!! 
LOGICAL::read_options_from_xml
Character(500) ::input_options_filename_xml
LOGICAL:: DEBUG=.false.

write(*,*) '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'
write(*,*) '!!!!  START:       lambda_out_dE_out                      !!!!!!!!'
write(*,*) '!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!'


PPDI_Propyl=.false.
read_options_from_xml=.false.
!!! Auswahl EMultipoles
calc_molpol=.false.
select_calc_molpol=' ' !' select_calc_molpol:= [alpha, r_cut ,all ]  '

! Startsetzungen nicht aendern!
calc_lambda_out_entire_box=.false.           ! Berechnung von allen resids fuer die Wahl von resid1
! Schalter begrenzen die Auswahl fuer resid2
calc_lambda_out_single_pair=.true.     ! Berechne nur ein Paar: resid1 resid2
calc_lambda_out_nearest_neighbours_list_NN_max=.false. ! Beschrenkung auf eine feste Anzahl an Nachbarn z.B. N_NN_max =12 (Empfohlen)
calc_lambda_out_r_cut_NN=.false.      ! Berechne die Naechsten Nachbarn anhand eines Abstandskriterium: r_cut_NN ( Nicht verwechseln mit r_cut_lambda_out
calc_lambda_out_nearest_neighbours_list_all=.false.  ! Berechne fuer alle moeglichen Nachbarn in der Liste lambda_out. (Kann sehr lang werden)

charge_name=''
type1='locoo'
type2='looco'


r_cut_lambda_out=0.0 ! Angstroem ! Gesamtkugel fuer Berechnung von lambda_out 
r_cut_NN=31.0        ! Angstroem ! Maximale Umkreis der naechsten Nachbarn ( ob Paar berechnet werden soll)
N_NN_max=12          ! Anzahl der naechsten Nachbarn fuer die zu resid1 die zweite resid gefunden werden soll. default=12

resid1_start=0
resid1_ende=1

gro_inputfile='my_grofile.gro'
neighbourlistfile='my_neighbours.ngh' !!!'sorted_lambda_neighbours_alq3_G0_rcut30.ngh'   !'sorted_lambda_neighbours_23_06.ngh'

partial_charge_methode='PBE0_6-31Gs_CHelpG' !! ; 'B3LYP_6-31Gs_hirshfeld'

resid1=3
resid2=4
N_Neighbours=4
Num=0
trajstep=0

!!! Start read info from inputline

	CALL get_command_argument(1,method)
	DO i=2,command_argument_count()
				CALL get_command_argument(i,dummyname)
				IF (check_filetermination_and_continue(dummyname,'.xml')) THEN
					input_options_filename_xml=dummyname
					inquire(file=TRIM(input_options_filename_xml),exist=Datei_vorhanden) 
					IF( .not. Datei_vorhanden) THEN 
						WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(input_options_filename_xml)
						CALL EXIT (1)
					ELSE 
						WRITE(*,*) 'Use options: ',TRIM(input_options_filename_xml)
						read_options_from_xml=.true.
					END IF ! input_options_filename_xml   vorhanden. 
				END IF !!! suche *.xml file
	ENDDO


	!! read the input parameters from an options.xml file
IF( read_options_from_xml .and. file_exists_and_continue(input_options_filename_xml) .and. &
		& check_filetermination_and_continue(input_options_filename_xml,'.xml')) THEN
		write(*,*) 'Start reading options from  input_options_filename_xml. '//TRIM(input_options_filename_xml)
		call set_defaults_KMC_setup(setup)
		call read_votca_optionsfile(input_options_filename_xml,setup," lambda_out_dE_out lambdaoutdEout system ")
		
		!!! Use data from setup in options.xml file.
		!!!   lambda_out_dE_out
		calc_lambda_out_entire_box = setup%calc_lambda_out_entire_box                                    
		calc_lambda_out_single_pair = setup%calc_lambda_out_single_pair                                    
		calc_lambda_out_nearest_neighbours_list_NN_max = setup%calc_lambda_out_nearest_neighbours_list_NN_max  
		calc_lambda_out_r_cut_NN = setup%calc_lambda_out_r_cut_NN                                      
		calc_lambda_out_nearest_neighbours_list_all = setup%calc_lambda_out_nearest_neighbours_list_all            
		calc_molpol = setup%calc_molpol                                                        
		select_calc_molpol= setup%select_calc_molpol                                                   
		r_cut_lambda_out = setup%r_cut_lambda_out                                                    
		r_cut_NN = setup%r_cut_NN                                                                
		N_NN_max = setup%N_NN_max                                                              
		neighbourlistfile = setup%neighbourlist_filename
		gro_inputfile = setup%gro_inputfile
		resid1 = setup%residA 
		residname1           = adjustl(int2str(setup%residA))          
		type1                = setup%typeA             
		resid2               = setup%residB  
		residname2           = adjustl(int2str(setup%residB))       
		type2                = setup%typeB  
		!!!! End lambda_out_dE_out

ELSE IF (command_argument_count() == 8) THEN
	                
        CALL get_command_argument(1,method)
        CALL get_command_argument(2,gro_inputfile)
        inquire(file=TRIM(gro_inputfile),exist=Datei_vorhanden) ! Abfrage ob gro-Datei vorhanden ist.
	IF (check_filetermination(gro_inputfile,'.gro')) THEN
        	IF( .NOT. Datei_vorhanden) THEN 
            		WRITE(*,*) ' Fehler: Die_gro_Datei_ist_nicht_vorhanden. '//TRIM(gro_inputfile)
            		WRITE(*,*) ' ENDE'
            		STOP
        	END IF ! gro-file vorhanden  
	END IF ! check if *.gro
        CALL get_command_argument(3,neighbourlistfile)     
	IF (file_exists(neighbourlistfile) .and. check_filetermination(neighbourlistfile,'.ngh')) THEN
		CALL get_command_argument(4,residname1) 
		READ(residname1,'(I10)') resid1   
 		CALL get_command_argument(5,residname2) 
		READ(residname2,'(I10)') resid2	
		CALL get_command_argument(6,partial_charge_methode)
		CALL get_command_argument(7,dummy)
		READ(dummy,'(I10)') Num	
		CALL get_command_argument(8,dummy)
		READ(dummy,'(I10)') trajstep
	END IF
ELSE
	WRITE(*,*)'use: lambda_out_dE_out  grofilename.gro    neighbourlistfile    Resid1   Resid2 partial_charge_methode  Num trajstep'
	WRITE(*,*)'     lambda_out_dE_out    alq3_G0.gro  sorted_neighbours_alq3_G0.ngh 0    449    PBE0_6-31Gs_CHelpG     0     0   '
	STOP 
END IF


!!!   lambda_out_dE_out
write(*,*)  'gro_inputfile: ',trim(gro_inputfile)
write(*,*)  'neighbourlistfile: ',trim(neighbourlistfile)
write(*,*)  'calc_lambda_out_entire_box: ',calc_lambda_out_entire_box                                    
write(*,*)  'calc_lambda_out_single_pair: ',calc_lambda_out_single_pair                                    
write(*,*)  'calc_lambda_out_nearest_neighbours_list_NN_max: ',calc_lambda_out_nearest_neighbours_list_NN_max  
write(*,*)  'calc_lambda_out_r_cut_NN: ',calc_lambda_out_r_cut_NN                                      
write(*,*)  'calc_lambda_out_nearest_neighbours_list_all: ',calc_lambda_out_nearest_neighbours_list_all            
write(*,*)  'calc_molpol: ',calc_molpol                                                        
write(*,*)  'select_calc_molpol: ',trim(adjustl(select_calc_molpol))
write(*,*)  'r_cut_lambda_out: ',r_cut_lambda_out                                                    
write(*,*)  'r_cut_NN: ',r_cut_NN                                                                
write(*,*)  'N_NN_max: ',N_NN_max                                                              
!!!! End lambda_out_dE_out

IF(calc_lambda_out_single_pair) then
	write(*,*) 'calc_lambda_out_single_pair: ',resid1,TRIM(type1),resid2,TRIM(type2)
ENDIF

lambda_out_filename_el='results_lambda_out_el_G'//TRIM(str(trajstep))//'.dat'
lambda_out_filename_lo='results_lambda_out_lo_G'//TRIM(str(trajstep))//'.dat'

allocate(Neighbours(N_Neighbours))
 ! Setzen der Ausgabedaten 
dimer='Dim_'//TRIM(type1)//'_'//TRIM(type2)//'_'//TRIM(str(resid1))//'_'//TRIM(str(resid2))
foldername=TRIM(dimer)//'_'//TRIM(calculation_method)//'_'//TRIM(charge_name)//'_r_cut_'//TRIM(str(INT(r_cut_lambda_out)))//'_G'//&
                                &TRIM(str(trajstep))//'_N'//TRIM(str(Num))//'_lam_out'

lio=TRIM(foldername)//'_'//TRIM(make_lio())  ! Parameter_um erstellte temporaere Dateien oder Ordner einzigartig zu benennen.

IF ( r_cut_NN > r_cut_lambda_out) THEN
    WRITE(*,*) 'Warning: Selection of r_cut_NN > r_cut_lambda_out may be incorrect!!'
END IF



CALL read_neighbours(Neighbourlist,Distances,neighbourlistfile,N_Resids)
! get resid offset
resid_found=.false.
find_resid1: DO i=1,N_Resids
        IF ( Neighbourlist(i,1) == resid1) THEN
            ind1=i
            
            resid_found=.true.
            EXIT find_resid1
        END IF
END DO find_resid1      
i_offset=ind1-resid1
IF (resid_found) THEN
    WRITE(*,*) 'i_offset:',i_offset
ELSE 
    STOP 'Error: resid was not found in the neighbour list'
END IF ! resid_found


 WRITE(*,*) '---- neighbourlist -----'
 i=1
 WRITE(*,*) Distances(i,1),Distances(i,2),Distances(i,3:int(Distances(i,2)+2))
 WRITE(*,*) Neighbourlist(i,1),Neighbourlist(i,2),Neighbourlist(i,3:Neighbourlist(i,2)+2)
 
 WRITE(*,*) 'N_Resids:',SIZE(Distances(:,1))
 i=SIZE(Distances(:,1))
 WRITE(*,*) Distances(i,1),Distances(i,2),Distances(i,3:int(Distances(i,2)+2))
 WRITE(*,*) Neighbourlist(i,1),Neighbourlist(i,2),Neighbourlist(i,3:Neighbourlist(i,2)+2)
 

CALL read_all_coords_from_gro(RundI,residue_names,atomsorte,koord,vel,N_Resids,Gesamtanzahl,x_box,y_box,z_box,gro_inputfile)


box(1)=x_box
box(2)=x_box
box(3)=z_box
 
 iF (DEBUG) THEN
    i=1
    WRITE(*,*) RundI(i,1),RundI(i,2),residue_names(i),atomsorte(RundI(i,2)),koord(RundI(i,2),:),vel(RundI(i,2),:)
    WRITE(*,*) RundI(i,1),RundI(i+1,2)-1,residue_names(i),atomsorte(RundI(i+1,2)-1),koord(RundI(i+1,2)-1,:),vel(RundI(i+1,2)-1,:)
    WRITE(*,*) '-----'
    i=N_Resids
    j=Gesamtanzahl
    WRITE(*,*) RundI(i,1),RundI(i,2),residue_names(i),atomsorte(RundI(i,2)),koord(RundI(i,2),:),vel(RundI(i,2),:)
    WRITE(*,*) RundI(i,1),RundI(i+1,2)-1,residue_names(i),atomsorte(RundI(i+1,2)-1),koord(RundI(i+1,2)-1,:),vel(RundI(i+1,2)-1,:)
    
    WRITE(*,*) '-----Resid1----'
    i=resid1+1
    WRITE(*,*) RundI(i,1),RundI(i,2),residue_names(i),atomsorte(RundI(i,2)),koord(RundI(i,2),:),vel(RundI(i,2),:)
    WRITE(*,*) RundI(i,1),RundI(i+1,2)-1,residue_names(i),atomsorte(RundI(i+1,2)-1),koord(RundI(i+1,2)-1,:),vel(RundI(i+1,2)-1,:)
    
    WRITE(*,*) '-----Resid2----'
    i=resid2+1
    WRITE(*,*) RundI(i,1),RundI(i,2),residue_names(i),atomsorte(RundI(i,2)),koord(RundI(i,2),:),vel(RundI(i,2),:)
    WRITE(*,*) RundI(i,1),RundI(i+1,2)-1,residue_names(i),atomsorte(RundI(i+1,2)-1),koord(RundI(i+1,2)-1,:),vel(RundI(i+1,2)-1,:)
    
    !Nresid1 gibt die Anzahl der Atome im Molekuel mit Resid1 an
    Nresid1=RundI(resid1+2,2)-RundI(resid1+1,2) ! muss ggf angepasst werde, wenn nicht bei 0 startend
    !Nresid2 gibt die Anzahl der Atome im Molekuel mit Resid2 an
    Nresid2=RundI(resid2+2,2)-RundI(resid2+1,2)
    WRITE(*,*) 'N_Atoms in resid1:',Nresid1,' and in resid2:',Nresid2
END IF ! DEBUG
	
WRITE(*,*) 'modify_mol_h_atoms:',modify_mol_h_atoms 
IF (modify_mol_h_atoms) THEN
	!!! Check how much needs to be allocated => Result in GesamtanzahlH
	CALL how_many_h_atoms_to_mol(RundI,atomsorte,residue_names,Gesamtanzahl,N_Resids,GesamtanzahlH,KETTE,PPDI_Propyl)
	GesamtanzahlH_precalc=GesamtanzahlH
ELSE
	GesamtanzahlH=Gesamtanzahl
	GesamtanzahlH_precalc=Gesamtanzahl
END IF  
 
!GesamtanzahlH=int(Gesamtanzahl*2.5) ! Abschaetzung, da die Anzahl der H-Atome nicht genau bestimmt ist. So bleiben wahrscheinlich auch viele Arrayelement frei,
IF ( Allocated(RundI_H))  Deallocate(RundI_H)
IF ( Allocated(residue_namesH))  Deallocate(residue_namesH)
IF ( Allocated(atomsorteH))  Deallocate(atomsorteH)
IF ( Allocated(koordH))  Deallocate(koordH)
IF ( Allocated(Molname))  Deallocate(Molname)
ALLOCATE(RundI_H(N_Resids+1,2))
ALLOCATE(residue_namesH(N_Resids))
ALLOCATE(atomsorteH(GesamtanzahlH))
ALLOCATE(koordH(GesamtanzahlH,3))
ALLOCATE(Molname(GesamtanzahlH))
RundI_H=0
atomsorteH=''
koordH=0
GesamtanzahlH=0
Molname=''


IF (modify_mol_h_atoms) THEN
    DO i=1,N_Resids
        ind1=RundI(i,1)+i_offset ! offset ggf anpassen !!!
        CALL add_h_atoms_to_mol(atomsorte(RundI(ind1,2):(RundI(ind1+1,2)-1)),koord(RundI(ind1,2):(RundI(ind1+1,2)-1),1:3),&
                    &(RundI(ind1+1,2)-RundI(ind1,2)),residue_names(ind1),KETTE,atomsorte1H,koord1H,NAtoms1H,Molname(ind1))
        RundI_H(ind1,1)=RundI(ind1,1)
        RundI_H(ind1,2)=GesamtanzahlH+1
        residue_namesH(ind1)=residue_names(ind1)
        DO j=1,NAtoms1H            
                atomsorteH(GesamtanzahlH+j)=atomsorte1H(j)
                koordH(GesamtanzahlH+j,:)=koord1H(j,:)
        END DO !j
        GesamtanzahlH=GesamtanzahlH+NAtoms1H
    END DO ! N_Resids
    RundI_H(N_Resids+1,2)=GesamtanzahlH+1
    RundI_H(N_Resids+1,1)=-100
    WRITE(*,*) 'GesamtanzahlH: ',GesamtanzahlH,' Gesamtanzahl: ',Gesamtanzahl
    IF(GesamtanzahlH_precalc /= GesamtanzahlH) THEN	
	WRITE(*,*) 'WARNING: Number of estimatesd needed atoms including extra H atoms',GesamtanzahlH_precalc,&
	&',does not match the added number',GesamtanzahlH,'! Revise implementation or input data!'
	STOP
    END IF
 ELSE ! modify_mol_h_atoms
    ! Uebergabe ohne H-Veraenderung
    Do i=1,Gesamtanzahl
        atomsorteH(i)=atomsorte(i)
        koordH(i,:)=koord(i,:)
    END DO
    DO i=1,N_Resids
        RundI_H(i,:)=RundI(i,:)
        residue_namesH(i)=residue_names(i)
	Molname(i)=residue_names(i)
    END DO
    GesamtanzahlH=Gesamtanzahl
    RundI_H(N_Resids+1,2)=GesamtanzahlH+1
    RundI_H(N_Resids+1,1)=-100
 END IF ! modify_mol_h_atoms



IF(print_coordH_to_xyz) THEN
	WRITE(*,*) ' print_coordH_to_xyz ' 
	dummyname='xyz_output_H.xyz'
	!CALL make_coord_to_xyz(atomsorteH(RundI_H(:,2):(RundI_H(:,2)-1)),koordH(RundI_H(:,2):(RundI_H(:,2)-1),:),&
	!	&GesamtanzahlH,dummyname)
	CALL make_coord_to_xyz(atomsorteH,koordH,GesamtanzahlH,dummyname)
END IF

IF (calc_molpol) THEN
	CONTINUE
ELSE 
	CALL get_partial_charges(RundI_H,N_Resids,GesamtanzahlH,residue_namesH,partial_charge_methode,&
                     &q_n_el_lo,trajstep,KETTE,lambda_out_filename_el,lambda_out_filename_lo,foldername)
END IF

IF (DEBUG) THEN
    i=1
    WRITE(*,*) '----- first ---'
    WRITE(*,*) TRIM(atomsorteH(RundI_H(i+1,2)-1))
    WRITE(*,*) RundI_H(i,1),RundI_H(i,2),TRIM(residue_namesH(i)),' ',TRIM(atomsorteH(RundI_H(i,2))),koordH(RundI_H(i,2),:)  !,vel(RundI(i,2),:)
    WRITE(*,*) RundI_H(i,1),RundI_H(i+1,2)-1,TRIM(residue_namesH(RundI_H(i+1,2)-1)),' ',TRIM(atomsorteH(RundI_H(i+1,2)-1)),&
                        &koordH(RundI_H(i+1,2)-1,:)  !,vel(RundI(i+1,2)-1,:)
    WRITE(*,*) '----- last ---'
    i=N_Resids !+i_offset
    WRITE(*,*) i,RundI_H(i,1),RundI_H(i,2),TRIM(residue_namesH(i)),' ',TRIM(atomsorteH(RundI_H(i,2))),koordH(RundI_H(i,2),:)   !,vel(RundI(i,2),:)
    WRITE(*,*) i,RundI_H(i,1),RundI_H(i+1,2)-1,TRIM(residue_namesH(i)),' ',TRIM(atomsorteH(RundI_H(i+1,2)-1)),&
		&koordH(RundI_H(i+1,2)-1,:)   !,vel(RundI(i+1,2)-1,:)
    
    WRITE(*,*) '-----Resid1----'
    i=resid1+i_offset
    WRITE(*,*) RundI_H(i,1),RundI_H(i,2),TRIM(residue_namesH(i)),' ',TRIM(atomsorteH(RundI_H(i,2))),koordH(RundI_H(i,2),:)              !,vel(RundI(i,2),:)
    WRITE(*,*) RundI_H(i,1),RundI_H(i+1,2)-1,TRIM(residue_namesH(i)),' ',TRIM(atomsorteH(RundI_H(i+1,2)-1)),&
		&koordH(RundI_H(i+1,2)-1,:)  !,vel(RundI(i+1,2)-1,:)
    
    WRITE(*,*) '-----Resid2----'
    i=resid2+i_offset
    WRITE(*,*) RundI_H(i,1),RundI_H(i,2),TRIM(residue_namesH(i)),' ',atomsorteH(RundI_H(i,2)),koordH(RundI_H(i,2),:)                      !,vel(RundI(i,2),:)
    WRITE(*,*) RundI_H(i,1),RundI_H(i+1,2)-1,TRIM(residue_namesH(i)),' ',TRIM(atomsorteH(RundI_H(i+1,2)-1)),&
                & koordH(RundI_H(i+1,2)-1,:)              ! ,vel(RundI(i+1,2)-1,:)
    
    Nresid1=RundI_H(resid1+i_offset+1,2)-RundI_H(resid1+i_offset,2) ! muss ggf angepasst werde, wenn nicht bei 0 startend
    Nresid2=RundI_H(resid2+i_offset+1,2)-RundI_H(resid2+i_offset,2)
    WRITE(*,*) 'N_Atoms resid1:',Nresid1,' resid2',Nresid2
END IF ! DEBUG



IF (calc_molpol) THEN
   ! CALL EMultipole_EvaluateFrame(N_Atoms_all,N_Resids,Resid1,Resid2,RundI,residue_names,atomsorte,koord,&
   !                                         &Molname,Neighbourlist,N_NN_max,select_calc_molpol)
  CALL EMultipole_EvaluateFrame(GesamtanzahlH,N_Resids,Resid1,Resid2,RundI_H(1:GesamtanzahlH,1:2),residue_namesH,atomsorteH,&
			&koordH(1:GesamtanzahlH,1:3),Molname,Neighbourlist,N_NN_max,select_calc_molpol,box)
	STOP

ELSE IF (calc_lambda_out_single_pair) THEN ! select lambda_out_modus
    resid_found=.false.
    find_resid: DO i=1,N_Resids
        IF ( Neighbourlist(i,1) == resid1) THEN
            ind1=i
            IF (resid_found) EXIT find_resid
            resid_found=.true.
        ELSE IF (Neighbourlist(i,1) == resid2) THEN
            ind2=i
            IF (resid_found) EXIT find_resid
            resid_found=.true.
        END IF ! find index
    END DO find_resid
    IF ( .NOT. resid_found) THEN
        WRITE(*,*) 'Error: resid1 or resid2 not found in the resid_list. Check the input!'
        STOP
    END IF

    CALL unite_neighbourlists(Neighbourlist(ind1,3:(Neighbourlist(ind1,2)+2)),Neighbourlist(ind1,2),&
            &Neighbourlist(ind2,3:(Neighbourlist(ind2,2)+2)),Neighbourlist(ind2,2),resid1,resid2,Neighbours,N_Neighbours)
    WRITE(*,*) 'unite Neighbourlists done',resid1,resid2
	CALL Ewald_lambda_out_dE_out_from_xyz_q_n_el_lo(resid1,resid2,N_Resids,Gesamtanzahl,RundI,koord,&
 & q_n_el_lo,Neighbours,N_Neighbours,x_box,y_box,z_box,r_cut_lambda_out,lambda_out_filename_el,lambda_out_filename_lo,foldername) 

    call lambda_out_dE_out_from_xyz_q_n_el_lo(resid1,resid2,N_Resids,RundI_H,koordH,q_n_el_lo,&
            &Neighbours,N_Neighbours,x_box,y_box,z_box,r_cut_lambda_out,lambda_out_filename_el,lambda_out_filename_lo,foldername) 
    WRITE(*,*) 'lambda_out_calculated for pair:',resid1,resid2
    STOP
ELSE

    WRITE(*,*) 'i_offset:',i_offset
    
    iF(calc_lambda_out_entire_box) THEN
        resid1_start=RundI_H(1,1)
        resid1_ende=RundI_H(N_Resids,1)
        WRITE(*,*) 'calc_lambda_out_entire_box: resid_start: ',resid1_start,' resid_ende: ',resid1_ende
    ELSE IF(calc_lambda_out_single_pair) THEN
        resid1_start=resid1
        resid1_ende=resid1
    END IF
    WRITE(*,*) 'resid1_start,resid1_ende:',resid1_start,resid1_ende
    DO i=resid1_start,resid1_ende ! Schleife ueber die resid1 
        residA=i
        ind1=residA+i_offset ! offset ggf anpassen !!!
        schwerpunktA=0
        WRITE(*,*) 'N_Atoms_resid1:',RundI_H(ind1+1,2)-RundI_H(ind1,2),ind1,RundI_H(ind1,2),(RundI_H(ind1+1,2)-1)
 	IF(debug) THEN
		DO k=RundI_H(ind1,2),RundI_H(ind1+1,2)-1
		 WRITE(*,'(A3,6F10.4)') atomsorteH(k),koordH(k,:),q_n_el_lo(k,1),q_n_el_lo(k,2),q_n_el_lo(k,3)
        	!WRITE(*,*) atomsorteH(RundI_H(ind1,2):(RundI_H(ind1+1,2)-1)),koordH(RundI_H(ind1,2):(RundI_H(ind1+1,2)-1),:)&
                !    &,(RundI_H(ind1+1,2)-RundI_H(ind1,2)),schwerpunktA,KETTE
		END DO
	END IF ! debug
       CALL Massenschwerpunkt(atomsorteH(RundI_H(ind1,2):(RundI_H(ind1+1,2)-1)),koordH(RundI_H(ind1,2):(RundI_H(ind1+1,2)-1),:)&
                    &,(RundI_H(ind1+1,2)-RundI_H(ind1,2)),schwerpunktA,KETTE) 
       WRITE(*,*) 'COM:',schwerpunktA

        IF (calc_lambda_out_nearest_neighbours_list_NN_max) THEN
            NN_min=1
            NN_max=min(Neighbourlist(ind1,2),N_NN_max) ! Maximale Anzahl der Naechsten Nachbarn (default N_NN_max=12) ! min stellt sicher, dass nicht mehr angefordert werde als verfuegbar sind
        ELSE IF (calc_lambda_out_nearest_neighbours_list_all) THEN
            NN_min=1
            NN_max=Neighbourlist(ind1,2) ! koennen sehr viele werden 
        ELSE IF(calc_lambda_out_r_cut_NN) THEN
            NN_min=1
            NN_max=1
            DO k=1,Neighbourlist(ind1,2) ! Durchgehen der Nachbarn
                IF( Distances(ind1,k+2) < r_cut_NN) THEN
                    NN_max=k
                ELSE
                    EXIT
                END IF
            END DO
        ELSE IF(calc_lambda_out_single_pair) THEN
            ind2=0
            DO k=1,Neighbourlist(ind1,2) 
                IF(Neighbourlist(ind1,k+2) == resid2) THEN
                    ind2=k
                END IF
            END DO
            if(ind2 /=0) THEN
                NN_min=ind2
                NN_max=NN_min
            ELSE 
                WRITE(*,*) 'Error: resid1 or resid2 not found in the resid_list. Check the input!'
                STOP
            END IF 
        END IF !calc_lambda_out_single_pair
        
        DO j=NN_min,NN_max,1 ! Schleife ueber die Anzahl der Nachbarn von resid1 also alle indizes der resid2
            WRITE(*,*) 'j=',j
            residB=Neighbourlist(ind1,j+2)
            ind2=residB+i_offset ! resid2+i_offset
            WRITE(*,*) 'lambda_out calculate for pair:',residA,residB,ind1,ind2
            
            CALL unite_neighbourlists(Neighbourlist(ind1,3:(Neighbourlist(ind1,2)+2)),Neighbourlist(ind1,2),&
            &Neighbourlist(ind2,3:(Neighbourlist(ind2,2)+2)),Neighbourlist(ind2,2),residA,residB,Neighbours,N_Neighbours)
            
             ! Setzen der Ausgabedaten 
            dimer='Dim_'//TRIM(residue_namesH(ind1))//'_'//TRIM(residue_namesH(ind2))//'_'//&
                            &TRIM(str(residA))//'_'//TRIM(str(residB))
            foldername=TRIM(dimer)//'_'//TRIM(calculation_method)//'_'//TRIM(charge_name)//'_r_cut_'//&
                &TRIM(str(INT(r_cut_lambda_out)))//'_G'//TRIM(str(trajstep))//'_N'//TRIM(str(Num))//'_lam_out'
                
            call lambda_out_dE_out_from_xyz_q_n_el_lo(residA,residB,N_Resids,RundI_H,koordH,q_n_el_lo,&
            &Neighbours,N_Neighbours,x_box,y_box,z_box,r_cut_lambda_out,lambda_out_filename_el,lambda_out_filename_lo,foldername) 
             WRITE(*,*) 'lambda_out calculated for pair:',residA,residB
             
        END DO ! j Schleife ueber resid2 Nachbarn
       
    END DO ! i Schleife ueber alle Resids in der Box fuer resid1
   WRITE(*,*) 'Ende lambda_out'
    
END IF ! select lambda_out_modus

   WRITE(*,*) 'Ende lambda_out main'
END SUBROUTINE lambda_out_dE_out

SUBROUTINE unite_neighbourlists(Neighbours1,N_Neighbours1,Neighbours2,N_Neighbours2,resid1,resid2,&
                                &Neighbours_united,N_Neighbours_united)
		!! Subroutine to unite the neighbourlists Neighbours1 and Neighbours2 from resid1 and resid2 without double counting and without resid1 and resid2, the list is stored in Neighbours_united with a total number of N_Neighbours_united.
		!! N_Neighbours1,N_Neighbours2,N_Neighbours_united: number of neighbours in each list
		INTEGER, Dimension(:), INTENT(IN)         :: Neighbours1,Neighbours2
		INTEGER, ALLOCATABLE, Dimension(:), INTENT(INOUT)      :: Neighbours_united
		INTEGER, INTENT(IN) :: N_Neighbours1,N_Neighbours2,resid1,resid2
		INTEGER, INTENT(INOUT) :: N_Neighbours_united
		LOGICAL::add_Neighbour, DEBUG=.false.
		INTEGER::i,j,ind1,ind2

		DEBUG=.false.

		IF ( Allocated(Neighbours_united))  DEALLOCATE(Neighbours_united)
		allocate(Neighbours_united(N_Neighbours1+N_Neighbours2))

		N_Neighbours_united=N_Neighbours1
		Neighbours_united=-100
		Neighbours_united(:)=Neighbours1(1:N_Neighbours1)

		loop_N1: DO i=1,N_Neighbours2
			add_Neighbour=.true.
			loop_N2: DO j=1,N_Neighbours1
				IF ( Neighbours_united(j) == Neighbours2(i) ) THEN
					add_Neighbour=.false.
					cycle loop_N2
				END IF
			END DO loop_N2
			IF (add_Neighbour) THEN ! anfuegen
				N_Neighbours_united=N_Neighbours_united+1
				Neighbours_united(N_Neighbours_united)=Neighbours2(i)
			END iF
		END DO loop_N1

		! delete resi1 and resid2 from neighbour Liste
		ind1=0
		ind2=0
		DO i=1,N_Neighbours_united ! delete resi1 and resid2 from neighbour Liste
			iF( Neighbours_united(i) == resid1) THEN
				ind1=i
			END IF
			IF ( Neighbours_united(i) == resid2) THEN
				ind2=i
			END IF
		END DO ! find resid1 and resid2
		IF(ind1 /=0) THEN ! resid1, delete element
			Neighbours_united =[Neighbours_united(:ind1-1), Neighbours_united(ind1+1:)]
			!Neighbours_united(ind1:) =[Neighbours_united(:ind1-1), Neighbours_united(ind1+1:)]
			N_Neighbours_united=N_Neighbours_united-1
		END IF ! resid 1 da
		IF(ind2 /=0) THEN ! resid2, delete element
			Neighbours_united =[Neighbours_united(:ind2-1), Neighbours_united(ind2+1:)]
			N_Neighbours_united=N_Neighbours_united-1
		END IF ! resid 2 da

		IF (DEBUG) THEN
			WRITE(*,*) 'N_Neighbours_united:',N_Neighbours_united
			WRITE(*,*) '---neighbours 1---'
			DO i=1,N_Neighbours1
				 WRITE(*,*) Neighbours1(i)
			END DO 

			WRITE(*,*) '---neighbours 2---'
			DO i=1,N_Neighbours2
				WRITE(*,*) Neighbours2(i)
			END DO 

			WRITE(*,*) '---neighbours united---'
			DO i=1,N_Neighbours_united
				WRITE(*,*) Neighbours_united(i)
			END DO 
		END IF ! DEBUG
		IF ( (N_Neighbours_united ==0) .OR. (N_Neighbours1 == 0) .OR. (N_Neighbours2 == 0) ) THEN
			WRITE(*,*) 'Error: N_Neighbours_united, N_Neighbours1 or N_Neighbours2 ==0; Check input!'
			WRITE(*,*) 'Values:',N_Neighbours_united,N_Neighbours1,N_Neighbours2
			STOP
		END IF

end subroutine unite_neighbourlists

SUBROUTINE get_partial_charges(RundI,N_Resids,N_Atoms,residue_names,partial_charge_methode,&
                        &q_n_el_lo,trajstep,KETTE,lambda_out_filename_el,lambda_out_filename_lo,foldername)
! SUBROUTINE to read the partial charges from the *.dat files for dE_out and lambda_out calculations

IMPLICIT NONE
Real, ALLOCATABLE, Dimension(:,:)       , INTENT(OUT) :: q_n_el_lo
INTEGER, ALLOCATABLE, Dimension(:,:)    , INTENT(IN) :: RundI ! Resid,Index_fuer_molekuelstart
Character(5), ALLOCATABLE, Dimension(:) , INTENT(IN) :: residue_names
Character(500) , INTENT(IN)  :: partial_charge_methode,foldername
Character(800) , INTENT(IN)  :: lambda_out_filename_el,lambda_out_filename_lo
INTEGER, INTENT(IN) ::N_Resids,N_Atoms,trajstep 
LOGICAL, INTENT(IN) ::KETTE
Real, ALLOCATABLE, Dimension(:) ::partial_charges_n,partial_charges_el,partial_charges_lo
Character(500)::Molname,old_residue_name,S_Ringe
Character(800) ::q_file_n,q_file_el,q_file_lo
INTEGER::i,j,MAXATM
LOGICAL::debug

debug=.false.
IF( N_Resids > N_Atoms) THEN
    WRITE(*,*) 'Error: N_Resids > N_Atoms; check input',N_Resids,N_Atoms
    STOP  'Error: N_Resids > N_Atoms; check input'
END IF

IF ( .NOT. Allocated(q_n_el_lo))  allocate(q_n_el_lo(N_Atoms,3))
q_n_el_lo=0.0
! H-Atome muessen schon vorher angefuegt worden sein!
    old_residue_name=''
    DO i=1,N_Resids
        IF( old_residue_name /= residue_names(i) ) THEN ! new molecule?
                ! Molname
                IF ( TRIM(ADJUSTL(residue_names(i)(1:3))) == 'THP' .OR. (TRIM(ADJUSTL(residue_names(i)))=='P3MT') .OR. &
                    &   (TRIM(ADJUSTL(residue_names(i)))=='P3HT') ) THEN
                    Molname='P3MT'
                    IF(KETTE) Molname ='P3HT'
                    WRITE(*,*) 'lambda_out_mode_not_for_P3MT, no polymers'
                    STOP
                ELSE IF ( TRIM(ADJUSTL(residue_names(i))) == 'DIPBI') THEN
                    Molname='DIPBI'
                    IF(KETTE) Molname='DIPBI_KETTE'
                ELSE IF ( TRIM(ADJUSTL(residue_names(i))) == 'PPDI_') THEN
                    Molname='PPDI'
                    IF(KETTE) Molname='PPDI_KETTE'
                ELSE IF ( TRIM(ADJUSTL(residue_names(i))) == '8poly') THEN
                    Molname='PBDT-TS1'
                    WRITE(*,*) 'lambda_out_mode_not_for_PBDT-TS1, no polymers'
                    STOP
                ELSE
                    Molname=TRIM(residue_names(i))
                END IF !Get molname
                
                S_Ringe=''
                q_file_n='./partial_charges/q_'//TRIM(partial_charge_methode)//'_n_'//TRIM(Molname)//TRIM(S_Ringe)//'.dat'
                q_file_el= './partial_charges/q_'//TRIM(partial_charge_methode)//'_el_'//TRIM(Molname)//TRIM(S_Ringe)//'.dat'
                q_file_lo= './partial_charges/q_'//TRIM(partial_charge_methode)//'_lo_'//TRIM(Molname)//TRIM(S_Ringe)//'.dat'
                MAXATM=RundI(i+1,2)-RundI(i,2)
                WRITE(*,*) 'Number of Atoms:',MAXATM
                IF ( Allocated(partial_charges_n))   deallocate(partial_charges_n)
                IF ( Allocated(partial_charges_el))  deallocate(partial_charges_el)
                IF ( Allocated(partial_charges_lo))  deallocate(partial_charges_lo)
                ALLOCATE(partial_charges_n(MAXATM),partial_charges_el(MAXATM),partial_charges_lo(MAXATM))
                CALL Read_part_charges_q_file(q_file_n,partial_charges_n,MAXATM,trajstep,lambda_out_filename_el,foldername)
                CALL Read_part_charges_q_file(q_file_el,partial_charges_el,MAXATM,trajstep,lambda_out_filename_el,foldername)
                CALL Read_part_charges_q_file(q_file_lo,partial_charges_lo,MAXATM,trajstep,lambda_out_filename_lo,foldername)
                IF(debug)THEN
			WRITE(*,*) '-----Partial charges '//TRIM(Molname)//' n -- el -- lo  ------'
			DO j=1,MAXATM
				WRITE(*,'(3F12.6)') partial_charges_n(j),partial_charges_el(j),partial_charges_lo(j)
			END DO
		END IF ! debug
                WRITE(*,*) 'Files used: ',TRIM(q_file_n),' ',TRIM(q_file_el),' ',TRIM(q_file_lo)
        END IF ! new element
                q_n_el_lo(RundI(i,2):(RundI(i+1,2)-1),1)=partial_charges_n(:)
                q_n_el_lo(RundI(i,2):(RundI(i+1,2)-1),2)=partial_charges_el(:)
                q_n_el_lo(RundI(i,2):(RundI(i+1,2)-1),3)=partial_charges_lo(:)
                !WRITE(*,*) q_n_el_lo(RundI(i,2):(RundI(i+1,2)-1),1)
                
                old_residue_name=residue_names(i)
    END DO ! i=1,N_Resids
END SUBROUTINE get_partial_charges

SUBROUTINE read_neighbours(Res_NN,Distances,neighbourlistfile,N_Resids) 
!! Subroutine um die Nachbarn einzulesen, aus dem neighbourlistfile
!! Es werden 2 Arrays zurueckgegeben Res_NN enthaelt die [Resids,Anzahl der Nachbarns, Liste aller Nachbarn ]
!! Distances entaelt die Abstaende der Zentren 
!! Sortierung der Nachbarn mit zunehmendem Abstand und zunehmender Resid ist mit sort_neighbour_list_data=.true. moeglich
use small_functions
IMPLICIT NONE
CHARACTER(500), INTENT(IN) :: neighbourlistfile
INTEGER, ALLOCATABLE, Dimension(:,:), INTENT(OUT)::Res_NN ! (Resid,Number of nearest neighbours, NN1,NN2,NN.. NNx)
REAL, ALLOCATABLE, DIMENSION(:,:):: Distances
INTEGER, PARAMETER::N_Alloc_Max=2**12 ! maximal allocierter Dummybereich
real*8  :: vals( N_Alloc_Max )
CHARACTER(len=N_Alloc_Max*12) ::line
INTEGER, DIMENSION(N_Alloc_Max)::int_dummyarray
REAL,    DIMENSION(N_Alloc_Max)::real_dummyarray
INTEGER::i,j,m,n,i_min,ierror1,N_Resids,int_dummy,i_end,j_end
REAL::real_dummy
LOGICAL::DEBUG=.false.,sort_neighbour_list_data=.true. ! Sorts the Neighbourlist with increasing Resids
N_Resids=Read_rows_file2(neighbourlistfile)/2 !Anzahl der Zentren der Ceter of Masses COM

ALLOCATE(Distances(N_Resids,N_Alloc_Max)) ! Es wird mehr allociert als besetzt wird
! Einlesen der Daten aus neighbourlistfile
ALLOCATE(Res_NN(N_Resids,N_Alloc_Max)) 

IF (file_exists(neighbourlistfile)) THEN
    OPEN(UNIT=11,FILE=TRIM(neighbourlistfile),STATUS='OLD',IOSTAT=ierror1)
END IF

DO i=1,N_Resids
        READ( 11, "(a)",IOSTAT=ierror1) line
        IF(ierror1 < 0) EXIT
        IF(ierror1 > 0) THEN
            WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(neighbourlistfile),' aufgetreten.'
            WRITE(*,*) 'Beende Einlesen !'
            STOP
        END IF
        CALL split( line, vals, n ) ! Auteilen der eingelesenen line in Einzelteile

        IF ( n == 0 ) THEN
            WRITE(*,*) "comment line: "//TRIM(line)
        ELSE
            Distances(i,1:n)=vals( 1 : n )
            Distances(i,2)=n-2   !Anzahl der Nachbarn
        END IF

        READ( 11, "(a)",IOSTAT=ierror1) line
        IF(ierror1 < 0) EXIT
        IF(ierror1 > 0) THEN
            WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(neighbourlistfile),' aufgetreten.'
            WRITE(*,*) 'Beende Einlesen !'
            STOP
        END IF
        CALL split( line, vals, n )
        if ( n == 0 ) then
            WRITE(*,*) "comment line: "//TRIM(line)
        else
            Res_NN(i,1:n)=nint( vals( 1 : n ) )
            Res_NN(i,2)=n-2 !Anzahl der Nachbarn 
        endif
END DO
CLOSE(11)

IF (sort_neighbour_list_data) THEN ! Sorts array with increasing Resids
    do j=1,N_Resids-1 ! Sortierung: Durchgehen der Resids     
            i_min=j
            DO i=j+1,N_Resids ! Durchgehen von B          
                IF( Res_NN(i,1) < Res_NN(i_min,1) ) THEN
                    i_min=i
                END IF
            END DO    
            IF( i_min /= j ) THEN ! tauschen
                j_end=Res_NN(j,2)+2          !obere arraygrenze, da nicht ganz befuellt
                i_end=Res_NN(i_min,2)+2       !obere arraygrenze, da nicht ganz befuellt
                int_dummyarray(1:j_end)=Res_NN(j,1:j_end) 
                Res_NN(j,1:i_end)=Res_NN(i_min,1:i_end) 
                Res_NN(i_min,1:j_end)=int_dummyarray(1:j_end)

                real_dummyarray(1:j_end)=Distances(j,1:j_end) 
                Distances(j,1:i_end)=Distances(i_min,1:i_end) 
                Distances(i_min,1:j_end)=real_dummyarray(1:j_end)              
            END IF           
    END DO

    ! Sort list for all distances
    Do m=1,N_Resids
        do j=3,Res_NN(m,2)+1  ! Neighbours  
            i_min=j
            DO i=j+1,Res_NN(m,2)+2 ! Durchgehen von B          
                IF( Distances(m,i) < Distances(m,i_min) ) THEN
                    i_min=i
                END IF
            END DO    
            IF( i_min /= j ) THEN ! tauschen
               int_dummy=Res_NN(m,j) 
               Res_NN(m,j)=Res_NN(m,i_min) 
               Res_NN(m,i_min)=int_dummy
               
               real_dummy=Distances(m,j) 
               Distances(m,j)=Distances(m,i_min) 
               Distances(m,i_min)=real_dummy
               !WRITE(*,*) 'SWAPED',Res_NN(m,j),Distances(m,j),Res_NN(m,i_min),Distances(m,i_min)
            END IF           
        END DO 
    END DO ! N_Resids
    ! Ende tauschen, abstandssortierung
END IF ! sort_neighbour_list_data

IF (DEBUG) THEN ! write neighbour list 
    Do i=1,N_Resids
        WRITE(*,*) Distances(i,1:int(Distances(i,2))+2)
        WRITE(*,*) Res_NN(i,1:Res_NN(i,2)+2)
    END DO 
END IF ! DEBUG

END SUBROUTINE read_neighbours

subroutine split( line, vals, n )
    implicit none
    character(*), intent(in) :: line
    real*8  :: vals(*), buf( 50000 )
    integer :: n

    n = 1
    do
        read( line, *, end=100, Err=100 ) buf( 1 : n )   !! (See Appendix for why buf is used here)
        vals( 1:n ) = buf( 1:n )
        n = n + 1
    end do
100 continue
    n = n - 1
end subroutine split



SUBROUTINE lambda_out_dE_out_from_xyz_q_n_el_lo(resid1,resid2,N_Resids,RundI,koord,&
    &q_n_el_lo,Neighbours,N_Neighbours,x_box,y_box,z_box,r_cut,lambda_out_filename_el,lambda_out_filename_lo,foldername) !
! Verwende Konvention erst geladene Molekuele mit Resid1 und Resid2
! Resid1 charged
! Resid2 charged
! Resid1 neutral
! Resid2 neutral
! Nachbarn neutral
! lambda_out=aeussere Reoraganisationsenergie, c_p=Pekar factor, E_out_el_i= elektrostatische Energie(je nach Einlesefile fuer Elektronen oder Loecher)
! epsilon_opt= hight(optical) frequency permittivity
! epsilon_s= low (static) frequency permittivity
! epsilon_0= vacuum permittivitiy
! V3 mit screening function
! s = screening length in screening funciton epsilon(r)
! epsilon_screening{ r_(ai,bk) }=epsilon_s-(epsilon_s-1.0)*(1+s*r+0.5*(s**2)*(r**2))*exp(-s*r)   ! r Abstand 
use small_functions
IMPLICIT NONE
Real, ALLOCATABLE, Dimension(:,:)      , INTENT(IN) :: koord,q_n_el_lo
INTEGER, ALLOCATABLE, Dimension(:,:)   , INTENT(IN) :: RundI ! Resid,Index_fuer_molekuelstart
INTEGER, ALLOCATABLE, Dimension(:)     , INTENT(IN) :: Neighbours
INTEGER , INTENT(IN)  ::resid1,resid2,N_neighbours
INTEGER , INTENT(IN)  ::N_Resids
REAL,     INTENT(IN)  ::x_box,y_box,z_box,r_cut ! Radius der Integrationskugel in Angstroem
CHARACTER (LEN=500), INTENT(IN) ::foldername,lambda_out_filename_el,lambda_out_filename_lo


INTEGER::i,j,k,m,o,ierror1,N_coord_ges
REAL,DIMENSION(3)::summe_el_ai,summe_el_aj,summe_lo_ai,summe_lo_aj,diff_r
REAL*8, PARAMETER::PI=4.D0*DATAN(1.D0)
REAL*8, PARAMETER::Einheitenfaktor=1.6021766208D3 !umrechenfaktor elementarladung*10^22
REAL::lambda_out_el,dE_out_el_ij,E_out_el_i,E_out_el_j,epsilon_opt,epsilon_s,epsilon_0,c_p
REAL::lambda_out_lo,dE_out_lo_ij,E_out_lo_i,E_out_lo_j,dE_out_lo_ij_screening,E_out_lo_i_screening,E_out_lo_j_screening
REAL::r, s,epsilon_screening,dE_out_el_ij_screening,E_out_el_i_screening,E_out_el_j_screening ! screening function variables
INTEGER, ALLOCATABLE, Dimension(:,:):: Start_index
INTEGER, ALLOCATABLE, Dimension(:)  :: NAtoms_list
REAL, ALLOCATABLE, Dimension(:) :: diff_q_el_ai,diff_q_el_aj,diff_q_lo_ai,diff_q_lo_aj
LOGICAL::Datei_vorhanden,Kugelvolumen,Debug=.false.,screening_function,resid1_da,resid2_da
INTEGER::resid_offset

WRITE(*,*) 'Start lambda_out'

! Startparameter
screening_function=.true.

! r_cut=15.0 ! Radius der Integrationskugel in Angstroem

epsilon_opt=3.5   ! 2.75 ! Alq3
epsilon_s=3.0     ! 2.82 ! Alq3
epsilon_0=8.854187817620 !E-12 C/(V*m)
c_p=((1/real(epsilon_opt))-(1/real(epsilon_s))) ! Pekar factor

s=0.13 ! in Angstroem**-1 / screening laenge in Adrienko-Paper fur Alq3 (0.3 Ang**-1) in H20

epsilon_screening=0

IF(abs(r_cut)==0) THEN
    Kugelvolumen=.false.
    WRITE(*,*) 'Use box volume with:',x_box,y_box,z_box
ELSE
   Kugelvolumen=.true.
   WRITE(*,*) 'Use sphere cutoff radius:',r_cut
END IF

IF( Debug) THEN
    resid_offset=1
    j=resid1+resid_offset ! +1 offset
    WRITE(*,*) 'Resid1:', j-1, koord(RundI(j,2),1),koord(RundI(j,2),2),koord(RundI(j,2),3),&
				&q_n_el_lo(RundI(j,2),1),q_n_el_lo(RundI(j,2),2),q_n_el_lo(RundI(j,2),3)
    j=resid2+resid_offset
    WRITE(*,*) 'Resid2:', j-1, koord(RundI(j,2),1),koord(RundI(j,2),2),koord(RundI(j,2),3),q_n_el_lo(RundI(j,2),:)
END IF 

IF ( Allocated(NAtoms_list))  DEALLOCATE(NAtoms_list) 
IF ( Allocated(Start_index))  DEALLOCATE(Start_index) 
ALLOCATE(NAtoms_list(N_Neighbours+4),Start_index(N_Neighbours+4,2)) ! Startindex fuer (resid1_el/lo,resid1_n,resid1_el/lo,resid2_n,Nachbarn..1_bis N_Nachbarn => 4 Optionen ,[Start=1,Ende=2])
NAtoms_list=0
Start_index=0
N_coord_ges=0
! Schleife zur Uebergabe der Startindizes
resid1_da=.false.
resid2_da=.false.
j=1  ! Nachbarn hochzaehlen
k=4 !Startindex

! Nach der Schleife sind die Nachbarn in der Reihenfolge der Resids aufsteigend sortiert!
DO i=1,N_Resids
   DO j=1,N_Neighbours
    IF( RundI(i,1) == Neighbours(j) ) THEN !Resids der Nachbarn
        k=k+1
        NAtoms_list(k)=RundI(i+1,2)-RundI(i,2) !Nachbarn neutral
        Start_index(k,1)=RundI(i,2)     !Start
        Start_index(k,2)=RundI(i+1,2)-1 !Ende
        N_coord_ges=N_coord_ges+NAtoms_list(k)
	EXIT 
    ELSE IF ((.NOT. resid1_da) .AND. RundI(i,1) == resid1) THEN
        NAtoms_list(1)=RundI(i+1,2)-RundI(i,2) ! fuer geladene Resid
        Start_index(1,1)=RundI(i,2) 
        Start_index(1,2)=RundI(i+1,2)-1 ! Ende
        NAtoms_list(3)=NAtoms_list(1)  !neutral
        Start_index(3,1)=Start_index(1,1)
        Start_index(3,2)=Start_index(1,2) ! Ende 
        N_coord_ges=N_coord_ges+NAtoms_list(1)
        resid1_da=.true.
    ELSE IF ((.NOT. resid2_da) .AND. RundI(i,1) == resid2) THEN
        NAtoms_list(2)=RundI(i+1,2)-RundI(i,2)  ! fuer geladene Resid
        Start_index(2,1)=RundI(i,2) 
        Start_index(2,2)=RundI(i+1,2)-1 ! Ende 
        NAtoms_list(4)=NAtoms_list(2) !neutral
        Start_index(4,1)=Start_index(2,1) 
        Start_index(4,2)=Start_index(2,2) ! Ende 
        N_coord_ges=N_coord_ges+NAtoms_list(2)
        resid2_da=.true.
    END IF
   END DO ! j-> 1,N_Neighbours
   IF( resid1_da .AND. resid2_da .AND.(k == N_Neighbours+4) ) THEN
	WRITE(*,*) 'EXIT: ',resid1_da,resid2_da,k
	EXIT
   END IF
END DO ! i ->1,N_Resids



IF(debug) THEN
   WRITE(*,*) 'Neighbours:',Neighbours(1:N_Neighbours)
    DO i=1,N_Neighbours+4
	WRITE(*,*) 'Start_index: ',Start_index(i,:),' NAtoms_list: ',NAtoms_list(i)
    END DO 
    WRITE(*,*) 'N_coord_ges:',N_coord_ges,'N_resid1:',NAtoms_list(1),'N_resid2:',NAtoms_list(2)
END IF
ALLOCATE(diff_q_el_ai(NAtoms_list(1)))
ALLOCATE(diff_q_el_aj(NAtoms_list(2)))

ALLOCATE(diff_q_lo_ai(NAtoms_list(1)))
ALLOCATE(diff_q_lo_aj(NAtoms_list(2)))


!Berechne Differenzen q_el - q_n
DO i=0,(NAtoms_list(1)-1),1
    diff_q_el_ai(i+1)=q_n_el_lo(Start_index(1,1)+i,2)-q_n_el_lo(Start_index(3,1)+i,1)
    WRITE(*,*) 'diff:',diff_q_el_ai(i+1),q_n_el_lo(Start_index(1,1)+i,2),q_n_el_lo(Start_index(3,1)+i,1)
END DO
!Berechne Differenzen ! q_n -q_el
DO i=0,(NAtoms_list(2)-1),1   ! q_n -q_el
    diff_q_el_aj(i+1)=q_n_el_lo(Start_index(4,1)+i,1)-q_n_el_lo(Start_index(2,1)+i,2)
END DO


!Berechne Differenzen
DO i=0,(NAtoms_list(1)-1),1 ! q_lo -q_n
    diff_q_lo_ai(i+1)=q_n_el_lo(Start_index(1,1)+i,3)-q_n_el_lo(Start_index(3,1)+i,1)
END DO

DO i=0,(NAtoms_list(2)-1),1 ! q_n -q_lo
    diff_q_lo_aj(i+1)=q_n_el_lo(Start_index(4,1)+i,1)-q_n_el_lo(Start_index(2,1)+i,3)    
END DO


epsilon_screening=1.0
lambda_out_el=0.0
E_out_el_i=0.0
E_out_el_j=0.0
E_out_el_i_screening=0.0
E_out_el_j_screening=0.0

lambda_out_lo=0.0
E_out_lo_i=0.0
E_out_lo_j=0.0
E_out_lo_i_screening=0.0
E_out_lo_j_screening=0.0

DO m=1,N_Neighbours ! Alles Nachbarn
   ! startindex der Nachbarn (m+4,1) , Endindex der nachbarn (m+4,2)
DO k=Start_index(m+4,1),Start_index(m+4,2),1 ! summe b_k alles Nachbaratome der Nachbarmolekuele in der Liste (k  traegt den Zugriffsindex
    summe_el_ai=0.0
    summe_el_aj=0.0
    summe_lo_ai=0.0
    summe_lo_aj=0.0
    
    ! summe ueber a_i
    DO i=0,(NAtoms_list(1)-1),1  ! summe a_i
         DO o=1,3,1           
             diff_r(o)= koord(k,o)-koord(Start_index(1,1)+i,o) ! diff_r=r_bk - r_ai
         END DO
         r=norm(diff_r(:)) ! abs( r_bk - r_ai) 
         summe_el_ai(:)=summe_el_ai(:)+diff_q_el_ai(i+1)*diff_r(:)/r**3
         E_out_el_i=E_out_el_i+diff_q_el_ai(i+1)*q_n_el_lo(k,2)/r
         
         summe_lo_ai(:)=summe_lo_ai(:)+diff_q_lo_ai(i+1)*diff_r(:)/r**3
         E_out_lo_i=E_out_lo_i+diff_q_lo_ai(i+1)*q_n_el_lo(k,3)/r
         
         IF (screening_function) THEN ! screening_function
            epsilon_screening=epsilon_s-(epsilon_s-1.0)*(1+s*r+0.5*(s**2)*(r**2))*exp(-1.0*s*r)
            E_out_el_i_screening=E_out_el_i_screening+diff_q_el_ai(i+1)*q_n_el_lo(k,2)/(r*epsilon_screening)
            E_out_lo_i_screening=E_out_lo_i_screening+diff_q_lo_ai(i+1)*q_n_el_lo(k,3)/(r*epsilon_screening)
            
            !IF (  k >= 0.998*N_coord_ges ) THEN ! (i==1) THEN !
                !write(*,*) k, epsilon_screening,E_out_el_i,E_out_el_i_screening,E_out_lo_i,E_out_lo_i_screening!r,(1+s*r+0.5*(s**2)*(r**2)),exp(-1.0*s*r)
            !END IF
         END IF ! screening_function
    END DO !a_i

    DO j=0,(NAtoms_list(2)-1),1 ! summe a_j
        DO o=1,3,1              ! diff_r=r_bk - r_aj
            diff_r(o)= koord(k,o)-koord(Start_index(2,1)+j,o)
        END DO
        r=norm(diff_r(:)) ! abs( r_bk - r_aj)
        summe_el_aj(:)=summe_el_aj(:)+diff_q_el_aj(j+1)*diff_r(:)/r**3
        E_out_el_j=E_out_el_j+diff_q_el_aj(j+1)*q_n_el_lo(k,2)/r
 
        summe_lo_aj(:)=summe_lo_aj(:)+diff_q_lo_aj(j+1)*diff_r(:)/r**3
        E_out_lo_j=E_out_lo_j+diff_q_lo_aj(j+1)*q_n_el_lo(k,3)/r

        IF (screening_function) THEN ! screening_function
            epsilon_screening=epsilon_s-(epsilon_s-1.0)*(1+s*r+0.5*(s**2)*(r**2))*exp(-1.0*s*r)
            E_out_el_j_screening=E_out_el_j_screening+diff_q_el_aj(j+1)*q_n_el_lo(k,2)/(r*epsilon_screening)
            E_out_lo_j_screening=E_out_lo_j_screening+diff_q_lo_aj(j+1)*q_n_el_lo(k,3)/(r*epsilon_screening)
        END IF ! screening_function    
    END DO !a_j
    lambda_out_el=lambda_out_el+norm(summe_el_ai(:)+summe_el_aj(:))**2
    lambda_out_lo=lambda_out_lo+norm(summe_lo_ai(:)+summe_lo_aj(:))**2
    IF( isnan(lambda_out_el) .or. isnan(lambda_out_lo) ) THEN ! Test fuer Bug mit NaN
        WRITE(*,*) 'Fehler: NaN'
        WRITE(*,*) ' lambda_out_el',lambda_out_el,'lambda_out_lo',lambda_out_lo,' in ',TRIM(foldername)
        WRITE(*,*) ' norm(diff_r(:))', norm(diff_r(:))
        WRITE(*,*) ' summe_el_ai(:)',summe_el_ai(:),' summe_lo_ai(:)',summe_lo_ai(:)
        WRITE(*,*) ' summe_el_aj(:)',summe_el_aj(:),' summe_lo_aj(:)',summe_lo_aj(:)
        WRITE(*,*) 'diff_r(:)',diff_r(:)
        WRITE(*,*) 'E_out_el_i',E_out_el_i,'E_out_lo_i',E_out_lo_i
        WRITE(*,*) 'E_out_el_j',E_out_el_j,'E_out_lo_j',E_out_lo_j
        WRITE(*,*) 'FEHLER: k=',k ! Index der Nachbaratome
        STOP 
    END IF    
END DO ! k-summe  D_I(r_bk) -D_F(r_bk)

END DO ! m- array to run over all atoms in the Neighbours-list

IF( Kugelvolumen) THEN
    lambda_out_el=lambda_out_el*c_p/(8.0*epsilon_0*PI)*(4.0*PI*r_cut**3/(3.0*(N_coord_ges-NAtoms_list(1)-NAtoms_list(2))) )  ! 2.Faktor als Kugelvolumen fuer die Integration 4Pi*r^3/3* 1/(Anzahl der Nachbarn/Integrationspunkte) = INT_V_{out} dV 
    lambda_out_el=lambda_out_el*Einheitenfaktor !Umrechnung auf eV
    
    lambda_out_lo=lambda_out_lo*c_p/(8.0*epsilon_0*PI)*(4.0*PI*r_cut**3/(3.0*(N_coord_ges-NAtoms_list(1)-NAtoms_list(2))) )  ! 2.Faktor als    Kugelvolumen fuer die Integration 4Pi*r^3/3* 1/(Anzahl der Nachbarn/Integrationspunkte) = INT_V_{out} dV 
    lambda_out_lo=lambda_out_lo*Einheitenfaktor !Umrechnung auf eV
ELSE
    lambda_out_el=lambda_out_el*c_p/(8.0*epsilon_0*PI)*(x_box*y_box*z_box/(N_coord_ges-NAtoms_list(1)-NAtoms_list(2)) )  ! 2.Faktor als Boxvolumen  x_box*y_box*z_box /N_coord_ges-NAtoms_list(1)-NAtoms_list(2)  = INT_V_{out} dV  Mit dem Mittelwertsatz der Integralrechnung
    lambda_out_el=lambda_out_el*Einheitenfaktor !Umrechnung auf eV
    
    lambda_out_lo=lambda_out_lo*c_p/(8.0*epsilon_0*PI)*(x_box*y_box*z_box/(N_coord_ges-NAtoms_list(1)-NAtoms_list(2)) )  ! 2.Faktor als Boxvolumen  x_box*y_box*z_box /N_coord_ges-NAtoms_list(1)-NAtoms_list(2)  = INT_V_{out} dV  Mit dem Mittelwertsatz der Integralrechnung
    lambda_out_lo=lambda_out_lo*Einheitenfaktor !Umrechnung auf eV
END IF


dE_out_el_ij=(E_out_el_i-E_out_el_j)/(4.0*PI*epsilon_0*epsilon_s)
dE_out_el_ij=dE_out_el_ij*Einheitenfaktor  !Umrechnung auf eV

dE_out_lo_ij=(E_out_lo_i-E_out_lo_j)/(4.0*PI*epsilon_0*epsilon_s)
dE_out_lo_ij=dE_out_lo_ij*Einheitenfaktor  !Umrechnung auf eV

IF ( screening_function) THEN ! use screening_function epsilon_(r)
    dE_out_el_ij_screening=(E_out_el_i_screening-E_out_el_j_screening)/(4.0*PI*epsilon_0)
    dE_out_el_ij_screening=dE_out_el_ij_screening*Einheitenfaktor  !Umrechnung auf eV
    
        
    dE_out_lo_ij_screening=(E_out_lo_i_screening-E_out_lo_j_screening)/(4.0*PI*epsilon_0)
    dE_out_lo_ij_screening=dE_out_lo_ij_screening*Einheitenfaktor  !Umrechnung auf eV
END IF ! screening_function

WRITE(*,*) '------------------ Results ------------------'
write(*,*) 'Die Reorganisationsenergie_out ist: '
write(*,*) 'lambda_out_el [eV] =', lambda_out_el
write(*,*) 'lambda_out_lo [eV] =', lambda_out_lo
WRITE(*,*) 'dE_out_el_ij  [eV] =',dE_out_el_ij
WRITE(*,*) 'dE_out_lo_ij  [eV] =',dE_out_lo_ij
IF ( screening_function) THEN ! use screening_function epsilon_(r)
    WRITE(*,*) 'dE_out_el_ij_screening [eV]=',dE_out_el_ij_screening
    !write(*,*) E_out_el_i_screening,E_out_el_j_screening
    WRITE(*,*) 'dE_out_lo_ij_screening [eV]=',dE_out_lo_ij_screening
END IF ! screening_function
WRITE(*,*) '---------------------------------------------'

       

inquire(file=TRIM(lambda_out_filename_el),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.        
IF (Datei_vorhanden) then
    OPEN(UNIT=28,FILE=lambda_out_filename_el,STATUS='unknown',IOSTAT=ierror1,action='write',position="append")
        IF ( .NOT. screening_function) THEN
            write(28,'(1X,2F12.8,2X,A100)') lambda_out_el, dE_out_el_ij, TRIM(foldername)
        ELSE 
            write(28,'(1X,3F12.8,2X,A100)') lambda_out_el, dE_out_el_ij, dE_out_el_ij_screening, TRIM(foldername) 
        END IF 
    CLOSE(28)
ELSE 
    OPEN(UNIT=28,FILE=lambda_out_filename_el,STATUS='unknown',IOSTAT=ierror1,action='write')
        IF ( .NOT. screening_function) THEN
            WRITE(28,*) '##### lambda_out_el, dE_out_el_ij  [eV] mit r_cut=',r_cut,' '//TRIM(foldername) 
            write(28,'(1X,2F12.8,2X,A100)') lambda_out_el, dE_out_el_ij, TRIM(foldername)
        ELSE 
            WRITE(28,*) '##### lambda_out_el, dE_out_el_ij, dE_out_el_ij_screening [eV] mit r_cut=',r_cut,' '//TRIM(foldername) 
            write(28,'(1X,3F12.8,2X,A100)') lambda_out_el, dE_out_el_ij, dE_out_el_ij_screening, TRIM(foldername) 
        END IF 
    CLOSE(28)
end if

inquire(file=TRIM(lambda_out_filename_lo),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.        
IF (Datei_vorhanden) then
    OPEN(UNIT=29,FILE=lambda_out_filename_lo,STATUS='unknown',IOSTAT=ierror1,action='write',position="append")
    IF ( .NOT. screening_function) THEN
        write(29,'(1X,2F12.8,2X,A100)') lambda_out_lo, dE_out_lo_ij, TRIM(foldername)
    ELSE 
        write(29,'(1X,3F12.8,2X,A100)') lambda_out_lo, dE_out_lo_ij, dE_out_lo_ij_screening, TRIM(foldername) 
    END IF 
    CLOSE(29)
ELSE 
    OPEN(UNIT=29,FILE=lambda_out_filename_lo,STATUS='unknown',IOSTAT=ierror1,action='write')
    IF ( .NOT. screening_function) THEN
        WRITE(29,*) '##### lambda_out_lo, dE_out_lo_ij, [eV] mit r_cut=',r_cut,' '//TRIM(foldername) 
        write(29,'(1X,2F12.8,2X,A100)') lambda_out_lo, dE_out_lo_ij, TRIM(foldername)
    ELSE 
        WRITE(29,*) '##### lambda_out_lo, dE_out_lo_ij, dE_out_lo_ij_screening [eV] mit r_cut=',r_cut,' '//TRIM(foldername) 
        write(29,'(1X,3F12.8,2X,A100)') lambda_out_lo, dE_out_lo_ij, dE_out_lo_ij_screening, TRIM(foldername) 
    END IF 
    CLOSE(29) 
END IF

DEALLOCATE(diff_q_lo_aj)
DEALLOCATE(diff_q_lo_ai)
DEALLOCATE(diff_q_el_aj)
DEALLOCATE(diff_q_el_ai)
DEALLOCATE(Start_index,NAtoms_list)

STOP 'ENDE EINES DURCHLAUFS'
END SUBROUTINE lambda_out_dE_out_from_xyz_q_n_el_lo



SUBROUTINE read_all_coords_from_gro(Resid_start_ind,residue_names,atomsorteA,koordA,vel,N_Resids,&
                                    &Gesamtanzahl,x_box,y_box,z_box,gro_inputfile)
! Einlesen aus der .gro Datei und Umrechnung in .xyz Format (Ang)
	use small_functions
Character(5), ALLOCATABLE, Dimension(:), INTENT(OUT) :: atomsorteA,residue_names
Real, ALLOCATABLE, Dimension(:,:), INTENT(OUT) :: koordA,vel
INTEGER, ALLOCATABLE, Dimension(:,:), INTENT(OUT) :: Resid_start_ind
Character(500), INTENT (IN) :: gro_inputfile
INTEGER, INTENT(OUT)::N_Resids,Gesamtanzahl
REAL, INTENT (OUT)::x_box,y_box,z_box
Character(500) ::dummyname
CHARACTER(10000)::bashline
Character(5) :: residue_name,lio
!Character(5) :: atom
INTEGER::i,j,ierror,residue_number,residue_number_old,atom_number,start_index,end_index
!REAL::x,y,z,v_x,v_y,v_z

! Einlesen
IF (file_exists(gro_inputfile)) THEN
    OPEN(UNIT=17,FILE=TRIM(gro_inputfile),STATUS='OLD',IOSTAT=ierror)
END IF
Read(17,*) dummyname                             !Einlesen des Infokopfes im File
Read(17,*) Gesamtanzahl                          !Einlesen der Atomanzahl im File

    !!! Erstelle String lio=Durcheinander, um die Rechnungen mit Hilfe von Zufallszahlen einzigartig zu machen, sodass keine Interferenzen mit anderen Rechnungen ggf. im gleichen Ordner auftreten koennen. 
    lio=TRIM(make_lio())
    !! Einlesen der Anzahl der Resids=N_Mol aus gro-file
    Bashline="start_index=$(sed -n '3p' "//TRIM(gro_inputfile)//' | cut -c 1-5) ; end_index=$(tail -2 '//TRIM(gro_inputfile)//&
    &' | head -1 | cut -c 1-5) ; echo ${start_index}  ${end_index} >> s2e_'//TRIM(lio)//'.dat'  ! start 2 end 
    CALL execute_command_line(TRIM(Bashline)) 
    OPEN(UNIT=31,FILE='s2e_'//TRIM(lio)//'.dat',STATUS='unknown',IOSTAT=ierror,action='read')
    READ(31,*) start_index,end_index
    CLOSE(31)
    Bashline=' rm s2e_'//TRIM(lio)//'.dat '
    CALL execute_command_line(TRIM(Bashline)) 

    N_Resids=end_index-start_index+1
    WRITE(*,*)' N_Resids= ',N_Resids,' in ',TRIM(gro_inputfile)

ALLOCATE(atomsorteA(Gesamtanzahl))
ALLOCATE(koordA(Gesamtanzahl,3))
ALLOCATE(vel(Gesamtanzahl,3))  ! velocities(:,v_x,v_y,v_z)
ALLOCATE(Resid_start_ind(N_Resids+1,2)) ! einen Eintrag mehr, damit an der letzten Stelle, der Resid_start_ind(N_Resids,Gesamtanzahl+1,2) stehen kann, um die Schleifenbegrenzungen nicht anpassen zu muessen

ALLOCATE(residue_names(N_Resids))
koordA=0.0
vel=0.0
Resid_start_ind=0
Resid_start_ind(N_Resids+1,1)=-100
Resid_start_ind(N_Resids+1,2)=Gesamtanzahl+1
residue_number_old=-1
i=0
DO j=1,Gesamtanzahl
    Read(17,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) residue_number,residue_name,atomsorteA(j),atom_number,&
                                            &koordA(j,1),koordA(j,2),koordA(j,3),vel(j,1),vel(j,2),vel(j,3)
    !WRITE(*,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) residue_number,residue_name,atomsorteA(j),atom_number,&
    !                                        &koordA(j,1),koordA(j,2),koordA(j,3),vel(j,1),vel(j,2),vel(j,3)
    IF(ierror < 0) EXIT
    IF(ierror > 0) THEN
        WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(gro_inputfile),' aufgetreten.'
        WRITE(*,*) 'Beende Einlesen !'
        STOP
    END IF
    if (residue_number /= residue_number_old ) THEN
        i=i+1
        Resid_start_ind(i,1)=residue_number
        Resid_start_ind(i,2)=j
        residue_names(i)=residue_name
        residue_number_old=residue_number
    END IF
    IF( i == N_Resids+1) EXIT
    IF (i==0 .and. j==Gesamtanzahl ) THEN
       write(*,*) ' Error: Es ist ein Fehler beim Einlesen ausgetreten: '//TRIM(gro_inputfile)
       write(*,*) ' ENDE '
       STOP
   END IF  
END DO
Read(17,*,IOSTAT=ierror) x_box,y_box,z_box
IF( ierror > 0) STOP 'Error: Reading_the_boxsize'
CLOSE(17)
koordA(:,:)=koordA(:,:)*10.0 ! Umrechnung von nm (.gro-Format) nach Angstroem (.xyz-Format)
vel=vel*10.0 ! Umrechnung nach Angstroem 
x_box=x_box*10.0 ! Umrechnung nach Angstroem 
y_box=y_box*10.0 ! Umrechnung nach Angstroem 
z_box=z_box*10.0 ! Umrechnung nach Angstroem 


END SUBROUTINE read_all_coords_from_gro


!!!!==================================================!!!!!!!!!!
!!!!  Ende:       lambda_out_dE_out                   !!!!!!!!!!
!!!!==================================================!!!!!!!!!!



!!!!!!!!!!!!!!! Ewald t_koch08 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE Ewald_lambda_out_dE_out_from_xyz_q_n_el_lo(resid1,resid2,N_Resids,Gesamtanzahl,RundI,koord,&
  &  q_n_el_lo,Neighbours,N_Neighbours,x_box,y_box,z_box,r_cut,lambda_out_filename_el,lambda_out_filename_lo,foldername)
	use small_functions
	IMPLICIT NONE
	Real, ALLOCATABLE, Dimension(:,:)      , INTENT(IN) :: koord,q_n_el_lo
	INTEGER, ALLOCATABLE, Dimension(:,:)   , INTENT(IN) :: RundI ! Resid,Index_fuer_molekuelstart
	INTEGER, ALLOCATABLE, Dimension(:)     , INTENT(IN) :: Neighbours
	INTEGER , INTENT(IN)  ::resid1,resid2,N_neighbours
	INTEGER , INTENT(IN)  ::N_Resids,Gesamtanzahl
	REAL,     INTENT(IN)  ::x_box,y_box,z_box,r_cut ! Radius der Integrationskugel in Angstroem
	CHARACTER (LEN=500), INTENT(IN) ::foldername,lambda_out_filename_el,lambda_out_filename_lo
!	Real, ALLOCATABLE, Dimension(:,:)      :: koord,q_n_el_lo
!	INTEGER, ALLOCATABLE, Dimension(:,:)   :: RundI ! Resid,Index_fuer_molekuelstart
!	INTEGER, ALLOCATABLE, Dimension(:)     :: Neighbours
!	INTEGER   ::resid1,resid2,N_neighbours
!	INTEGER   ::N_Resids,Gesamtanzahl
!	REAL     ::x_box,y_box,z_box,r_cut ! Radius der Integrationskugel in Angstroem

	! U_coulomb = U_short_range + U_long_range - U_self
	REAL*8::U_coul ! U_coulomb 
	REAL*8::U_sr ! U_short_range
	REAL*8::U_lr,U_lr_old ! U_long_range
	REAL*8::U_se ! U_long_self
   	REAL*8, PARAMETER::PI=4.D0*DATAN(1.D0)
	INTEGER::i,j,o,ind,n_box_shells,n_boxes_max,n_box_shell
	! INTEGER:: N_coord_ges
 	REAL::alpha,sqrt_alpha,alpha_opt,dU_lr_cutoff ! for convergence PARAMETER
	REAL*8::dist,k2,kR,summe,summe_im,prefactor
   	REAL::V_box
   	REAL, ALLOCATABLE, Dimension(:,:,:)  :: dist_q_ij_arr
	! helpbox with all indizes to address neighbouring boxes

   	INTEGER, DIMENSION (3,26) :: hbox= reshape( (/1,0,0,0,1,0,0,0,1,-1,0,0,0,-1,0,0,0,-1,&
                                    & 1,1,1,1,1,0,1,0,1,0,1,1,-1,-1,-1,-1,-1,0,-1,0,-1,0,-1,-1,&  
                                    &  -1,1,1,1,-1,1,1,1,-1,-1,1,0,1,-1,0,-1,0,1,1,0,-1,0,-1,1,0,1,-1,&
                                    & -1,1,-1,-1,-1,1,1,-1,-1 /),(/3,26/))
   	REAL, DIMENSION(3)::vbox,kbox,b1,b2,b3
   	LOGICAL:: U_lr_concerged,DEBUG=.FALSE.
	
	IF(DEBUG) THEN
		write(*,*) "Caution: Poor implementation => Does not converge... as expected..."
		write(*,*) 'Parameters not used.'
		write(*,*) 'Start EWald summation for ',resid1,' and ',resid2
		write(*,*) 'N_Resids:',N_Resids
		write(*,*) 'r_cut:',r_cut
		write(*,*) 'N_Neighbours:',N_Neighbours
		write(*,*) 'Neighbours(1):',Neighbours(1),'  last: ',Neighbours(size(Neighbours))
		write(*,*) 'lambda_out_filename_el: ',trim(lambda_out_filename_el)
		write(*,*) 'lambda_out_filename_lo: ',trim(lambda_out_filename_lo)
		write(*,*) 'foldername: ',trim(foldername)
		write(*,*) '--- hbox directions ---'
		DO i=1,26
			WRITE(*,*) hbox(1,i),hbox(2,i),hbox(3,i)
		END DO
	END IF ! DEBUG


   alpha=1.0 ! for convergence 
   dU_lr_cutoff=1.0E5 

   sqrt_alpha=SQRT(alpha)
   n_box_shells=5
   n_boxes_max=1+26*n_box_shells ! oder 27 fure alles naechsten nachbarn 
   
   !! Boxvolume
   V_box= x_box * y_box * z_box
   !!! reciprocal space vectors
   b1 = (/ (y_box * z_box / V_box) , 0.0,0.0 /)
   b2 = (/  0.0,(x_box * z_box / V_box) ,0.0 /)
   b3 = (/ 0.0 ,0.0, (x_box * y_box / V_box) /)
   
   alpha_opt= sqrt(PI)*(Gesamtanzahl/V_box**2)**(real(1.0/6.))
   
   WRITE(*,*) 'alpha_opt: ',alpha_opt,' alpha: ',alpha
   !!! dist_q_ij_arr(o,i,j)  o =={dx,dy,dz, q_i*q_j }
   WRITE(*,*) Gesamtanzahl,'   ',Gesamtanzahl**2
   ALLOCATE(dist_q_ij_arr(1,Gesamtanzahl,Gesamtanzahl))
   dist_q_ij_arr=0.0
   
   
   !!!!! Short range summation
   U_sr=0.0
	DO n_box_shells=0,n_boxes_max-1
      IF (n_box_shells /= 0) THEN
         ind=mod(n_box_shells-1,26)+1
         n_box_shell=((n_box_shells-1)/26)+1
         vbox(1)=hbox(1,ind)*x_box*n_box_shell
         vbox(2)=hbox(2,ind)*y_box*n_box_shell
         vbox(3)=hbox(3,ind)*z_box*n_box_shell
      ELSE !n_box_shell 
         vbox=  (/0,0,0/) ! Zentrum 
         ind=0
         n_box_shell=0
      END IF
      WRITE(*,*) n_box_shell,ind,n_box_shell,' -- ',vbox
		DO i=1,Gesamtanzahl
			DO j=1,Gesamtanzahl
				IF( i == j) CYCLE
               dist = norm(koord(RundI(i,2),:)-koord(RundI(j,2),:)+vbox)		
               IF(n_box_shells == 0) THEN ! save distances in first box to array for faster access
                     DO o=1,3
                        dist_q_ij_arr(o,i,j)=koord(RundI(i,2),o)-koord(RundI(j,2),o)
                     END DO
                     dist_q_ij_arr(4,i,j)=q_n_el_lo(RundI(i,2),1) * q_n_el_lo(RundI(j,2),1)     
               END IF
               U_sr = U_sr + dist_q_ij_arr(4,i,j) * erfc(sqrt_alpha*dist)/dist   ! noch beide neutral !!!!
			END DO !j
		END DO ! i
	END DO ! n_boxes

	U_sr = 0.5*U_sr

   U_se=0.0
   DO i=1,Gesamtanzahl   
      U_se = U_se + q_n_el_lo(RundI(i,2),1)**2   ! q_i**2 noch beide neutral !!!!
   END DO
   U_se= SQRT(alpha/PI)*U_se


   n_boxes_max=3 ! 1E5 !
   ! Long-range   
   
   ! determine distance array
   
   
   U_lr=0.0
   U_lr_old=-100.0 ! random assignment 
   U_lr_concerged = .FALSE.
   
   Do n_box_shells=0,n_boxes_max ! loops all k
      IF (n_box_shells /= 0) THEN
         ind=mod(n_box_shells-1,26)+1
         n_box_shell=((n_box_shells-1)/26)+1
         kbox(1)=hbox(1,ind)*b1(1)*n_box_shell
         kbox(2)=hbox(2,ind)*b2(2)*n_box_shell
         kbox(3)=hbox(3,ind)*b3(3)*n_box_shell
         k2=norm(kbox)**2
         prefactor=exp(-k2/(4*alpha))/k2
      END IF !n_box_shell 
      summe=0
      summe_im=0
		DO i=1,Gesamtanzahl
			DO j=1,Gesamtanzahl
				IF( i == j) CYCLE
                kR=dot_product(kbox(1:3),dist_q_ij_arr(1:3,i,j))
                summe    = summe    + dist_q_ij_arr(4,i,j)  *cos(kR)     
                summe_im = summe_im + dist_q_ij_arr(4,i,j)  *sin(kR)   
			END DO !j
		END DO ! i
      summe = prefactor * SQRT( summe**2 + summe_im**2)
      U_lr = U_lr + summe
      
      !!! Exit Loop ???
      IF ( abs(U_lr-U_lr_old) < dU_lr_cutoff) THEN
            U_lr_concerged = .TRUE.
            EXIT
      END IF
      U_lr_old=U_lr
   END DO ! loop for k 
      
   U_lr = 2*PI/ V_box * U_lr   
      
	U_coul = U_sr + U_lr -U_se  ! U_coulomb = U_short_range + U_long_range - U_self
   
   
   WRITE(*,*) ' U_coul: ',U_coul
   WRITE(*,*) ' U_sr,U_lr,U_se:  ',U_sr,U_lr,U_se
   
   IF(U_lr_concerged) THEN
         WRITE(*,*) ' U_coul: ',U_coul
         WRITE(*,*) ' U_sr,U_lr,U_se:  ',U_sr,U_lr,U_se
   ELSE
      WRITE(*,*) 'Error: U_lr did not converge in the Ewald summation: ',U_lr
      STOP
   END IF
   
   
END SUBROUTINE Ewald_lambda_out_dE_out_from_xyz_q_n_el_lo
!!!!!!!!!!!!!!! Ewald t_koch08 !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!








!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!! EMultipoles / polarizabilities / Thole model 
!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!!!  /**
!!!   * Creates threads to work on individual segments
!!!   * ... Rigidifies + equips topology with polar sites
!!!   * ... Creates, starts threads
!!!   * ... Waits for threads to finish
!!!   */
SUBROUTINE EMultipole_EvaluateFrame(N_Atoms_all,N_Resids,Resid1,Resid2,RundI,residue_names,atomsorte,koord,&
                                    &Molname,Neighbourlist,N_NN_max,select_calc_molpol,box)
    IMPLICIT NONE
    ! DATA INPUT: 
    !gro Daten
    INTEGER :: N_Resids,N_Atoms_all,Resid1,Resid2,N_NN_max
    ! INPUT GLOBAL Arrays
    Character(5), Dimension(N_Atoms_all)                :: atomsorte,residue_names
    Character(500), Dimension(N_Atoms_all)              :: Molname 
    Real, Dimension(N_Atoms_all,3)                      :: koord
    INTEGER, Dimension(N_Resids,N_NN_max+2)             :: Neighbourlist ! (Resid, Number of nearest neighbours, NN1,NN2,NN..) ; 1 bis N_NN_max+2
    INTEGER, Dimension(N_Resids+1,2)                    :: RundI         !  Resid,Index_fuer_molekuelstart
    CHARACTER (LEN=500) :: select_calc_molpol
    REAL, DIMENSION(3)::box  ! box(xbox,ybox,zbox)   
    
    !!! GLOBAL ARRAYS (N_Atoms_all,3) => (1 = neutral , 2 = electron, 3 = hole ) 
    !!! pol_charge(:,3,Q00) !!!  (:,3) charge
    REAL, ALLOCATABLE,  DIMENSION(:,:)   ::pol_q00
    !!! pol_dip(:,3,Q1x,Q1y,Q1z) !!!  (:,3,3)  dipole
    REAL, ALLOCATABLE,  DIMENSION(:,:,:)  ::pol_dip
    !!! pol_quad(:,3,Q20,Q21c,Q21s,Q22c,Q22s) (:,3,5)  !!! quadrupole
    REAL, ALLOCATABLE,  DIMENSION(:,:,:)  ::pol_quad
    !!!  pol_alpha(P1) !!! polarizability_alpha  //  :,3) Dipole polarizability
    REAL, ALLOCATABLE,  DIMENSION(:,:)  :: pol_alpha  
    REAL, ALLOCATABLE,  DIMENSION(:)	:: pol_alpha_tmp ! temporeary array, to pass data to subroutine 
    !!! rank array global (:,3) 
    INTEGER,  ALLOCATABLE, DIMENSION(:,:)  :: pol_rank
    !!!
    !!! FP= Electric field (due to permanent), FU=Electric field (due to induced), U1ind=Induced dipole, History  (N_poles,3) 1=_x  2=_y 3=_z 
    REAL, ALLOCATABLE, Dimension(:,:)    :: pol_FP,pol_FU,pol_U1ind,pol_U1_Hist 
    !!! Arrays for the selection of atoms/sites which are transfered to subroutines, Arrays will be filled with data to N_poles but are allocated for all atoms with N_Atoms_all
    !!! I_poles(N_Atoms_all) selects the charged state (1 = neutral , 2 = anion  3 = cation )
    INTEGER, ALLOCATABLE, DIMENSION (:) ::I_poles,Iq_poles
    CHARACTER (LEN=800) :: GDMAfilepath,alphaOutFile
    INTEGER :: N_poles,NN_max,charges_select
    LOGICAL :: calcAlphaMol,doSystem,all_nearest_neighbbours,r_cut_neighbours
    LOGICAL :: KETTE=.false.,DEBUG=.false.,convert_angstroem_to_nm=.true.
    REAL, PARAMETER:: ANG_2_NM=10.0 ! convert angstroem to nm 
    INTEGER ::i,j,k,l
    
    REAL:: wSOR,eTOL,r_cut_NN
	
	r_cut_NN=15  !Angstroem Cutoff nearest neighbours / unused so far...
    wSOR=0.75    ! VOTCA default options.xmultipole.convergence _wSOR_C = 0.75, wSOR_N = 0.75
    eTOL=1.0E-3  !_epsTol = 0.001; tolerance
    
    GDMAfilepath='./MP_FILES' 
    alphaOutFile='my_alphaOutFile.dat'
    calcAlphaMol=.true.
    doSystem =.true.
    all_nearest_neighbbours=.false.
    r_cut_neighbours=.false.
    
    IF ( index(select_calc_molpol,'alpha') /= 0 ) THEN
            calcAlphaMol = .true.
    END IF
    
    IF ( (index(select_calc_molpol,'r_cut') /= 0) .OR. (index(select_calc_molpol,'r_cutoff') /= 0)   ) THEN
        r_cut_neighbours=.true.
    END IF
    
    IF ( index(select_calc_molpol,'all') /= 0 ) THEN
        doSystem =.true.
    END IF
    k=1
    WRITE(*,*) " tmp: ... ... ... Segment with Resid: ",RundI(k,1),' and index:',RundI(k,2) !TO DO Kill
	if(debug) then
		WRITE(*,*) 'tmp:',Neighbourlist(k,:)
		WRITE(*,*) 'tmp Molname(1): ',trim(Molname(1))   !! unused
		WRITE(*,*) 'tmp NAtoms: ',size(atomsorte)  !! unused
		WRITE(*,*) 'tmp: Resid1:',Resid1,'Resid2:',Resid2  !! unused
	endif
    ! 1. get frame geometry from gro
    
    ! 2. get neighbour list
    
    ! 3. get emultipole data form GDMA
 
    ! 4. calc alpha
 

    !N_Atoms_all=52  !Global
    !N_Resids=1
    
   ! ALLOCATE(RundI(N_Resids+1,2))
   ! ALLOCATE(residue_names(N_Resids))
    
    !residue_names(1)='Alq3'
    !RundI(1,1)=0
    !RundI(1,2)=1
    !1RundI(2,1)=1
    !RundI(2,2)=53
 
    !!!   ++++++++++++++++++++   !!!
    !!! START MULTIOPOLE DATA END !!!
    !!!    ++++++++++++++++++++  !!!

       
    !! Allocate GLOBAL array
    ALLOCATE(pol_q00(N_Atoms_all,3))            
    ALLOCATE(pol_dip(N_Atoms_all,3,3))
    ALLOCATE(pol_quad(N_Atoms_all,3,5))
    ALLOCATE(pol_alpha(N_Atoms_all,3)) 
    ALLOCATE(pol_rank(N_Atoms_all,3))
    ALLOCATE(pol_FP(N_Atoms_all,3))
    ALLOCATE(pol_FU(N_Atoms_all,3))
    ALLOCATE(pol_U1ind(N_Atoms_all,3))
    ALLOCATE(pol_U1_Hist(N_Atoms_all,3))
    
    ! Integer for selection 
    ALLOCATE(I_poles(N_Atoms_all))
    ALLOCATE(Iq_poles(N_Atoms_all))
    !!! Read data form GDMA *.mps files
    CALL prepare_multipoles(RundI,N_Resids,N_Atoms_all,residue_names,KETTE,GDMAfilepath,pol_q00,pol_dip,pol_quad,pol_alpha,pol_rank)

    IF (DEBUG) THEN
        WRITE(*,*) '!!! Data read from GDMA file '
        DO i=RundI(N_Resids,1),RundI(N_Resids+1,1)
           ! WRITE(*,*) TRIM(pol_name(i,2)),pol_coord(i,2,1),&
           !    & pol_coord(i,2,2),pol_coord(i,2,3),
               WRITE(*,*)' Rank ',pol_rank(i,2)   
            IF ( pol_rank(i,2) >=0) WRITE(*,*) pol_q00(i,2)    
            IF ( pol_rank(i,2) >=1) WRITE(*,*) pol_dip(i,2,3),pol_dip(i,2,1),pol_dip(i,2,2)
            IF ( pol_rank(i,2) >=2) WRITE(*,*) pol_quad(i,2,:)   
            WRITE(*,*) '   P',pol_alpha(i,2) 
        END DO
    END IF

    !!!   ++++++++++++++++++++   !!!
    !!! READ MULTIOPOLE DATA END !!!
    !!!    ++++++++++++++++++++  !!!


    !! ++++++++++++++++++++ !!
    !! Ridigidfy + Estatify !!
    !! ++++++++++++++++++++ !!

    !! Rigidify if (a) not rigid yet (b) rigidification at all possible
    !IF (!top->isRigid()) {
     !   bool isRigid = top->Rigidify();
     !   IF (!isRigid) { return 0; }
    !}
    !else { cout << endl << "... ... System is already rigidified."; }

    !! Forward multipoles to topology
 !  IF (top->isEStatified() == false) {
 !      this->DistributeMpoles(top);
 !      cout << endl << "... ... Created " << top->PolarSites().size()
 !               << " multipole sites." << flush;
 !  }
 !  else { cout << endl << "... ... System is already estatified."; }
 !
 !  IF (_checkPolesPDB != "") {
 !      cout << endl << "... ... Writing polar-site coordinates to "
 !           << _checkPolesPDB << ". " << flush;
 !      !! To check rotation into global frame
 !      string mpNAME = _checkPolesPDB;
 !      FILE *mpPDB = NULL;
 !      mpPDB = fopen(mpNAME.c_str(), "w");
 !      vector<Segment*>::iterator sit;
 !      DO (sit = top->Segments().begin();
 !           sit < top->Segments().end();
 !           ++sit) {
 !          (*sit)->WritePDB(mpPDB, "Multipoles", "MD");
 !      }
 !      fclose(mpPDB);
 !  }
 !
 !  IF (_calcESP && _ESPdoSystem) {
 !      this->CalculateESPRigid(top);
 !  }

    !! What has already been done? If anything at all, return 0. TO DO
 !  IF ( (calcAlphaMol && !doSystem) .AND. _calcESP .AND. _calcESF .AND. _dma_input) {
 !
 !      cout << endl << "... ... Calculated ";
 !
 !      IF (this->calcAlphaMol) THEN
 !          cout << "site polarizability tensors, ";
 !      }
 !      IF (this->_calcESP) THEN
 !          cout << "ESPs, ";
 !      }
 !      IF (this->_calcESF) THEN
 !          cout << "ESFs, ";
 !      }
 !      IF (this->_dma_input) THEN
 !          cout << "multipole moments, ";
 !      }
 !      cout << "return. ";
 !      return 0;
 !  }

    !! ++++++++++++++++++++++++++++++++++++++++ !!
    !! Polarizabilities for all sites in system !!
    !! ++++++++++++++++++++++++++++++++++++++++ !!
	
    IF(convert_angstroem_to_nm) THEN
	koord=koord*ANG_2_NM
	box=box*ANG_2_NM
    END IF	

    IF (calcAlphaMol .AND. doSystem) THEN

        WRITE(*,*)"... ... Calculating site polarizabilities"
     
        DO charges_select =1,3 ! 1 = neutral , 2 = anion, 3 = cation

            DO k=1,N_Resids ! loop all Resids
                N_poles=0
                pol_FP=0.0
                pol_FU=0.0
                pol_U1ind=0.0
                pol_U1_Hist=0.0           
                I_poles=-1  ! inactive
                Iq_poles=-1 ! inactive
               !vector< PolarSite* > poles = (*sit)->PolarSites();
                WRITE(*,*) " ... ... ... Segment with Resid: ",RundI(k,1),' and index:',RundI(k,2)
                
                IF(all_nearest_neighbbours) THEN ! number of nearest neighbours
                    NN_max=Neighbourlist(k,2)
                ELSE IF (r_cut_neighbours) THEN
                    !distance_check r_cut
                    WRITE(*,*) 'sphere cutoff not implemented yet'
                    STOP
                    NN_max=3
                ELSE 
                    NN_max=min(Neighbourlist(k,2),N_NN_max)
                END IF ! select maximum number of nearest neighbours
                WRITE(*,*) " ... ... ... Segment with number of neighbours: ",NN_max
		WRITE(*,*) 'tmp:',Neighbourlist(k,:), ' N_NN_max: ',N_NN_max

                DO i=1,N_Resids ! all resids
                    IF (RundI(i,1) == Neighbourlist(k,1) ) THEN  ! resid selected with k is charged
			     DO l=RundI(i,2),RundI(i+1,2)-1   ! loop for all atom indizes in resid RundI(i,1)
                             	N_poles = N_poles + 1
                             	I_poles(N_poles) = l   ! index l for atom in resid k selection
                             	Iq_poles(N_poles) =  charges_select  !charged 
			     END DO ! index l for atom in resid k 
                    ELSE ! check neighbours
                        Do j=3,NN_max+2  ! select number of nearest neighbours 
                            IF ( RundI(i,1) == Neighbourlist(k,j) ) THEN  ! Caution: The I_poles array will be ordered with rising resid, not with the relative distance of the neighbours 
					DO l=RundI(i,2),RundI(i+1,2)-1   ! loop for all atom indizes in resid RundI(i,1)
                                		N_poles = N_poles + 1
                                		I_poles(N_poles) = l   ! index l for atom in adjacent neighbour molecule selected
                                		Iq_poles(N_poles) = 1  !  neutral
					END DO ! lor neighbour selection
                            END IF ! neighbours
                        END DO ! j=3,NN_max+2       
                    END iF ! resid k                    
                END DO !  i=1,N_Atoms_all 
  
		!WRITE(*,*) 'tmp N_poles:',N_poles,I_poles(1:N_poles), 'Iq_poles',Iq_poles(1:N_poles)

		IF ( allocated(pol_alpha_tmp)) Deallocate(pol_alpha_tmp) ! unite data ! TO DO find a solution to avoid extra array!!!
		ALLOCATE(pol_alpha_tmp(N_poles))
		DO i=1,N_poles      
			pol_alpha_tmp(i)=pol_alpha(I_poles(i),Iq_poles(i)) ! FAILS:: WRITE(*;*) pol_alpha(I_poles(1:N_poles),Iq_poles(1:N_poles))
		END DO

	
		
                !CALL CalculateAlphaRigid(wSOR,eTOL,alphaOutFile,N_poles1,pol1_coord,pol1_alpha,pol1_FP,pol1_FU,pol1_U1ind,pol1_U1_Hist)
                CALL CalculateAlphaRigid(wSOR,eTOL,alphaOutFile,N_poles,koord(I_poles(1:N_poles),1:3),&
                                !&   pol_alpha(I_poles(1:N_poles),Iq_poles(1:N_poles)),& !!! FAILS
				&   pol_alpha_tmp(1:N_poles), &
                                &   pol_FP(I_poles(1:N_poles),1:3),pol_FU(I_poles(1:N_poles),1:3),&
                                &   pol_U1ind(I_poles(1:N_poles),1:3),pol_U1_Hist(I_poles(1:N_poles),1:3),box)       
                WRITE(*,*) " ... ... ... Segment calculated: ",RundI(k,1)
		STOP "EXIT"
            END DO ! loop all Resids: k
        END Do  ! charges_select =1,2,3
    END IF ! calcAlphaMol .AND. doSystem
        
END SUBROUTINE EMultipole_EvaluateFrame

!!! /**
!!!  * Calculates polarizability for arbitrary assembly of polar sites
!!!  */
!!! void EMultipole::CalculateAlphaRigid(vector< PolarSite* > &poles,
!!!                                      FILE *out, bool system) {

! vector< PolarSite* > ::iterator pit;

SUBROUTINE CalculateAlphaRigid(wSOR,eTOL,alphaOutFile,N_poles1,pol1_coord,pol1_alpha,pol1_FP,pol1_FU,pol1_U1ind,pol1_U1_Hist,box)

                            !!           & N_poles2,pol2_coord,pol2_alpha,pol2_FP,pol2_FU,pol1_U1ind,pol2_U1_Hist)
    !! IN:: wSOR,eTOL,alphaOutFile
    !! IN:: N_poles1,pol1_coord,pol1_alpha,pol1_FP,pol1_FU,pol1_U1ind,pol1_U1_Hist  !! pol1
    !!!     number of polar sites, coordinates of polar sites, atomic polarizabilities alpha, FP= Electric field (due to permanent), FU=Electric field (due to induced), U1ind=Induced dipole, History
	use small_functions
    IMPLICIT NONE
    REAL, INTENT(IN)    :: wSOR,eTOL      
    CHARACTER (LEN=*)   :: alphaOutFile    
    INTEGER, INTENT(IN) ::N_poles1
    REAL, DIMENSION(3), INTENT(IN)::box
    REAL, DIMENSION (N_poles1):: pol1_alpha
    REAL, Dimension(N_poles1,3), INTENT(IN)     :: pol1_coord
    !!! FP= Electric field (due to permanent), FU=Electric field (due to induced), U1ind=Induced dipole, History
    REAL, Dimension(N_poles1,3)  :: pol1_FP,pol1_FU,pol1_U1ind,pol1_U1_Hist 
    !!! box


    REAL*8 :: axx, axy, axz            !! |
    REAL*8 :: ayx, ayy, ayz            !! |-> Polarizability tensor
    REAL*8 :: azx, azy, azz            !! |

    REAL*8 :: siteU1x, siteU1y, siteU1z !! |-> Molecular ind. dipole

    REAL*8 :: extFx, extFy, extFz       !! |-> External applied field

    ! Eigenvalue problem with LAPACK
    INTEGER :: n_max,lwork,info
    REAL*8, ALLOCATABLE, DIMENSION(:,:) :: alpha_mat,diag_mat
    REAL*8, ALLOCATABLE, DIMENSION(:)   :: eigval,work

    REAL*8 :: SUM_alpha = 0.0D0
    REAL*8 :: ISO_alpha = 0.0D0
    REAL*8 :: NM3_2_A3 = 1.0D3
    INTEGER::i,ierror
    LOGICAL::DEBUG=.false.,system=.true.
	

    WRITE(*,*) 'use wSOR: ',wSOR,'  eTOL: ',eTOL
    !! +++++++++++++++++++++++++++++ !!
    !! External field in x-direction !!
    !! +++++++++++++++++++++++++++++ !!

    siteU1x = 0.0D0
    siteU1y = 0.0D0
    siteU1z = 0.0D0

    extFx = 0.1D0
    extFy = 0.0D0
    extFz = 0.0D0
    
	IF (DEBUG) THEN
    		DO i=1,N_poles1
			WRITE(*,*) pol1_coord(i,:), 'alpha=',pol1_alpha(i)
    		END DO
	END IF 

    !! Set permanent field
    !! ???? Iteration immer uer alle sites vom ausgangszustand !! Nicht die Nachbarn sonst schleifen mit 1,N_poles verdoppeln !! TO DO
    !!DO (pit = poles.begin(); pit < poles.end(); ++pit) {
    
    Do i=1,N_poles1
        pol1_FP(i,1)=Real(extFx,4)
        pol1_FP(i,2)=Real(extFy,4)
        pol1_FP(i,3)=Real(extFz,4)
    END DO 

    !! Calculate induction field
    !!this->SiteAlphaInduce(NULL, poles);
    CALL SiteAlphaInduce(wSOR,eTOL,N_poles1,pol1_coord,pol1_alpha,pol1_FP,pol1_FU,pol1_U1ind,pol1_U1_Hist,box) 

    !! Add up ind. dpl.s to yield molecular U1
    !DO (pit = poles.begin(); pit < poles.end(); ++pit) {
    Do i=1,N_poles1
        siteU1x = siteU1x + pol1_U1ind(i,1)
        siteU1y = siteU1y + pol1_U1ind(i,2)
        siteU1z = siteU1z + pol1_U1ind(i,3)
    END DO

    !! Calculate associated column of polarizability tensor
    axx = - siteU1x / extFx
    ayx = - siteU1y / extFx
    azx = - siteU1z / extFx

    !! +++++++++++++++++++++++++++++ !!
    !! External field in y-direction !!
    !! +++++++++++++++++++++++++++++ !!

    siteU1x = 0.0
    siteU1y = 0.0
    siteU1z = 0.0

    extFx = 0.0
    extFy = 0.1
    extFz = 0.0

    !! Set permanent field
    Do i=1,N_poles1
        pol1_FP(i,1)=Real(extFx,4)
        pol1_FP(i,2)=Real(extFy,4)
        pol1_FP(i,3)=Real(extFz,4)
    END DO 

    !! Calculate induction field
    !!this->SiteAlphaInduce(NULL, poles);
    CALL SiteAlphaInduce(wSOR,eTOL,N_poles1,pol1_coord,pol1_alpha,pol1_FP,pol1_FU,pol1_U1ind,pol1_U1_Hist,box) 
    !CALL SiteAlphaInduce(wSOR,eTOL,N_poles1,pol1_coord,pol1_alpha,pol1_FP,pol1_FU,pol1_U1ind,pol1_U1_Hist,&   !data resid1
    !                             &   N_poles2,pol2_coord,pol2_alpha,pol2_FP,pol2_FU,pol1_U1ind,pol2_U1_Hist)  !data fuer alle nachbarn


    !! Add up ind. dpl.s to yield molecular U1
    Do i=1,N_poles1
        siteU1x = siteU1x + pol1_U1ind(i,1)
        siteU1y = siteU1y + pol1_U1ind(i,2)
        siteU1z = siteU1z + pol1_U1ind(i,3)
    END DO


    !! Calculate associated column of polarizability tensor
    axy = -1.0 * siteU1x / extFy;
    ayy = -1.0 * siteU1y / extFy;
    azy = -1.0 * siteU1z / extFy;

    !! +++++++++++++++++++++++++++++ !!
    !! External field in z-direction !!
    !! +++++++++++++++++++++++++++++ !!

    siteU1x = 0.0
    siteU1y = 0.0
    siteU1z = 0.0

    extFx = 0.0
    extFy = 0.0
    extFz = 0.1

    !! Set permanent field
    Do i=1,N_poles1
        pol1_FP(i,1)=Real(extFx,4)
        pol1_FP(i,2)=Real(extFy,4)
        pol1_FP(i,3)=Real(extFz,4)
    END DO 
    
    !! Calculate induction field
    !!this->SiteAlphaInduce(NULL, poles);
    
    CALL SiteAlphaInduce(wSOR,eTOL,N_poles1,pol1_coord,pol1_alpha,pol1_FP,pol1_FU,pol1_U1ind,pol1_U1_Hist,box) 
    !CALL SiteAlphaInduce(wSOR,eTOL,N_poles1,pol1_coord,pol1_alpha,pol1_FP,pol1_FU,pol1_U1ind,pol1_U1_Hist,&   !data resid1
    !                             &   N_poles2,pol2_coord,pol2_alpha,pol2_FP,pol2_FU,pol1_U1ind,pol2_U1_Hist,box)  !data fuer alle nachbarn

    !! Add up ind. dpl.s to yield molecular U1
    Do i=1,N_poles1
        siteU1x = siteU1x + pol1_U1ind(i,1)
        siteU1y = siteU1y + pol1_U1ind(i,2)
        siteU1z = siteU1z + pol1_U1ind(i,3)
    END DO


    !! Calculate associated column of polarizability tensor
    axz = -1.0 * siteU1x / extFz
    ayz = -1.0 * siteU1y / extFz
    azz = -1.0 * siteU1z / extFz

    !! +++++++++++++++++++++++++++ !!
    !! Sum, Trace, Diagonalization !!
    !! +++++++++++++++++++++++++++ !!

    !! Sum over atomic polarizabilities
    SUM_alpha = 0.0
    Do i=1,N_poles1
        SUM_alpha = SUM_alpha + pol1_alpha(i)
    end do

    SUM_alpha = SUM_alpha * NM3_2_A3

    !! TODO Diagonalize polarizability tensor
    !! For now, trace is enough
    ISO_alpha = (axx + ayy + azz) / 3.0

    ISO_alpha = ISO_alpha * NM3_2_A3

    !! Eigenvalues of polarizability tensor
    IF (ALLOCATED(alpha_mat))  DEALLOCATE (alpha_mat)
    IF (ALLOCATED(diag_mat))  DEALLOCATE (diag_mat)
    IF (ALLOCATED(eigval))  DEALLOCATE (alpha_mat)
    IF (ALLOCATED(work))  DEALLOCATE (work)
    
    n_max=3
    ALLOCATE(alpha_mat(n_max,n_max))
    ALLOCATE(diag_mat(n_max,n_max))
    lwork=3*n_max
    ALLOCATE(eigval(n_max))
    ALLOCATE(work(lwork))
    
    alpha_mat(1,1:3) = (/ axx, ayx, azx /)
    alpha_mat(2,1:3) = (/ axy, ayy, azy /)
    alpha_mat(3,1:3) = (/ axz, ayz, azz /)
    
    diag_mat=alpha_mat
    ! Initializing the diagonal-matrix and matrix to be diagonalized
    ! Include LAPACK routine for Diagonalisation
    !CALL DSYEV('V','U', n_max , diag_mat, n_max , eigval, work, lwork, info)
    
    IF ( info == 0) then
                    WRITE(*,*) ' Diagonalisation successful '
    ELSE IF ( info < 0) then 
                    WRITE(*,*) ' The argument',info,' had an illigal value'        
    ELSE
                    WRITE(*,*) info, ' > 0 => the algorithm failed to converge'
                    WRITE(*,*) 'off-diagonal elements of an intermediate tridiagonal form did not converge to zero.'
    END IF
        

    !matrix::eigensystem_t EIGEN;
    !alpha.SolveEigensystem(EIGEN);

    if ( .NOT. system .OR. DEBUG) THEN
        write(*,*) "... ... ... ... Sum over atomic alphas:    ",SUM_alpha," A**3."
        write(*,*) "... ... ... ... 1/3 trace of alpha tensor: ",ISO_alpha," A**3."
        write(*,*) "... ... ... ... Eigenvalues: "
        write(*,*) "... ... ... ... ", eigval(1)*NM3_2_A3," A**3 "
        write(*,*) "... ... ... ... ", eigval(2)*NM3_2_A3," A**3 "
        write(*,*) "... ... ... ... ", eigval(3)*NM3_2_A3," A**3 "
    END IF

    if (alphaOutFile /= "noname" .AND. alphaOutFile /= "") THEN
        IF (file_exists(alphaOutFile)) THEN
            OPEN(UNIT=32,FILE=TRIM(alphaOutFile),STATUS='OLD',action ='WRITE',IOSTAT=ierror)
            IF (check_ierror(alphaOutFile,ierror)) CONTINUE 
            
            if ( .NOT. system .OR. DEBUG ) THEN ! 
                write(32,*) "Polarizability tensor in global frame"
                write(32,'(3F16.6)')  axx*NM3_2_A3, axy*NM3_2_A3, axz*NM3_2_A3
                write(32,'(3F16.6)')  ayx*NM3_2_A3, ayy*NM3_2_A3, ayz*NM3_2_A3
                write(32,'(3F16.6)')  azx*NM3_2_A3, azy*NM3_2_A3, azz*NM3_2_A3
                      
                write(32,*) "Polarizability tensor in eigenframe "
                write(32,'(3F16.6)')  eigval(1)*NM3_2_A3,0.,0.
                write(32,'(3F16.6)')  0.,eigval(2)*NM3_2_A3,0.
                write(32,'(3F16.6)')  0.,0.,eigval(3)*NM3_2_A3
                      
                write(32,*) "Polarizability tensor main axes "
                write(32,'(3F16.6)') diag_mat(1,1:3)    !   x.getX(),x.getY(),x.getZ()
                write(32,'(3F16.6)') diag_mat(2,1:3)    !   y.getX(),y.getY(),y.getZ()
                write(32,'(3F16.6)') diag_mat(3,1:3)    !   z.getX(),z.getY(),z.getZ()
            ELSE
                write(32,'(5F16.6)') ISO_alpha, SUM_alpha,eigval(1)*NM3_2_A3,eigval(2)*NM3_2_A3,eigval(3)*NM3_2_A3
            END IF ! Debug
        END IF
    else
        write(*,'(5F16.6)') ISO_alpha, SUM_alpha,eigval(1)*NM3_2_A3,eigval(2)*NM3_2_A3,eigval(3)*NM3_2_A3
    END IF ! file noname

END SUBROUTINE CalculateAlphaRigid




!!!/**
!!! * Induces dipoles on polar sites in self-consistent manner until converged
!!! * ... NOTE Designed to be used in conjunction with ::CalculateAlphaMol()
!!!*/

!void EMultipole::SiteAlphaInduce(Topology *top, vector<PolarSite*> &poles) {
SUBROUTINE SiteAlphaInduce(wSOR,eTOL,N_poles1,pol1_coord,pol1_alpha,pol1_FP,pol1_FU,pol1_U1ind,pol1_U1_Hist,box) ! ,&
                               !TO DO kill?   OLD:!& N_poles2,pol2_coord,pol2_alpha,pol2_FP,pol2_FU,pol_U1ind,pol2_U1_Hist)
    !! IN:: wSOR,eTOL
    !! IN:: N_poles1,pol1_coord,pol1_alpha,pol1_FP,pol1_FU,pol_U1ind,pol1_U1_Hist  !! pol1
    !! IN:: N_poles2,pol2_coord,pol2_alpha,pol2_FP,pol2_FU,pol_U1ind,pol1_U1_Hist  !! pol2 data for all sites in the neighbourhood
    IMPLICIT NONE
    
    !double wSOR = this->_wSOR_N;
    !double eTOL = this->_epsTol; 
    REAL, INTENT(IN) ::wSOR,eTOL       
    INTEGER, INTENT(IN) ::N_poles1
    REAL, DIMENSION (N_poles1):: pol1_alpha
    REAL, Dimension(N_poles1,3), INTENT(IN)    :: pol1_coord
     !!! FP= Electric field (due to permanent), FU=Electric field (due to induced), U1ind=Induced dipole, History
    REAL, Dimension(N_poles1,3), INTENT(INOUT)  :: pol1_FP,pol1_FU,pol1_U1ind,pol1_U1_Hist
    REAL, DIMENSION(3), INTENT(IN)   ::box
    !INTEGER, INTENT(IN) :: N_poles2    
    !REAL, Dimension(N_poles2,3), INTENT(INOUT)  :: pol2_coord,pol2_FP,pol2_FU,pol_U2ind,pol2_U1_Hist
    !REAL, DIMENSION (N_poles2):: pol2_alpha

    INTEGER ::   maxIter = 100000 ! 1.0E5 ! this->_maxIter;

    LOGICAL :: converged
    REAL    :: dU,maxdU,avgdU
    INTEGER :: iter,baseN 
    INTEGER :: i,j


    ! ???? vector< PolarSite* >::iterator pit1;
    ! ????? vector< PolarSite* >::iterator pit2;

    ! ??? Interactor TO DO 
 !   Interactor actor = Interactor(top, this);

    !!!  Induce to first order

    DO i=1,N_poles1
        !!(*pit1)->InduceDirect();
        CALL InduceDirect(pol1_alpha(i),pol1_FP(i,1:3),pol1_U1ind(i,1:3),pol1_U1_Hist(i,1:3))
	!WRITE(*,*) 'tmp induce Direct',pol1_alpha(i),pol1_FP(i,1:3),pol1_U1ind(i,1:3),pol1_U1_Hist(i,1:3)
    END DO 

   iter = 0
   DO WHILE ( iter < maxIter ) 
        iter=iter+1
        !!!  Reset induction field
        DO i=1,N_poles1
            CALL ResetFieldU(pol1_FU(i,1:3))    !(*pit1)->ResetFieldU();
        END DO

        !!!  Calculate higher-order induction field
        DO i=1,N_poles1
            DO j=i+1,N_poles1
                ! TO DO ???? Ueber 1 oder alle Paare in dem Array
                !!actor.FieldInduAlpha(*(*pit1),*(*pit2));
                !! zwei zentren
                !! FieldInduAlpha(pol1_coord,pol1_alpha,pol1_U1vec,pol1_FU,pol2_coord,pol2_alpha,pol2_U1vec,pol2_FU) 
!WRITE(*,*) 'i v FieldInduAlpha: ', pol1_alpha(i),pol1_FP(i,1:3),pol1_coord(i,1:3),pol1_alpha(i),pol1_U1ind(i,1:3),pol1_FU(i,1:3)
!WRITE(*,*) 'j Vorher FAlpha  p: ', pol1_alpha(j),pol1_FP(j,1:3),pol1_coord(j,1:3),pol1_alpha(j),pol1_U1ind(j,1:3),pol1_FU(j,1:3)
                CALL FieldInduAlpha(pol1_coord(i,1:3),pol1_alpha(i),pol1_U1ind(i,1:3),pol1_FU(i,1:3)&
                                  &,pol1_coord(j,1:3),pol1_alpha(j),pol1_U1ind(j,1:3),pol1_FU(j,1:3),box) 
!WRITE(*,*) 'i Nachher FAlpha tmp: ', pol1_alpha(i),pol1_FP(i,1:3),pol1_coord(i,1:3),pol1_alpha(i),pol1_U1ind(i,1:3),pol1_FU(i,1:3)
!WRITE(*,*) 'j Nachher FAlpha tmp: ', pol1_alpha(j),pol1_FP(j,1:3),pol1_coord(j,1:3),pol1_alpha(j),pol1_U1ind(j,1:3),pol1_FU(j,1:3)
		STOP
            END DO
        END DO

        !!!  Induce dipoles
        DO i=1,N_poles1        
            !!! (*pit1)->Induce(wSOR);
            !!!CALL Induce(wSOR,P1,FPvec,FUvec,U1ind,U1_Hist) 
	    WRITE(*,*) '1 tmp: ', pol1_alpha(i),pol1_FP(i,1:3),pol1_FU(i,1:3),pol1_U1ind(i,1:3),pol1_U1_Hist(i,1:3)
            CALL Induce(wSOR,pol1_alpha(i),pol1_FP(i,1:3),pol1_FU(i,1:3),pol1_U1ind(i,1:3),pol1_U1_Hist(i,1:3))	
	    WRITE(*,*) '2 tmp: ', pol1_alpha(i),pol1_FP(i,1:3),pol1_FU(i,1:3),pol1_U1ind(i,1:3),pol1_U1_Hist(i,1:3)
	     STOP
        END DO

        !!!  Check for convergence
        converged = .true.
        maxdU = -1
        avgdU = 0.0
        baseN = 0

        DO i=1,N_poles1
            !  double dU = (*pit1)->HistdU();
            dU =   HistdU(pol1_U1ind(i,1:3),pol1_U1_Hist(i,1:3))
            avgdU = avgdU + dU
            baseN = baseN + 1
            if ( dU > maxdU ) THEN
                maxdU = dU
            END IF
            if ( dU > eTOL ) THEN
                converged = .false.
            END IF
        END DO

        avgdU = avgdU /REAL(baseN)
        if (avgdU < (eTOL/10.) ) THEN
            converged = .true.
        END IF
        WRITE(*,*) "ITER: ",iter," | MAX dU: ",maxdU, " average dU: ",avgdU 
        !!!  Break if converged
        if (converged) THEN
            EXIT
        else if (iter == maxIter - 1) THEN
            WRITE(*,*) "... ... ... WARNING Induced multipoles did not converge to precision: "
            WRITE(*,*) " AVG dU:U ",avgdU 
            EXIT
        END IF
    END DO
END SUBROUTINE SiteAlphaInduce


SUBROUTINE Induce(wSOR,P1,FPvec,FUvec,U1ind,U1_Hist) 
    !!! For SiteAlphaInduce
    !!! IN  :: wSOR,P1, FPvec(FPx, FPy, FPz), FUvec(FUx, FUy, FUz)
    !!! OUT :: U1ind = (U1x,U1y,U1z)   
    IMPLICIT NONE
    REAL, INTENT (IN) :: P1  ! == alpha polarizability
    REAL, INTENT (IN) :: wSOR
    REAL, DIMENSION(3), INTENT(IN):: FPvec,FUvec ! Pvec(FPx, FPy, FPz), FUvec(FUx, FUy, FUz)
    REAL, DIMENSION (3), INTENT(INOUT):: U1ind ! U1ind(U1x,U1y,U1z)
    REAL, DIMENSION (3), INTENT(INOUT):: U1_Hist !History
    INTEGER::i
    
    !! U1_Hist.push_back( vec(U1ind(1),U1ind(2),U1ind(3)) ); 
    DO i=1,3
        U1_Hist(i)=U1ind(i)
    END DO
    
    U1ind(1) = (1 - wSOR) * U1ind(1) + wSOR * ( - P1 * (FPvec(1) + FUvec(1)) )  !! OVERRIDE
    U1ind(2) = (1 - wSOR) * U1ind(2) + wSOR * ( - P1 * (FPvec(2) + FUvec(2)) )  !! OVERRIDE
    U1ind(3) = (1 - wSOR) * U1ind(3) + wSOR * ( - P1 * (FPvec(3) + FUvec(3)) )  !! OVERRIDE

END SUBROUTINE Induce

SUBROUTINE InduceDirect(P1,FPvec,U1ind,U1_Hist)
    !!! IN  :: P1, FPvec(FPx, FPy, FPz)
    !!! OUT :: U1ind = (U1x,U1y,U1z)
    IMPLICIT NONE
    REAL, INTENT (IN) :: P1  ! P1=alpha => polarizability
    REAL, DIMENSION (3), INTENT(IN)   :: FPvec   ! FPvec(FPx, FPy, FPz)
    REAL, DIMENSION (3), INTENT(OUT)  :: U1ind   ! U1ind(U1x,U1y,U1z)
    REAL, DIMENSION (3), INTENT(INOUT):: U1_Hist ! History
    !! U1_Hist.push_back( vec(0.,0.,0.) );
    U1_Hist(:)=0.0
    
    U1ind(1) =  - P1 * FPvec(1)    !! OVERRIDE
    U1ind(2) =  - P1 * FPvec(2)    !! OVERRIDE
    U1ind(3) =  - P1 * FPvec(3)    !! OVERRIDE
END SUBROUTINE  InduceDirect


REAL FUNCTION HistdU(U1vec,U1_Hist) 
    ! changes in dU History 
    ! HistdU = norm( U1vec(U1x, U1y, U1z) - U1_His(U1x, U1y, U1z) )/ | U1_His |
    use small_functions
    IMPLICIT NONE
    REAL, DIMENSION(3), INTENT(IN) ::U1vec,U1_Hist
    REAL, DIMENSION(3)::dU
    INTEGER::i
    REAL::betrag,result1
    !vec dU = vec(U1x, U1y, U1z) - U1_Hist.back()
    DO i=1,3 ! U1x, U1y, U1z
        dU(i)=U1vec(i) - U1_Hist(i)
    END DO
    betrag=norm(U1_Hist)  
    !!!return abs(dU)/abs(U1_Hist.back())
    IF (betrag < 1.0E-20) THEN
        result1 = 0.0
    ELSE
        result1 = norm(dU)/betrag
    END IF 
    HistdU = result1
END FUNCTION HistdU


SUBROUTINE Depolarize(U1ind,FPvec,FUvec,U1_Hist)
    IMPLICIT NONE
    REAL, DIMENSION(3), INTENT(INOUT):: U1ind,FPvec,FUvec,U1_Hist
    !! Zero out induced moments
    U1ind=0.0
    !! U1_Hist.clear();
    U1_Hist=0.0
    !! Zero out fields
    FPvec=0.0
    FUvec=0.0
END SUBROUTINE



SUBROUTINE ResetFieldU(FUvec) !{ FUx = FUy = FUz = 0.0; }
    IMPLICIT NONE
    REAL, DIMENSION(3), INTENT(INOUT):: FUvec
    FUvec=0.0
END SUBROUTINE ResetFieldU


SUBROUTINE ResetFieldP(FPvec) !{ FPx = FPy = FPz = 0.0; }
    IMPLICIT NONE
    REAL, DIMENSION(3), INTENT(INOUT):: FPvec
    FPvec=0.0
END SUBROUTINE ResetFieldP




!!!/**
!!! * Used in molecular-polarizability calculator (initialize stage)
!!! */
SUBROUTINE FieldInduAlpha(pol1_coord,pol1_alpha,pol1_U1vec,pol1_FU,pol2_coord,pol2_alpha,pol2_U1vec,pol2_FU,box)
    !!!  IN:: coordinates, polarizability(P1), U1Vec induced, induced fieled FU, box(xbox,ybox,zbox)  !! for polar sites pol1 and pol2
    !!! OUT:: pol1_FU,pol2_FU   modified  induced fieled FU 
    !!! NOTE >>> e12 points from polar site 1 to polar site 2 <<< NOTE !!
    use small_functions
    REAL, DIMENSION (3), INTENT(IN) :: pol1_coord,pol2_coord
    REAL, DIMENSION (3), INTENT(IN) :: pol1_U1vec,pol2_U1vec
    REAL, DIMENSION (3), INTENT(INOUT) :: pol1_FU,pol2_FU
    REAL, INTENT(IN) ::pol1_alpha,pol2_alpha
    REAL, DIMENSION(3), INTENT(IN) ::box
    !!! local variables
    REAL, DIMENSION(3)::e12
    REAL::R,R2,R3,R4,R5
    REAL::rax,ray,raz,rbx,rby,rbz,cxx,cxy,cxz,cyx,cyy,cyz,czx,czy,czz
    REAL :: lambda3,lambda5,lambda7,lambda9
    REAL::a,u3

    !! NOTE >>> e12 points from polar site 1 to polar site 2 <<< NOTE !!
	
    CALL PBC_dist_vec(e12,pol1_coord,pol2_coord,box) !!! e12  = pol2_coord-pol1_coord !distance_vec(pol1_coord,pol2_coord,box)
 
    R    = 1.0/norm(e12) 
    R2   = R*R 		!!!  |
    R3   = R2*R 	!!!  |
    R4   = R3*R 	!!!  |-> NOTE: reciprocal, i.e. e.g. R3 = 1/(R*R*R)
    R5   = R4*R 	!!!  |
    e12  = R*e12 	!!!  |

    !! Thole damping init.
    a    = 0.39 ! _em->_aDamp =???= <exp_damp>0.39</exp_damp>

    u3   = 1 / (R3 * SQRT(pol1_alpha * pol2_alpha)) 

    lambda3=calc_lambda3(a,u3)	   
    lambda5=calc_lambda5(a,u3)	   
    lambda7=calc_lambda7(a,u3)	   
    lambda9=calc_lambda9(a,u3)	

!!        rax =   pol1._locX * e12;
!!        ray =   pol1._locY * e12;
!!        raz =   pol1._locZ * e12;
!!        rbx = - pol2._locX * e12;
!!        rby = - pol2._locY * e12;
!!        rbz = - pol2._locZ * e12;

        rax = e12(1)
        ray = e12(2)
        raz = e12(3)
        rbx = - rax
        rby = - ray
        rbz = - raz

!!        cxx = pol1._locX * pol2._locX;
!!        cxy = pol1._locX * pol2._locY;
!!        cxz = pol1._locX * pol2._locZ;
!!        cyx = pol1._locY * pol2._locX;
!!        cyy = pol1._locY * pol2._locY;
!!        cyz = pol1._locY * pol2._locZ;
!!        czx = pol1._locZ * pol2._locX;
!!        czy = pol1._locZ * pol2._locY;
!!        czz = pol1._locZ * pol2._locZ;

        cxx = 1.0
        cxy = 0.0
        cxz = 0.0
        cyx = 0.0
        cyy = 1.0
        cyz = 0.0
        czx = 0.0
        czy = 0.0
        czz = 1.0

    !! Fields generated by rank-1 induced m'poles

    if (a*u3 < 40.0) THEN
        pol1_FU(1) = pol1_FU(1) + TU1x_1x(R3,lambda5,rax,rbx,lambda3,cxx) * pol2_U1vec(1)
        pol1_FU(1) = pol1_FU(1) + TU1x_1y(R3,lambda5,rax,rby,lambda3,cxy) * pol2_U1vec(2)
        pol1_FU(1) = pol1_FU(1) + TU1x_1z(R3,lambda5,rax,rbz,lambda3,cxz) * pol2_U1vec(3)
        pol1_FU(2) = pol1_FU(2) + TU1y_1x(R3,lambda5,ray,rbx,lambda3,cyx) * pol2_U1vec(1)
        pol1_FU(2) = pol1_FU(2) + TU1y_1y(R3,lambda5,ray,rby,lambda3,cyy) * pol2_U1vec(2)
        pol1_FU(2) = pol1_FU(2) + TU1y_1z(R3,lambda5,ray,rbz,lambda3,cyz) * pol2_U1vec(3)
        pol1_FU(3) = pol1_FU(3) + TU1z_1x(R3,lambda5,raz,rbx,lambda3,czx) * pol2_U1vec(1)
        pol1_FU(3) = pol1_FU(3) + TU1z_1y(R3,lambda5,raz,rby,lambda3,czy) * pol2_U1vec(2)
        pol1_FU(3) = pol1_FU(3) + TU1z_1z(R3,lambda5,raz,rbz,lambda3,czz) * pol2_U1vec(3)
                            
        pol2_FU(1) = pol2_FU(1) + TU1x_1x(R3,lambda5,rax,rbx,lambda3,cxx) * pol1_U1vec(1)
        pol2_FU(1) = pol2_FU(1) + TU1y_1x(R3,lambda5,ray,rbx,lambda3,cyx) * pol1_U1vec(2)
        pol2_FU(1) = pol2_FU(1) + TU1z_1x(R3,lambda5,raz,rbx,lambda3,czx) * pol1_U1vec(3)
        pol2_FU(2) = pol2_FU(2) + TU1x_1y(R3,lambda5,rax,rby,lambda3,cxy) * pol1_U1vec(1)
        pol2_FU(2) = pol2_FU(2) + TU1y_1y(R3,lambda5,ray,rby,lambda3,cyy) * pol1_U1vec(2)
        pol2_FU(2) = pol2_FU(2) + TU1z_1y(R3,lambda5,raz,rby,lambda3,czy) * pol1_U1vec(3)
        pol2_FU(3) = pol2_FU(3) + TU1x_1z(R3,lambda5,rax,rbz,lambda3,cxz) * pol1_U1vec(1)
        pol2_FU(3) = pol2_FU(3) + TU1y_1z(R3,lambda5,ray,rbz,lambda3,cyz) * pol1_U1vec(2)
        pol2_FU(3) = pol2_FU(3) + TU1z_1z(R3,lambda5,raz,rbz,lambda3,czz) * pol1_U1vec(3)
    else                       
        pol1_FU(1) = pol1_FU(1) + T1x_1x(R3,rax,rbx,cxx) * pol2_U1vec(1)
        pol1_FU(1) = pol1_FU(1) + T1x_1y(R3,rax,rby,cxy) * pol2_U1vec(2)
        pol1_FU(1) = pol1_FU(1) + T1x_1z(R3,rax,rbz,cxz) * pol2_U1vec(3)
        pol1_FU(2) = pol1_FU(2) + T1y_1x(R3,ray,rbx,cyx) * pol2_U1vec(1)
        pol1_FU(2) = pol1_FU(2) + T1y_1y(R3,ray,rby,cyy) * pol2_U1vec(2)
        pol1_FU(2) = pol1_FU(2) + T1y_1z(R3,ray,rbz,cyz) * pol2_U1vec(3)
        pol1_FU(3) = pol1_FU(3) + T1z_1x(R3,raz,rbx,czx) * pol2_U1vec(1)
        pol1_FU(3) = pol1_FU(3) + T1z_1y(R3,raz,rby,czy) * pol2_U1vec(2)
        pol1_FU(3) = pol1_FU(3) + T1z_1z(R3,raz,rbz,czz) * pol2_U1vec(3)
                           
        pol2_FU(1) = pol2_FU(1) + T1x_1x(R3,rax,rbx,cxx) * pol1_U1vec(1)
        pol2_FU(1) = pol2_FU(1) + T1y_1x(R3,ray,rbx,cyx) * pol1_U1vec(2)
        pol2_FU(1) = pol2_FU(1) + T1z_1x(R3,raz,rbx,czx) * pol1_U1vec(3)
        pol2_FU(2) = pol2_FU(2) + T1x_1y(R3,rax,rby,cxy) * pol1_U1vec(1)
        pol2_FU(2) = pol2_FU(2) + T1y_1y(R3,ray,rby,cyy) * pol1_U1vec(2)
        pol2_FU(2) = pol2_FU(2) + T1z_1y(R3,raz,rby,czy) * pol1_U1vec(3)
        pol2_FU(3) = pol2_FU(3) + T1x_1z(R3,rax,rbz,cxz) * pol1_U1vec(1)
        pol2_FU(3) = pol2_FU(3) + T1y_1z(R3,ray,rbz,cyz) * pol1_U1vec(2)
        pol2_FU(3) = pol2_FU(3) + T1z_1z(R3,raz,rbz,czz) * pol1_U1vec(3)
    END IF
END SUBROUTINE FieldInduAlpha

     
!!!   /**
!!!    * Used in energy evaluation of converged fields (evaluation stage)
!!!    */
!!!   inline double EMultipole::Interactor::EnergyInter(PolarSite &pol1,PolarSite &pol2) 

!!! NOTE >>> e12 points from polar site 1 to polar site 2 <<< NOTE !!
    

SUBROUTINE Interactor_EnergyInter(pol1_coord,pol1_rank,pol1_q00,pol1_dip,pol1_quad,pol1_alpha,pol1_U1ind,&        !site1 polarizible input
			      & pol2_coord,pol2_rank,pol2_q00,pol2_dip,pol2_quad,pol2_alpha,pol2_U1ind,&	!site2 polarizible input
			      & box, &	
			      & EP,EU_INTER,E_sum) ! output TO DO wie wird das verwendet???
			use small_functions
IMPLICIT NONE
!!!! InteractorEMultipole(coordinates,rank,charge,dipolemoment,quadrupolemoments,polarizability_alpha,induced_dipoles
!!!! coordinates for two polarizible sites pol1 and pol2
REAL, DIMENSION(3), INTENT(IN) ::pol1_coord,pol2_coord
!!! rank 
INTEGER, INTENT(IN) ::pol1_rank,pol2_rank
!!! pol1_charge(Q00) !!! charge
REAL, INTENT(IN)  ::pol1_q00,pol2_q00
!!! pol1_dip(Q1x,Q1y,Q1z) !!! dipole
REAL, DIMENSION(3), INTENT(IN) ::pol1_dip,pol2_dip
!!! pol1_quad(Q20,Q21c,Q21s,Q22c,Q22s) !!! quadrupole
REAL, DIMENSION(5), INTENT(IN) ::pol1_quad,pol2_quad
!!! pol1_alpha(P1) !!! polarizability_alpha
REAL ::pol1_alpha,pol2_alpha
!!! pol1_U1ind=(U1x, U1y, U1z)                   !! Induced dipole
REAL, DIMENSION(3), INTENT(IN) ::pol1_U1ind,pol2_U1ind
!!! box=(xbox,ybox,zbox) for periodic boundary corrections
REAL, DIMENSION(3), INTENT(IN) :: box
!!! OUTPUT: EP,EU_INTER,E_sum = E+U
REAL::EP,EU_INTER,E_sum
!!!
!!! local variables
REAL, DIMENSION(3)::e12
REAL::R,R2,R3,R4,R5
REAL::rax,ray,raz,rbx,rby,rbz,cxx,cxy,cxz,cyx,cyy,cyz,czx,czy,czz
REAL :: lambda3,lambda5,lambda7,lambda9
REAL::a,u3
REAL::E = 0.0 !! <- Electrostatic energy
REAL::U = 0.0 !! <- Induction energy

    !! NOTE >>> e12 points from polar site 1 to polar site 2 <<< NOTE !!
    CALL PBC_dist_vec(e12,pol1_coord,pol2_coord,box) !!! e12  = pol2_coord-pol1_coord !distance_vec(pol1_coord,pol2_coord,box)
    R    = 1.0/norm(e12) 
    R2   = R*R 		!!!  |
    R3   = R2*R 	!!!  |
    R4   = R3*R 	!!!  |-> NOTE: reciprocal, i.e. e.g. R3 = 1/(R*R*R)
    R5   = R4*R 	!!!  |
    e12  = R*e12 	!!!  |

    !! Thole damping init.
    a    = 0.39 ! _em->_aDamp =???= <exp_damp>0.39</exp_damp>

    u3   = 1 / (R3 * SQRT(pol1_alpha * pol2_alpha)) 

    lambda3=calc_lambda3(a,u3)	   
    lambda5=calc_lambda5(a,u3)	   
    lambda7=calc_lambda7(a,u3)	   
    lambda9=calc_lambda9(a,u3)	


    !!cout << "frag1 " << pol1.getFragment()->getId() << endl 
    !!cout << "frag2 " << pol2.getFragment()->getId() << endl 
    !!cout << "seg1  " << pol1.getSegment()->getId() << endl 
    !!cout << "seg2  " << pol2.getSegment()->getId() << endl    

    
!!        rax =   pol1._locX * e12 
!!        ray =   pol1._locY * e12 
!!        raz =   pol1._locZ * e12 
!!        rbx = - pol2._locX * e12 
!!        rby = - pol2._locY * e12 
!!        rbz = - pol2._locZ * e12 

        rax = e12(1)
        ray = e12(2) 
        raz = e12(3) 
        rbx = - rax 
        rby = - ray 
        rbz = - raz 

    IF ((pol1_rank > 0) .OR. (pol2_rank > 0)) THEN
!!        cxx = pol1._locX * pol2._locX 
!!        cxy = pol1._locX * pol2._locY 
!!        cxz = pol1._locX * pol2._locZ 
!!        cyx = pol1._locY * pol2._locX 
!!        cyy = pol1._locY * pol2._locY 
!!        cyz = pol1._locY * pol2._locZ 
!!        czx = pol1._locZ * pol2._locX 
!!        czy = pol1._locZ * pol2._locY 
!!        czz = pol1._locZ * pol2._locZ 

        cxx = 1 
        cxy = 0 
        cxz = 0 
        cyx = 0 
        cyy = 1 
        cyz = 0 
        czx = 0 
        czy = 0 
        czz = 1 
    END IF

    !double E = 0.0 !! <- Electrostatic energy
    !double U = 0.0 !! <- Induction energy
    E = 0.0 !! <- Electrostatic energy
    U = 0.0 !! <- Induction energy

    E = E + pol1_Q00 * T00_00(R) * pol2_Q00 

        !!cout << "E up to q <-> q " << E << endl 

    IF (a*u3 < 40) THEN
        U = U + pol1_U1ind(1) * TU1x_00(lambda3,R2,rax) * pol2_Q00 
        U = U + pol1_U1ind(2) * TU1y_00(lambda3,R2,ray) * pol2_Q00 
        U = U + pol1_U1ind(3) * TU1z_00(lambda3,R2,raz) * pol2_Q00 

        U = U + pol1_Q00 * TU00_1x(lambda3,R2,rbx) * pol2_U1ind(1) 
        U = U + pol1_Q00 * TU00_1y(lambda3,R2,rby) * pol2_U1ind(2) 
        U = U + pol1_Q00 * TU00_1z(lambda3,R2,rbz) * pol2_U1ind(3) 
    ELSE
        U = U + pol1_U1ind(1) * T1x_00(R2,rax) * pol2_Q00 
        U = U + pol1_U1ind(2) * T1y_00(R2,ray) * pol2_Q00 
        U = U + pol1_U1ind(3) * T1z_00(R2,raz) * pol2_Q00 

        U = U + pol1_Q00 * T00_1x(R2,rbx) * pol2_U1ind(1) 
        U = U + pol1_Q00 * T00_1y(R2,rby) * pol2_U1ind(2) 
        U = U + pol1_Q00 * T00_1z(R2,rbz) * pol2_U1ind(3) 
    END IF



    IF (pol1_rank > 0) THEN
        E = E + pol1_dip(1) * T1x_00(R2,rax) * pol2_Q00 
        E = E + pol1_dip(2) * T1y_00(R2,ray) * pol2_Q00 
        E = E + pol1_dip(3) * T1z_00(R2,raz) * pol2_Q00 
    END IF

    IF (pol2_rank > 0) THEN
        E = E + pol1_Q00 * T00_1x(R2,rbx) * pol2_dip(1) 
        E = E + pol1_Q00 * T00_1y(R2,rby) * pol2_dip(2) 
        E = E + pol1_Q00 * T00_1z(R2,rbz) * pol2_dip(3) 
    END IF
        !!cout << "E up to q <-> d " << E << endl 

    IF (pol1_rank > 1) THEN
        E = E + pol1_quad(1)  * T20_00(R3,raz)  * pol2_Q00 
        E = E + pol1_quad(2) * T21c_00(R3,rax,raz) * pol2_Q00 
        E = E + pol1_quad(3) * T21s_00(R3,ray,raz) * pol2_Q00 
        E = E + pol1_quad(4) * T22c_00(R3,rax,ray) * pol2_Q00 
        E = E + pol1_quad(5) * T22s_00(R3,rax,ray) * pol2_Q00 
    END IF

    IF (pol2_rank > 1) THEN
        E = E + pol1_Q00 * T00_20(R3,rbz)  * pol2_quad(1) 
        E = E + pol1_Q00 * T00_21c(R3,rbx,rbz) * pol2_quad(2) 
        E = E + pol1_Q00 * T00_21s(R3,rby,rbz) * pol2_quad(3) 
        E = E + pol1_Q00 * T00_22c(R3,rbx,rby) * pol2_quad(4) 
        E = E + pol1_Q00 * T00_22s(R3,rbx,rby) * pol2_quad(5) 
    END IF
        !!cout << "E up to q <-> Q " << E << endl 

    IF ((pol1_rank > 0) .AND. (pol2_rank > 0)) THEN
        E = E + pol1_dip(1) * T1x_1x(R3,rax,rbx,cxx) * pol2_dip(1) 
        E = E + pol1_dip(1) * T1x_1y(R3,rax,rby,cxy) * pol2_dip(2) 
        E = E + pol1_dip(1) * T1x_1z(R3,rax,rbz,cxz) * pol2_dip(3) 

        E = E + pol1_dip(2) * T1y_1x(R3,ray,rbx,cyx) * pol2_dip(1) 
        E = E + pol1_dip(2) * T1y_1y(R3,ray,rby,cyy) * pol2_dip(2) 
        E = E + pol1_dip(2) * T1y_1z(R3,ray,rbz,cyz) * pol2_dip(3) 

        E = E + pol1_dip(3) * T1z_1x(R3,raz,rbx,czx) * pol2_dip(1) 
        E = E + pol1_dip(3) * T1z_1y(R3,raz,rby,czy) * pol2_dip(2) 
        E = E + pol1_dip(3) * T1z_1z(R3,raz,rbz,czz) * pol2_dip(3) 
    END IF

    IF (pol1_rank > 0) THEN
        IF (a*u3 < 40) THEN
            U = U + pol1_dip(1) * TU1x_1x(R3,lambda5,rax,rbx,lambda3,cxx) * pol2_U1ind(1) 
            U = U + pol1_dip(1) * TU1x_1y(R3,lambda5,rax,rby,lambda3,cxy) * pol2_U1ind(2) 
            U = U + pol1_dip(1) * TU1x_1z(R3,lambda5,rax,rbz,lambda3,cxz) * pol2_U1ind(3) 
            U = U + pol1_dip(2) * TU1y_1x(R3,lambda5,ray,rbx,lambda3,cyx) * pol2_U1ind(1) 
            U = U + pol1_dip(2) * TU1y_1y(R3,lambda5,ray,rby,lambda3,cyy) * pol2_U1ind(2) 
            U = U + pol1_dip(2) * TU1y_1z(R3,lambda5,ray,rbz,lambda3,cyz) * pol2_U1ind(3) 
            U = U + pol1_dip(3) * TU1z_1x(R3,lambda5,raz,rbx,lambda3,czx) * pol2_U1ind(1) 
            U = U + pol1_dip(3) * TU1z_1y(R3,lambda5,raz,rby,lambda3,czy) * pol2_U1ind(2) 
            U = U + pol1_dip(3) * TU1z_1z(R3,lambda5,raz,rbz,lambda3,czz) * pol2_U1ind(3) 
        ELSE
            U = U + pol1_dip(1) * T1x_1x(R3,rax,rbx,cxx) * pol2_U1ind(1) 
            U = U + pol1_dip(1) * T1x_1y(R3,rax,rby,cxy) * pol2_U1ind(2) 
            U = U + pol1_dip(1) * T1x_1z(R3,rax,rbz,cxz) * pol2_U1ind(3) 
            U = U + pol1_dip(2) * T1y_1x(R3,ray,rbx,cyx) * pol2_U1ind(1) 
            U = U + pol1_dip(2) * T1y_1y(R3,ray,rby,cyy) * pol2_U1ind(2) 
            U = U + pol1_dip(2) * T1y_1z(R3,ray,rbz,cyz) * pol2_U1ind(3) 
            U = U + pol1_dip(3) * T1z_1x(R3,raz,rbx,czx) * pol2_U1ind(1) 
            U = U + pol1_dip(3) * T1z_1y(R3,raz,rby,czy) * pol2_U1ind(2) 
            U = U + pol1_dip(3) * T1z_1z(R3,raz,rbz,czz) * pol2_U1ind(3) 
        END IF
    END IF
    IF (pol2_rank > 0) THEN
        IF (a*u3 < 40) THEN
            U = U + pol1_U1ind(1) * TU1x_1x(R3,lambda5,rax,rbx,lambda3,cxx) * pol2_dip(1) 
            U = U + pol1_U1ind(1) * TU1x_1y(R3,lambda5,rax,rby,lambda3,cxy) * pol2_dip(2) 
            U = U + pol1_U1ind(1) * TU1x_1z(R3,lambda5,rax,rbz,lambda3,cxz) * pol2_dip(3) 
            U = U + pol1_U1ind(2) * TU1y_1x(R3,lambda5,ray,rbx,lambda3,cyx) * pol2_dip(1) 
            U = U + pol1_U1ind(2) * TU1y_1y(R3,lambda5,ray,rby,lambda3,cyy) * pol2_dip(2) 
            U = U + pol1_U1ind(2) * TU1y_1z(R3,lambda5,ray,rbz,lambda3,cyz) * pol2_dip(3) 
            U = U + pol1_U1ind(3) * TU1z_1x(R3,lambda5,raz,rbx,lambda3,czx) * pol2_dip(1) 
            U = U + pol1_U1ind(3) * TU1z_1y(R3,lambda5,raz,rby,lambda3,czy) * pol2_dip(2) 
            U = U + pol1_U1ind(3) * TU1z_1z(R3,lambda5,raz,rbz,lambda3,czz) * pol2_dip(3) 
        ELSE
            U = U + pol1_U1ind(1) * T1x_1x(R3,rax,rbx,cxx) * pol2_dip(1) 
            U = U + pol1_U1ind(1) * T1x_1y(R3,rax,rby,cxy) * pol2_dip(2) 
            U = U + pol1_U1ind(1) * T1x_1z(R3,rax,rbz,cxz) * pol2_dip(3) 
            U = U + pol1_U1ind(2) * T1y_1x(R3,ray,rbx,cyx) * pol2_dip(1) 
            U = U + pol1_U1ind(2) * T1y_1y(R3,ray,rby,cyy) * pol2_dip(2) 
            U = U + pol1_U1ind(2) * T1y_1z(R3,ray,rbz,cyz) * pol2_dip(3) 
            U = U + pol1_U1ind(3) * T1z_1x(R3,raz,rbx,czx) * pol2_dip(1) 
            U = U + pol1_U1ind(3) * T1z_1y(R3,raz,rby,czy) * pol2_dip(2) 
            U = U + pol1_U1ind(3) * T1z_1z(R3,raz,rbz,czz) * pol2_dip(3) 
        END IF
    END IF    
        !!cout << "E up to d <-> d " << E << endl 

    IF (pol1_rank > 1 .AND. pol2_rank > 0) THEN
        E = E + pol1_quad(1) * T20_1x(R4,raz,rbx,czx) * pol2_dip(1) 
        E = E + pol1_quad(1) * T20_1y(R4,raz,rby,czy) * pol2_dip(2) 
        E = E + pol1_quad(1) * T20_1z(R4,raz,rbz,czz) * pol2_dip(3) 

        E = E + pol1_quad(2) * T21c_1x(R4,rax,czx,cxx,raz,rbx) * pol2_dip(1) 
        E = E + pol1_quad(2) * T21c_1y(R4,rax,czy,cxy,raz,rby) * pol2_dip(2) 
        E = E + pol1_quad(2) * T21c_1z(R4,rax,czz,cxz,raz,rbz) * pol2_dip(3) 

        E = E + pol1_quad(3) * T21s_1x(R4,ray,czx,cyx,raz,rbx) * pol2_dip(1) 
        E = E + pol1_quad(3) * T21s_1y(R4,ray,czy,cyy,raz,rby) * pol2_dip(2) 
        E = E + pol1_quad(3) * T21s_1z(R4,ray,czz,cyz,raz,rbz) * pol2_dip(3) 

        E = E + pol1_quad(4) * T22c_1x(R4,rax,ray,rbx,cxx,cyx) * pol2_dip(1) 
        E = E + pol1_quad(4) * T22c_1y(R4,rax,ray,rby,cxy,cyy) * pol2_dip(2) 
        E = E + pol1_quad(4) * T22c_1z(R4,rax,ray,rbz,cxz,cyz) * pol2_dip(3) 

        E = E + pol1_quad(5) * T22s_1x(R4,rax,ray,rbx,cyx,cxx) * pol2_dip(1) 
        E = E + pol1_quad(5) * T22s_1y(R4,rax,ray,rby,cyy,cxy) * pol2_dip(2) 
        E = E + pol1_quad(5) * T22s_1z(R4,rax,ray,rbz,cyz,cxz) * pol2_dip(3) 
    END IF

    IF ((pol1_rank > 0) .AND. (pol2_rank > 1)) THEN
        E = E + pol1_dip(1) * T1x_20(R4,rbz,rax,cxz) * pol2_quad(1) 
        E = E + pol1_dip(2) * T1y_20(R4,rbz,ray,cyz) * pol2_quad(1) 
        E = E + pol1_dip(3) * T1z_20(R4,rbz,raz,czz) * pol2_quad(1) 

        E = E + pol1_dip(1) * T1x_21c(R4,rbx,cxz,cxx,rbz,rax) * pol2_quad(2) 
        E = E + pol1_dip(2) * T1y_21c(R4,rbx,cyz,cyx,rbz,ray) * pol2_quad(2) 
        E = E + pol1_dip(3) * T1z_21c(R4,rbx,czz,czx,rbz,raz) * pol2_quad(2) 

        E = E + pol1_dip(1) * T1x_21s(R4,rby,cxz,cxy,rbz,rax) * pol2_quad(3) 
        E = E + pol1_dip(2) * T1y_21s(R4,rby,cyz,cyy,rbz,ray) * pol2_quad(3) 
        E = E + pol1_dip(3) * T1z_21s(R4,rby,czz,czy,rbz,raz) * pol2_quad(3) 

        E = E + pol1_dip(1) * T1x_22c(R4,rbx,rby,rax,cxx,cxy) * pol2_quad(4) 
        E = E + pol1_dip(2) * T1y_22c(R4,rbx,rby,ray,cyx,cyy) * pol2_quad(4) 
        E = E + pol1_dip(3) * T1z_22c(R4,rbx,rby,raz,czx,czy) * pol2_quad(4) 

        E = E + pol1_dip(1) * T1x_22s(R4,rbx,rby,rax,cxy,cxx) * pol2_quad(5) 
        E = E + pol1_dip(2) * T1y_22s(R4,rbx,rby,ray,cyy,cyx) * pol2_quad(5) 
        E = E + pol1_dip(3) * T1z_22s(R4,rbx,rby,raz,czy,czx) * pol2_quad(5) 
    END IF

    IF (pol1_rank > 1) THEN
        IF (a*u3 < 40.0) THEN
            U = U + pol1_quad(1)  * TU20_1x(R4,lambda7,raz,rbx,lambda5,czx)  * pol2_U1ind(1) 
            U = U + pol1_quad(1)  * TU20_1y(R4,lambda7,raz,rby,lambda5,czy)  * pol2_U1ind(2) 
            U = U + pol1_quad(1)  * TU20_1z(R4,lambda7,raz,rbz,lambda5,czz)  * pol2_U1ind(3) 
            U = U + pol1_quad(2) * TU21c_1x(R4,lambda5,rax,czx,cxx,raz,lambda7,rbx) * pol2_U1ind(1) 
            U = U + pol1_quad(2) * TU21c_1y(R4,lambda5,rax,czy,cxy,raz,lambda7,rby) * pol2_U1ind(2) 
            U = U + pol1_quad(2) * TU21c_1z(R4,lambda5,rax,czz,cxz,raz,lambda7,rbz) * pol2_U1ind(3) 
            U = U + pol1_quad(3) * TU21s_1x(R4,lambda5,ray,czx,cyx,raz,lambda7,rbx) * pol2_U1ind(1) 
            U = U + pol1_quad(3) * TU21s_1y(R4,lambda5,ray,czy,cyy,raz,lambda7,rby) * pol2_U1ind(2) 
            U = U + pol1_quad(3) * TU21s_1z(R4,lambda5,ray,czz,cyz,raz,lambda7,rbz) * pol2_U1ind(3) 
            U = U + pol1_quad(4) * TU22c_1x(R4,lambda7,rax,ray,rbx,lambda5,cxx,cyx) * pol2_U1ind(1) 
            U = U + pol1_quad(4) * TU22c_1y(R4,lambda7,rax,ray,rby,lambda5,cxy,cyy) * pol2_U1ind(2) 
            U = U + pol1_quad(4) * TU22c_1z(R4,lambda7,rax,ray,rbz,lambda5,cxz,cyz) * pol2_U1ind(3) 
            U = U + pol1_quad(5) * TU22s_1x(R4,lambda7,rax,ray,rbx,lambda5,cyx,cxx) * pol2_U1ind(1) 
            U = U + pol1_quad(5) * TU22s_1y(R4,lambda7,rax,ray,rby,lambda5,cyy,cxy) * pol2_U1ind(2) 
            U = U + pol1_quad(5) * TU22s_1z(R4,lambda7,rax,ray,rbz,lambda5,cyz,cxz) * pol2_U1ind(3) 
        ELSE
            U = U + pol1_quad(1)  * T20_1x(R4,raz,rbx,czx)  * pol2_U1ind(1) 
            U = U + pol1_quad(1)  * T20_1y(R4,raz,rby,czy)  * pol2_U1ind(2) 
            U = U + pol1_quad(1)  * T20_1z(R4,raz,rbz,czz)  * pol2_U1ind(3) 
            U = U + pol1_quad(2) * T21c_1x(R4,rax,czx,cxx,raz,rbx) * pol2_U1ind(1) 
            U = U + pol1_quad(2) * T21c_1y(R4,rax,czy,cxy,raz,rby) * pol2_U1ind(2) 
            U = U + pol1_quad(2) * T21c_1z(R4,rax,czz,cxz,raz,rbz) * pol2_U1ind(3) 
            U = U + pol1_quad(3) * T21s_1x(R4,ray,czx,cyx,raz,rbx) * pol2_U1ind(1) 
            U = U + pol1_quad(3) * T21s_1y(R4,ray,czy,cyy,raz,rby) * pol2_U1ind(2) 
            U = U + pol1_quad(3) * T21s_1z(R4,ray,czz,cyz,raz,rbz) * pol2_U1ind(3) 
            U = U + pol1_quad(4) * T22c_1x(R4,rax,ray,rbx,cxx,cyx) * pol2_U1ind(1) 
            U = U + pol1_quad(4) * T22c_1y(R4,rax,ray,rby,cxy,cyy) * pol2_U1ind(2) 
            U = U + pol1_quad(4) * T22c_1z(R4,rax,ray,rbz,cxz,cyz) * pol2_U1ind(3) 
            U = U + pol1_quad(5) * T22s_1x(R4,rax,ray,rbx,cyx,cxx) * pol2_U1ind(1) 
            U = U + pol1_quad(5) * T22s_1y(R4,rax,ray,rby,cyy,cxy) * pol2_U1ind(2) 
            U = U + pol1_quad(5) * T22s_1z(R4,rax,ray,rbz,cyz,cxz) * pol2_U1ind(3) 
        END IF
    END IF
    IF (pol2_rank > 1) THEN
        IF (a*u3 < 40.0) THEN
            U = U + pol1_U1ind(1) * TU1x_20(R4,lambda7,rbz,rax,lambda5,cxz)  * pol2_quad(1) 
            U = U + pol1_U1ind(1) * TU1x_21c(R4,lambda5,rbx,cxz,cxx,rbz,lambda7,rax) * pol2_quad(2) 
            U = U + pol1_U1ind(1) * TU1x_21s(R4,lambda5,rby,cxz,cxy,rbz,lambda7,rax) * pol2_quad(3) 
            U = U + pol1_U1ind(1) * TU1x_22c(R4,lambda7,rbx,rby,rax,lambda5,cxx,cxy) * pol2_quad(4) 
            U = U + pol1_U1ind(1) * TU1x_22s(R4,lambda7,rbx,rby,rax,lambda5,cxy,cxx) * pol2_quad(5) 
            U = U + pol1_U1ind(2) * TU1y_20(R4,lambda7,rbz,ray,lambda5,cyz)  * pol2_quad(1) 
            U = U + pol1_U1ind(2) * TU1y_21c(R4,lambda5,rbx,cyz,cyx,rbz,lambda7,ray) * pol2_quad(2) 
            U = U + pol1_U1ind(2) * TU1y_21s(R4,lambda5,rby,cyz,cyy,rbz,lambda7,ray) * pol2_quad(3) 
            U = U + pol1_U1ind(2) * TU1y_22c(R4,lambda7,rbx,rby,ray,lambda5,cyx,cyy) * pol2_quad(4) 
            U = U + pol1_U1ind(2) * TU1y_22s(R4,lambda7,rbx,rby,ray,lambda5,cyy,cyx) * pol2_quad(5) 
            U = U + pol1_U1ind(3) * TU1z_20(R4,lambda7,rbz,raz,lambda5,czz)  * pol2_quad(1) 
            U = U + pol1_U1ind(3) * TU1z_21c(R4,lambda5,rbx,czz,czx,rbz,lambda7,raz) * pol2_quad(2) 
            U = U + pol1_U1ind(3) * TU1z_21s(R4,lambda5,rby,czz,czy,rbz,lambda7,raz) * pol2_quad(3) 
            U = U + pol1_U1ind(3) * TU1z_22c(R4,lambda7,rbx,rby,raz,lambda5,czx,czy) * pol2_quad(4) 
            U = U + pol1_U1ind(3) * TU1z_22s(R4,lambda7,rbx,rby,raz,lambda5,czy,czx) * pol2_quad(5) 
        ELSE
            U = U + pol1_U1ind(1) * T1x_20(R4,rbz,rax,cxz)  * pol2_quad(1) 
            U = U + pol1_U1ind(1) * T1x_21c(R4,rbx,cxz,cxx,rbz,rax) * pol2_quad(2) 
            U = U + pol1_U1ind(1) * T1x_21s(R4,rby,cxz,cxy,rbz,rax) * pol2_quad(3) 
            U = U + pol1_U1ind(1) * T1x_22c(R4,rbx,rby,rax,cxx,cxy) * pol2_quad(4) 
            U = U + pol1_U1ind(1) * T1x_22s(R4,rbx,rby,rax,cxy,cxx) * pol2_quad(5) 
            U = U + pol1_U1ind(2) * T1y_20(R4,rbz,ray,cyz)  * pol2_quad(1) 
            U = U + pol1_U1ind(2) * T1y_21c(R4,rbx,cyz,cyx,rbz,ray) * pol2_quad(2) 
            U = U + pol1_U1ind(2) * T1y_21s(R4,rby,cyz,cyy,rbz,ray) * pol2_quad(3) 
            U = U + pol1_U1ind(2) * T1y_22c(R4,rbx,rby,ray,cyx,cyy) * pol2_quad(4) 
            U = U + pol1_U1ind(2) * T1y_22s(R4,rbx,rby,ray,cyy,cyx) * pol2_quad(5) 
            U = U + pol1_U1ind(3) * T1z_20(R4,rbz,raz,czz)  * pol2_quad(1) 
            U = U + pol1_U1ind(3) * T1z_21c(R4,rbx,czz,czx,rbz,raz) * pol2_quad(2) 
            U = U + pol1_U1ind(3) * T1z_21s(R4,rby,czz,czy,rbz,raz) * pol2_quad(3) 
            U = U + pol1_U1ind(3) * T1z_22c(R4,rbx,rby,raz,czx,czy) * pol2_quad(4) 
            U = U + pol1_U1ind(3) * T1z_22s(R4,rbx,rby,raz,czy,czx) * pol2_quad(5) 
        END IF
    END IF
        !!cout << "E up to d <-> Q " << E << endl 

    IF ((pol1_rank > 1) .AND. (pol2_rank > 1)) THEN
        E = E + pol1_quad(1)  * T20_20(R5,raz,rbz,czz)   * pol2_quad(1) 
        E = E + pol1_quad(2) * T21c_21c(R5,rax,raz,rbx,rbz,czz,czx,cxz,cxx) * pol2_quad(2) 
        E = E + pol1_quad(3) * T21s_21s(R5,ray,raz,rby,rbz,czz,czy,cyz,cyy) * pol2_quad(3) 
        E = E + pol1_quad(4) * T22c_22c(R5,rax,rbx,rby,ray,cxx,cxy,cyx,cyy) * pol2_quad(4) 
        E = E + pol1_quad(5) * T22s_22s(R5,rax,ray,rbx,rby,cyy,cyx,cxy,cxx) * pol2_quad(5) 


        E = E + pol1_quad(1)  * T20_21c(R5,raz,rbx,rbz,czz,czx) * pol2_quad(2) 
        E = E + pol1_quad(1)  * T20_21s(R5,raz,rby,rbz,czz,czy) * pol2_quad(3) 
        E = E + pol1_quad(1)  * T20_22c(R5,raz,rbx,rby,czx,czy) * pol2_quad(4) 
        E = E + pol1_quad(1)  * T20_22s(R5,raz,rbx,rby,czy,czx) * pol2_quad(5) 
        E = E + pol1_quad(2) * T21c_20(R5,rbz,rax,raz,czz,cxz) * pol2_quad(1) 
        E = E + pol1_quad(3) * T21s_20(R5,rbz,ray,raz,czz,cyz) * pol2_quad(1) 
        E = E + pol1_quad(4) * T22c_20(R5,rbz,rax,ray,cxz,cyz) * pol2_quad(1) 
        E = E + pol1_quad(5) * T22s_20(R5,rbz,rax,ray,cyz,cxz) * pol2_quad(1) 


        E = E + pol1_quad(2) * T21c_21s(R5,rax,raz,rby,rbz,czz,czy,cxz,cxy) * pol2_quad(3) 
        E = E + pol1_quad(2) * T21c_22c(R5,rax,raz,rbx,rby,czx,czy,cxx,cxy) * pol2_quad(4) 
        E = E + pol1_quad(2) * T21c_22s(R5,rax,raz,rbx,rby,czy,czx,cxy,cxx) * pol2_quad(5) 
        E = E + pol1_quad(3) * T21s_21c(R5,rbx,rbz,ray,raz,czz,cyz,czx,cyx) * pol2_quad(2) 
        E = E + pol1_quad(4) * T22c_21c(R5,rbx,rbz,rax,ray,cxz,cyz,cxx,cyx) * pol2_quad(2) 
        E = E + pol1_quad(5) * T22s_21c(R5,rbx,rbz,rax,ray,cyz,cxz,cyx,cxx) * pol2_quad(2) 


        E = E + pol1_quad(3) * T21s_22c(R5,ray,raz,rbx,rby,czx,czy,cyx,cyy) * pol2_quad(4) 
        E = E + pol1_quad(3) * T21s_22s(R5,ray,raz,rbx,rby,czy,czx,cyy,cyx) * pol2_quad(5) 
        E = E + pol1_quad(4) * T22c_21s(R5,rby,rbz,rax,ray,cxz,cyz,cxy,cyy) * pol2_quad(3) 
        E = E + pol1_quad(5) * T22s_21s(R5,rby,rbz,rax,ray,cyz,cxz,cyy,cxy) * pol2_quad(3) 

        E = E + pol1_quad(5) * T22s_22c(R5,rbx,rax,ray,rby,cyx,cxx,cyy,cxy) * pol2_quad(4) 
        E = E + pol1_quad(4) * T22c_22s(R5,rax,rbx,rby,ray,cxy,cxx,cyy,cyx) * pol2_quad(5) 
    END IF
        !!cout << "E up to Q <-> Q " << E << endl 
        

    !! Take into account work required to induce multipoles
    U = 0.5 * U

    EP = EP + E 
    EU_INTER = EU_INTER + U 
    E_sum = E + U ! returned in votca
END SUBROUTINE Interactor_EnergyInter



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!! Start Read GDMA files         !!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
SUBROUTINE prepare_multipoles(RundI,N_Resids,N_Atoms,residue_names,KETTE,GDMAfilepath,pol_q00,pol_dip,pol_quad,pol_alpha,pol_rank)
!!! FILLS the arrays with *.mps data
!!! read all the multipole moments from the GDMA files ito the GLOBAL arrays for neutral, electron, and hole charged state
!!! here you find a loop over all resids in the residue_name array, and check if a new resid_name occures, then three new *.mps files are read
!!! the data is read with the readGDMAFile subroutine.
!!! IN :: RundI,N_Resids,N_Atoms,residue_names
!!! OUT GLOBAL :: pol_q00,pol_dip,pol_quad,pol_alpha,pol_rank
    IMPLICIT NONE   
    INTEGER, INTENT(IN)::N_Resids,N_Atoms 
    INTEGER, Dimension(N_Resids+1,2)  , INTENT(IN) :: RundI ! Resid,Index_fuer_molekuelstart
    Character(5), Dimension(N_Resids) , INTENT(IN) :: residue_names  
    LOGICAL, INTENT(IN) ::KETTE

    !!! GLOBAL ARRAYS (NAtoms,3) => (1 = neutral , 2 = electron, 3 = hole ) 
    !!! pol_charge(N_Atoms,3,Q00) !!! charge
    REAL, DIMENSION(N_Atoms,3)   ::pol_q00
    !!! pol_dip(N_Atoms,3,Q1x,Q1y,Q1z) !!! dipole
    REAL, DIMENSION(N_Atoms,3,3), INTENT(OUT)  ::pol_dip
    !!! pol_quad(N_Atoms,3,Q20,Q21c,Q21s,Q22c,Q22s) !!! quadrupole
    REAL, DIMENSION(N_Atoms,3,5), INTENT(OUT)  ::pol_quad
    !!!  pol_alpha(P1) !!! polarizability_alpha  // Dipole polarizability
    REAL, Dimension(N_Atoms,3), INTENT(OUT)  :: pol_alpha  
    !!! rank array global
    INTEGER, Dimension(N_Atoms,3), INTENT(OUT)  :: pol_rank
       
    !!! LOCAL ARRAYS neutral _n_, electron _el_, hole _lo_

    !!! pol_n_charge(N_poles,Q00) !!! charge
    REAL, ALLOCATABLE, DIMENSION(:)   ::pol_n_q00,pol_el_q00,pol_lo_q00
    !!! pol_n_dip(N_poles,Q1x,Q1y,Q1z) !!! dipole
    REAL, ALLOCATABLE, DIMENSION(:,:)  ::pol_n_dip,pol_el_dip,pol_lo_dip
    !!! pol_n_quad(N_poles,Q20,Q21c,Q21s,Q22c,Q22s) !!! quadrupole
    REAL, ALLOCATABLE, DIMENSION(:,:)  ::pol_n_quad,pol_el_quad,pol_lo_quad
    !!!  pol_n_alpha(P1) !!! polarizability_alpha  // Dipole polarizability
    REAL, ALLOCATABLE, DIMENSION(:)  :: pol_n_alpha,pol_el_alpha,pol_lo_alpha 
    !!! rank local 
    INTEGER, ALLOCATABLE, DIMENSION(:)  :: pol_n_rank,pol_el_rank,pol_lo_rank
    !!! local
    INTEGER::i,j,k,l,N_poles
    CHARACTER (LEN=500)::Molname,old_residue_name,S_Ringe
    
    Character(800) ::GDMA_mps_file_n,GDMA_mps_file_el,GDMA_mps_file_lo,GDMAfilepath
    LOGICAL::DEBUG=.false.
    
    
    debug=.false.
    IF( N_Resids > N_Atoms) THEN
        WRITE(*,*) 'Error: N_Resids > N_Atoms; check input',N_Resids,N_Atoms
        STOP  'Error: N_Resids > N_Atoms; check input'
    END IF

!IF ( .NOT. Allocated(q_n_el_lo))  allocate(q_n_el_lo(N_Atoms,3))
!q_n_el_lo=0.0

! H-Atome muessen schon vorher angefuegt worden sein!
    old_residue_name=''
    DO i=1,N_Resids
        IF( old_residue_name /= residue_names(i) ) THEN ! new molecule?
                ! Molname
                IF ( TRIM(residue_names(i)(1:3)) == 'THP' .OR. (residue_names(i)=='P3MT') .OR. (residue_names(i)=='P3HT') ) THEN
                    Molname='P3MT'
                    IF(KETTE) Molname='P3HT'
                    WRITE(*,*) 'prepare_multipoles_mode_not_for_P3MT, no polymers'
                    STOP
                ELSE IF (  TRIM(ADJUSTL(residue_names(i))) == 'DIPBI') THEN
                    Molname='DIPBI'
                    IF(KETTE) Molname='DIPBI_KETTE'
                ELSE IF (  TRIM(ADJUSTL(residue_names(i))) == 'PPDI_') THEN
                    Molname='PPDI'
                    IF(KETTE) Molname='PPDI_KETTE'
                ELSE IF (  TRIM(ADJUSTL(residue_names(i))) == '8poly') THEN
                    Molname='PBDT-TS1'
                    WRITE(*,*) 'prepare_multipoles_mode_not_for_PBDT-TS1, no polymers'
                    STOP
                ELSE
                    Molname=TRIM(residue_names(i))
                END IF !Get molname
                
                S_Ringe=''
                GDMA_mps_file_n = TRIM(GDMAfilepath)//'/'//TRIM(Molname)//TRIM(S_Ringe)//'_n.mps'
                GDMA_mps_file_el= TRIM(GDMAfilepath)//'/'//TRIM(Molname)//TRIM(S_Ringe)//'_el.mps'
                GDMA_mps_file_lo= TRIM(GDMAfilepath)//'/'//TRIM(Molname)//TRIM(S_Ringe)//'_lo.mps'
                N_poles=RundI(i+1,2)-RundI(i,2)
                WRITE(*,*) '... ... ... Number of poles / atoms: ',N_poles
                IF ( Allocated(pol_n_q00))   deallocate(pol_n_q00,pol_n_dip,pol_n_quad,pol_n_alpha,pol_n_rank)
                IF ( Allocated(pol_el_q00))  deallocate(pol_el_q00,pol_el_dip,pol_el_quad,pol_el_alpha,pol_el_rank)
                IF ( Allocated(pol_lo_q00))  deallocate(pol_lo_q00,pol_lo_dip,pol_lo_quad,pol_lo_alpha,pol_lo_rank)
                
                ALLOCATE(pol_n_q00(N_poles),pol_el_q00(N_poles),pol_lo_q00(N_poles))
                ALLOCATE(pol_n_dip(N_poles,3),pol_el_dip(N_poles,3),pol_lo_dip(N_poles,3))
                ALLOCATE(pol_n_quad(N_poles,5),pol_el_quad(N_poles,5),pol_lo_quad(N_poles,5))
                ALLOCATE(pol_n_alpha(N_poles),pol_el_alpha(N_poles),pol_lo_alpha(N_poles)) 
                ALLOCATE(pol_n_rank(N_poles),pol_el_rank(N_poles),pol_lo_rank(N_poles))
                
                call readGDMAFile(GDMA_mps_file_n,N_poles,pol_n_q00,pol_n_dip,pol_n_quad,pol_n_alpha,pol_n_rank)
                call readGDMAFile(GDMA_mps_file_el,N_poles,pol_el_q00,pol_el_dip,pol_el_quad,pol_el_alpha,pol_el_rank)
                call readGDMAFile(GDMA_mps_file_lo,N_poles,pol_lo_q00,pol_lo_dip,pol_lo_quad,pol_lo_alpha,pol_lo_rank)
                IF(debug)THEN
                        WRITE(*,*) '-----Partial charges q00 '//TRIM(Molname)//' n -- el -- lo  ------'
                        DO j=1,N_poles
                            WRITE(*,'(3F12.6)') pol_n_q00(j),pol_el_q00(j),pol_lo_q00(j)
                        END DO
			WRITE(*,*) '-----Partial pol_n_dipoles '//TRIM(Molname)//' n -- el -- lo  ------'
			DO j=1,N_poles
				WRITE(*,'(9F12.6)') pol_n_dip(j,1:3),pol_el_dip(j,1:3),pol_lo_dip(j,1:3)
			END DO
			WRITE(*,*) '-----Partial pol_n_quarupoles '//TRIM(Molname)//' n -- el -- lo  ------'
			DO j=1,N_poles
				WRITE(*,'(9F12.6)') pol_n_quad(j,1:5),pol_el_quad(j,1:5),pol_lo_quad(j,1:5)
			END DO
			WRITE(*,*) '-----Partial pol_alpha '//TRIM(Molname)//' n -- el -- lo  ------'
			DO j=1,N_poles
				WRITE(*,'(3F12.6)') pol_n_alpha(j),pol_el_alpha(j),pol_lo_alpha(j)
			END DO

                END IF ! debug
                WRITE(*,*) 'Files used: ',TRIM(GDMA_mps_file_n),' ',TRIM(GDMA_mps_file_el),' ',TRIM(GDMA_mps_file_lo)
        END IF ! new element
   
        !!!! Transfer GDMA *.mps data form local array to the GLOBAL ARRAYS: pol_q00,pol_dip,pol_quad,pol_alpha,pol_rank 

        l=0
        DO k=RundI(i,2),RundI(i+1,2)-1,1 !!! cycle over all atoms with the same resid
          l=l+1
          pol_q00(k,1)=pol_n_q00(l)
          pol_q00(k,2)=pol_el_q00(l)
          pol_q00(k,3)=pol_lo_q00(l)
          
          DO j=1,3  ! dip_x,dip_y,dip_z
              pol_dip(k,1,j)=pol_n_dip(l,j)
              pol_dip(k,2,j)=pol_el_dip(l,j)
              pol_dip(k,3,j)=pol_lo_dip(l,j)
          END DO
         
          DO j=1,5  ! Q20,Q21c,Q21s,Q22c,Q22s
              pol_quad(k,1,j)=pol_n_quad(l,j)
              pol_quad(k,2,j)=pol_el_quad(l,j)
              pol_quad(k,3,j)=pol_lo_quad(l,j)
          END DO
          
          pol_alpha(k,1)=pol_n_alpha(l)
          pol_alpha(k,2)=pol_el_alpha(l)
          pol_alpha(k,3)=pol_lo_alpha(l)
          
          pol_rank(k,1)=pol_n_rank(l)
          pol_rank(k,2)=pol_el_rank(l)
          pol_rank(k,3)=pol_lo_rank(l)
   
        END DO ! k ... all atoms in one Resid
          
        old_residue_name=residue_names(i)
    END DO ! i=1,N_Resids
    WRITE(*,*) '... ... ... prepare_multipoles done'
END SUBROUTINE prepare_multipoles

!!!**
!!!* Parses GDMA punch file (for structure sample see below)
!!!* ... Loads positions, rank, multipoles
!!!* ... Converts from a.u. to internal units
!!!* ... Determines polarizabilities from element type
!!!* 
!!!*
!!! The GDMA program carries out Distributed Multipole Analysis of wavefunctions expressed in
!!! terms of Gaussian atomic orbitals, calculated using either the Gaussian system of programs,
!!! using the formatted checkpoint file produced by Gaussian. (by Anthony J. Stone)
!!!  *.mps format

!vector<PolarSite*> EMultipole::ParseGdmaFile(string GDMAfilename, int state) 
!!!  Reads the data from one GDMA file 
!!!    IN:GDMAfilename,N_poles    OUT:  pol_q00,pol_dip,  pol_quad, pol_alpha,        pol_rank
!!!Bsp IN:alq3_h.mps,52           OUT: charges,dipoles,quadrupoles,alpha_polarizabilities,rank
SUBROUTINE readGDMAFile(GDMAfilename,N_poles,pol_q00,pol_dip,pol_quad,pol_alpha,pol_rank)
	use small_functions
    CHARACTER(Len=*), INTENT(IN)::GDMAfilename
    INTEGER, INTENT(IN):: N_poles !! Number of poles / atoms in the file
    INTEGER, Dimension(N_poles), INTENT(OUT)  :: pol_rank
    !!! pol_charge(N_poles,Q00) !!! charge
    REAL, DIMENSION(N_poles), INTENT(OUT)  ::pol_q00
    !!! pol_dip(N_poles,Q1x,Q1y,Q1z) !!! dipole
    REAL, DIMENSION(N_poles,3), INTENT(OUT) ::pol_dip
    !!! pol_quad(N_poles,Q20,Q21c,Q21s,Q22c,Q22s) !!! quadrupole
    REAL, DIMENSION(N_poles,5), INTENT(OUT) ::pol_quad
    !!!  pol_alpha(P1) !!! polarizability_alpha  // Dipole polarizability
    REAL, Dimension(N_poles), INTENT(OUT)  :: pol_alpha    
    !!! only local for reference
    Character(5), Dimension(N_poles) :: pol_name
    Real, Dimension(N_poles,3) :: pol_coord  !!! coordinates of poles

    !vector<PolarSite*> poles;
    !PolarSite *thisPole = NULL;

    !REAL, DIMENSION (3):: Qs; !! <- multipole moments
    !REAL::                P1; !! <- dipole polarizability
    REAL::Q0_total = 0.0
    !!! local variables
    CHARACTER (len=50):: units
    CHARACTER (len=10):: read_a_dummy,read_dummy2,read_dummy3,read_dummy4,read_dummy5,read_dummy6
    REAL::BOHR2NM = 0.0529189379
    REAL::ANGSTROM2NM = 0.1
    REAL:: alpha    
    LOGICAL:: useDefaultPs = .true.
    LOGICAL:: warn_anisotropy = .false. 
    INTEGER::i,ierror,pol_counter,lineRank
    LOGICAL::DEBUG=.false.
    
    warn_anisotropy = .false. 
    useDefaultPs = .true.
    IF (check_filetermination(GDMAfilename,'.mps')) CONTINUE

    !!! reset data
    pol_rank=0
    pol_coord=0
    pol_q00=0
    pol_dip=0
    pol_quad=0
    pol_alpha=0.0
    pol_name=""
    
    units=""
    Q0_total=0.0
    
    pol_counter=0    
    if (file_exists(GDMAfilename)) THEN ! file exists?
        OPEN(UNIT=31,FILE=TRIM(GDMAfilename),STATUS='OLD',action ='READ',IOSTAT=ierror)
        IF (check_ierror(GDMAfilename,ierror)) CONTINUE 
        WRITE(*,*) '... ... ... Read data from *.mps file: ',TRIM(GDMAfilename)
        DO while ( ierror == 0 ) 
            !!! ignore command lines
            !READ(31,'(A5)',IOSTAT=ierror,ADVANCE='NO',size =j) read_a_dummy !TO DO ,read_dummy2,read_dummy3,read_dummy4,read_dummy5,read_dummy6
            READ(31,*,IOSTAT=ierror) read_a_dummy !,read_dummy2,read_dummy3,read_dummy4,read_dummy5,read_dummy6
            BACKSPACE (31)  !!! read line again 
            !WRITE(*,*) TRIM(read_a_dummy)  !,TRIM(read_dummy2),TRIm(read_dummy3),TRIM(read_dummy4),TRIM(read_dummy5),TRIM(read_dummy6)
            IF (check_ierror(GDMAfilename,ierror)) CONTINUE 
            IF(ierror < 0) EXIT
            !std::getline(intt, line);
            !vector<string> split;
            !Tokenizer toker(line, " \t");
            !toker.ToVector(split);
            IF( (TRIM(read_a_dummy(1:1)) == "!") .OR. (index(read_a_dummy,"!") /= 0) .OR. &
                & (TRIM(read_a_dummy(1:1)) == "#") .OR. (index(read_a_dummy,"#") /= 0) ) THEN ! ignore command line
                READ(31,*,IOSTAT=ierror) read_a_dummy
                IF(DEBUG) WRITE(*,*) '... ... ... Read_comment: ',TRIM(read_a_dummy)
                CYCLE


    !! ! Interesting information here, e.g.
    !! ! DCV2T opt
    !! ! SP        RB3LYP          6-311+G(d,p)
    !! Units bohr
    !!
    !! C          -4.2414603400   -3.8124751600    0.0017575736    Rank  2
    !!  -0.3853409355
    !!  -0.0002321905   0.2401559510   0.6602334308
    !!  -0.7220625314   0.0004894995  -0.0003833545   0.4526409813  -0.50937399
    !!  P 1.75

            !! Units used
            ELSE IF ( TRIM(adjustl(read_a_dummy(1:5))) == "Units" .OR. TRIM(adjustl(read_a_dummy(1:1))) == "U" ) THEN
                READ(31,*,IOSTAT=ierror) read_a_dummy,read_dummy2 
                units = TRIM(read_dummy2)
                WRITE(*,*) '... ... ... Read unit: ',TRIM(units)                
                IF (check_ierror(GDMAfilename,ierror)) CONTINUE 
                if ( (TRIM(adjustl(units)) /= "bohr") .AND. (TRIM(adjustl(units)) /= "angstrom")) THEN
                    WRITE(*,*) "Unit "//TRIM(adjustl(units))//" in file "//TRIM(GDMAfilename)//" not supported."
                    STOP
                END IF
                CYCLE
            END IF !units


                READ(31,*,IOSTAT=ierror) read_a_dummy,read_dummy2,read_dummy3,read_dummy4,read_dummy5,read_dummy6
                BACKSPACE (31)  !!! read line again 
                IF(DEBUG) WRITE(*,*) TRIM(read_a_dummy),TRIM(read_dummy2),TRIm(read_dummy3),&
                            &TRIM(read_dummy4),TRIM(read_dummy5),TRIM(read_dummy6)
                if ( TRIM(adjustl(read_dummy5)) == "Rank" ) THEN

                    !Qs.clear();
                    !P1 = -1.;
                    pol_counter=pol_counter+1  !! <- starts from 0
                    
                    READ(31,*,IOSTAT=ierror) pol_name(pol_counter),pol_coord(pol_counter,1),pol_coord(pol_counter,2),&
                                            &pol_coord(pol_counter,3),read_dummy5,pol_rank(pol_counter)
                    !WRITE(*,*) TRIM(pol_name(pol_counter)),pol_coord(pol_counter,1),pol_coord(pol_counter,2),&
                    !                        &pol_coord(pol_counter,3),read_dummy5,pol_rank(pol_counter)                        
                    IF (check_ierror(GDMAfilename,ierror)) CONTINUE 
    
                    if (TRIM(adjustl(units)) == "bohr") THEN
                        pol_coord(pol_counter,:) = BOHR2NM * pol_coord(pol_counter,:)
                    elSE if (TRIM(adjustl(units)) == "angstrom") THEN
                        pol_coord(pol_counter,:) = ANGSTROM2NM * pol_coord(pol_counter,:)
                    else 
                        WRITE(*,*) "Unit "//TRIM(adjustl(units))//" in file "//TRIM(GDMAfilename)//" not supported."
                        STOP "EXIT"
                    END IF
                    
                    !!!vec pos = vec(x,y,z);
                    !!!
                    !!!int rank = boost::lexical_cast<int>(split[5]);
                    !!!
                    !!!PolarSite *newPole = new PolarSite(id, name);
                    !!!newPole->setRank(rank);
                    !!!newPole->setPos(pos);
                    !!!poles.push_back(newPole);
                    !!!thisPole = newPole;
                    
                    !!!!!
                    !!!!!  READ multipole lines
      
                    lineRank = pol_rank(pol_counter)
                    if (lineRank >= 0) THEN
                        READ(31,*,IOSTAT=ierror) pol_q00(pol_counter)   
                        IF(DEBUG) WRITE(*,*) 'charge: ',pol_q00(pol_counter)  
                        IF (check_ierror(GDMAfilename,ierror)) CONTINUE                    
                        Q0_total = Q0_total + pol_q00(pol_counter)  
                    END IF ! lineRank
    
                    !!!!! NOTE: Order differs in GDMA *.mps convention and Order used here !!!
                    !!Q1z = _Qs[idx][1]   !! |
                    !!Q1x = _Qs[idx][2]   !! |-> NOTE: order z - x - y
                    !!Q1y = _Qs[idx][3]   !! |               
                    if (lineRank >= 1) THEN         ! read pol_dip(pol_counter,Q1x,Q1y,Q1z) !!! dipole
                        READ(31,*,IOSTAT=ierror) pol_dip(pol_counter,3),pol_dip(pol_counter,1),pol_dip(pol_counter,2)          
                        IF(DEBUG) WRITE(*,*) 'dipole:',pol_dip(pol_counter,3),pol_dip(pol_counter,1),pol_dip(pol_counter,2) 
                        IF (check_ierror(GDMAfilename,ierror)) CONTINUE  
                        !! Convert e*(a_0)^k to e*(nm)^k where k = rank                    
                        pol_dip(pol_counter,:)=pol_dip(pol_counter,:)*BOHR2NM**1 
                    END IF ! lineRank
    
                    if (lineRank >= 2) THEN
                        READ(31,*,IOSTAT=ierror) pol_quad(pol_counter,:)   
                        IF(DEBUG) WRITE(*,*) 'quadrupole: ',pol_quad(pol_counter,:) 
                        IF (check_ierror(GDMAfilename,ierror)) CONTINUE  
                        !! Convert e*(a_0)^k to e*(nm)^k where k = rank                    
                        pol_quad(pol_counter,:)=pol_quad(pol_counter,:)*BOHR2NM**2
                    END IF ! lineRank
    
                    if (lineRank >= 3) THEN
                        WRITE(*,*) 'Error: Rank is too, high octopoles are not implemented: Rank=',lineRank
                        STOP
                        !READ(31,*,IOSTAT=ierror) pol_octopole(pol_counter,:)        
                        !IF (check_ierror(GDMAfilename,ierror)) CONTINUE  
                        !! Convert e*(a_0)^k to e*(nm)^k where k = rank                    
                        !pol_octopole(pol_counter,:)=pol_octopole(pol_counter,:)*BOHR2NM**3
                    END IF ! lineRank
    
    
                    !DO j=1,pol_rank(pol_counter),1 !! (unsigned int i = 0; i < split.size(); i++) {
                    !
                    !    REAL::qXYZ = boost::lexical_cast<double>(split[i]);
                    !
                    !    !! Convert e*(a_0)^k to e*(nm)^k where k = rank
                    !    REAL::BOHR2NM = 0.0529189379;
                    !    qXYZ = qXYZ * pow(BOHR2NM, lineRank); !! OVERRIDE
                    !    pol_dip(pol_counter,:)=pol_dip(pol_counter,:)*BOHR2NM**1
                    !    Qs.push_back(qXYZ);
                    !
                    !END DO ! loop over multipole lones Qxx_xx
                    
                    !!!TO DO check this
                    !thisPole->setQs(Qs, state);
                    
                    !!!! End read multipoles for one pol site 
                
        
                !! 'P', read dipole polarizability
                READ(31,*,IOSTAT=ierror) read_a_dummy,read_dummy2,read_dummy3,read_dummy4,read_dummy5
                !WRITE(*,*) 'Test: ',TRIM(read_a_dummy),TRIM(read_dummy2),TRIm(read_dummy3),TRIM(read_dummy4),TRIM(read_dummy5),&
                 !       & "ierror",ierror 
                IF( ierror == -1 ) THEN ! Dateiende -> Korrektur, damit P noch ausgewertet wird. Haesslich aber notwendig.
                    read_dummy5=""
                END IF
                        
                !WRITE(*,*) 'Rank5: ',TRIM(read_dummy5(1:4))
                if ((TRIM(adjustl(read_a_dummy(1:1))) == "P") .AND. (TRIM(adjustl(read_dummy5(1:4))) /= "Rank" )) THEN
                    BACKSPACE(31)  !!! read line again 
                    BACKSPACE(31)  !!! read line again 
                ELSE if ((TRIM(adjustl(read_a_dummy(1:1))) == "P") .AND. (TRIM(adjustl(read_dummy5(1:4))) == "Rank" )) THEN
                    pol_alpha(pol_counter)=0.0
                    read_dummy5=''
                    BACKSPACE(31)  !!! read line again
                    Cycle               
                ELSE if ((TRIM(adjustl(read_a_dummy(1:1))) /= "P") .AND. (TRIM(adjustl(read_dummy5(1:4))) == "Rank" )) THEN
                    BACKSPACE(31)  !!! read line again
                ELSE ! Standard
                    BACKSPACE(31)  !!! read line again
                    BACKSPACE(31)  !!! read line again
                END IF ! check p and rank
                
                
                !!! Read polarizabilities
                
                if (((TRIM(adjustl(read_a_dummy(1:1))) == "P") .OR. (TRIM(adjustl(read_a_dummy(1:3))) == "Pol") .OR. &
                    &(TRIM(adjustl(read_a_dummy(1:3))) == "alpha") ) ) THEN ! TO DO (split.size() == 2 .OR. split.size() == 7)  !!!   .AND. (TRIM(adjustl(read_dummy5)) /= "Rank") 
                    if ( .false. ) THEN  !!! TO DO split.size() == 7
                        warn_anisotropy = .true.
                    END IF
                    READ(31,*,IOSTAT=ierror) read_a_dummy,pol_alpha(pol_counter) 
                    IF(DEBUG) WRITE(*,*) 'Read alpha:',TRIM(read_a_dummy), pol_alpha(pol_counter) 
                    IF (check_ierror(GDMAfilename,ierror)) CONTINUE 
                    pol_alpha(pol_counter) = 1.0E-3 * pol_alpha(pol_counter) 
                    !thisPole->setPs(P1, state); TD DO check if value is changed!!!!!
                    useDefaultPs = .false.
    
                !!! element,  position,  rank limit
                END IF ! !!! Read polarizabilities
                
                
                
            ELSE
                WRITE(*,*) "Error: Should not terminate here reading: "//TRIM(GDMAfilename)
                WRITE(*,*) "Check input file format!"
                WRITE(*,*) 'Check the inputfile, maybe you need to replace the "P" for the polarizarbilities by "alpha" '
                STOP 
            END IF
            IF(ierror < 0) EXIT
        END DO !! ierror == 0 !!         } /* Exit loop over lines */

    else 
        WRITE(*,*) "ERROR: No such file: "//TRIM(GDMAfilename)
        STOP
    END if
    WRITE(*,*)"... ... ... Reading "//TRIM(GDMAfilename)//": Q0(Total) = ",Q0_total
    IF( N_poles /= pol_counter ) THEN
        WRITE(*,*) 'ERROR: The number of expected polar sites ',N_poles,' does not match the number of polar sites ',pol_counter,&
                &' in the file: '//TRIM(GDMAfilename)
        STOP                
    END IF ! check equal number of elements
    CLOSE(31) !!close
    
    if (useDefaultPs) THEN
        WRITE(*,*) "... ... ... NOTE Using default Thole polarizabilities for charge state, not the GDMA file: ",TRIM(GDMAfilename)
        !vector< PolarSite* > ::iterator pol;
        DO i=1,N_poles
            alpha = 0.0
            !!! Original set of Thole polarizabilites
            if      (TRIM(adjustl(pol_name(i))) == "C") THEN
                alpha = 1.75E-3                              !! <- conversion from Angstroem**3 to nm**3 = 10**-3
            else if (TRIM(adjustl(pol_name(i))) == "H") THEN !!
                alpha = 0.696E-3                             !!    
            else if (TRIM(adjustl(pol_name(i))) == "N") THEN
                alpha = 1.073E-3
            else if (TRIM(adjustl(pol_name(i))) == "O") THEN
                alpha = 0.837E-3
            else if (TRIM(adjustl(pol_name(i))) == "S") THEN
                alpha = 2.926E-3
            !! Different set of Thole polarizabilities
            !!if (TRIM(adjustl(pol_name(i))) == "C") THEN
            !!      alpha = 1.334E-3   !! <- conversion from
            !!else if (TRIM(adjustl(pol_name(i))) == "H") THEN
            !!      alpha = 0.496E-3   !!    Angstroem**3 to nm**3 = 10**-3
            !!else if (TRIM(adjustl(pol_name(i))) == "N") THEN
            !!      alpha = 1.073E-3  
            !!else if (TRIM(adjustl(pol_name(i))) == "O") THEN
            !!      alpha = 0.837E-3  
            !!else if (TRIM(adjustl(pol_name(i))) == "S") THEN
            !!      alpha = 3.300E-3  
            else 
                WRITE(*,*) "Warning: No polarizability given for polar site type "//TRIM(pol_name(i))//".  alpha=",alpha
            END IF
            !! TO DO alpha uebergebe!
            !(*pol)->setPs(alpha, state);
            pol_alpha(i)= alpha
        END DO 
    END IF !!!! useDefaultPs
    
    if (warn_anisotropy) THEN
         WRITE(*,*) "WARNING: '"//TRIM(GDMAfilename)//"': EMultipole does not support "
         WRITE(*,*) "tensorial polarizabilities, use zmultipole instead." 
         STOP
    END IF
    
    IF (DEBUG) THEN
        WRITE(*,*) '!!! Data read from GDMA file '//TRIM(GDMAfilename)//'  !!!'
        WRITE(*,*) '!!! Use Thole polarizabilities: ',useDefaultPs
        WRITE(*,*) '!!! Unit: '//TRIM(units)
        DO pol_counter=1,N_poles
            WRITE(*,*) TRIM(pol_name(pol_counter)),pol_coord(pol_counter,1),&
               & pol_coord(pol_counter,2),pol_coord(pol_counter,3),' Rank ',pol_rank(pol_counter)   
            IF ( pol_rank(pol_counter) >=0) WRITE(*,*) pol_q00(pol_counter)    
            IF ( pol_rank(pol_counter) >=1) WRITE(*,*) pol_dip(pol_counter,3),pol_dip(pol_counter,1),pol_dip(pol_counter,2)
            IF ( pol_rank(pol_counter) >=2) WRITE(*,*) pol_quad(pol_counter,:)   
            WRITE(*,*) '   P',pol_alpha(pol_counter) 
        END DO
    END IF
    
    !return poles;
END SUBROUTINE readGDMAFile


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!! END Read GDMA files          !!! 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!! INTERACTOR MULTIPOLES  !!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

	REAL FUNCTION T00_00(R)	  
	IMPLICIT NONE	  
	REAL :: R	  
	 T00_00=R 	  
	END FUNCTION T00_00  	  
	     	  

  	 	 	 		 		 	          	 	 	 
	REAL FUNCTION T1x_00(R2,rax)	  
	IMPLICIT NONE	  
	REAL :: R2,rax	  
	 T1x_00=R2 * rax 	  
	END FUNCTION T1x_00  	  
	     	  

	REAL FUNCTION T1y_00(R2,ray)	  
	IMPLICIT NONE	  
	REAL :: R2,ray	  
	 T1y_00=R2 * ray 	  
	END FUNCTION T1y_00  	  
	     	  

	REAL FUNCTION T1z_00(R2,raz)	  
	IMPLICIT NONE	  
	REAL :: R2,raz	  
	 T1z_00=R2 * raz 	  
	END FUNCTION T1z_00  	  
	     	  

	REAL FUNCTION T00_1x(R2,rbx)	  
	IMPLICIT NONE	  
	REAL :: R2,rbx	  
	 T00_1x=R2 * rbx 	  
	END FUNCTION T00_1x  	  
	     	  

	REAL FUNCTION T00_1y(R2,rby)	  
	IMPLICIT NONE	  
	REAL :: R2,rby	  
	 T00_1y=R2 * rby 	  
	END FUNCTION T00_1y  	  
	     	  

	REAL FUNCTION T00_1z(R2,rbz)	  
	IMPLICIT NONE	  
	REAL :: R2,rbz	  
	 T00_1z=R2 * rbz 	  
	END FUNCTION T00_1z  	  
	     	  

  	 	 	 		 		 	          	 	 	 
	REAL FUNCTION T20_00(R3,raz)	  
	IMPLICIT NONE	  
	REAL :: R3,raz	  
	 T20_00=R3 * 0.5 * (3 * raz*raz - 1) 	  
	END FUNCTION T20_00  	  
	     	  

	REAL FUNCTION T21c_00(R3,rax,raz)	  
	IMPLICIT NONE	  
	REAL :: R3,rax,raz	  
	 T21c_00=R3 * SQRT(3.0) * rax * raz 	  
	END FUNCTION T21c_00  	  
	     	  

	REAL FUNCTION T21s_00(R3,ray,raz)	  
	IMPLICIT NONE	  
	REAL :: R3,ray,raz	  
	 T21s_00=R3 * SQRT(3.0) * ray * raz 	  
	END FUNCTION T21s_00  	  
	     	  

	REAL FUNCTION T22c_00(R3,rax,ray)	  
	IMPLICIT NONE	  
	REAL :: R3,rax,ray	  
	 T22c_00=R3 * 0.5 * SQRT(3.0) * (rax*rax - ray*ray) 	  
	END FUNCTION T22c_00  	  
	     	  

	REAL FUNCTION T22s_00(R3,rax,ray)	  
	IMPLICIT NONE	  
	REAL :: R3,rax,ray	  
	 T22s_00=R3 * SQRT(3.0) * rax*ray 	  
	END FUNCTION T22s_00  	  
	     	  

	REAL FUNCTION T00_20(R3,rbz)	  
	IMPLICIT NONE	  
	REAL :: R3,rbz	  
	 T00_20=R3 * 0.5 * (3 * rbz*rbz - 1) 	  
	END FUNCTION T00_20  	  
	     	  

	REAL FUNCTION T00_21c(R3,rbx,rbz)	  
	IMPLICIT NONE	  
	REAL :: R3,rbx,rbz	  
	 T00_21c=R3 * SQRT(3.0) * rbx * rbz 	  
	END FUNCTION T00_21c  	  
	     	  

	REAL FUNCTION T00_21s(R3,rby,rbz)	  
	IMPLICIT NONE	  
	REAL :: R3,rby,rbz	  
	 T00_21s=R3 * SQRT(3.0) * rby * rbz 	  
	END FUNCTION T00_21s  	  
	     	  

	REAL FUNCTION T00_22c(R3,rbx,rby)	  
	IMPLICIT NONE	  
	REAL :: R3,rbx,rby	  
	 T00_22c=R3 * 0.5 * SQRT(3.0) * (rbx*rbx - rby*rby) 	  
	END FUNCTION T00_22c  	  
	     	  

	REAL FUNCTION T00_22s(R3,rbx,rby)	  
	IMPLICIT NONE	  
	REAL :: R3,rbx,rby	  
	 T00_22s=R3 * SQRT(3.0) * rbx*rby 	  
	END FUNCTION T00_22s  	  
	     	  

  	 	 	 		 		 	          	 	 	 
	REAL FUNCTION T1x_1x(R3,rax,rbx,cxx)	  
	IMPLICIT NONE	  
	REAL :: R3,rax,rbx,cxx	  
	 T1x_1x=R3 * (3 * rax*rbx + cxx) 	  
	END FUNCTION T1x_1x  	  
	     	  

	REAL FUNCTION T1x_1y(R3,rax,rby,cxy)	  
	IMPLICIT NONE	  
	REAL :: R3,rax,rby,cxy	  
	 T1x_1y=R3 * (3 * rax*rby + cxy) 	  
	END FUNCTION T1x_1y  	  
	     	  

	REAL FUNCTION T1x_1z(R3,rax,rbz,cxz)	  
	IMPLICIT NONE	  
	REAL :: R3,rax,rbz,cxz	  
	 T1x_1z=R3 * (3 * rax*rbz + cxz) 	  
	END FUNCTION T1x_1z  	  
	     	  

	REAL FUNCTION T1y_1x(R3,ray,rbx,cyx)	  
	IMPLICIT NONE	  
	REAL :: R3,ray,rbx,cyx	  
	 T1y_1x=R3 * (3 * ray*rbx + cyx) 	  
	END FUNCTION T1y_1x  	  
	     	  

	REAL FUNCTION T1y_1y(R3,ray,rby,cyy)	  
	IMPLICIT NONE	  
	REAL :: R3,ray,rby,cyy	  
	 T1y_1y=R3 * (3 * ray*rby + cyy) 	  
	END FUNCTION T1y_1y  	  
	     	  

	REAL FUNCTION T1y_1z(R3,ray,rbz,cyz)	  
	IMPLICIT NONE	  
	REAL :: R3,ray,rbz,cyz	  
	 T1y_1z=R3 * (3 * ray*rbz + cyz) 	  
	END FUNCTION T1y_1z  	  
	     	  

	REAL FUNCTION T1z_1x(R3,raz,rbx,czx)	  
	IMPLICIT NONE	  
	REAL :: R3,raz,rbx,czx	  
	 T1z_1x=R3 * (3 * raz*rbx + czx) 	  
	END FUNCTION T1z_1x  	  
	     	  

	REAL FUNCTION T1z_1y(R3,raz,rby,czy)	  
	IMPLICIT NONE	  
	REAL :: R3,raz,rby,czy	  
	 T1z_1y=R3 * (3 * raz*rby + czy) 	  
	END FUNCTION T1z_1y  	  
	     	  

	REAL FUNCTION T1z_1z(R3,raz,rbz,czz)	  
	IMPLICIT NONE	  
	REAL :: R3,raz,rbz,czz	  
	 T1z_1z=R3 * (3 * raz*rbz + czz) 	  
	END FUNCTION T1z_1z  	  
	     	  

  	 	 	 		 		 	          	 	 	 
	REAL FUNCTION T20_1x(R4,raz,rbx,czx)	  
	IMPLICIT NONE	  
	REAL :: R4,raz,rbx,czx	  
	 T20_1x=R4 * 0.5 * (15*raz*raz*rbx + 6*raz*czx - 3*rbx) 	  
	END FUNCTION T20_1x  	  
	     	  

	REAL FUNCTION T20_1y(R4,raz,rby,czy)	  
	IMPLICIT NONE	  
	REAL :: R4,raz,rby,czy	  
	 T20_1y=R4 * 0.5 * (15*raz*raz*rby + 6*raz*czy - 3*rby) 	  
	END FUNCTION T20_1y  	  
	     	  

	REAL FUNCTION T20_1z(R4,raz,rbz,czz)	  
	IMPLICIT NONE	  
	REAL :: R4,raz,rbz,czz	  
	 T20_1z=R4 * 0.5 * (15*raz*raz*rbz + 6*raz*czz - 3*rbz) 	  
	END FUNCTION T20_1z  	  
	     	  

	REAL FUNCTION T21c_1x(R4,rax,czx,cxx,raz,rbx)	  
	IMPLICIT NONE	  
	REAL :: R4,rax,czx,cxx,raz,rbx	  
	 T21c_1x=R4 * SQRT(3.0) * (rax*czx + cxx*raz + 5*rax*raz*rbx) 	  
	END FUNCTION T21c_1x  	  
	     	  

	REAL FUNCTION T21c_1y(R4,rax,czy,cxy,raz,rby)	  
	IMPLICIT NONE	  
	REAL :: R4,rax,czy,cxy,raz,rby	  
	 T21c_1y=R4 * SQRT(3.0) * (rax*czy + cxy*raz + 5*rax*raz*rby) 	  
	END FUNCTION T21c_1y  	  
	     	  

	REAL FUNCTION T21c_1z(R4,rax,czz,cxz,raz,rbz)	  
	IMPLICIT NONE	  
	REAL :: R4,rax,czz,cxz,raz,rbz	  
	 T21c_1z=R4 * SQRT(3.0) * (rax*czz + cxz*raz + 5*rax*raz*rbz) 	  
	END FUNCTION T21c_1z  	  
	     	  

	REAL FUNCTION T21s_1x(R4,ray,czx,cyx,raz,rbx)	  
	IMPLICIT NONE	  
	REAL :: R4,ray,czx,cyx,raz,rbx	  
	 T21s_1x=R4 * SQRT(3.0) * (ray*czx + cyx*raz + 5*ray*raz*rbx) 	  
	END FUNCTION T21s_1x  	  
	     	  

	REAL FUNCTION T21s_1y(R4,ray,czy,cyy,raz,rby)	  
	IMPLICIT NONE	  
	REAL :: R4,ray,czy,cyy,raz,rby	  
	 T21s_1y=R4 * SQRT(3.0) * (ray*czy + cyy*raz + 5*ray*raz*rby) 	  
	END FUNCTION T21s_1y  	  
	     	  

	REAL FUNCTION T21s_1z(R4,ray,czz,cyz,raz,rbz)	  
	IMPLICIT NONE	  
	REAL :: R4,ray,czz,cyz,raz,rbz	  
	 T21s_1z=R4 * SQRT(3.0) * (ray*czz + cyz*raz + 5*ray*raz*rbz) 	  
	END FUNCTION T21s_1z  	  
	     	  

	REAL FUNCTION T22c_1x(R4,rax,ray,rbx,cxx,cyx)	  
	IMPLICIT NONE	  
	REAL :: R4,rax,ray,rbx,cxx,cyx	  
	 T22c_1x=R4 * 0.5 * SQRT(3.0) * ( 5*(rax*rax-ray*ray)*rbx + 2*rax*cxx - 2*ray*cyx) 	  
	END FUNCTION T22c_1x  	  
	     	  

	REAL FUNCTION T22c_1y(R4,rax,ray,rby,cxy,cyy)	  
	IMPLICIT NONE	  
	REAL :: R4,rax,ray,rby,cxy,cyy	  
	 T22c_1y=R4 * 0.5 * SQRT(3.0) * ( 5*(rax*rax-ray*ray)*rby + 2*rax*cxy - 2*ray*cyy) 	  
	END FUNCTION T22c_1y  	  
	     	  

	REAL FUNCTION T22c_1z(R4,rax,ray,rbz,cxz,cyz)	  
	IMPLICIT NONE	  
	REAL :: R4,rax,ray,rbz,cxz,cyz	  
	 T22c_1z=R4 * 0.5 * SQRT(3.0) * ( 5*(rax*rax-ray*ray)*rbz + 2*rax*cxz - 2*ray*cyz) 	  
	END FUNCTION T22c_1z  	  
	     	  

	REAL FUNCTION T22s_1x(R4,rax,ray,rbx,cyx,cxx)	  
	IMPLICIT NONE	  
	REAL :: R4,rax,ray,rbx,cyx,cxx	  
	 T22s_1x=R4 * SQRT(3.0) * ( 5*rax*ray*rbx + rax*cyx + ray*cxx ) 	  
	END FUNCTION T22s_1x  	  
	     	  

	REAL FUNCTION T22s_1y(R4,rax,ray,rby,cyy,cxy)	  
	IMPLICIT NONE	  
	REAL :: R4,rax,ray,rby,cyy,cxy	  
	 T22s_1y=R4 * SQRT(3.0) * ( 5*rax*ray*rby + rax*cyy + ray*cxy ) 	  
	END FUNCTION T22s_1y  	  
	     	  

	REAL FUNCTION T22s_1z(R4,rax,ray,rbz,cyz,cxz)	  
	IMPLICIT NONE	  
	REAL :: R4,rax,ray,rbz,cyz,cxz	  
	 T22s_1z=R4 * SQRT(3.0) * ( 5*rax*ray*rbz + rax*cyz + ray*cxz ) 	  
	END FUNCTION T22s_1z  	  
	     	  

	 	 	 		 		 	          	 	 	 
	REAL FUNCTION T1x_20(R4,rbz,rax,cxz)	  
	IMPLICIT NONE	  
	REAL :: R4,rbz,rax,cxz	  
	 T1x_20=R4 * 0.5 * (15*rbz*rbz*rax + 6*rbz*cxz - 3*rax) 	  
	END FUNCTION T1x_20 	  
	     	  

	REAL FUNCTION T1y_20(R4,rbz,ray,cyz)	  
	IMPLICIT NONE	  
	REAL :: R4,rbz,ray,cyz	  
	 T1y_20=R4 * 0.5 * (15*rbz*rbz*ray + 6*rbz*cyz - 3*ray) 	  
	END FUNCTION T1y_20 	  
	     	  

	REAL FUNCTION T1z_20(R4,rbz,raz,czz)	  
	IMPLICIT NONE	  
	REAL :: R4,rbz,raz,czz	  
	 T1z_20=R4 * 0.5 * (15*rbz*rbz*raz + 6*rbz*czz - 3*raz) 	  
	END FUNCTION T1z_20 	  
	     	  

	REAL FUNCTION T1x_21c(R4,rbx,cxz,cxx,rbz,rax)	  
	IMPLICIT NONE	  
	REAL :: R4,rbx,cxz,cxx,rbz,rax	  
	 T1x_21c=R4 * SQRT(3.0) * (rbx*cxz + cxx*rbz + 5*rbx*rbz*rax) 	  
	END FUNCTION T1x_21c  	  
	     	  

	REAL FUNCTION T1y_21c(R4,rbx,cyz,cyx,rbz,ray)	  
	IMPLICIT NONE	  
	REAL :: R4,rbx,cyz,cyx,rbz,ray	  
	 T1y_21c=R4 * SQRT(3.0) * (rbx*cyz + cyx*rbz + 5*rbx*rbz*ray) 	  
	END FUNCTION T1y_21c  	  
	     	  

	REAL FUNCTION T1z_21c(R4,rbx,czz,czx,rbz,raz)	  
	IMPLICIT NONE	  
	REAL :: R4,rbx,czz,czx,rbz,raz	  
	 T1z_21c=R4 * SQRT(3.0) * (rbx*czz + czx*rbz + 5*rbx*rbz*raz) 	  
	END FUNCTION T1z_21c  	  
	     	  

	REAL FUNCTION T1x_21s(R4,rby,cxz,cxy,rbz,rax)	  
	IMPLICIT NONE	  
	REAL :: R4,rby,cxz,cxy,rbz,rax	  
	 T1x_21s=R4 * SQRT(3.0) * (rby*cxz + cxy*rbz + 5*rby*rbz*rax) 	  
	END FUNCTION T1x_21s  	  
	     	  

	REAL FUNCTION T1y_21s(R4,rby,cyz,cyy,rbz,ray)	  
	IMPLICIT NONE	  
	REAL :: R4,rby,cyz,cyy,rbz,ray	  
	 T1y_21s=R4 * SQRT(3.0) * (rby*cyz + cyy*rbz + 5*rby*rbz*ray) 	  
	END FUNCTION T1y_21s  	  
	     	  

	REAL FUNCTION T1z_21s(R4,rby,czz,czy,rbz,raz)	  
	IMPLICIT NONE	  
	REAL :: R4,rby,czz,czy,rbz,raz	  
	 T1z_21s=R4 * SQRT(3.0) * (rby*czz + czy*rbz + 5*rby*rbz*raz) 	  
	END FUNCTION T1z_21s  	  
	     	  

	REAL FUNCTION T1x_22c(R4,rbx,rby,rax,cxx,cxy)	  
	IMPLICIT NONE	  
	REAL :: R4,rbx,rby,rax,cxx,cxy	  
	 T1x_22c=R4 * 0.5 * SQRT(3.0) * ( 5*(rbx*rbx-rby*rby)*rax + 2*rbx*cxx - 2*rby*cxy) 	  
	END FUNCTION T1x_22c  	  
	     	  

	REAL FUNCTION T1y_22c(R4,rbx,rby,ray,cyx,cyy)	  
	IMPLICIT NONE	  
	REAL :: R4,rbx,rby,ray,cyx,cyy	  
	 T1y_22c=R4 * 0.5 * SQRT(3.0) * ( 5*(rbx*rbx-rby*rby)*ray + 2*rbx*cyx - 2*rby*cyy) 	  
	END FUNCTION T1y_22c  	  
	     	  

	REAL FUNCTION T1z_22c(R4,rbx,rby,raz,czx,czy)	  
	IMPLICIT NONE	  
	REAL :: R4,rbx,rby,raz,czx,czy	  
	 T1z_22c=R4 * 0.5 * SQRT(3.0) * ( 5*(rbx*rbx-rby*rby)*raz + 2*rbx*czx - 2*rby*czy) 	  
	END FUNCTION T1z_22c  	  
	     	  

	REAL FUNCTION T1x_22s(R4,rbx,rby,rax,cxy,cxx)	  
	IMPLICIT NONE	  
	REAL :: R4,rbx,rby,rax,cxy,cxx	  
	 T1x_22s=R4 * SQRT(3.0) * ( 5*rbx*rby*rax + rbx*cxy + rby*cxx ) 	  
	END FUNCTION T1x_22s  	  
	     	  

	REAL FUNCTION T1y_22s(R4,rbx,rby,ray,cyy,cyx)	  
	IMPLICIT NONE	  
	REAL :: R4,rbx,rby,ray,cyy,cyx	  
	 T1y_22s=R4 * SQRT(3.0) * ( 5*rbx*rby*ray + rbx*cyy + rby*cyx ) 	  
	END FUNCTION T1y_22s  	  
	     	  

	REAL FUNCTION T1z_22s(R4,rbx,rby,raz,czy,czx)	  
	IMPLICIT NONE	  
	REAL :: R4,rbx,rby,raz,czy,czx	  
	 T1z_22s=R4 * SQRT(3.0) * ( 5*rbx*rby*raz + rbx*czy + rby*czx ) 	  
	END FUNCTION T1z_22s  	  
	     	  

  	 	 	 		 		 	          	 	 	 
	REAL FUNCTION T20_20(R5,raz,rbz,czz)	  
	IMPLICIT NONE	  
	REAL :: R5,raz,rbz,czz	  
	 T20_20=R5 * 0.75 * (35*raz*raz*rbz*rbz - 5*raz*raz - 5*rbz*rbz + 20*raz*rbz*czz + 2*czz*czz + 1) 	  
	END FUNCTION T20_20  	  
	     	  

	REAL FUNCTION T20_21c(R5,raz,rbx,rbz,czz,czx)	  
	IMPLICIT NONE	  
	REAL :: R5,raz,rbx,rbz,czz,czx	  
	 T20_21c=R5 * 0.5 * SQRT(3.0) * (35*raz*raz*rbx*rbz - 5*rbx*rbz + 10*raz*rbx*czz + 10*raz*rbz*czx + 2*czx*czz) 	  
	END FUNCTION T20_21c  	  
	     	  

	REAL FUNCTION T20_21s(R5,raz,rby,rbz,czz,czy)	  
	IMPLICIT NONE	  
	REAL :: R5,raz,rby,rbz,czz,czy	  
	 T20_21s=R5 * 0.5 * SQRT(3.0) * (35*raz*raz*rby*rbz - 5*rby*rbz + 10*raz*rby*czz + 10*raz*rbz*czy + 2*czy*czz) 	  
	END FUNCTION T20_21s  	  
	     	  

	REAL FUNCTION T20_22c(R5,raz,rbx,rby,czx,czy)	  
	IMPLICIT NONE	  
	REAL :: R5,raz,rbx,rby,czx,czy	  
	 T20_22c=R5 * 0.25 * SQRT(3.0) * (35*raz*raz*rbx*rbx - 35*raz*raz*rby*rby - 5*rbx*rbx + 5*rby*rby + 20*raz*rbx*czx & 
     & -20*raz*rby*czy + 2*czx*czx - 2*czy*czy) 	  
	END FUNCTION T20_22c  	  
	     	  

	REAL FUNCTION T20_22s(R5,raz,rbx,rby,czy,czx)	  
	IMPLICIT NONE	  
	REAL :: R5,raz,rbx,rby,czy,czx	  
	 T20_22s=R5 * 0.5 * SQRT(3.0) * (35*raz*raz*rbx*rby - 5*rbx*rby + 10*raz*rbx*czy + 10*raz*rby*czx + 2*czx*czy) 	  
	END FUNCTION T20_22s  	  
	     	  

	REAL FUNCTION T21c_21c(R5,rax,raz,rbx,rbz,czz,czx,cxz,cxx)	  
	IMPLICIT NONE	  
	REAL :: R5,rax,raz,rbx,rbz,czz,czx,cxz,cxx	  
	 T21c_21c=R5 * (35*rax*raz*rbx*rbz + 5*rax*rbx*czz + 5*rax*rbz*czx + 5*raz*rbx*cxz + 5*raz*rbz*cxx + cxx*czz + cxz*czx) 	  
	END FUNCTION T21c_21c	  
	     	  

	REAL FUNCTION T21c_21s(R5,rax,raz,rby,rbz,czz,czy,cxz,cxy)	  
	IMPLICIT NONE	  
	REAL :: R5,rax,raz,rby,rbz,czz,czy,cxz,cxy	  
	 T21c_21s=R5 * (35*rax*raz*rby*rbz + 5*rax*rby*czz + 5*rax*rbz*czy + 5*raz*rby*cxz + 5*raz*rbz*cxy + cxy*czz + cxz*czy) 	  
	END FUNCTION T21c_21s	  
	     	  

	REAL FUNCTION T21c_22c(R5,rax,raz,rbx,rby,czx,czy,cxx,cxy)	  
	IMPLICIT NONE	  
	REAL :: R5,rax,raz,rbx,rby,czx,czy,cxx,cxy	  
	 T21c_22c=R5 * 0.5 * (35*rax*raz*rbx*rbx - 35*rax*raz*rby*rby + 10*rax*rbx*czx - 10*rax*rby*czy + 10*raz*rbx*cxx &
     &-10*raz*rby*cxy + 2*cxx*czx - 2*cxy*czy) 	  
	END FUNCTION T21c_22c	  
	     	  

	REAL FUNCTION T21c_22s(R5,rax,raz,rbx,rby,czy,czx,cxy,cxx)	  
	IMPLICIT NONE	  
	REAL :: R5,rax,raz,rbx,rby,czy,czx,cxy,cxx	  
	 T21c_22s=R5 * (35*rax*raz*rbx*rby + 5*rax*rbx*czy + 5*rax*rby*czx + 5*raz*rbx*cxy + 5*raz*rby*cxx + cxx*czy + cxy*czx) 	  
	END FUNCTION T21c_22s	  
	     	  

	REAL FUNCTION T21s_21s(R5,ray,raz,rby,rbz,czz,czy,cyz,cyy)	  
	IMPLICIT NONE	  
	REAL :: R5,ray,raz,rby,rbz,czz,czy,cyz,cyy	  
	 T21s_21s=R5 * (35*ray*raz*rby*rbz + 5*ray*rby*czz + 5*ray*rbz*czy + 5*raz*rby*cyz + 5*raz*rbz*cyy + cyy*czz + cyz*czy) 	  
	END FUNCTION T21s_21s	  
	     	  

	REAL FUNCTION T21s_22c(R5,ray,raz,rbx,rby,czx,czy,cyx,cyy)	  
	IMPLICIT NONE	  
	REAL :: R5,ray,raz,rbx,rby,czx,czy,cyx,cyy	  
	 T21s_22c=R5 * 0.5 * (35*ray*raz*rbx*rbx - 35*ray*raz*rby*rby + 10*ray*rbx*czx - 10*ray*rby*czy + 10*raz*rbx*cyx &
     & -10*raz*rby*cyy + 2*cyx*czx - 2*cyy*czy) 	  
	END FUNCTION T21s_22c	  
	     	  

	REAL FUNCTION T21s_22s(R5,ray,raz,rbx,rby,czy,czx,cyy,cyx)	  
	IMPLICIT NONE	  
	REAL :: R5,ray,raz,rbx,rby,czy,czx,cyy,cyx	  
	 T21s_22s=R5 * (35*ray*raz*rbx*rby + 5*ray*rbx*czy + 5*ray*rby*czx + 5*raz*rbx*cyy + 5*raz*rby*cyx + cyx*czy + cyy*czx) 	  
	END FUNCTION T21s_22s	  
	     	  

	REAL FUNCTION T22c_22c(R5,rax,rbx,rby,ray,cxx,cxy,cyx,cyy)	  
	IMPLICIT NONE	  
	REAL :: R5,rax,rbx,rby,ray,cxx,cxy,cyx,cyy	  
	 T22c_22c=R5 * 0.25 * (35*rax*rax*rbx*rbx - 35*rax*rax*rby*rby - 35*ray*ray*rbx*rbx + 35*ray*ray*rby*rby + 20*rax*rbx*cxx &
     &-20*rax*rby*cxy - 20*ray*rbx*cyx + 20*ray*rby*cyy + 2*cxx*cxx - 2*cxy*cxy - 2*cyx*cyx + 2*cyy*cyy) 	  
	END FUNCTION T22c_22c	  
	     	  

	REAL FUNCTION T22c_22s(R5,rax,rbx,rby,ray,cxy,cxx,cyy,cyx)	  
	IMPLICIT NONE	  
	REAL :: R5,rax,rbx,rby,ray,cxy,cxx,cyy,cyx	  
	 T22c_22s=R5 * 0.5 * (35*rax*rax*rbx*rby - 35*ray*ray*rbx*rby + 10*rax*rbx*cxy + 10*rax*rby*cxx - 10*ray*rbx*cyy &
     &-10*ray*rby*cyx + 2*cxx*cxy - 2*cyx*cyy) 	  
	END FUNCTION T22c_22s	  
	     	  

	REAL FUNCTION T22s_22s(R5,rax,ray,rbx,rby,cyy,cyx,cxy,cxx)	  
	IMPLICIT NONE	  
	REAL :: R5,rax,ray,rbx,rby,cyy,cyx,cxy,cxx	  
	 T22s_22s=R5 * (35*rax*ray*rbx*rby + 5*rax*rbx*cyy + 5*rax*rby*cyx + 5*ray*rbx*cxy + 5*ray*rby*cxx + cxx*cyy + cxy*cyx) 	  
	END FUNCTION T22s_22s	  
	     	  

  	 	 	 		 		 	          	 	 	 
	REAL FUNCTION T21c_20(R5,rbz,rax,raz,czz,cxz)	  
	IMPLICIT NONE	  
	REAL :: R5,rbz,rax,raz,czz,cxz	  
	 T21c_20=R5 * 0.5 * SQRT(3.0) * (35*rbz*rbz*rax*raz - 5*rax*raz + 10*rbz*rax*czz + 10*rbz*raz*cxz + 2*cxz*czz) 	  
	END FUNCTION T21c_20  	  
	     	  

	REAL FUNCTION T21s_20(R5,rbz,ray,raz,czz,cyz)	  
	IMPLICIT NONE	  
	REAL :: R5,rbz,ray,raz,czz,cyz	  
	 T21s_20=R5 * 0.5 * SQRT(3.0) * (35*rbz*rbz*ray*raz - 5*ray*raz + 10*rbz*ray*czz + 10*rbz*raz*cyz + 2*cyz*czz) 	  
	END FUNCTION T21s_20  	  
	     	  

	REAL FUNCTION T22c_20(R5,rbz,rax,ray,cxz,cyz)	  
	IMPLICIT NONE	  
	REAL :: R5,rbz,rax,ray,cxz,cyz	  
	 T22c_20=R5 * 0.25 * SQRT(3.0) * (35*rbz*rbz*rax*rax - 35*rbz*rbz*ray*ray - 5*rax*rax + 5*ray*ray + 20*rbz*rax*cxz &
     &-20*rbz*ray*cyz + 2*cxz*cxz - 2*cyz*cyz) 	  
	END FUNCTION T22c_20  	  
	     	  

	REAL FUNCTION T22s_20(R5,rbz,rax,ray,cyz,cxz)	  
	IMPLICIT NONE	  
	REAL :: R5,rbz,rax,ray,cyz,cxz	  
	 T22s_20=R5 * 0.5 * SQRT(3.0) * (35*rbz*rbz*rax*ray - 5*rax*ray + 10*rbz*rax*cyz + 10*rbz*ray*cxz + 2*cxz*cyz) 	  
	END FUNCTION T22s_20  	  
	     	  

	REAL FUNCTION T21s_21c(R5,rbx,rbz,ray,raz,czz,cyz,czx,cyx)	  
	IMPLICIT NONE	  
	REAL :: R5,rbx,rbz,ray,raz,czz,cyz,czx,cyx	  
	 T21s_21c=R5 * (35*rbx*rbz*ray*raz + 5*rbx*ray*czz + 5*rbx*raz*cyz + 5*rbz*ray*czx + 5*rbz*raz*cyx + cyx*czz + czx*cyz) 	  
	END FUNCTION T21s_21c	  
	     	  

	REAL FUNCTION T22c_21c(R5,rbx,rbz,rax,ray,cxz,cyz,cxx,cyx)	  
	IMPLICIT NONE	  
	REAL :: R5,rbx,rbz,rax,ray,cxz,cyz,cxx,cyx	  
	 T22c_21c=R5 * 0.5 * (35*rbx*rbz*rax*rax - 35*rbx*rbz*ray*ray + 10*rbx*rax*cxz - 10*rbx*ray*cyz + 10*rbz*rax*cxx &
     		&-10*rbz*ray*cyx + 2*cxx*cxz - 2*cyx*cyz) 	  
	END FUNCTION T22c_21c	  
	     	  

	REAL FUNCTION T22s_21c(R5,rbx,rbz,rax,ray,cyz,cxz,cyx,cxx)	  
	IMPLICIT NONE	  
	REAL :: R5,rbx,rbz,rax,ray,cyz,cxz,cyx,cxx	  
	 T22s_21c=R5 * (35*rbx*rbz*rax*ray + 5*rbx*rax*cyz + 5*rbx*ray*cxz + 5*rbz*rax*cyx + 5*rbz*ray*cxx + cxx*cyz + cyx*cxz) 	  
	END FUNCTION T22s_21c	  
	     	  

	REAL FUNCTION T22c_21s(R5,rby,rbz,rax,ray,cxz,cyz,cxy,cyy)	  
	IMPLICIT NONE	  
	REAL :: R5,rby,rbz,rax,ray,cxz,cyz,cxy,cyy	  
	 T22c_21s=R5 * 0.5 * (35*rby*rbz*rax*rax - 35*rby*rbz*ray*ray + 10*rby*rax*cxz - 10*rby*ray*cyz + 10*rbz*rax*cxy &
     	&-10*rbz*ray*cyy + 2*cxy*cxz - 2*cyy*cyz) 	  
	END FUNCTION T22c_21s	  
	     	  

	REAL FUNCTION T22s_21s(R5,rby,rbz,rax,ray,cyz,cxz,cyy,cxy)	  
	IMPLICIT NONE	  
	REAL :: R5,rby,rbz,rax,ray,cyz,cxz,cyy,cxy	  
	 T22s_21s=R5 * (35*rby*rbz*rax*ray + 5*rby*rax*cyz + 5*rby*ray*cxz + 5*rbz*rax*cyy + 5*rbz*ray*cxy + cxy*cyz + cyy*cxz) 	  
	END FUNCTION T22s_21s	  
	     	  

	REAL FUNCTION T22s_22c(R5,rbx,rax,ray,rby,cyx,cxx,cyy,cxy)	  
	IMPLICIT NONE	  
	REAL :: R5,rbx,rax,ray,rby,cyx,cxx,cyy,cxy	  
     	 T22s_22c=R5 * 0.5 * (35*rbx*rbx*rax*ray - 35*rby*rby*rax*ray + 10*rbx*rax*cyx + 10*rbx*ray*cxx &
              & - 10*rby*rax*cyy - 10*rby*ray*cxy + 2*cxx*cyx - 2*cxy*cyy) 	  
	END FUNCTION T22s_22c	  

!!! lambda functions for TU
    REAL FUNCTION calc_lambda3(a,u3)	   
    IMPLICIT NONE	   
    REAL :: a,u3	   
     calc_lambda3= 1 - exp( -a*u3) 	   
    END FUNCTION calc_lambda3  	   


    REAL FUNCTION calc_lambda5(a,u3)	   
    IMPLICIT NONE	   
    REAL :: a,u3	   
     calc_lambda5= 1 - (1 + a*u3) * exp( -a*u3) 	   
    END FUNCTION calc_lambda5  	   


    REAL FUNCTION calc_lambda7(a,u3)	   
    IMPLICIT NONE	   
    REAL :: a,u3	   
     calc_lambda7= 1 - (1 + a*u3 + 0.6*a*a*u3*u3) * exp( -a*u3) 	   
    END FUNCTION calc_lambda7  	   


    REAL FUNCTION calc_lambda9(a,u3)	   
    IMPLICIT NONE	   
    REAL :: a,u3	   
     calc_lambda9= 1 - (1 + a*u3 + (18*a*a*u3*u3 + 9*a*a*a*u3*u3*u3)/35) * exp( -a*u3) 	   
    END FUNCTION calc_lambda9  	   


!!! TU functions			                		         				
    REAL FUNCTION TU1x_00(lambda3,R2,rax)	   
    IMPLICIT NONE	   
    REAL :: lambda3,R2,rax	   
     TU1x_00= lambda3 * R2 * rax 	   
    END FUNCTION TU1x_00  	   


    REAL FUNCTION TU1y_00(lambda3,R2,ray)	   
    IMPLICIT NONE	   
    REAL :: lambda3,R2,ray	   
     TU1y_00= lambda3 * R2 * ray 	   
    END FUNCTION TU1y_00  	   


    REAL FUNCTION TU1z_00(lambda3,R2,raz)	   
    IMPLICIT NONE	   
    REAL :: lambda3,R2,raz	   
     TU1z_00= lambda3 * R2 * raz 	   
    END FUNCTION TU1z_00  	   


    REAL FUNCTION TU00_1x(lambda3,R2,rbx)	   
    IMPLICIT NONE	   
    REAL :: lambda3,R2,rbx	   
     TU00_1x= lambda3 * R2 * rbx 	   
    END FUNCTION TU00_1x  	   


    REAL FUNCTION TU00_1y(lambda3,R2,rby)	   
    IMPLICIT NONE	   
    REAL :: lambda3,R2,rby	   
     TU00_1y= lambda3 * R2 * rby 	   
    END FUNCTION TU00_1y  	   


    REAL FUNCTION TU00_1z(lambda3,R2,rbz)	   
    IMPLICIT NONE	   
    REAL :: lambda3,R2,rbz	   
     TU00_1z= lambda3 * R2 * rbz 	   
    END FUNCTION TU00_1z  	   


				                		         				
    REAL FUNCTION TU1x_1x(R3,lambda5,rax,rbx,lambda3,cxx)	   
    IMPLICIT NONE	   
    REAL :: R3,lambda5,rax,rbx,lambda3,cxx	   
     TU1x_1x= R3 * (lambda5*3*rax*rbx + lambda3*cxx) 	   
    END FUNCTION TU1x_1x  	   


    REAL FUNCTION TU1x_1y(R3,lambda5,rax,rby,lambda3,cxy)	   
    IMPLICIT NONE	   
    REAL :: R3,lambda5,rax,rby,lambda3,cxy	   
     TU1x_1y= R3 * (lambda5*3*rax*rby + lambda3*cxy) 	   
    END FUNCTION TU1x_1y  	   


    REAL FUNCTION TU1x_1z(R3,lambda5,rax,rbz,lambda3,cxz)	   
    IMPLICIT NONE	   
    REAL :: R3,lambda5,rax,rbz,lambda3,cxz	   
     TU1x_1z= R3 * (lambda5*3*rax*rbz + lambda3*cxz) 	   
    END FUNCTION TU1x_1z  	   


    REAL FUNCTION TU1y_1x(R3,lambda5,ray,rbx,lambda3,cyx)	   
    IMPLICIT NONE	   
    REAL :: R3,lambda5,ray,rbx,lambda3,cyx	   
     TU1y_1x= R3 * (lambda5*3*ray*rbx + lambda3*cyx) 	   
    END FUNCTION TU1y_1x  	   


    REAL FUNCTION TU1y_1y(R3,lambda5,ray,rby,lambda3,cyy)	   
    IMPLICIT NONE	   
    REAL :: R3,lambda5,ray,rby,lambda3,cyy	   
     TU1y_1y= R3 * (lambda5*3*ray*rby + lambda3*cyy) 	   
    END FUNCTION TU1y_1y  	   


    REAL FUNCTION TU1y_1z(R3,lambda5,ray,rbz,lambda3,cyz)	   
    IMPLICIT NONE	   
    REAL :: R3,lambda5,ray,rbz,lambda3,cyz	   
     TU1y_1z= R3 * (lambda5*3*ray*rbz + lambda3*cyz) 	   
    END FUNCTION TU1y_1z  	   


    REAL FUNCTION TU1z_1x(R3,lambda5,raz,rbx,lambda3,czx)	   
    IMPLICIT NONE	   
    REAL :: R3,lambda5,raz,rbx,lambda3,czx	   
     TU1z_1x= R3 * (lambda5*3*raz*rbx + lambda3*czx) 	   
    END FUNCTION TU1z_1x  	   


    REAL FUNCTION TU1z_1y(R3,lambda5,raz,rby,lambda3,czy)	   
    IMPLICIT NONE	   
    REAL :: R3,lambda5,raz,rby,lambda3,czy	   
     TU1z_1y= R3 * (lambda5*3*raz*rby + lambda3*czy) 	   
    END FUNCTION TU1z_1y  	   


    REAL FUNCTION TU1z_1z(R3,lambda5,raz,rbz,lambda3,czz)	   
    IMPLICIT NONE	   
    REAL :: R3,lambda5,raz,rbz,lambda3,czz	   
     TU1z_1z= R3 * (lambda5*3*raz*rbz + lambda3*czz) 	   
    END FUNCTION TU1z_1z  	   


				                		         				
    REAL FUNCTION TU20_1x(R4,lambda7,raz,rbx,lambda5,czx)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,raz,rbx,lambda5,czx	   
     TU20_1x= R4 * 0.5 * (lambda7*15*raz*raz*rbx + lambda5*(6*raz*czx - 3*rbx)) 	   
    END FUNCTION TU20_1x  	   


    REAL FUNCTION TU20_1y(R4,lambda7,raz,rby,lambda5,czy)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,raz,rby,lambda5,czy	   
     TU20_1y= R4 * 0.5 * (lambda7*15*raz*raz*rby + lambda5*(6*raz*czy - 3*rby)) 	   
    END FUNCTION TU20_1y  	   


    REAL FUNCTION TU20_1z(R4,lambda7,raz,rbz,lambda5,czz)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,raz,rbz,lambda5,czz	   
     TU20_1z= R4 * 0.5 * (lambda7*15*raz*raz*rbz + lambda5*(6*raz*czz - 3*rbz)) 	   
    END FUNCTION TU20_1z  	   


    REAL FUNCTION TU21c_1x(R4,lambda5,rax,czx,cxx,raz,lambda7,rbx)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda5,rax,czx,cxx,raz,lambda7,rbx	   
     TU21c_1x= R4 * SQRT(3.0) * (lambda5*(rax*czx + cxx*raz) + lambda7*5*rax*raz*rbx) 	   
    END FUNCTION TU21c_1x 	   


    REAL FUNCTION TU21c_1y(R4,lambda5,rax,czy,cxy,raz,lambda7,rby)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda5,rax,czy,cxy,raz,lambda7,rby	   
     TU21c_1y= R4 * SQRT(3.0) * (lambda5*(rax*czy + cxy*raz) + lambda7*5*rax*raz*rby) 	   
    END FUNCTION TU21c_1y 	   


    REAL FUNCTION TU21c_1z(R4,lambda5,rax,czz,cxz,raz,lambda7,rbz)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda5,rax,czz,cxz,raz,lambda7,rbz	   
     TU21c_1z= R4 * SQRT(3.0) * (lambda5*(rax*czz + cxz*raz) + lambda7*5*rax*raz*rbz) 	   
    END FUNCTION TU21c_1z 	   


    REAL FUNCTION TU21s_1x(R4,lambda5,ray,czx,cyx,raz,lambda7,rbx)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda5,ray,czx,cyx,raz,lambda7,rbx	   
     TU21s_1x= R4 * SQRT(3.0) * (lambda5*(ray*czx + cyx*raz) + lambda7*5*ray*raz*rbx) 	   
    END FUNCTION TU21s_1x 	   


    REAL FUNCTION TU21s_1y(R4,lambda5,ray,czy,cyy,raz,lambda7,rby)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda5,ray,czy,cyy,raz,lambda7,rby	   
     TU21s_1y= R4 * SQRT(3.0) * (lambda5*(ray*czy + cyy*raz) + lambda7*5*ray*raz*rby) 	   
    END FUNCTION TU21s_1y 	   


    REAL FUNCTION TU21s_1z(R4,lambda5,ray,czz,cyz,raz,lambda7,rbz)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda5,ray,czz,cyz,raz,lambda7,rbz	   
     TU21s_1z= R4 * SQRT(3.0) * (lambda5*(ray*czz + cyz*raz) + lambda7*5*ray*raz*rbz) 	   
    END FUNCTION TU21s_1z 	   


    REAL FUNCTION TU22c_1x(R4,lambda7,rax,ray,rbx,lambda5,cxx,cyx)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,rax,ray,rbx,lambda5,cxx,cyx	   
     TU22c_1x= R4 * 0.5 * SQRT(3.0) * (lambda7*5*(rax*rax-ray*ray)*rbx + lambda5*(2*rax*cxx - 2*ray*cyx)) 	   
    END FUNCTION TU22c_1x 	   


    REAL FUNCTION TU22c_1y(R4,lambda7,rax,ray,rby,lambda5,cxy,cyy)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,rax,ray,rby,lambda5,cxy,cyy	   
     TU22c_1y= R4 * 0.5 * SQRT(3.0) * (lambda7*5*(rax*rax-ray*ray)*rby + lambda5*(2*rax*cxy - 2*ray*cyy)) 	   
    END FUNCTION TU22c_1y 	   


    REAL FUNCTION TU22c_1z(R4,lambda7,rax,ray,rbz,lambda5,cxz,cyz)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,rax,ray,rbz,lambda5,cxz,cyz	   
     TU22c_1z= R4 * 0.5 * SQRT(3.0) * (lambda7*5*(rax*rax-ray*ray)*rbz + lambda5*(2*rax*cxz - 2*ray*cyz)) 	   
    END FUNCTION TU22c_1z 	   


    REAL FUNCTION TU22s_1x(R4,lambda7,rax,ray,rbx,lambda5,cyx,cxx)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,rax,ray,rbx,lambda5,cyx,cxx	   
     TU22s_1x= R4 * SQRT(3.0) * (lambda7*5*rax*ray*rbx + lambda5*(rax*cyx + ray*cxx) ) 	   
    END FUNCTION TU22s_1x 	   


    REAL FUNCTION TU22s_1y(R4,lambda7,rax,ray,rby,lambda5,cyy,cxy)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,rax,ray,rby,lambda5,cyy,cxy	   
     TU22s_1y= R4 * SQRT(3.0) * (lambda7*5*rax*ray*rby + lambda5*(rax*cyy + ray*cxy) ) 	   
    END FUNCTION TU22s_1y 	   


    REAL FUNCTION TU22s_1z(R4,lambda7,rax,ray,rbz,lambda5,cyz,cxz)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,rax,ray,rbz,lambda5,cyz,cxz	   
     TU22s_1z= R4 * SQRT(3.0) * (lambda7*5*rax*ray*rbz + lambda5*(rax*cyz + ray*cxz) ) 	   
    END FUNCTION TU22s_1z 	   


				                		         				
    REAL FUNCTION TU1x_20(R4,lambda7,rbz,rax,lambda5,cxz)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,rbz,rax,lambda5,cxz	   
     TU1x_20= R4 * 0.5 * (lambda7*15*rbz*rbz*rax + lambda5*(6*rbz*cxz - 3*rax)) 	   
    END FUNCTION TU1x_20  	   


    REAL FUNCTION TU1y_20(R4,lambda7,rbz,ray,lambda5,cyz)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,rbz,ray,lambda5,cyz	   
     TU1y_20= R4 * 0.5 * (lambda7*15*rbz*rbz*ray + lambda5*(6*rbz*cyz - 3*ray)) 	   
    END FUNCTION TU1y_20  	   


    REAL FUNCTION TU1z_20(R4,lambda7,rbz,raz,lambda5,czz)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,rbz,raz,lambda5,czz	   
     TU1z_20= R4 * 0.5 * (lambda7*15*rbz*rbz*raz + lambda5*(6*rbz*czz - 3*raz)) 	   
    END FUNCTION TU1z_20  	   


    REAL FUNCTION TU1x_21c(R4,lambda5,rbx,cxz,cxx,rbz,lambda7,rax)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda5,rbx,cxz,cxx,rbz,lambda7,rax	   
     TU1x_21c= R4 * SQRT(3.0) * (lambda5*(rbx*cxz + cxx*rbz) + lambda7*5*rbx*rbz*rax) 	   
    END FUNCTION TU1x_21c 	   


    REAL FUNCTION TU1y_21c(R4,lambda5,rbx,cyz,cyx,rbz,lambda7,ray)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda5,rbx,cyz,cyx,rbz,lambda7,ray	   
     TU1y_21c= R4 * SQRT(3.0) * (lambda5*(rbx*cyz + cyx*rbz) + lambda7*5*rbx*rbz*ray) 	   
    END FUNCTION TU1y_21c 	   


    REAL FUNCTION TU1z_21c(R4,lambda5,rbx,czz,czx,rbz,lambda7,raz)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda5,rbx,czz,czx,rbz,lambda7,raz	   
     TU1z_21c= R4 * SQRT(3.0) * (lambda5*(rbx*czz + czx*rbz) + lambda7*5*rbx*rbz*raz) 	   
    END FUNCTION TU1z_21c 	   


    REAL FUNCTION TU1x_21s(R4,lambda5,rby,cxz,cxy,rbz,lambda7,rax)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda5,rby,cxz,cxy,rbz,lambda7,rax	   
     TU1x_21s= R4 * SQRT(3.0) * (lambda5*(rby*cxz + cxy*rbz) + lambda7*5*rby*rbz*rax) 	   
    END FUNCTION TU1x_21s 	   


    REAL FUNCTION TU1y_21s(R4,lambda5,rby,cyz,cyy,rbz,lambda7,ray)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda5,rby,cyz,cyy,rbz,lambda7,ray	   
     TU1y_21s= R4 * SQRT(3.0) * (lambda5*(rby*cyz + cyy*rbz) + lambda7*5*rby*rbz*ray) 	   
    END FUNCTION TU1y_21s 	   


    REAL FUNCTION TU1z_21s(R4,lambda5,rby,czz,czy,rbz,lambda7,raz)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda5,rby,czz,czy,rbz,lambda7,raz	   
     TU1z_21s= R4 * SQRT(3.0) * (lambda5*(rby*czz + czy*rbz) + lambda7*5*rby*rbz*raz) 	   
    END FUNCTION TU1z_21s 	   


    REAL FUNCTION TU1x_22c(R4,lambda7,rbx,rby,rax,lambda5,cxx,cxy)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,rbx,rby,rax,lambda5,cxx,cxy	   
     TU1x_22c= R4 * 0.5 * SQRT(3.0) * (lambda7*5*(rbx*rbx-rby*rby)*rax + lambda5*(2*rbx*cxx - 2*rby*cxy)) 	   
    END FUNCTION TU1x_22c 	   


    REAL FUNCTION TU1y_22c(R4,lambda7,rbx,rby,ray,lambda5,cyx,cyy)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,rbx,rby,ray,lambda5,cyx,cyy	   
     TU1y_22c= R4 * 0.5 * SQRT(3.0) * (lambda7*5*(rbx*rbx-rby*rby)*ray + lambda5*(2*rbx*cyx - 2*rby*cyy)) 	   
    END FUNCTION TU1y_22c 	   


    REAL FUNCTION TU1z_22c(R4,lambda7,rbx,rby,raz,lambda5,czx,czy)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,rbx,rby,raz,lambda5,czx,czy	   
     TU1z_22c= R4 * 0.5 * SQRT(3.0) * (lambda7*5*(rbx*rbx-rby*rby)*raz + lambda5*(2*rbx*czx - 2*rby*czy)) 	   
    END FUNCTION TU1z_22c 	   


    REAL FUNCTION TU1x_22s(R4,lambda7,rbx,rby,rax,lambda5,cxy,cxx)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,rbx,rby,rax,lambda5,cxy,cxx	   
     TU1x_22s= R4 * SQRT(3.0) * (lambda7*5*rbx*rby*rax + lambda5*(rbx*cxy + rby*cxx) ) 	   
    END FUNCTION TU1x_22s 	   


    REAL FUNCTION TU1y_22s(R4,lambda7,rbx,rby,ray,lambda5,cyy,cyx)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,rbx,rby,ray,lambda5,cyy,cyx	   
     TU1y_22s= R4 * SQRT(3.0) * (lambda7*5*rbx*rby*ray + lambda5*(rbx*cyy + rby*cyx) ) 	   
    END FUNCTION TU1y_22s 	   


    REAL FUNCTION TU1z_22s(R4,lambda7,rbx,rby,raz,lambda5,czy,czx)	   
    IMPLICIT NONE	   
    REAL :: R4,lambda7,rbx,rby,raz,lambda5,czy,czx 	   
     TU1z_22s= R4 * SQRT(3.0) * (lambda7*5*rbx*rby*raz + lambda5*(rbx*czy + rby*czx) ) 	   
    END FUNCTION TU1z_22s 	   
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!! End all functions for the InteractorEMultipole
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!






!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!! ENDE:  EMultipoles / polarizabilities / Tholes model 
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!






!!!!!!!!!!!!!!!!! Traegheitstensor bestimmen 

SUBROUTINE traegheitstensor_analysis(atomsorte1,koord1,NAtoms1,atomsorte2,koord2,NAtoms2,Kette,res_traegheit)
		 use small_functions
         IMPLICIT NONE
         INTEGER, INTENT(IN)::NAtoms1,NAtoms2
         Real, Dimension(NAtoms1,3), INTENT(IN) :: koord1
         Real, Dimension(NAtoms2,3), INTENT(IN) :: koord2
         Character(5), Dimension(NAtoms1), INTENT(IN) :: atomsorte1
         Character(5), Dimension(NAtoms2), INTENT(IN) :: atomsorte2
         LOGICAL, INTENT(IN):: Kette
         Character(LEN=50000), INTENT(OUT):: res_traegheit    ! collects all results from the different calculations
         REAL, DIMENSION(3)  :: COM1,COM2,ST1,ST2
         REAL, DIMENSION(3)  :: HT1,HT2,zero_vec,EW1,EW2 ! collects all eigenvalues / EigenWerte
         REAL::angel_HT1_dCOM,angel_HT2_dCOM,angel_ST1_dCOM,angel_ST2_dCOM,dih_HT,dih_ST
         Character(500) ::str1
         LOGICAL::DEBUG=.false.

         zero_vec=0.0
         res_traegheit=''
         CALL Massenschwerpunkt(atomsorte1,koord1,NAtoms1,COM1,Kette)
         CALL Massenschwerpunkt(atomsorte2,koord2,NAtoms2,COM2,Kette)       
         CALL traegheitstensor(atomsorte1,koord1,NAtoms1,HT1,ST1,EW1,Kette)
         CALL traegheitstensor(atomsorte2,koord2,NAtoms2,HT2,ST2,EW2,Kette)

	IF(DEBUG) THEN
		WRITE(*,*) 'Sorted results:'
		WRITE(*,*) "EW1:",EW1
     		WRITE(*,*) "HT1:",HT1
     		WRITE(*,*) "ST1:",ST1
		WRITE(*,*) "COM1:",COM1
		
		WRITE(*,*) "EW2:",EW2
     		WRITE(*,*) "HT2:",HT2
     		WRITE(*,*) "ST2:",ST2
		WRITE(*,*) "COM2:",COM2
	END IF


	 CALL calc_dihedral(COM1+HT1,COM1,COM2,COM2+HT2,dih_HT)
	 WRITE(str1,'(1F10.4)') dih_HT
 	 res_traegheit=TRIM(res_traegheit)//' dih_HT: '//TRIM(str1)

	 angel_HT1_dCOM=angle(HT1,zero_vec,COM2-COM1)
	 angel_HT1_dCOM=MIN(angel_HT1_dCOM,180-angel_HT1_dCOM)
	 WRITE(str1,'(1F10.4)') angel_HT1_dCOM
 	 res_traegheit=TRIM(res_traegheit)//' angel_HT1_dCOM: '//TRIM(str1)

	 angel_HT2_dCOM=angle(HT2,zero_vec,COM2-COM1)
	 angel_HT2_dCOM=MIN(angel_HT2_dCOM,180-angel_HT2_dCOM)
	 WRITE(str1,'(1F10.4)') angel_HT2_dCOM
 	 res_traegheit=TRIM(res_traegheit)//' angel_HT2_dCOM: '//TRIM(str1)
 
	 CALL calc_dihedral(COM1+ST1,COM1,COM2,COM2+ST2,dih_ST)
	 WRITE(str1,'(1F10.4)') dih_ST
 	 res_traegheit=TRIM(res_traegheit)//' dih_ST: '//TRIM(str1)

	 angel_ST1_dCOM=angle(ST1,zero_vec,COM2-COM1)
	 angel_ST1_dCOM=MIN(angel_ST1_dCOM,180-angel_ST1_dCOM)
	 WRITE(str1,'(1F10.4)') angel_ST1_dCOM
 	 res_traegheit=TRIM(res_traegheit)//' angel_ST1_dCOM: '//TRIM(str1)

	 angel_ST2_dCOM=angle(ST2,zero_vec,COM2-COM1)
	 angel_ST2_dCOM=MIN(angel_ST2_dCOM,180-angel_ST2_dCOM)
	 WRITE(str1,'(1F10.4)') angel_ST2_dCOM
 	 res_traegheit=TRIM(res_traegheit)//' angel_ST2_dCOM: '//TRIM(str1)

	WRITE(str1,'(3F14.4)') EW1
     	res_traegheit=TRIM(res_traegheit)//' EW_1: '//TRIM(str1)
	WRITE(str1,'(3F14.4)') EW2
     	res_traegheit=TRIM(res_traegheit)//' EW_2: '//TRIM(str1)

	WRITE(*,*) TRIM(res_traegheit)

END SUBROUTINE traegheitstensor_analysis




SUBROUTINE traegheitstensor(atomsorte,koord,NAtoms,HT,ST,EW,Kette)
	!!! Eigenvektor Haupttraegheitsachse HT
	!!! Eigenvektor 2.-Traegheitsachse ST ( zum zweitgroessten Eigenwert)
	!!! Eigenwerte / Eigenvalues
		use small_functions
         IMPLICIT NONE
         INTEGER, INTENT(IN)::NAtoms
         Real, Dimension(NAtoms,3), INTENT(IN) :: koord
         Character(5), Dimension(NAtoms), INTENT(IN) :: atomsorte
         LOGICAL, INTENT(IN):: Kette
         REAL, DIMENSION(3), INTENT(OUT) :: HT,ST,EW

         REAL*8, DIMENSION(3,3)::ThetaMat
         REAL*8 ::ISO_Theta
         REAL, DIMENSION(3)::r,COM
         REAL::mass,mass_all,dummy
         INTEGER::i,i_min,j,n
         LOGICAL::DEBUG=.false.,system=.false.
         ! Eigenvalue problem with LAPACK
         INTEGER :: n_max,lwork,info
         REAL*8, ALLOCATABLE, DIMENSION(:,:) :: alpha_mat,eigenvectors
         REAL*8, ALLOCATABLE, DIMENSION(:)   :: eigval,work
         LOGICAL::LAPACK_activated=.false.
         
         ! Berechne traegheitstensor / inertia tensor for molecule in koord
         ThetaMat=0.0
          mass_all=0.0
         CALL Massenschwerpunkt(atomsorte,koord,NAtoms,COM,Kette)
         DO n=1,NAtoms
            mass=element_to_mass(atomsorte(n),Kette)
            mass_all=mass_all+mass
            r(1:3)=koord(n,1:3)-COM(1:3)
            ThetaMat(1,1)=ThetaMat(1,1)+mass*(r(2)**2+r(3)**2)
            ThetaMat(2,2)=ThetaMat(2,2)+mass*(r(1)**2+r(3)**2)
            ThetaMat(3,3)=ThetaMat(3,3)+mass*(r(1)**2+r(2)**2)    
            
            ThetaMat(1,2)=ThetaMat(1,2)-mass*(r(1)*r(2))
            ThetaMat(1,3)=ThetaMat(1,3)-mass*(r(1)*r(3))
            ThetaMat(2,3)=ThetaMat(2,3)-mass*(r(2)*r(3))
         END DO !Atome NAtoms1
         
         ThetaMat(2,1)=ThetaMat(1,2)
         ThetaMat(3,1)=ThetaMat(1,3)
         ThetaMat(3,2)=ThetaMat(2,3)

    !! Eigenvalues of polarizability tensor
    IF (ALLOCATED(eigenvectors))  DEALLOCATE (eigenvectors)
    IF (ALLOCATED(eigval))  DEALLOCATE (alpha_mat)
    IF (ALLOCATED(work))  DEALLOCATE (work)
    
    n_max=3
    ALLOCATE(eigenvectors(n_max,n_max))
    lwork=3*n_max
    ALLOCATE(eigval(n_max))
    ALLOCATE(work(lwork))
    eigval=0
    work=0
    
    eigenvectors=ThetaMat
    ! Initializing the diagonal-matrix and matrix to be diagonalized
    ! Include LAPACK routine for Diagonalisation 
    ! CALL DSYEV('V','U', n_max , eigenvectors, n_max , eigval, work, lwork, info)
    LAPACK_activated=.false.
    if( .not. LAPACK_activated) then
		write(*,*)  "! CALL DSYEV('V','U', n_max , eigenvectors, n_max , eigval, work, lwork, info)"
		write(*,*)  "! Include LAPACK routine for Diagonalisation. Activate the following line HERE!." 
		write(*,*)  "! CALL DSYEV('V','U', n_max , eigenvectors, n_max , eigval, work, lwork, info)"
		LAPACK_activated=.true.
		! CALL DSYEV('V','U', n_max , eigenvectors, n_max , eigval, work, lwork, info)
		IF(LAPACK_activated) then
			continue
		ELSE
			write(*,*) '#################################################'
			write(*,*) 'Error: Can not calculate the momentum of inertia.'
			write(*,*) 'LAPACK is missing.  or   LAPACK_activated=.false.'
			write(*,*) '#################################################'
			return
		ENDIF
    endif
    
    IF ( info == 0) then
                    WRITE(*,*) ' Diagonalisation successful '
    ELSE IF ( info < 0) then 
                    WRITE(*,*) ' The argument',info,' had an illigal value'        
    ELSE
                    WRITE(*,*) info, ' > 0 => the algorithm failed to converge'
                    WRITE(*,*) 'off-diagonal elements of an intermediate tridiagonal form did not converge to zero.'
    END IF
        
    !matrix::eigensystem_t EIGEN;
    !alpha.SolveEigensystem(EIGEN);

    if ( .NOT. system .OR. DEBUG) THEN
        ISO_Theta = ( ThetaMat(1,1) +  ThetaMat(2,2) +  ThetaMat(3,3)) / 3.0D0
        write(*,*) "... ... ... ... 1/3 trace of inertia tensor: ",ISO_Theta
        write(*,*) "... ... ... ... Eigenvalues: "
        write(*,*) "... ... ... ... ", eigval(1)
        write(*,*) "... ... ... ... ", eigval(2)
        write(*,*) "... ... ... ... ", eigval(3)
    END IF

  !  if (thetaOutFile /= "noname" .AND. thetaOutFile /= "") THEN
      !  IF (file_exists(thetaOutFile)) THEN
        !    OPEN(UNIT=32,FILE=TRIM(thetaOutFile),STATUS='OLD',action ='WRITE',IOSTAT=ierror)
          !  IF (check_ierror(thetaOutFile,ierror)) CONTINUE 
            
   if ( .NOT. system .OR. DEBUG ) THEN ! 
                write(*,*) "Inertia tensor in global frame"
                write(*,'(3F16.6)')  ThetaMat(1,1), ThetaMat(1,2), ThetaMat(1,3)
                write(*,'(3F16.6)')  ThetaMat(2,1), ThetaMat(2,2), ThetaMat(2,3)
                write(*,'(3F16.6)')  ThetaMat(3,1), ThetaMat(3,2), ThetaMat(3,3)

                write(*,*) "Inertia tensor in global frame / total mass"
                write(*,'(3F16.6)')  ThetaMat(1,1)/mass_all, ThetaMat(1,2)/mass_all, ThetaMat(1,3)/mass_all
                write(*,'(3F16.6)')  ThetaMat(2,1)/mass_all, ThetaMat(2,2)/mass_all, ThetaMat(2,3)/mass_all
                write(*,'(3F16.6)')  ThetaMat(3,1)/mass_all, ThetaMat(3,2)/mass_all, ThetaMat(3,3)/mass_all

                      
                write(*,*) "Inertia tensor in eigenframe "
                write(*,'(3F16.6)')  eigval(1),0.,0.
                write(*,'(3F16.6)')  0.,eigval(2),0.
                write(*,'(3F16.6)')  0.,0.,eigval(3)
                      
                write(*,*) "Inertia tensor main axes "
                write(*,'(3F16.6)') eigenvectors(1,1:3)    !   x.getX(),x.getY(),x.getZ()
                write(*,'(3F16.6)') eigenvectors(2,1:3)    !   y.getX(),y.getY(),y.getZ()
                write(*,'(3F16.6)') eigenvectors(3,1:3)    !   z.getX(),z.getY(),z.getZ()
      END IF ! DEBUG

      !!! Ergebnisse
      HT=0
      ST=0
      EW=eigval

	! Selection Sort
	n_max=3
	DO j=1,n_max-1 ! Durchgehen der Eigenwerte  
	    i_min=j
		DO i=j+1,n_max ! Durchgehen von B          
		   IF( EW(i) > EW(i_min) ) THEN
		       i_min=i
		   END IF
		END DO    
		IF( i_min /= j ) THEN ! tauschen
		       ! Eigenwerte tauschen
		       dummy=EW(j)
		       EW(j)=EW(i_min)
		       EW(i_min)=dummy
		       ! Eigenvektoren tauschen 
			 ST=eigenvectors(1:3,j)
			 eigenvectors(1:3,j)=eigenvectors(1:3,i_min)
			 eigenvectors(1:3,i_min)=ST
		END IF           
	END DO
	HT=eigenvectors(1:3,1)
	ST=eigenvectors(1:3,2)
	IF(DEBUG) THEN
		WRITE(*,*) 'Sorted results:'
		WRITE(*,*) "EW:",EW
     		WRITE(*,*) "HT:",HT
     		WRITE(*,*) "ST:",ST
	END IF

END SUBROUTINE traegheitstensor


LOGICAL FUNCTION check_ierror(filename,ierror)
    !! IN: filename, ierror
    !! Function checks if ierror > 0 => stops program
    !! Else the function returns true
    IMPLICIT NONE
	! Checks if the ierror for a file filename
	CHARACTER (LEN=*), INTENT(IN) ::filename
    INTEGER , INTENT(IN)::ierror
	LOGICAL::ierror_ok
	ierror_ok=.false.
	IF( ierror > 0 ) THEN
		WRITE(*,*) 'Error: while reading file '//TRIM(filename)
		CALL EXIT(1)
	ELSE
		ierror_ok=.true.
	END IF
	check_ierror=ierror_ok
END FUNCTION

end module gro_to_DIPRO
!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!!  End gro_to_DIPRO
!!! ------------------------------------------------------------------------------------------------------------------- !!!


!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!!        DImer  PROjection  Method  (DIPRO)                                                                           !!!
!!! ------------------------------------------------------------------------------------------------------------------- !!!
module DIPRO_nMO

CONTAINS

subroutine DImer_PROjection()
use small_functions
use gro_to_DIPRO
!! Program for calculating transfer integrals between two monomers. 
!! Needs the data for monomerA, monomerB and dimer.
!! Execute this program for g09 input fata in a folder "dim" where 
!!  ./dimer.log, ./fort.7, 
!!  ../molA/monomer.log, ../molA/fort.7,
!!  ../molB/monomer.log, ../molB/fort.7 are available.
!!  for dftb+ you need
!!  ./overreal.dat ./detailed ./eigenvec.out
!!  ../molA/detailed.out   ../molA/eigenvec.out
!!  ../molB/detailed.out   ../molB/eigenvec.out
!! It will print out certain transfer integrals (in eV!) and writes every integral of 
!! interest in fock.txt

implicit none
!! overlap-matrix, fock matrix and transposed matrix
Real*8, Allocatable:: overlap(:,:), fock(:,:), transmat(:,:)
! !expansioncoefficients of monomer A and B and Dimer D
Real*8, Allocatable:: zeta_A(:,:), zeta_B(:,:), zeta_D(:,:)
!! dimer-eigenvalues
Real*8, Allocatable:: energy(:,:)
!! projectionmatrices 
Real*8, Allocatable:: gamma_A(:,:), gamma_B(:,:)
!! transferintegral J_AB and effective transferintegral t_AB
Real*8, Allocatable::J_AB(:,:), e_A(:,:), e_B(:,:), S_AB(:,:)
Integer:: ierror, i, j, l, m, p,i_max,j_max
!! number of basis functions monomerA, monomerB, dimerD
Integer :: n_A, n_B, n_D
!! n_MO :: number of extra frontier orbitals above / below the homo lumo gap. default n_MO =0 => only 2x2 eigenvalue problem HOMO A to HOMO B and LUMO A to LUMO B 
Integer :: counter, homoA, homoB, lumoA, lumoB, n_MO=0, n1_MO, n2_MO, n_MOmax ,frontier,Maximal_MO

Character (len=500):: dummy
Character (len=500):: dummy2
Real*8:: fock_max, S_AB_max
Real*8:: HOMO_A_to_HOMO_B,LUMO_A_to_LUMO_B,S_AB_HOMO_A_to_HOMO_B,S_AB_LUMO_A_to_LUMO_B
integer::i_homo,i_lumo
Character (len=500):: buf
Character (len=12) :: FM1='(A26,ES14.6)'         !Format output 1
Character (len=21) :: FM2='(A26,ES14.6,A,ES14.6)' !Format output 2
Character (len=29) :: FM3='(A8,ES14.6,X,ES14.6,X,ES14.6)' !Format output 3
!! arrays for transformation-purposes 
Real*8, Allocatable:: eigval(:), S_diag(:,:), work(:)
Integer:: Info, lwork
! !Zusatz fuer viele nMOs
REAL, ALLOCATABLE, DIMENSION (:)::E_Orbitale_A,E_Orbitale_B,w_A,w_B
!INTEGER, DIMENSION (17) :: Output_nMO=(/0,1,2,4,5,10,25,50,75,100,125,150,175,200,225,240,1000/) ! letztes Element wird spaeter aus n_MOmax gesetzt
INTEGER, DIMENSION (2) :: Output_nMO=(/0,300/) 
CHARACTER(30)::filename1
INTEGER::DummyNR1,DummyNR2
REAL::k_B,T,DummyNR3
REAL::homo_dim,lumo_dim
REAL::sumA_lo,sumB_lo,sumA_el,sumB_el
REAL::J_ges_lo_w1,J_ges_lo_w2,J_ges_el_w1,J_ges_el_w2,J_ges_lo_w3,J_ges_el_w3,J_ges_lo_w4,J_ges_el_w4
LOGICAL::calc_dipro_with_max_nMO=.false.,read_g09=.false.,read_dftb_plus=.false.
! additional data for dftb+
INTEGER, ALLOCATABLE, DIMENSION(:,:) ::IAtom_Nneigh_Norbs
INTEGER::NAtoms,ATOM1,INEIGH,IATOM2F,icase,i_min,j_min,Ineighbours,Ineighbours_max
CHARACTER(500) :: mol,eigenvectorfile,detailedfile,eigenvec_molX
CHARACTER(500):: method, JAB_filename
INTEGER, DIMENSION(3)::CELL
REAL::E_deg_cut_off
LOGICAL:: DEBUG=.false.

write(*,*) '!!=====================================================!!'
write(*,*) '!!        DImer  PROjection  Method  (DIPRO)           !!'
write(*,*) '!!=====================================================!!'

DEBUG=.false.
dummy=''
E_deg_cut_off=0.01 ! eV energy cutoff to treat the orbitals with degenerated states
JAB_filename='Datenauswertung_SAB_H_H0_Jab_H0_H0_SAB_L0_L0_Jab_L0_L0_G0.dat'


IF( (command_argument_count() == 1) .or. (command_argument_count() == 2)) THEN         !Einlesen der Flags
		if( command_argument_count() == 1) then
			CALL get_command_argument(1,method)
		else if(command_argument_count() == 2) then
			CALL get_command_argument(1,dummy)
			CALL get_command_argument(2,method)
			if( (index(dummy,'DIPRO') .ne. 0) .or. (index(dummy,'dipro') .ne. 0) & 
				& .or. (index(dummy,'DIPRO-nMO') .ne. 0) .or. (index(dummy,'DIPRO_nMO') .ne. 0) ) then
				write(*,*) 'DIPRO_nMO Start: ',trim(dummy),' ',trim(method)
			else
				WRITE(*,*) trim(dummy),' ',trim(method)
				WRITE(*,*) 'Error: select g09 or dftb+'
				WRITE(*,*) 'Use:    DIPRO-nMO   [g09/dftb+]'
				STOP
			endif
		endif
		
		IF( (TRIM(method) == 'g09') .OR. (TRIM(method) == 'sub_g09') )THEN
			read_g09=.true.
			read_dftb_plus=.false.
		ELSE IF((TRIM(method) == 'dftb+') .OR. (TRIM(method) == 'DFTB+') .OR. (TRIM(method) == 'dftb_plus') .OR. &
			&   (TRIM(method) == 'sub_dftb_plus') .OR. (TRIM(method) == 'sub_dftb+') )THEN
			read_dftb_plus=.true.
			read_g09=.false.
		ELSE
			WRITE(*,*) 'Error: select g09 or dftb+'
			STOP
		END IF
ELSE IF (command_argument_count() == 0) THEN
        read_g09=.true. !default is g09
END IF

OPEN(Unit=23, File='Daten-V11.txt', Status='REPLACE', IOSTAT=ierror)
do p=1,size(Output_nMO)
        n_MO=Output_nMO(p)
        write(*,*) "Berechne Schritt fuer n_MO=",n_MO
        
    IF( read_g09 ) THEN ! read gausian09 output (default setting)
		if(file_exists('dimer.log') .and. &
			& file_exists('fort.7') .and. &
			& file_exists('../molA/monomer.log') .and. &
			& file_exists('../molA/fort.7') .and. &
			& file_exists('../molB/monomer.log') .and. &
			& file_exists('../molB/fort.7') )then
			write(*,*) 'Start reading DIPRO g09 input.'
		endif
		
        Open(Unit=7, File='dimer.log', Status='OLD', IOSTAT=ierror)
        
        Open(Unit=8, File='../molA/fort.7', Status='OLD', IOSTAT=ierror)
        
        Open(Unit=9, File='../molB/fort.7', Status='OLD', IOSTAT=ierror)
        
        Open(Unit=10, File='fort.7', Status='OLD', IOSTAT=ierror)
        
        OPEN(Unit=11, File='fock.txt', Status='REPLACE', IOSTAT=ierror)
        
        
        !Reading number of basis functions for molecule A
        Open(Unit=12, File="../molA/monomer.log", Status='OLD', IOSTAT=ierror)
        
        do
            read(12,*,IOSTAT=ierror) buf, dummy
            if(ierror/=0) exit
            if (index(buf,'NBasis=') .ne. 0) then
                Read(dummy,*) n_A
                exit
            end if
        
        end do
        close(12)
        
        !looking for the indices of HOMO and LUMO
        Open(Unit=12, File="../molA/monomer.log", Status='OLD', IOSTAT=ierror)
        
        do 
                read(12,*,IOSTAT=ierror) dummy, buf
                if(ierror/=0) exit
                if(index(buf,'alpha') .ne. 0) then
                        Read(dummy,*) homoA
                        lumoA=homoA+1
                        exit
                end if
        end do
        
        !extra: Read orbital energies to construct weighting function.
        Allocate(E_Orbitale_A(n_A))
        E_Orbitale_A(:)=0.0d0
        do ! Einlesen der Orbitalenergien in umgekehrter Reihenfolge; hinterher aufsteigend in E_Orbitale_A
            read(12,*,IOSTAT=ierror) buf,dummy
            if(ierror/=0) exit
            if (index(buf,'Orbital') .ne. 0 .AND. index(dummy,'energies') .ne. 0) then
                Read(12,*) DummyNR1,DummyNR2
                DO i=1,n_A
                    read(12,*,IOSTAT=ierror) DummyNR1,dummy,E_Orbitale_A(i),DummyNR3
                    if(ierror/=0) exit
                END DO
                exit
            end if
        end do
        
        close(12)
        
        !Reading number of basis functions for molecule B
        Open(Unit=13, File="../molB/monomer.log", Status='OLD', IOSTAT=ierror)
        
        do
            read(13,*,IOSTAT=ierror) buf, dummy
            if(ierror/=0) exit
            if (index(buf,'NBasis=') .ne. 0) then
                Read(dummy,*) n_B
                exit
            end if
        end do
        
        !extra: Read orbital energies to construct weighting function.
        Allocate(E_Orbitale_B(n_B))
        E_Orbitale_B(:)=0.0d0
        do ! Einlesen der Orbitalenergien in umgekehrter Reihenfolge; hinterher aufsteigend in E_Orbitale_B
            read(13,*,IOSTAT=ierror) buf, dummy
            if(ierror/=0) exit
            if (index(buf,'Orbital') .ne. 0 .AND. index(dummy,'energies') .ne. 0) then
                Read(13,*) DummyNR1,DummyNR2
                DO i=1,n_B,1
                    read(13,*,IOSTAT=ierror) DummyNR1,dummy,E_Orbitale_B(i),DummyNR3   
                    !WRITE(*,*) E_Orbitale_A(i),E_Orbitale_B(i)
                    if(ierror/=0) exit
                END DO
                exit
            end if
        end do
        
        close(13)
        
        !looking for the indices of HOMO and LUMO
        Open(Unit=13, File="../molB/monomer.log", Status='OLD', IOSTAT=ierror)
        
        do 
                read(13,*,IOSTAT=ierror) dummy, buf
                if(ierror/=0) exit
                if(index(buf,'alpha') .ne. 0) then
                        Read(dummy,*) homoB
                        lumoB=homoB+1
                        exit
                end if
        end do
        close(13)
        !Reading number of basis functions for the dimer
        do
            read(7,*,IOSTAT=ierror) buf, dummy
            if(ierror/=0) exit
            if (index(buf,'NBasis=') .ne. 0) then
                Read(dummy,*) n_D
                exit
            end if
        end do
        close(7)
        
        
    ELSE IF (read_dftb_plus) THEN ! read data from dftb+ (formated) output
    
		!!! -----------------------------------------------------------
		!!! read_dftb_plus
		!!! -----------------------------------------------------------
		write(*,*) 'Start reading DIPRO dftb+ input.'
		IF( file_exists('./overreal.dat'))then
			eigenvectorfile='eigenvec.out'
			detailedfile='detailed.out'
			do i=1,3
				if(i==1) mol='dim'
				if(i==2) mol='molA'
				if(i==3) mol='molB'
				detailedfile='../'//Trim(mol)//'/detailed.out'
				eigenvectorfile='../'//Trim(mol)//'/eigenvec.out'
				eigenvec_molX='../'//Trim(mol)//'/eigenvec_'//TRIM(mol)//'.dat'
				if( .not. file_exists_and_continue(eigenvec_molX)) then
					CALL eigenvDFTB_plus_2DIPRO(eigenvectorfile,detailedfile,eigenvec_molX)
				endif
			enddo
		endif
        
        IF (file_exists('../molA/eigenvec_molA.dat')) THEN
            Open(Unit=8, File='../molA/eigenvec_molA.dat', Status='OLD', IOSTAT=ierror)
        END IF 
        
       !Reading number of basis functions for molecule A       
        do
            read(8,*,IOSTAT=ierror) buf, dummy
            if(ierror/=0) exit
            IF(index(dummy,'NBasis=') .ne. 0) then ! dummy = nbasis, for an uneven number of basis functions
                backspace(8) ! back 
                CYCLE
            END IF
            if (index(buf,'NBasis=') .ne. 0) then ! read number of basis function in molA
                Read(dummy,*) n_A
                read(8,*,IOSTAT=ierror) buf, dummy ! Read homo index
                if(ierror/=0) then
					write(*,*) 'buf: ',trim(buf)
					write(*,*) 'dummy: ',trim(dummy)
					stop "Error: reading eigenvector molA."
				endif
                if (index(buf,'HOMO=') .ne. 0) then 
                    Read(dummy,*) homoA
                    lumoA=homoA+1
                END IF ! read HOMO
                exit
            end if
        end do ! reading: n_A,homoA,lumoA
        !WRITE(*,*) 'molA:',n_A,homoA,lumoA
        rewind(8)  ! open again and read orbital energies. (as the order in the file is mixed)
        Allocate(E_Orbitale_A(n_A))
        E_Orbitale_A=0.0d0
        do ! Einlesen der Orbitalenergien in umgekehrter Reihenfolge; hinterher aufsteigend in E_Orbitale_A
            read(8,*,IOSTAT=ierror) buf, dummy
            if(ierror/=0) exit
            IF(index(dummy,'Eigenvalues') .ne. 0) then 
                backspace(8) ! back 
                CYCLE
            END IF
            if (index(buf,'Eigenvalues') .ne. 0 .AND. index(dummy,'[a.u.]') .ne. 0) then
                !Read(8,*,IOSTAT=ierror) dummy
                DO i=1,n_A,1
                    read(8,*,IOSTAT=ierror) E_Orbitale_A(i)
                    if(ierror/=0) then
						write(*,*) 'i: ',i,' E_Orbitale_A(i): ', E_Orbitale_A(i)
						stop "Error: reading eigenvector molA."
					endif
                END DO
                exit
            end if
        end do ! read orbital energies in Hartee molA
        
        if(debug) then
			write(*,*) 'dftb+ orbital energies molA.'
			do i=1,n_A
				WRITE(*,*)  E_Orbitale_A(i)
			end do 
		endif
        WRITE(*,*) 'molA:',n_A,' HOMO: ',homoA,' LUMO: ',lumoA

        IF (file_exists('../molB/eigenvec_molB.dat')) THEN
            Open(Unit=9, File='../molB/eigenvec_molB.dat', Status='OLD', IOSTAT=ierror)
        END IF  

       !Reading number of basis functions for molecule B       
        do
            read(9,*,IOSTAT=ierror) buf, dummy
            if(ierror/=0) exit
            IF(index(dummy,'NBasis=') .ne. 0) then ! dummy = nbasis, for an uneven number of basis functions
                backspace(9) ! back 
                CYCLE
            END IF
            if (index(buf,'NBasis=') .ne. 0) then ! read number of basis function in molB
                Read(dummy,*) n_B
                read(9,*,IOSTAT=ierror) buf, dummy ! Read homo index
                if(ierror/=0) stop "Error: reading eigenvector molB."
                if (index(buf,'HOMO=') .ne. 0) then 
                    Read(dummy,*) homoB
                    lumoB=homoB+1
                END IF ! read HOMO
                exit
            end if
        end do ! reading: n_B,homoB,lumoB
        
        if(debug) WRITE(*,*) 'molB:',n_B,homoB,lumoB
        rewind(9) ! open again and read orbital energies. (as the order in the file is mixed)
        Allocate(E_Orbitale_B(n_B))
        E_Orbitale_B=0.0d0
        do ! Einlesen der Orbitalenergien in umgekehrter Reihenfolge; hinterher aufsteigend in E_Orbitale_B
            read(9,*,IOSTAT=ierror) buf, dummy
            if(ierror/=0) exit
            IF(index(dummy,'Eigenvalues') .ne. 0) then 
                backspace(9) ! back 
                CYCLE
            END IF
            if (index(buf,'Eigenvalues') .ne. 0 .AND. index(dummy,'[a.u.]') .ne. 0) then
                !Read(9,*,IOSTAT=ierror) dummy
                DO i=1,n_B,1
                    read(9,*,IOSTAT=ierror) E_Orbitale_B(i)
                    if(ierror/=0) stop "Error: reading eigenvector molB."
                END DO
                exit
            end if
        end do ! read orbital energies in Hartee molB
        if(debug) then
			write(*,*) 'dftb+ orbital energies molB.'
			do i=1,n_B
				WRITE(*,*)  E_Orbitale_B(i)
			end do 
		endif
        WRITE(*,*) 'molB:',n_B,' HOMO: ',homoB,' LUMO: ',lumoB
        IF ( n_A == 0 .OR. n_B ==0 ) THEN
                WRITE(*,*) 'Error: Number of basis functions is zero, check input: ',n_A,n_B
                STOP
        END IF

        IF (file_exists('eigenvec_dim.dat')) THEN
            Open(Unit=7, File='eigenvec_dim.dat', Status='OLD', IOSTAT=ierror)
        END IF 
       !Reading number of basis functions for dimer: n_D      
        do
            read(7,*,IOSTAT=ierror) buf, dummy
            if(ierror/=0) exit
            IF(index(dummy,'NBasis=') .ne. 0) then ! dummy = nbasis, for an uneven number of basis functions
                backspace(7) ! back 
                CYCLE
            END IF
            if (index(buf,'NBasis=') .ne. 0) then ! read number of basis function in dimer
                Read(dummy,*) n_D
                read(7,*,IOSTAT=ierror) buf, dummy ! Read homo index
                if(ierror/=0) stop "Error: reading eigenvector dimer"
                if (index(buf,'HOMO=') .ne. 0) then 
                    Read(dummy,*) homo_dim
                    lumo_dim=homo_dim+1
                END IF ! read HOMO
                exit
            end if
        end do ! reading: n_D
        close(7)
               
        !! replace fock matrix file
        OPEN(Unit=11, File='fock.txt', Status='REPLACE', IOSTAT=ierror)
    ELSE
        WRITE(*,*) 'Error: You need to select an input format for DIPRO calcualtion (g09 or DFTB+)'
        STOP
    END IF ! read g09 or dftb+

!allocating arrays with known number of orbitals
Allocate(energy(n_D,n_D))	
Allocate(overlap(n_D,n_D))
Allocate(zeta_A(n_A,n_D))
Allocate(zeta_B(n_B,n_D))
Allocate(zeta_D(n_D,n_D))
Allocate(gamma_A(n_A,n_D))
Allocate(gamma_B(n_B,n_D))
Allocate(J_AB(n_A,n_B))
Allocate(S_AB(n_A,n_B))
Allocate(e_A(n_A,n_A))
Allocate(e_B(n_B,n_B))
Allocate(fock(n_D,n_D))
Allocate(transmat(n_D,n_D))


energy=0.0d0
zeta_A=0.0d0
zeta_B=0.0d0

IF( read_g09 ) THEN ! read gausian09 output (default setting)
    !Read overlap
    if(file_exists('dimer.log')) then
		Open(Unit=7, File='dimer.log', Status='OLD', IOSTAT=ierror)
	endif
    do
        Read (7,'(A)',IOSTAT=ierror) buf
        if (ierror /= 0) stop "Error reading overlap matrix."
        !reading the file until the Overlap is shown
        if ( index(buf, '* Overlap') .ne. 0) exit
    end do
    
    l=ceiling(real(n_D)/real(5))
    Do i=1,l
    Read(7,'(I17)') j
    
        Do m=j,n_D
            if (m<=j+4) then
                Read(7,*) dummy, overlap(m, j:m)
            else
                Read(7,*) dummy, overlap(m,j:(j+4))
            End if
        End Do
    End Do
    
    !overlap is symmetric, so mirror the lower triangle-matrix
    Do i=1,n_D
        overlap(i,i:n_D)=overlap(i:n_D,i)
    end Do
    
    
    
    j=ceiling(real(n_A)/real(5))
    ! Reading coefficents of monomer A out of fort.7
    ! first line is FORMAT of coefficients
    Read(8,'(A8)') dummy
    counter=0
    Do i=1,n_A
        Read(8,'(A18, D15.8)') dummy2, energy(i,i)
        
        Do l=1,j
            if (l/=j) Then
                Read(8,dummy) zeta_A(i,(5*(l-1)+1):(5*l))
            Else
                Read(8,dummy) zeta_A(i,(j*5-5+1):(n_A))
            End if
        End Do
    End Do
    
    
    j=ceiling(real(n_B)/real(5))
    !Reading coefficents of monomer B out of fort.7
    Read(9,'(A8)') dummy
    counter=0
    Do i=1,n_B
        Read(9,'(A18, D15.8)') dummy2, energy(i,i)
        Do l=1,j
            if (l/=j) Then
    
                Read(9,dummy) zeta_B(i,n_A+(5*(l-1)+1):n_A+(5*l))
            Else
                Read(9,dummy) zeta_B(i,n_A+(j*5-5+1):n_A+(n_B))
    
            End if
        End Do
    End Do
    
    
    !Reading coefficients and eigenvalues of dimer out of fort.7
    Read(10,'(A8)') dummy
    
    Do i=1,n_D
    Read(10,'(A18, D15.8)') dummy2, energy(i,i)
    j=ceiling(real(n_D)/real(5))
    
        Do l=1,j
            if (l/=j) Then
    
            Read(10,dummy) zeta_D(i,(5*(l-1)+1):(5*l))
        Else
            Read(10,dummy) zeta_D(i,(j*5-5+1):(n_D))
    
            End if
        End Do
    End Do
    CLOSE(10)
    CLOSE(9)
    CLOSE(8)
    CLOSE(7)
ELSE IF (read_dftb_plus) THEN ! read data from dftb+ (formated) output
    !!!!!! Reading DFTB+ data !!!!!!!!!!!!!!!!!!!!

    ! build 1-Matrix
    overlap=0.0d0 
    DO i=1,n_D
        overlap(i,i)=1.0d0
    END DO
    !!! reading overlap S_AB from DFTB+ format for sparse storage S_AB-Matrix (overreal.dat WriteRealHS =Yes) !!!
    IF (file_exists('./overreal.dat')) THEN
        Open(Unit=10, File='./overreal.dat', Status='OLD', IOSTAT=ierror)
    END IF ! overlap matrix in real format exists? 
        
    icase=1 ! select cases
    Ineighbours_max=int(1.0E7) !Maximale Anzahl an besuchten Nachbarn (Wird spaeter als sum_i(Nneigh_i) gesetzt.
    Ineighbours=0 ! counts the number of neighbours (gives the loop exit)
    do    ! read data from overreal.dat (DFTB+ real overlap matrix S) 
        Read (10,'(A)',IOSTAT=ierror) buf ! read #-lines
        !WRITE(*,*) TRIM(buf)
        if (index(buf,'#') .ne. 0) then 
            CONTINUE
        END IF
        if (ierror /= 0) THEN
            WRITE(*,*) "Error reading overlap matrix."
            stop 
        END IF
        IF (icase==1) THEN ! read NAtoms
            Read (10,*,IOSTAT=ierror) NAtoms
            if (ierror /= 0) stop "Error reading overlap matrix."
            WRITE(*,*) 'NAtoms=',NAtoms
            icase=icase+1
            CYCLE
        END IF ! read NAtoms
        
        IF(icase==2) THEN
            Allocate(IAtom_Nneigh_Norbs(NAtoms,4)) ! Number of Atoms, Number of Neighbour including the atom I, Number of orbitals Norbs, 4= sum of N_Orbs to the index
            IAtom_Nneigh_Norbs=0 ! Initializing
            Do j=1,NAtoms
                Read (10,*,IOSTAT=ierror) IAtom_Nneigh_Norbs(j,1),IAtom_Nneigh_Norbs(j,2),IAtom_Nneigh_Norbs(j,3)
                !WRITE(*,*) IAtom_Nneigh_Norbs(j,1),IAtom_Nneigh_Norbs(j,2),IAtom_Nneigh_Norbs(j,3)
                IF (j==1) THEN
                    IAtom_Nneigh_Norbs(j,4)=1
                ELSE
                    IAtom_Nneigh_Norbs(j,4)=IAtom_Nneigh_Norbs(j-1,4)+IAtom_Nneigh_Norbs(j-1,3)  !
                END IF
                if (ierror /= 0) THEN
                    WRITE(*,*) "Error reading overlap matrix."
                    stop 
                END IF ! ierror
            END DO ! read 
            Ineighbours_max=sum(IAtom_Nneigh_Norbs(:,2))
            WRITE(*,*) 'Ineighbours_max=',Ineighbours_max
            icase=icase+1
            CYCLE
        END IF ! icase=2 read IAtom_Nneigh_Norbs
        
        IF(icase==3) THEN ! read: IATOM1    INEIGH   IATOM2F  ICELL(1)  ICELL(2)  ICELL(3)
            Read (10,*,IOSTAT=ierror) ATOM1,INEIGH,IATOM2F,CELL(1),CELL(2),CELL(3)
            !WRITE(*,*) ATOM1,INEIGH,IATOM2F,CELL(1),CELL(2),CELL(3)
            if (ierror /= 0) stop "Error reading overlap matrix."
            icase=4
            CYCLE
        END IF ! case 3
        
        IF(icase==4) THEN ! read overlapp matrix part
            !WRITE(*,*) ATOM1,INEIGH,IATOM2F,CELL(1),CELL(2),CELL(3)
            i_min= IAtom_Nneigh_Norbs(ATOM1,4)             !SUM(IAtom_Nneigh_Norbs(1:(ATOM1),3))+1 ! sum_1^ATOM1 NOrbs + 1
            IF (ATOM1==NAtoms) THEN ! check end of array, array will get out of range otherwise 
                i_max=IAtom_Nneigh_Norbs(ATOM1,4)+IAtom_Nneigh_Norbs(ATOM1,3)-1
            ELSE
                i_max=IAtom_Nneigh_Norbs(ATOM1+1,4)-1
            END IF
            !WRITE(*,*) 'SUM_ORBS i_min,i_max:',i_min,i_max
            j_min=IAtom_Nneigh_Norbs(IATOM2F,4)        !SUM(IAtom_Nneigh_Norbs(1:(IATOM2F),3))+1 ! sum_1^AATOMF NOrbs + 1
            IF(IATOM2F==NAtoms) THEN
                j_max=IAtom_Nneigh_Norbs(IATOM2F,4)+IAtom_Nneigh_Norbs(IATOM2F,3)-1
            ELSE
                j_max=IAtom_Nneigh_Norbs(IATOM2F+1,4)-1
            END IF             
            !WRITE(*,*) 'SUM_ORBS j_min,j_max:',j_min,j_max
            DO i=i_min,i_max,1
                Read (10,*,IOSTAT=ierror) overlap(i,j_min:j_max)
                if (ierror /= 0) stop "Error reading overlap matrix."
                !WRITE(*,*) overlap(i,j_min:j_max)
            END DO
            icase=3
            Ineighbours=Ineighbours+1
            if ( Ineighbours == Ineighbours_max) exit  !reading the file until the maximum number of neighbours is reached: Ineighbours_max
            CYCLE
        END IF ! case 4        
    end do ! read data from overreal.dat 
    CLOSE(10)
    !!! end reading overlap S_AB from DFTB+ format !!!
     WRITE(*,*) 'Ineighbours=', Ineighbours

    !overlap is symmetric, so mirror the lower triangle-matrix
    Do i=1,n_D
        overlap(i,i:n_D)=overlap(i:n_D,i)
    end Do
    
    WRITE(*,*) '________End reading dftb+ overlap_______'
    
    !!!Start reading coefficents of monomer A from dftb+:     
    i=0 !count eigenvectors
    do ! Einlesen eigenvectoren monomer A
        read(8,*,IOSTAT=ierror) buf
        !WRITE(*,*) buf
        if(ierror < 0) exit
        if(ierror > 0) then
					write(*,*) 'Error: Reading the file: ','eigenvec_molA.dat'
					call exit(1)
		endif
        if (index(buf,'Eigenvector:') .ne. 0 ) then
            i=i+1
            !Read(8,*,IOSTAT=ierror) dummy
            DO j=1,n_A,1 !read eigenvector
                read(8,*,IOSTAT=ierror) zeta_A(i,j)
                !WRITE(*,*) i,j,'tmp zeta_A(i,j): ',zeta_A(i,j)
                if(ierror/=0) STOP "Error: reading eigenvectors: eigenvec_molA.dat"
            END DO
            IF (i== n_A) EXIT
        end if
    end do ! Einlesen eigenvectoren
   

    WRITE(*,*) 'n_A=',n_A

    
    !!!Start reading coefficents of monomer B from dftb+:  
    i=0 !count eigenvectors
    do   ! Einlesen eigenvectoren monomer B
			read(9,*,IOSTAT=ierror) buf
			!WRITE(*,*) buf
            if(ierror < 0) exit
            if(ierror > 0) then
					write(*,*) 'Error: Reading the file: ','eigenvec_molB.dat'
					call exit(1)
			endif
			if (index(buf,'Eigenvector:') .ne. 0 ) then
				i=i+1
				!Read(9,*,IOSTAT=ierror) dummy
				DO j=1,n_B,1 !read eigenvector
					read(9,*,IOSTAT=ierror) zeta_B(i,n_A+j)
					!WRITE(*,*) i,n_A+j,'tmp: zeta_B(i,n_A+j) ',zeta_B(i,n_A+j)
					if(ierror/=0) STOP "Error: reading eigenvectors: eigenvec_molB.dat"
				END DO
				IF (i== n_B) EXIT
			end if
    end do ! Einlesen eigenvectoren monomer B 
    
    WRITE(*,*) 'n_B=',n_B
  
    
    !!!Start reading dimer data from dftb+
    IF (file_exists('eigenvec_dim.dat')) THEN !open again
            Open(Unit=7, File='eigenvec_dim.dat', Status='OLD', IOSTAT=ierror)
    END IF 
    do ! Einlesen der Orbitalenergien in energy(i,i) (in Hartree)
            read(7,*,IOSTAT=ierror) buf, dummy
            WRITE(*,*) trim(buf)," ",trim(dummy),ierror
            if(ierror < 0) exit
            if(ierror > 0) then
					WRITE(*,*) trim(buf)," ",trim(dummy)
					write(*,*) 'Error: Reading the file: ','eigenvec_dim.dat'
					call exit(1)
			endif
            if ((index(trim(adjustl(buf)),'Eigenvalues') .ne. 0) .AND. (index(trim(adjustl(dummy)),'[a.u.]') .ne. 0)) then
                DO i=1,n_D,1
                    read(7,*,IOSTAT=ierror) energy(i,i)
                    !write(*,*) 'dim EV tmp: i=',i,' energy(i,i): ',energy(i,i)
                    if(ierror/=0) STOP "Error: reading eigenvectors: eigenvec_dim.dat"
                END DO
                exit
            end if
    end do ! read orbital energies in Hartee molA

       
    !!!Start reading coefficents of the dimer from dftb+: 
    i=0 !count eigenvectors
    do   ! Einlesen eigenvectoren dimer
        read(7,*,IOSTAT=ierror) buf
        !WRITE(*,*) buf
        if(ierror/=0) EXIT
        if (index(buf,'Eigenvector:') .ne. 0 ) then
            i=i+1
            !Read(7,*,IOSTAT=ierror) dummy
            DO j=1,n_D,1 !read eigenvector
                read(7,*,IOSTAT=ierror) zeta_D(i,j)
                !WRITE(*,*) 'tmp ',i,j,'zeta_D(i,j): ',zeta_D(i,j)
                if(ierror/=0) STOP "Error: reading eigenvectors: eigenvec_dim.dat"
            END DO
            IF (i== n_D) EXIT
        end if
    end do ! Einlesen eigenvectoren dimer 
    
    WRITE(*,*) 'n_D=',n_D
    !WRITE(*,*) 'Ineighbours=', Ineighbours
        
    
ELSE ! end read dftb+ data
        WRITE(*,*) 'Error: You need to select an input format for DIPRO calcualtion (g09 or DFTB+)'
        STOP
END IF ! read g09 or dftb+

if( .not. (n_A + n_B == n_D) )then
	write(*,*) 'Error: Missmatch in the dimension of the basis functions.'
	write(*,*) 'n_A: ',n_A,' n_B: ',n_B,' n_D: ',n_D 
	call exit(1)
endif
WRITE(*,*) 'START DIPRO METHODE'

  
!!!!!!! Start with the DIPRO calculations
!calculating gamma
gamma_A=matmul(zeta_A,(matmul(overlap,transpose(zeta_D))))
gamma_B=matmul(zeta_B,(matmul(overlap,transpose(zeta_D))))

!calculation of J_AB
J_AB=matmul(gamma_A,matmul(energy,transpose(gamma_B)))

!calculation of side-energies
e_A=matmul(gamma_A,matmul(energy,transpose(gamma_A)))
e_B=matmul(gamma_B,matmul(energy,transpose(gamma_B)))

!calculation of overlap of monomers					!80
S_AB=matmul(gamma_A,transpose(gamma_B))

!forming the complete fock-matrix
fock(1:n_A,1:n_A)=e_A
fock(n_A+1:n_D,n_A+1:n_D)=e_B
fock(1:n_A,n_A+1:n_D)=J_AB
fock(n_A+1:n_D,1:n_A)=transpose(J_AB)

!calculating the overlap-matrix for transformation to effective fock-matrix
transmat(1:n_A,1:n_A)=matmul(gamma_A,transpose(gamma_A))
transmat(n_A+1:n_D,n_A+1:n_D)=matmul(gamma_B,transpose(gamma_B))
transmat(1:n_A,n_A+1:n_D)=S_AB
transmat(n_A+1:n_D,1:n_A)=transpose(S_AB)

!converting Hartree to eV!
fock=fock*27.21138386d0
  
write (filename1,'(I0)') n_MO
Open(Unit=14, File='Ergebnis-'//TRIM(filename1)//'MO-V11.txt' , Status='REPLACE', IOSTAT=ierror)
Open(Unit=15, File='Matrix_'//TRIM(filename1)//'MO-V11.txt' , Status='REPLACE', IOSTAT=ierror)
Write(14,*) 'HomoA:', homoA
Write(14,*) 'LumoA:', lumoA
Write(14,*) 'HomoB:', homoB
Write(14,*) 'LumoB:', lumoB
!printing certain matrix-elements to check validity
		Write(14,*) 'untransformed:'
		Write(14,FM1) 'HOMO_A to HOMO_A', fock(homoA,homoA)
		Write(14,FM1) 'HOMO_A to LUMO_A', fock(homoA,lumoA)
		Write(14,FM1) 'HOMO_A to HOMO_B', fock(homoA,homoB+n_A)
		Write(14,FM1) 'HOMO_A to LUMO_B', fock(homoA,lumoB+n_A)
		Write(14,FM1) 'LUMO_A to LUMO_B', fock(lumoA,lumoB+n_A)

!Writing out lower left part of the fock-matrix (monomerA to monomerB-transfer)



!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
Deallocate(energy)
Deallocate(zeta_A)
Deallocate(zeta_B)
Deallocate(zeta_D)
IF (read_dftb_plus) THEN
    Deallocate(IAtom_Nneigh_Norbs)
END IF 

!Now we take just the elements we need for HOMO and LUMO +/-n_MO
!while taking energy as a dummy-matrix
!Determine the maximum Value for n_MO as the smallest gap for the frontier space!
if( homoA < n_A/2 ) then ! determine n1_MO for molA
	n1_MO=homoA-1
else
	n1_MO=n_A-homoA-1
end if

if( homoB < n_B/2 ) then ! determine n2_MO for molB
        n2_MO=homoB-1
else
        n2_MO=n_B-homoB-1
end if

IF(n1_MO < n2_MO) THEN ! select smaller range as n_MO
        n_MO=n1_MO
ELSE
        n_MO=n2_MO
END IF

IF(n_MO < 0) THEN
     WRITE(*,*) ' n_MO < 0; Error in evaluation of n_MO. Check selected space of frontier orbitals.'
     WRITE(*,*) ' STOP DIPRO program'
     STOP
END IF
Maximal_MO=n_MO !set last element in Output_nMO to the maximum nMO value
Output_nMO(size(Output_nMO))=Maximal_MO
n_MO=Output_nMO(p)                ! calculate iteration p ! selects n_MO here!!!!
!WRITE(*,*) "Gebe die Anzahl der Orbitale zusaetzlich zum HOMO an von 0 bis ",n_MO
!READ(*,*) n_MO
WRITE(*,*) "Anzahl der HOMO-", n_MO, " und Anzahl der LUMO+",n_MO
IF( (n_MO .GT. Maximal_MO) )THEN
    WRITE(*,*) 'Error: The_selected n_MO=',n_MO,' is too big'
    WRITE(*,*) 'The limit is:',Maximal_MO
    IF(.not. calc_dipro_with_max_nMO) THEN ! calculate with 
        n_MO=Maximal_MO
        calc_dipro_with_max_nMO=.true.
        WRITE(*,*) 'Selected nMO limit:',n_MO
    ELSE
        WRITE(*,*) 'STOP DIPRO program'
        STOP
    END IF
END IF
n_MOmax=4*(n_MO+1) ! maximum dimension of matrix

Allocate(energy(n_MOmax,n_MOmax))
energy(1:(n_MOmax/2),1:(n_MOmax/2))=transmat(homoA-n_MO:lumoA+n_MO,homoA-n_MO:lumoA+n_MO)
energy((n_MOmax/2+1):n_MOmax,(n_MOmax/2+1):n_MOmax)=transmat((n_A+homoB)-n_MO:(n_A+lumoB)+n_MO,(n_A+homoB)-n_MO:(n_A+lumoB)+n_MO)
energy((n_MOmax/2+1):n_MOmax,1:(n_MOmax/2))=transmat((n_A+homoB)-n_MO:(n_A+lumoB)+n_MO,homoA-n_MO:lumoA+n_MO)
energy(1:(n_MOmax/2),(n_MOmax/2+1):n_MOmax)=transpose(energy((n_MOmax/2+1):n_MOmax,1:(n_MOmax/2+1)))
Deallocate(transmat)
Allocate(transmat(n_MOmax,n_MOmax))
transmat=energy

! Now the diagonalization of S and transformation to effective fock-matrix will be done
lwork=3*n_MOmax
Allocate(eigval(n_MOmax))
Allocate(work(lwork))
Allocate(S_diag(n_MOmax,n_MOmax))

!Initializing the diagonal-matrix and matrix to be diagonalized

!CALL DSYEV('V','U', n_MOmax , transmat, n_MOmax , eigval, work, lwork, info)

IF ( info == 0) then
        Write(*,*) ' Diagonalisation successful '
        else if ( info < 0) then 
                Write(*,*) ' The argument',info,' had an illigal value'        
        else
                Write(*,*) info, ' > 0 => the algorithm failed to converge'
                Write(*,*) 'off-diagonal elements of an intermediate tridiagonal form did not converge to zero.'
END IF     


!! check for small eigenvalues, to prevent division by zero in S_diag calculation, which leads to NaN for alle Elements in transmat. 
j=0
Do i=1,n_MOmax
	IF ( abs(eigval(i)) < 1.0E-11 .or. isnan(eigval(i)) ) THEN
		IF(j==0) THEN ! Warning is only printed once.		
			write(*,*) ' Caution, small eigenvalue in eigval(i) encountered, check the results: ',eigval(i),' i=',i
			write(*,*) ' use: ',sign(1.0D-11,eigval(i))
			j=1
		END IF 
		eigval(i)=sign(1.0D-11,eigval(i))
	END IF 
end do ! check small eigenvalues

S_diag=0.0d0
Do i=1,n_MOmax
	S_diag(i,i)=1.0d0/sqrt(eigval(i))
End Do
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!Having calculated all the eigenvalues and eigenvectors, one can finally build the transformation-matrix


transmat=matmul(transmat,matmul(S_diag,transpose(transmat)))


!finally calculating the effective fock-matrix:
!takiing the relevant elements of fock matrix analogous to transmat
energy(1:(n_MOmax/2),1:(n_MOmax/2))=fock(homoA-n_MO:lumoA+n_MO,homoA-n_MO:lumoA+n_MO)
energy((n_MOmax/2+1):n_MOmax,(n_MOmax/2+1):n_MOmax)=fock((n_A+homoB)-n_MO:(n_A+lumoB)+n_MO,(n_A+homoB)-n_MO:(n_A+lumoB)+n_MO)
energy((n_MOmax/2+1):n_MOmax,1:(n_MOmax/2))=fock((n_A+homoB)-n_MO:(n_A+lumoB)+n_MO,homoA-n_MO:lumoA+n_MO)
energy(1:(n_MOmax/2),(n_MOmax/2+1):n_MOmax)=transpose(energy((n_MOmax/2+1):n_MOmax,1:(n_MOmax/2)))
Deallocate(fock)
Allocate(fock(n_MOmax,n_MOmax))
fock=energy

!  \mathbf{H}^{\text{eff}}= \mathbf{S}^{- \frac{1}{2}} \mathbf{H}\mathbf{S}^{- \frac{1}{2}}
fock=matmul(transmat,matmul(fock, transmat))

S_AB_HOMO_A_to_HOMO_B=S_AB(homoA,homoB)
S_AB_LUMO_A_to_LUMO_B=S_AB(lumoA,lumoB)
HOMO_A_to_HOMO_B=fock((n_MO+1),(n_MOmax/2+1+n_MO))
LUMO_A_to_LUMO_B=fock((n_MO+2),(n_MOmax/2+2+n_MO))

!!! start check energetic degeneration of frontier orbitals in A and B
! Check if the frontier orbital energies are degenerated
IF(allocated(E_Orbitale_A) .AND. allocated(E_Orbitale_B)) THEN
        WRITE(*,*) 'A HOMO , HOMO-1',E_Orbitale_A(homoA),E_Orbitale_A(homoA-1)
        WRITE(*,*) 'A LUMO , LUMO+1',E_Orbitale_A(lumoA),E_Orbitale_A(lumoA+1)
        WRITE(*,*) 'B HOMO , HOMO-1',E_Orbitale_B(homoB),E_Orbitale_B(homoB-1)
        WRITE(*,*) 'B LUMO , LUMO+1',E_Orbitale_B(lumoB),E_Orbitale_B(lumoB+1)
        
        HOMO_A_to_HOMO_B=fock((n_MO+1),(n_MOmax/2+1+n_MO))**2
        S_AB_HOMO_A_to_HOMO_B=S_AB(homoA,homoB)**2
        i_homo=1
        IF(abs(E_Orbitale_A(homoA)-E_Orbitale_A(homoA-1)) < E_deg_cut_off) THEN
                ! A HOMO_A to HOMO_B + HOMO_A -1 to HOMO_B
                HOMO_A_to_HOMO_B=HOMO_A_to_HOMO_B+fock((n_MO),(n_MOmax/2+1+n_MO))**2
                S_AB_HOMO_A_to_HOMO_B=S_AB_HOMO_A_to_HOMO_B+S_AB(homoA-1,homoB)**2
                i_homo=i_homo+1
        END IF
        IF(abs(E_Orbitale_B(homoB)-E_Orbitale_B(homoB-1)) < E_deg_cut_off) THEN
                ! A HOMO_A to HOMO_B + HOMO_A  to HOMO_B -1
                HOMO_A_to_HOMO_B=HOMO_A_to_HOMO_B+fock((n_MO+1),(n_MOmax/2+n_MO))**2
                S_AB_HOMO_A_to_HOMO_B=S_AB_HOMO_A_to_HOMO_B+S_AB(homoA,homoB-1)**2
                i_homo=i_homo+1
        END IF
        IF (i_homo ==3 ) THEN
                ! HOMO_A to HOMO_B + HOMO_A -1 to HOMO_B -1
                HOMO_A_to_HOMO_B=HOMO_A_to_HOMO_B+fock((n_MO),(n_MOmax/2+n_MO))**2
                S_AB_HOMO_A_to_HOMO_B=S_AB_HOMO_A_to_HOMO_B+S_AB(homoA-1,homoB-1)**2
                i_homo=i_homo+1
        END IF
        ! summe J_AB = sqrt( 1/N* sum_{i,j}  |J_ij|*2)  mit i,j in {homo, homo-1}
        HOMO_A_to_HOMO_B=sqrt(1.0d0/(i_homo)*HOMO_A_to_HOMO_B)
        S_AB_HOMO_A_to_HOMO_B=sqrt(S_AB_HOMO_A_to_HOMO_B/Real(i_homo))
        IF (i_homo /= 1) THEN
                WRITE(*,*) 'Caution, degenerated HOMO, HOMO-1 orbital energies found'
                WRITE(*,*) 'Replace J_AB:',fock((n_MO+1),(n_MOmax/2+1+n_MO)),' by ',HOMO_A_to_HOMO_B
                WRITE(*,*) 'and     S_AB:',S_AB(homoA,homoB),' by ',S_AB_HOMO_A_to_HOMO_B
                fock((n_MO+1),(n_MOmax/2+1+n_MO))=HOMO_A_to_HOMO_B
                S_AB(homoA,homoB)=S_AB_HOMO_A_to_HOMO_B
        END IF



        ! check degeneration of lumo, lumo+1 Orbitals
        LUMO_A_to_LUMO_B=fock((n_MO+2),(n_MOmax/2+2+n_MO))**2
        S_AB_LUMO_A_to_LUMO_B=S_AB(lumoA,lumoB)**2
        i_lumo=1
        IF(abs(E_Orbitale_A(lumoA)-E_Orbitale_A(lumoA+1)) < E_deg_cut_off) THEN
                ! A LUMO_A to LUMO_B + LUMO_A +1 to LUMO_B
                LUMO_A_to_LUMO_B=LUMO_A_to_LUMO_B+fock((n_MO+3),(n_MOmax/2+2+n_MO))**2
                S_AB_LUMO_A_to_LUMO_B=S_AB_LUMO_A_to_LUMO_B+S_AB(lumoA+1,lumoB)**2
                i_lumo=i_lumo+1
        END IF
        IF(abs(E_Orbitale_B(lumoB)-E_Orbitale_B(lumoB+1)) < E_deg_cut_off) THEN
                ! A LUMO_A to LUMO_B + LUMO_A  to LUMO_B +1
                LUMO_A_to_LUMO_B=LUMO_A_to_LUMO_B+fock((n_MO+2),(n_MOmax/2+3+n_MO))**2
                S_AB_LUMO_A_to_LUMO_B=S_AB_LUMO_A_to_LUMO_B+S_AB(lumoA,lumoB+1)**2
                i_lumo=i_lumo+1
        END IF
        IF (i_lumo == 3) THEN
                ! LUMO_A to LUMO_B + LUMO_A +1 to LUMO_B +1
                LUMO_A_to_LUMO_B=LUMO_A_to_LUMO_B+fock((n_MO+3),(n_MOmax/2+3+n_MO))**2
                S_AB_LUMO_A_to_LUMO_B=S_AB_LUMO_A_to_LUMO_B+S_AB(lumoA+1,lumoB+1)**2
                i_lumo=i_lumo+1
        END IF
        ! summe J_AB = sqrt( 1/N* sum_{i,j}  |J_ij|*2)  mit i,j in {lumo, lumo+1}
        LUMO_A_to_LUMO_B=sqrt(1.0d0/(i_lumo)*LUMO_A_to_LUMO_B)
        S_AB_LUMO_A_to_LUMO_B=sqrt(S_AB_LUMO_A_to_LUMO_B/Real(i_lumo)) 
        IF (i_lumo /= 1) THEN
                WRITE(*,*) 'Caution, degenerated LUMO, LUMO+1 orbital energies found'
                WRITE(*,*) 'Replace J_AB:',fock((n_MO+2),(n_MOmax/2+2+n_MO)),' by ',LUMO_A_to_LUMO_B
                WRITE(*,*) 'and     S_AB:',S_AB(lumoA,lumoB),' by ',S_AB_LUMO_A_to_LUMO_B
                fock((n_MO+2),(n_MOmax/2+2+n_MO))=LUMO_A_to_LUMO_B
                S_AB(lumoA,lumoB)=S_AB_LUMO_A_to_LUMO_B
        END IF
END IF 
!!! end check energetic degeneration of frontier orbitals in A and B


!printing certain matrix-elements to check validity
			Write(14,*) 'transformed'
			Write(14,FM1) 'HOMO_A to HOMO_A  ', fock((n_MO+1),(n_MO+1))
			Write(14,FM1) 'HOMO_A to LUMO_A  ', fock((n_MO+1),(n_MO+2))
			Write(14,FM1) '1 HOMO_A to HOMO_B', fock((n_MO+1),(n_MOmax/2+1+n_MO))
			Write(14,FM1) 'HOMO_A to LUMO_B  ', fock((n_MO+1),(n_MOmax/2+2+n_MO))
			Write(14,FM1) '2 LUMO_A to LUMO_B', fock((n_MO+2),(n_MOmax/2+2+n_MO))
			Write(14,FM1) 'LUMO_A to LUMO_A  ', fock((n_MO+2),(n_MO+2))
			Write(14,FM1) 'HOMO_B to HOMO_B  ', fock((n_MOmax/2+1+n_MO),(n_MOmax/2+1+n_MO))
			Write(14,FM1) 'LUMO_B to LUMO_B  ', fock((n_MOmax/2+2+n_MO),(n_MOmax/2+2+n_MO))
                
            if( n_MO /= 0) then                
                Write(14,*) '*** mixed transitions ***'
                Write(14,FM1) 'HOMO_A   to HOMO_B-1  ',fock((n_MO+1),(n_MOmax/2+n_MO))
                Write(14,FM1) 'HOMO_A-1 to HOMO_B    ',fock((n_MO),(n_MOmax/2+1+n_MO))
                Write(14,FM1) 'LUMO_A   to LUMO_B+1  ',fock((n_MO+2),(n_MOmax/2+3+n_MO))
                Write(14,FM1) 'LUMO_A+1 to LUMO_B    ',fock((n_MO+3),(n_MOmax/2+2+n_MO))
            end if

            if( n_MO >= 2) then
                Write(14,*) '*** n_MO >= 2 ***'
                Write(14,FM1) 'HOMO_A-2 to HOMO_B    ',fock((n_MO-1),(n_MOmax/2+1+n_MO))
                Write(14,FM1) 'LUMO_A+2 to LUMO_B+1  ',fock((n_MO+4),(n_MOmax/2+3+n_MO))
             end if
!Writing out the effective matrix in the file fock.txt
!Locate the biggest matrix element
!write(*,*) 'Start to print fock matrix '
if(debug) then
	fock_max=0.0d0
	i_max=0
	j_max=0
	Do i=1,n_MOmax
		Do j=1,n_MOmax
			Write(11,*)i,j, fock(i,j)
			if(abs(fock(i,j)) > fock_max ) then
				fock_max=abs(fock(i,j))		
				i_max=i
				j_max=j
			end if
		End Do
	End Do
	Write(*,*) '*** biggest fock-matrix element ***'
	Write(*,*) i_max,' to ',j_max,abs(fock(i_max,j_max))
endif !debug => fock_max



IF(n_MO>=4) THEN
! Print Overlapp of the Monomer-Orbitals
  Write(14,*) '*** overlapp of orbitals S_AB from monomer A and monomer B ***'
  Write(14,FM1) 'S_AB HOMO_A   HOMO_B  ',   S_AB(homoA,homoB)
  Write(14,FM1) 'S_AB HOMO_A-1 HOMO_B-1',   S_AB((homoA-1),(homoB-1))
  Write(14,FM1) 'S_AB HOMO_A-1 HOMO_B  ',   S_AB((homoA-1),(homoB))
  Write(14,FM1) 'S_AB HOMO_A   HOMO_B-1',   S_AB(homoA,(homoB-1))
  Write(14,FM1) 'S_AB LUMO_A   LUMO_B  ',   S_AB(lumoA,lumoB)  
  Write(14,FM1) 'S_AB LUMO_A+1 LUMO_B+1',   S_AB((lumoA+1),(lumoB+1))   
  Write(14,FM1) 'S_AB LUMO_A+1 LUMO_B  ',   S_AB((lumoA+1),(lumoB))  
  Write(14,FM1) 'S_AB LUMO_A   LUMO_B+1',   S_AB((lumoA),(lumoB+1)) 

Write(14,*) '*** overlapp of orbitals |S_AB| holes from monomer A and monomer B and |J ab|'

Write(14,FM2) '|S_AB| HOMO_A   HOMO_B     ',abs(S_AB(homoA,homoB))        ,' ',abs(fock((n_MO+1),(n_MOmax/2+1+n_MO)) )
Write(14,FM2) '|S_AB| HOMO_A   HOMO_B-1   ',abs(S_AB(homoA,(homoB-1))    ),' ',abs(fock((n_MO+1),(n_MOmax/2+n_MO))   )
Write(14,FM2) '|S_AB| HOMO_A-1 HOMO_B     ',abs(S_AB((homoA-1),(homoB))  ),' ',abs(fock((n_MO),(n_MOmax/2+1+n_MO))   )
Write(14,FM2) '|S_AB| HOMO_A-1 HOMO_B-1   ',abs(S_AB((homoA-1),(homoB-1))),' ',abs(fock((n_MO),(n_MOmax/2+n_MO))     )
         
Write(14,FM2) '|S_AB| HOMO_A-2 HOMO_B     ',abs(S_AB(homoA-2,homoB))      ,' ',abs(fock((n_MO-1),(n_MOmax/2+1+n_MO)))
Write(14,FM2) '|S_AB| HOMO_A-2 HOMO_B-1   ',abs(S_AB(homoA-2,homoB-1))    ,' ',abs(fock((n_MO-1),(n_MOmax/2+n_MO)))
Write(14,FM2) '|S_AB| HOMO_A-2 HOMO_B-2   ',abs(S_AB(homoA-2,homoB-2))    ,' ',abs(fock((n_MO-1),(n_MOmax/2-1+n_MO)))
         
Write(14,FM2) '|S_AB| HOMO_A-3 HOMO_B     ',abs(S_AB(homoA-3,homoB))      ,' ',abs(fock((n_MO-2),(n_MOmax/2+1+n_MO)))
Write(14,FM2) '|S_AB| HOMO_A-3 HOMO_B-1   ',abs(S_AB(homoA-3,homoB-1))    ,' ',abs(fock((n_MO-2),(n_MOmax/2+n_MO)))
Write(14,FM2) '|S_AB| HOMO_A-3 HOMO_B-2   ',abs(S_AB(homoA-3,homoB-2))    ,' ',abs(fock((n_MO-2),(n_MOmax/2-1+n_MO)))
Write(14,FM2) '|S_AB| HOMO_A-3 HOMO_B-3   ',abs(S_AB(homoA-3,homoB-3))    ,' ',abs(fock((n_MO-2),(n_MOmax/2-2+n_MO)))
         
Write(14,FM2) '|S_AB| HOMO_A-4 HOMO_B     ',abs(S_AB(homoA-4,homoB))      ,' ',abs(fock((n_MO-3),(n_MOmax/2+1+n_MO)))
Write(14,FM2) '|S_AB| HOMO_A-4 HOMO_B-1   ',abs(S_AB(homoA-4,homoB-1))    ,' ',abs(fock((n_MO-3),(n_MOmax/2+n_MO)))
Write(14,FM2) '|S_AB| HOMO_A-4 HOMO_B-2   ',abs(S_AB(homoA-4,homoB-2))    ,' ',abs(fock((n_MO-3),(n_MOmax/2-1+n_MO)))
Write(14,FM2) '|S_AB| HOMO_A-4 HOMO_B-3   ',abs(S_AB(homoA-4,homoB-3))    ,' ',abs(fock((n_MO-3),(n_MOmax/2-2+n_MO)))
Write(14,FM2) '|S_AB| HOMO_A-4 HOMO_B-4   ',abs(S_AB(homoA-4,homoB-4))    ,' ',abs(fock((n_MO-3),(n_MOmax/2-3+n_MO)))
         
Write(14,*) '*** overlapp of orbitals |S_AB| elektrons from monomer A and monomer B and |J ab|'                                                                     
         
Write(14,FM2) '|S_AB| LUMO_A   LUMO_B     ',abs(S_AB(lumoA,lumoB)        ),' ',abs(fock((n_MO+2),(n_MOmax/2+2+n_MO)) )
Write(14,FM2) '|S_AB| LUMO_A   LUMO_B+1   ',abs(S_AB((lumoA),(lumoB+1))  ),' ',abs(fock((n_MO+2),(n_MOmax/2+3+n_MO)) )

Write(14,FM2) '|S_AB| LUMO_A+1 LUMO_B     ',abs(S_AB((lumoA+1),(lumoB))  ),' ',abs(fock((n_MO+3),(n_MOmax/2+2+n_MO)) )
Write(14,FM2) '|S_AB| LUMO_A+1 LUMO_B+1   ',abs(S_AB((lumoA+1),(lumoB+1))),' ',abs(fock((n_MO+3),(n_MOmax/2+3+n_MO)) )
                                                                      
Write(14,FM2) '|S_AB| LUMO_A+2 LUMO_B     ',abs(S_AB(lumoA+2,lumoB))      ,' ',abs(fock((n_MO+4),(n_MOmax/2+2+n_MO)))
Write(14,FM2) '|S_AB| LUMO_A+2 LUMO_B+1   ',abs(S_AB(lumoA+2,lumoB+1))    ,' ',abs(fock((n_MO+4),(n_MOmax/2+3+n_MO)))
Write(14,FM2) '|S_AB| LUMO_A+2 LUMO_B+2   ',abs(S_AB(lumoA+2,lumoB+2))    ,' ',abs(fock((n_MO+4),(n_MOmax/2+4+n_MO)))
                                                                     
Write(14,FM2) '|S_AB| LUMO_A+3 LUMO_B     ',abs(S_AB(lumoA+3,lumoB))      ,' ',abs(fock((n_MO+5),(n_MOmax/2+2+n_MO)))
Write(14,FM2) '|S_AB| LUMO_A+3 LUMO_B+1   ',abs(S_AB(lumoA+3,lumoB+1))    ,' ',abs(fock((n_MO+5),(n_MOmax/2+3+n_MO)))
Write(14,FM2) '|S_AB| LUMO_A+3 LUMO_B+2   ',abs(S_AB(lumoA+3,lumoB+2))    ,' ',abs(fock((n_MO+5),(n_MOmax/2+4+n_MO)))
Write(14,FM2) '|S_AB| LUMO_A+3 LUMO_B+3   ',abs(S_AB(lumoA+3,lumoB+3))    ,' ',abs(fock((n_MO+5),(n_MOmax/2+5+n_MO)))
         
Write(14,FM2) '|S_AB| LUMO_A+4 LUMO_B     ',abs(S_AB(lumoA+4,lumoB))      ,' ',abs(fock((n_MO+6),(n_MOmax/2+2+n_MO)))
Write(14,FM2) '|S_AB| LUMO_A+4 LUMO_B+1   ',abs(S_AB(lumoA+4,lumoB+1))    ,' ',abs(fock((n_MO+6),(n_MOmax/2+3+n_MO)))
Write(14,FM2) '|S_AB| LUMO_A+4 LUMO_B+2   ',abs(S_AB(lumoA+4,lumoB+2))    ,' ',abs(fock((n_MO+6),(n_MOmax/2+4+n_MO)))
Write(14,FM2) '|S_AB| LUMO_A+4 LUMO_B+3   ',abs(S_AB(lumoA+4,lumoB+3))    ,' ',abs(fock((n_MO+6),(n_MOmax/2+5+n_MO)))
Write(14,FM2) '|S_AB| LUMO_A+4 LUMO_B+4   ',abs(S_AB(lumoA+4,lumoB+4))    ,' ',abs(fock((n_MO+6),(n_MOmax/2+6+n_MO)))





! Find maximum overlapp in frontier orbitals homo-3 to lumo+3 from monomers
! for hole transport
frontier=10 !homo+/-frontier
i_max=0
j_max=0
S_AB_max=0.0
Do i=(homoA-frontier),(homoA),1
	Do j=(homoB-frontier),(homoB),1		
		if(abs(S_AB(i,j)) > S_AB_max ) then
			S_AB_max=abs(S_AB(i,j))		
			i_max=i
			j_max=j
		end if
	End Do
End Do

  Write(14,*) '*** frontier monomer orbital maximum |S_AB| *** number frontier=',frontier
  Write(14,'(2X,A12,1X,I3,1X,A11,1X,I3,1X,A8,1X,ES14.6)') 'S_AB HOMO_A ',(i_max-homoA),' HOMO_B ',(j_max-homoB),' |S_AB|=',S_AB_max
  Write(14,'(2X,A12,1X,I3,1X,A11,1X,I3,1X,A8,1X,ES14.6)') 'J_AB HOMO_A ',(i_max-homoA),' to HOMO_B ',(j_max-homoB),&
  ' |J_AB|=',fock((n_MO+1+i_max-homoA),(n_MOmax/2+1+n_MO+j_max-homoB))

! for elektron transport
i_max=0
j_max=0
S_AB_max=0.0
Do i=(lumoA),(lumoA+frontier),1
	Do j=(lumoB),(lumoB+frontier),1		
		if(abs(S_AB(i,j)) > S_AB_max ) then
			S_AB_max=abs(S_AB(i,j))		
			i_max=i
			j_max=j
		end if
	End Do
End Do

  Write(14,*) '*** frontier monomer orbital maximum |S_AB| *** '
  Write(14,'(2X,A12,1X,I3,1X,A11,1X,I3,1X,A8,1X,ES14.6)') 'S_AB LUMO_A+',(i_max-lumoA),' LUMO_B+',(j_max-lumoB),' |S_AB|=',S_AB_max
  Write(14,'(2X,A12,1X,I3,1X,A11,1X,I3,1X,A8,1X,ES14.6)') 'J_AB LUMO_A+',(i_max-lumoA),' to LUMO_B+',(j_max-lumoB),&
  ' |J_AB|=',fock((n_MO+2+i_max-lumoA),(n_MOmax/2+2+n_MO+j_max-lumoB))

END IF !!! END  PRINTING for (IF nMO>=4)


! Gewichtets |J_AB|

!write(*,*) 'E_Orbitale_A (homoA)', E_Orbitale_A(homoA), 'homoA=',homoA
!write(*,*) 'E_Orbitale_B (homoB)', E_Orbitale_B(homoB), 'homoB=',homoB

ALLOCATE(w_A(n_MOmax/2))
ALLOCATE(w_B(n_MOmax/2))

T=300            ! K
k_B=8.617332E-5  !eV/K
sumA_lo=0.0
sumB_lo=0.0
sumA_el=0.0
sumB_el=0.0
J_ges_lo_w1=0.0
J_ges_lo_w2=0.0
J_ges_lo_w3=0.0

J_ges_el_w1=0.0
J_ges_el_w2=0.0
J_ges_el_w3=0.0
J_ges_lo_w4=0.0
J_ges_el_w4=0.0

!converting Hartree to eV!
E_Orbitale_A=E_Orbitale_A*27.21138386
E_Orbitale_B=E_Orbitale_B*27.21138386


DO i=1,n_MOmax/4 
    !L\F6cher
    w_A(i)=exp(-abs(E_Orbitale_A(homoA-(i-1))-E_Orbitale_A(homoA))/(k_B*T))
    w_B(i)=exp(-abs(E_Orbitale_B(homoB-(i-1))-E_Orbitale_B(homoB))/(k_B*T))
    sumA_lo=sumA_lo+w_A(i)
    sumB_lo=sumB_lo+w_B(i)
    !Elektronen
    w_A(i+n_MOmax/4)=exp(-abs(E_Orbitale_A(lumoA+(i-1))-E_Orbitale_A(lumoA))/(k_B*T))
    w_B(i+n_MOmax/4)=exp(-abs(E_Orbitale_B(lumoB+(i-1))-E_Orbitale_B(lumoB))/(k_B*T))
    sumA_el=sumA_el+w_A(i+n_MOmax/4)
    sumB_el=sumB_el+w_B(i+n_MOmax/4)
    !write(*,*) 'wA_lo=',w_A(i),'wB_lo=',w_B(i),'wA_el=',w_A(i+n_MOmax/4),'wB_el=',w_B(i+n_MOmax/4)
END DO

DO i=1,n_MOmax/4 !Normierung
    w_A(i)=w_A(i)/sumA_lo
    w_B(i)=w_B(i)/sumB_lo
    w_A(i+n_MOmax/4)=w_A(i+n_MOmax/4)/sumA_el
    w_B(i+n_MOmax/4)=w_B(i+n_MOmax/4)/sumB_el
    !write(*,*) 'NORMIERT: wA_lo=',w_A(i),'wB_lo=',w_B(i),'wA_el=',w_A(i+n_MOmax/4),'wB_el=',w_B(i+n_MOmax/4)
END do

!WRITE(*,*) sumA_el,sumB_el,sumA_lo,sumB_lo
! |J_{1}^{ges}| = \frac{1}{n_{\text{MO}}+1}  \sum_{i=0}^{n_\text{MO}}  \sum_{j=0}^{n_\text{MO}} w_{A} |J_{ij}| 
! Hier mit index-Verschiebung i=>i+1 und n_MOmax/4=n_MO+1
DO i=1,n_MOmax/4
    DO j=1,n_MOmax/4                 !Loecher fock(homoA-i,homoB-j)       
        J_ges_lo_w1=J_ges_lo_w1+w_A(i)*abs(fock((n_MO+1)-(i-1),(n_MOmax/2+1+n_MO)-(j-1)))
        J_ges_lo_w2=J_ges_lo_w2+(w_A(i)*w_B(j))*abs(fock((n_MO+1)-(i-1),(n_MOmax/2+1+n_MO)-(j-1)))
        J_ges_lo_w3=J_ges_lo_w3+w_A(i)*abs(fock((n_MO+1)-(i-1),(n_MOmax/2+1+n_MO)-(j-1)))**2
        J_ges_lo_w4=J_ges_lo_w4+(w_A(i)*w_B(j))*abs(fock((n_MO+1)-(i-1),(n_MOmax/2+1+n_MO)-(j-1)))**2
                                    !Elektronen fock(lumoA+i,lumoB+j)  
        J_ges_el_w1=J_ges_el_w1+w_A(i+n_MOmax/4)*abs(fock((n_MO+2)+(i-1),(n_MOmax/2+2+n_MO)+(j-1)))
        J_ges_el_w2=J_ges_el_w2+(w_A(i+n_MOmax/4)*w_B(j+n_MOmax/4))*abs(fock((n_MO+2)+(i-1),(n_MOmax/2+2+n_MO)+(j-1)) )
        J_ges_el_w3=J_ges_el_w3+w_A(i+n_MOmax/4)*abs(fock((n_MO+2)+(i-1),(n_MOmax/2+2+n_MO)+(j-1)))**2
        J_ges_el_w4=J_ges_el_w4+(w_A(i+n_MOmax/4)*w_B(j+n_MOmax/4))*abs(fock((n_MO+2)+(i-1),(n_MOmax/2+2+n_MO)+(j-1)))**2
     END DO
END DO
J_ges_lo_w1=J_ges_lo_w1/(n_MOmax/4)
J_ges_el_w1=J_ges_el_w1/(n_MOmax/4)

J_ges_lo_w3=J_ges_lo_w3/(n_MOmax/4)
J_ges_el_w3=J_ges_el_w3/(n_MOmax/4)

J_ges_lo_w4=J_ges_lo_w4/(n_MOmax/4)
J_ges_el_w4=J_ges_el_w4/(n_MOmax/4)

write(23,*)'nMO=',Output_nMO(p), ' HOMO_A_to_HOMO_B ', abs(fock((n_MO+1),(n_MOmax/2+1+n_MO)) ),&
&'J_ges_lo_w1=',J_ges_lo_w1,'J_ges_lo_w2=', J_ges_lo_w2,' LUMO_A_to_LUMO_B ',&
&abs(fock((n_MO+2),(n_MOmax/2+2+n_MO)) ),'J_ges_el_w1=',J_ges_el_w1, ' J_ges_el_w2= ',J_ges_el_w2,&
&' J_ges_lo_w3= ',J_ges_lo_w3, ' J_ges_el_w3= ',J_ges_el_w3,&
&' J_ges_lo_w4= ',J_ges_lo_w4, ' J_ges_el_w4= ',J_ges_el_w4




IF( n_MO >= 9 ) THEN
    Write(15,*) '*** overlapp of orbitals |S_AB| elektrons from monomer A and monomer B and |J ab|**2 und w_A(i)*|J ab|**2 ***'                                                                     
!    
!Write(15,FM2)'|S_AB| LUMO_A+0 LUMO_B+0 ',abs(S_AB(lumoA,lumoB))    ,' ',abs(fock((n_MO+2),(n_MOmax/2+2+n_MO)))**2 !,w_A(1+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+2+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+0 LUMO_B+1 ',abs(S_AB(lumoA,lumoB+1))  ,' ',abs(fock((n_MO+2),(n_MOmax/2+3+n_MO)))**2 !,w_A(2+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+3+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+0 LUMO_B+2 ',abs(S_AB(lumoA,lumoB+2))  ,' ',abs(fock((n_MO+2),(n_MOmax/2+4+n_MO)))**2 !,w_A(3+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+4+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+0 LUMO_B+3 ',abs(S_AB(lumoA,lumoB+3))  ,' ',abs(fock((n_MO+2),(n_MOmax/2+5+n_MO)))**2 !,w_A(4+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+5+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+0 LUMO_B+4 ',abs(S_AB(lumoA,lumoB+4))  ,' ',abs(fock((n_MO+2),(n_MOmax/2+6+n_MO)))**2 !,w_A(5+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+6+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+0 LUMO_B+5 ',abs(S_AB(lumoA,lumoB+5))  ,' ',abs(fock((n_MO+2),(n_MOmax/2+7+n_MO)))**2 !,w_A(6+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+7+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+0 LUMO_B+6 ',abs(S_AB(lumoA,lumoB+6))  ,' ',abs(fock((n_MO+2),(n_MOmax/2+8+n_MO)))**2 !,w_A(7+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+8+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+0 LUMO_B+7 ',abs(S_AB(lumoA,lumoB+7))  ,' ',abs(fock((n_MO+2),(n_MOmax/2+9+n_MO)))**2 !,w_A(8+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+9+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+0 LUMO_B+8 ',abs(S_AB(lumoA,lumoB+8))  ,' ',abs(fock((n_MO+2),(n_MOmax/2+10+n_MO)))**2!,w_A(9+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+10+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+0 LUMO_B+9 ',abs(S_AB(lumoA,lumoB+9))  ,' ',abs(fock((n_MO+2),(n_MOmax/2+11+n_MO)))**2!,w_A(10+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+11+n_MO)))**2
!                                                                                                 
!Write(15,FM2)'|S_AB| LUMO_A+1 LUMO_B+0 ',abs(S_AB(lumoA+1,lumoB))  ,' ',abs(fock((n_MO+3),(n_MOmax/2+2+n_MO)))**2 !,w_A(1+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+2+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+1 LUMO_B+1 ',abs(S_AB(lumoA+1,lumoB+1)),' ',abs(fock((n_MO+3),(n_MOmax/2+3+n_MO)))**2 !,w_A(2+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+3+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+1 LUMO_B+2 ',abs(S_AB(lumoA+1,lumoB+2)),' ',abs(fock((n_MO+3),(n_MOmax/2+4+n_MO)))**2 !,w_A(3+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+4+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+1 LUMO_B+3 ',abs(S_AB(lumoA+1,lumoB+3)),' ',abs(fock((n_MO+3),(n_MOmax/2+5+n_MO)))**2 !,w_A(4+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+5+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+1 LUMO_B+4 ',abs(S_AB(lumoA+1,lumoB+4)),' ',abs(fock((n_MO+3),(n_MOmax/2+6+n_MO)))**2 !,w_A(5+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+6+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+1 LUMO_B+5 ',abs(S_AB(lumoA+1,lumoB+5)),' ',abs(fock((n_MO+3),(n_MOmax/2+7+n_MO)))**2 !,w_A(6+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+7+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+1 LUMO_B+6 ',abs(S_AB(lumoA+1,lumoB+6)),' ',abs(fock((n_MO+3),(n_MOmax/2+8+n_MO)))**2 !,w_A(7+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+8+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+1 LUMO_B+7 ',abs(S_AB(lumoA+1,lumoB+7)),' ',abs(fock((n_MO+3),(n_MOmax/2+9+n_MO)))**2 !,w_A(8+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+9+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+1 LUMO_B+8 ',abs(S_AB(lumoA+1,lumoB+8)),' ',abs(fock((n_MO+3),(n_MOmax/2+10+n_MO)))**2!,w_A(9+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+10+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+1 LUMO_B+9 ',abs(S_AB(lumoA+1,lumoB+9)),' ',abs(fock((n_MO+3),(n_MOmax/2+11+n_MO)))**2!,w_A(10+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+11+n_MO)))**2
!                                                                                                     
!Write(15,FM2)'|S_AB| LUMO_A+2 LUMO_B+0 ',abs(S_AB(lumoA+2,lumoB))  ,' ',abs(fock((n_MO+4),(n_MOmax/2+2+n_MO)))**2 !,w_A(1+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+2+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+2 LUMO_B+1 ',abs(S_AB(lumoA+2,lumoB+1)),' ',abs(fock((n_MO+4),(n_MOmax/2+3+n_MO)))**2 !,w_A(2+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+3+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+2 LUMO_B+2 ',abs(S_AB(lumoA+2,lumoB+2)),' ',abs(fock((n_MO+4),(n_MOmax/2+4+n_MO)))**2 !,w_A(3+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+4+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+2 LUMO_B+3 ',abs(S_AB(lumoA+2,lumoB+3)),' ',abs(fock((n_MO+4),(n_MOmax/2+5+n_MO)))**2 !,w_A(4+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+5+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+2 LUMO_B+4 ',abs(S_AB(lumoA+2,lumoB+4)),' ',abs(fock((n_MO+4),(n_MOmax/2+6+n_MO)))**2 !,w_A(5+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+6+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+2 LUMO_B+5 ',abs(S_AB(lumoA+2,lumoB+5)),' ',abs(fock((n_MO+4),(n_MOmax/2+7+n_MO)))**2 !,w_A(6+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+7+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+2 LUMO_B+6 ',abs(S_AB(lumoA+2,lumoB+6)),' ',abs(fock((n_MO+4),(n_MOmax/2+8+n_MO)))**2 !,w_A(7+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+8+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+2 LUMO_B+7 ',abs(S_AB(lumoA+2,lumoB+7)),' ',abs(fock((n_MO+4),(n_MOmax/2+9+n_MO)))**2 !,w_A(8+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+9+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+2 LUMO_B+8 ',abs(S_AB(lumoA+2,lumoB+8)),' ',abs(fock((n_MO+4),(n_MOmax/2+10+n_MO)))**2!,w_A(9+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+10+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+2 LUMO_B+9 ',abs(S_AB(lumoA+2,lumoB+9)),' ',abs(fock((n_MO+4),(n_MOmax/2+11+n_MO)))**2!,w_A(10+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+11+n_MO)))**2
!                                                                                                              
!Write(15,FM2)'|S_AB| LUMO_A+3 LUMO_B+0 ',abs(S_AB(lumoA+3,lumoB))  ,' ',abs(fock((n_MO+5),(n_MOmax/2+2+n_MO)))**2 !,w_A(1+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+2+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+3 LUMO_B+1 ',abs(S_AB(lumoA+3,lumoB+1)),' ',abs(fock((n_MO+5),(n_MOmax/2+3+n_MO)))**2 !,w_A(2+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+3+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+3 LUMO_B+2 ',abs(S_AB(lumoA+3,lumoB+2)),' ',abs(fock((n_MO+5),(n_MOmax/2+4+n_MO)))**2 !,w_A(3+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+4+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+3 LUMO_B+3 ',abs(S_AB(lumoA+3,lumoB+3)),' ',abs(fock((n_MO+5),(n_MOmax/2+5+n_MO)))**2 !,w_A(4+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+5+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+3 LUMO_B+4 ',abs(S_AB(lumoA+3,lumoB+4)),' ',abs(fock((n_MO+5),(n_MOmax/2+6+n_MO)))**2 !,w_A(5+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+6+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+3 LUMO_B+5 ',abs(S_AB(lumoA+3,lumoB+5)),' ',abs(fock((n_MO+5),(n_MOmax/2+7+n_MO)))**2 !,w_A(6+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+7+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+3 LUMO_B+6 ',abs(S_AB(lumoA+3,lumoB+6)),' ',abs(fock((n_MO+5),(n_MOmax/2+8+n_MO)))**2 !,w_A(7+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+8+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+3 LUMO_B+7 ',abs(S_AB(lumoA+3,lumoB+7)),' ',abs(fock((n_MO+5),(n_MOmax/2+9+n_MO)))**2 !,w_A(8+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+9+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+3 LUMO_B+8 ',abs(S_AB(lumoA+3,lumoB+8)),' ',abs(fock((n_MO+5),(n_MOmax/2+10+n_MO)))**2!,w_A(9+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+10+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+3 LUMO_B+9 ',abs(S_AB(lumoA+3,lumoB+9)),' ',abs(fock((n_MO+5),(n_MOmax/2+11+n_MO)))**2!,w_A(10+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+11+n_MO)))**2
!                                                                                                  
!Write(15,FM2)'|S_AB| LUMO_A+4 LUMO_B+0 ',abs(S_AB(lumoA+4,lumoB))  ,' ',abs(fock((n_MO+6),(n_MOmax/2+2+n_MO)))**2 !,w_A(1+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+2+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+4 LUMO_B+1 ',abs(S_AB(lumoA+4,lumoB+1)),' ',abs(fock((n_MO+6),(n_MOmax/2+3+n_MO)))**2 !,w_A(2+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+3+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+4 LUMO_B+2 ',abs(S_AB(lumoA+4,lumoB+2)),' ',abs(fock((n_MO+6),(n_MOmax/2+4+n_MO)))**2 !,w_A(3+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+4+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+4 LUMO_B+3 ',abs(S_AB(lumoA+4,lumoB+3)),' ',abs(fock((n_MO+6),(n_MOmax/2+5+n_MO)))**2 !,w_A(4+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+5+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+4 LUMO_B+4 ',abs(S_AB(lumoA+4,lumoB+4)),' ',abs(fock((n_MO+6),(n_MOmax/2+6+n_MO)))**2 !,w_A(5+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+6+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+4 LUMO_B+5 ',abs(S_AB(lumoA+4,lumoB+5)),' ',abs(fock((n_MO+6),(n_MOmax/2+7+n_MO)))**2 !,w_A(6+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+7+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+4 LUMO_B+6 ',abs(S_AB(lumoA+4,lumoB+6)),' ',abs(fock((n_MO+6),(n_MOmax/2+8+n_MO)))**2 !,w_A(7+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+8+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+4 LUMO_B+7 ',abs(S_AB(lumoA+4,lumoB+7)),' ',abs(fock((n_MO+6),(n_MOmax/2+9+n_MO)))**2 !,w_A(8+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+9+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+4 LUMO_B+8 ',abs(S_AB(lumoA+4,lumoB+8)),' ',abs(fock((n_MO+6),(n_MOmax/2+10+n_MO)))**2!,w_A(9+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+10+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+4 LUMO_B+9 ',abs(S_AB(lumoA+4,lumoB+9)),' ',abs(fock((n_MO+6),(n_MOmax/2+11+n_MO)))**2!,w_A(10+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+11+n_MO)))**2  
!                                                                                                       
!Write(15,FM2)'|S_AB| LUMO_A+5 LUMO_B+0 ',abs(S_AB(lumoA+5,lumoB))  ,' ',abs(fock((n_MO+7),(n_MOmax/2+2+n_MO)))**2 !,w_A(1+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+2+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+5 LUMO_B+1 ',abs(S_AB(lumoA+5,lumoB+1)),' ',abs(fock((n_MO+7),(n_MOmax/2+3+n_MO)))**2 !,w_A(2+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+3+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+5 LUMO_B+2 ',abs(S_AB(lumoA+5,lumoB+2)),' ',abs(fock((n_MO+7),(n_MOmax/2+4+n_MO)))**2 !,w_A(3+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+4+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+5 LUMO_B+3 ',abs(S_AB(lumoA+5,lumoB+3)),' ',abs(fock((n_MO+7),(n_MOmax/2+5+n_MO)))**2 !,w_A(4+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+5+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+5 LUMO_B+4 ',abs(S_AB(lumoA+5,lumoB+4)),' ',abs(fock((n_MO+7),(n_MOmax/2+6+n_MO)))**2 !,w_A(5+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+6+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+5 LUMO_B+5 ',abs(S_AB(lumoA+5,lumoB+5)),' ',abs(fock((n_MO+7),(n_MOmax/2+7+n_MO)))**2 !,w_A(6+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+7+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+5 LUMO_B+6 ',abs(S_AB(lumoA+5,lumoB+6)),' ',abs(fock((n_MO+7),(n_MOmax/2+8+n_MO)))**2 !,w_A(7+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+8+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+5 LUMO_B+7 ',abs(S_AB(lumoA+5,lumoB+7)),' ',abs(fock((n_MO+7),(n_MOmax/2+9+n_MO)))**2 !,w_A(8+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+9+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+5 LUMO_B+8 ',abs(S_AB(lumoA+5,lumoB+8)),' ',abs(fock((n_MO+7),(n_MOmax/2+10+n_MO)))**2!,w_A(9+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+10+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+5 LUMO_B+9 ',abs(S_AB(lumoA+5,lumoB+9)),' ',abs(fock((n_MO+7),(n_MOmax/2+11+n_MO)))**2!,w_A(10+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+11+n_MO)))**2
!                                                                                                      
!Write(15,FM2)'|S_AB| LUMO_A+6 LUMO_B+0 ',abs(S_AB(lumoA+6,lumoB))  ,' ',abs(fock((n_MO+8),(n_MOmax/2+2+n_MO)))**2 !,w_A(1+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+2+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+6 LUMO_B+1 ',abs(S_AB(lumoA+6,lumoB+1)),' ',abs(fock((n_MO+8),(n_MOmax/2+3+n_MO)))**2 !,w_A(2+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+3+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+6 LUMO_B+2 ',abs(S_AB(lumoA+6,lumoB+2)),' ',abs(fock((n_MO+8),(n_MOmax/2+4+n_MO)))**2 !,w_A(3+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+4+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+6 LUMO_B+3 ',abs(S_AB(lumoA+6,lumoB+3)),' ',abs(fock((n_MO+8),(n_MOmax/2+5+n_MO)))**2 !,w_A(4+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+5+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+6 LUMO_B+4 ',abs(S_AB(lumoA+6,lumoB+4)),' ',abs(fock((n_MO+8),(n_MOmax/2+6+n_MO)))**2 !,w_A(5+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+6+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+6 LUMO_B+5 ',abs(S_AB(lumoA+6,lumoB+5)),' ',abs(fock((n_MO+8),(n_MOmax/2+7+n_MO)))**2 !,w_A(6+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+7+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+6 LUMO_B+6 ',abs(S_AB(lumoA+6,lumoB+6)),' ',abs(fock((n_MO+8),(n_MOmax/2+8+n_MO)))**2 !,w_A(7+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+8+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+6 LUMO_B+7 ',abs(S_AB(lumoA+6,lumoB+7)),' ',abs(fock((n_MO+8),(n_MOmax/2+9+n_MO)))**2 !,w_A(8+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+9+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+6 LUMO_B+8 ',abs(S_AB(lumoA+6,lumoB+8)),' ',abs(fock((n_MO+8),(n_MOmax/2+10+n_MO)))**2!,w_A(9+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+10+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+6 LUMO_B+9 ',abs(S_AB(lumoA+6,lumoB+9)),' ',abs(fock((n_MO+8),(n_MOmax/2+11+n_MO)))**2!,w_A(10+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+11+n_MO)))**2
!                                                                                                          
!Write(15,FM2)'|S_AB| LUMO_A+7 LUMO_B+0 ',abs(S_AB(lumoA+7,lumoB))  ,' ',abs(fock((n_MO+9),(n_MOmax/2+2+n_MO)))**2 !,w_A(1+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+2+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+7 LUMO_B+1 ',abs(S_AB(lumoA+7,lumoB+1)),' ',abs(fock((n_MO+9),(n_MOmax/2+3+n_MO)))**2 !,w_A(2+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+3+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+7 LUMO_B+2 ',abs(S_AB(lumoA+7,lumoB+2)),' ',abs(fock((n_MO+9),(n_MOmax/2+4+n_MO)))**2 !,w_A(3+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+4+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+7 LUMO_B+3 ',abs(S_AB(lumoA+7,lumoB+3)),' ',abs(fock((n_MO+9),(n_MOmax/2+5+n_MO)))**2 !,w_A(4+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+5+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+7 LUMO_B+4 ',abs(S_AB(lumoA+7,lumoB+4)),' ',abs(fock((n_MO+9),(n_MOmax/2+6+n_MO)))**2 !,w_A(5+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+6+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+7 LUMO_B+5 ',abs(S_AB(lumoA+7,lumoB+5)),' ',abs(fock((n_MO+9),(n_MOmax/2+7+n_MO)))**2 !,w_A(6+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+7+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+7 LUMO_B+6 ',abs(S_AB(lumoA+7,lumoB+6)),' ',abs(fock((n_MO+9),(n_MOmax/2+8+n_MO)))**2 !,w_A(7+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+8+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+7 LUMO_B+7 ',abs(S_AB(lumoA+7,lumoB+7)),' ',abs(fock((n_MO+9),(n_MOmax/2+9+n_MO)))**2 !,w_A(8+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+9+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+7 LUMO_B+8 ',abs(S_AB(lumoA+7,lumoB+8)),' ',abs(fock((n_MO+9),(n_MOmax/2+10+n_MO)))**2!,w_A(9+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+10+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+7 LUMO_B+9 ',abs(S_AB(lumoA+7,lumoB+9)),' ',abs(fock((n_MO+9),(n_MOmax/2+11+n_MO)))**2!,w_A(10+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+11+n_MO)))**2
!                                                                                              
!Write(15,FM2)'|S_AB| LUMO_A+8 LUMO_B+0 ',abs(S_AB(lumoA+8,lumoB))  ,' ',abs(fock((n_MO+10),(n_MOmax/2+2+n_MO)))**2!,,w_A(1+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+2+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+8 LUMO_B+1 ',abs(S_AB(lumoA+8,lumoB+1)),' ',abs(fock((n_MO+10),(n_MOmax/2+3+n_MO)))**2!,,w_A(2+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+3+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+8 LUMO_B+2 ',abs(S_AB(lumoA+8,lumoB+2)),' ',abs(fock((n_MO+10),(n_MOmax/2+4+n_MO)))**2!,,w_A(3+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+4+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+8 LUMO_B+3 ',abs(S_AB(lumoA+8,lumoB+3)),' ',abs(fock((n_MO+10),(n_MOmax/2+5+n_MO)))**2!,,w_A(4+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+5+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+8 LUMO_B+4 ',abs(S_AB(lumoA+8,lumoB+4)),' ',abs(fock((n_MO+10),(n_MOmax/2+6+n_MO)))**2!,,w_A(5+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+6+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+8 LUMO_B+5 ',abs(S_AB(lumoA+8,lumoB+5)),' ',abs(fock((n_MO+10),(n_MOmax/2+7+n_MO)))**2!,,w_A(6+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+7+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+8 LUMO_B+6 ',abs(S_AB(lumoA+8,lumoB+6)),' ',abs(fock((n_MO+10),(n_MOmax/2+8+n_MO)))**2!,,w_A(7+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+8+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+8 LUMO_B+7 ',abs(S_AB(lumoA+8,lumoB+7)),' ',abs(fock((n_MO+10),(n_MOmax/2+9+n_MO)))**2!,,w_A(8+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+9+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+8 LUMO_B+8 ',abs(S_AB(lumoA+8,lumoB+8)),' ',abs(fock((n_MO+10),(n_MOmax/2+10+n_MO)))**2!,,w_A(9+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+10+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+8 LUMO_B+9 ',abs(S_AB(lumoA+8,lumoB+9)),' ',abs(fock((n_MO+10),(n_MOmax/2+11+n_MO)))**2!,,w_A(10+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+11+n_MO)))**2
!                                                                                                        
!Write(15,FM2)'|S_AB| LUMO_A+9 LUMO_B+0 ',abs(S_AB(lumoA+9,lumoB))  ,' ',abs(fock((n_MO+11),(n_MOmax/2+2+n_MO)))**2!,,w_A(1+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+2+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+9 LUMO_B+1 ',abs(S_AB(lumoA+9,lumoB+1)),' ',abs(fock((n_MO+11),(n_MOmax/2+3+n_MO)))**2!,,w_A(2+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+3+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+9 LUMO_B+2 ',abs(S_AB(lumoA+9,lumoB+2)),' ',abs(fock((n_MO+11),(n_MOmax/2+4+n_MO)))**2!,,w_A(3+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+4+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+9 LUMO_B+3 ',abs(S_AB(lumoA+9,lumoB+3)),' ',abs(fock((n_MO+11),(n_MOmax/2+5+n_MO)))**2!,,w_A(4+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+5+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+9 LUMO_B+4 ',abs(S_AB(lumoA+9,lumoB+4)),' ',abs(fock((n_MO+11),(n_MOmax/2+6+n_MO)))**2!,,w_A(5+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+6+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+9 LUMO_B+5 ',abs(S_AB(lumoA+9,lumoB+5)),' ',abs(fock((n_MO+11),(n_MOmax/2+7+n_MO)))**2!,,w_A(6+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+7+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+9 LUMO_B+6 ',abs(S_AB(lumoA+9,lumoB+6)),' ',abs(fock((n_MO+11),(n_MOmax/2+8+n_MO)))**2!,,w_A(7+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+8+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+9 LUMO_B+7 ',abs(S_AB(lumoA+9,lumoB+7)),' ',abs(fock((n_MO+11),(n_MOmax/2+9+n_MO)))**2!,,w_A(8+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+9+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+9 LUMO_B+8 ',abs(S_AB(lumoA+9,lumoB+8)),' ',abs(fock((n_MO+11),(n_MOmax/2+10+n_MO)))**2!,,w_A(9+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+10+n_MO)))**2
!Write(15,FM2)'|S_AB| LUMO_A+9 LUMO_B+9 ',abs(S_AB(lumoA+9,lumoB+9)),' ',abs(fock((n_MO+11),(n_MOmax/2+11+n_MO)))**2!,,w_A(10+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+11+n_MO)))**2
!
!Gewichtet 
IF (DEBUG) THEN
        DO i=1,n_MOmax/4
		IF ((w_A(i+n_MOmax/4) > 1.0E-20) .and. ( w_B(i+n_MOmax/4) > 1.0E-20)) THEN 
                	WRITE(*,*) 'w_A =',w_A(i+n_MOmax/4),'w_B=',w_B(i+n_MOmax/4)
		END IF
        END DO 
END IF
!########
Write(15,*) 'Elektrontransport monomer A to monomer B with overlap |S_AB| transition matrix element |J ab|**2 und w_A(i)*|J ab|**2'
Write(15,FM3)'A+0 B+0 ',abs(S_AB(lumoA,lumoB))    ,abs(fock((n_MO+2),(n_MOmax/2+2+n_MO)))**2 &
,w_A(1+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+2+n_MO)))**2
Write(15,FM3)'A+0 B+1 ',abs(S_AB(lumoA,lumoB+1))  ,abs(fock((n_MO+2),(n_MOmax/2+3+n_MO)))**2 &
,w_A(1+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+3+n_MO)))**2
Write(15,FM3)'A+0 B+2 ',abs(S_AB(lumoA,lumoB+2))  ,abs(fock((n_MO+2),(n_MOmax/2+4+n_MO)))**2 &
,w_A(1+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+4+n_MO)))**2
Write(15,FM3)'A+0 B+3 ',abs(S_AB(lumoA,lumoB+3))  ,abs(fock((n_MO+2),(n_MOmax/2+5+n_MO)))**2 &
,w_A(1+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+5+n_MO)))**2
Write(15,FM3)'A+0 B+4 ',abs(S_AB(lumoA,lumoB+4))  ,abs(fock((n_MO+2),(n_MOmax/2+6+n_MO)))**2 &
,w_A(1+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+6+n_MO)))**2
Write(15,FM3)'A+0 B+5 ',abs(S_AB(lumoA,lumoB+5))  ,abs(fock((n_MO+2),(n_MOmax/2+7+n_MO)))**2 &
,w_A(1+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+7+n_MO)))**2
Write(15,FM3)'A+0 B+6 ',abs(S_AB(lumoA,lumoB+6))  ,abs(fock((n_MO+2),(n_MOmax/2+8+n_MO)))**2 &
,w_A(1+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+8+n_MO)))**2
Write(15,FM3)'A+0 B+7 ',abs(S_AB(lumoA,lumoB+7))  ,abs(fock((n_MO+2),(n_MOmax/2+9+n_MO)))**2 &
,w_A(1+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+9+n_MO)))**2
Write(15,FM3)'A+0 B+8 ',abs(S_AB(lumoA,lumoB+8))  ,abs(fock((n_MO+2),(n_MOmax/2+10+n_MO)))**2&
,w_A(1+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+10+n_MO)))**2
Write(15,FM3)'A+0 B+9 ',abs(S_AB(lumoA,lumoB+9))  ,abs(fock((n_MO+2),(n_MOmax/2+11+n_MO)))**2&
,w_A(1+n_MOmax/4)*abs(fock((n_MO+2),(n_MOmax/2+11+n_MO)))**2
                                                                                            
Write(15,FM3)'A+1 B+0 ',abs(S_AB(lumoA+1,lumoB))  ,abs(fock((n_MO+3),(n_MOmax/2+2+n_MO)))**2 &
,w_A(2+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+2+n_MO)))**2
Write(15,FM3)'A+1 B+1 ',abs(S_AB(lumoA+1,lumoB+1)),abs(fock((n_MO+3),(n_MOmax/2+3+n_MO)))**2 &
,w_A(2+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+3+n_MO)))**2
Write(15,FM3)'A+1 B+2 ',abs(S_AB(lumoA+1,lumoB+2)),abs(fock((n_MO+3),(n_MOmax/2+4+n_MO)))**2 &
,w_A(2+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+4+n_MO)))**2
Write(15,FM3)'A+1 B+3 ',abs(S_AB(lumoA+1,lumoB+3)),abs(fock((n_MO+3),(n_MOmax/2+5+n_MO)))**2 &
,w_A(2+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+5+n_MO)))**2
Write(15,FM3)'A+1 B+4 ',abs(S_AB(lumoA+1,lumoB+4)),abs(fock((n_MO+3),(n_MOmax/2+6+n_MO)))**2 &
,w_A(2+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+6+n_MO)))**2
Write(15,FM3)'A+1 B+5 ',abs(S_AB(lumoA+1,lumoB+5)),abs(fock((n_MO+3),(n_MOmax/2+7+n_MO)))**2 &
,w_A(2+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+7+n_MO)))**2
Write(15,FM3)'A+1 B+6 ',abs(S_AB(lumoA+1,lumoB+6)),abs(fock((n_MO+3),(n_MOmax/2+8+n_MO)))**2 &
,w_A(2+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+8+n_MO)))**2
Write(15,FM3)'A+1 B+7 ',abs(S_AB(lumoA+1,lumoB+7)),abs(fock((n_MO+3),(n_MOmax/2+9+n_MO)))**2 &
,w_A(2+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+9+n_MO)))**2
Write(15,FM3)'A+1 B+8 ',abs(S_AB(lumoA+1,lumoB+8)),abs(fock((n_MO+3),(n_MOmax/2+10+n_MO)))**2&
,w_A(2+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+10+n_MO)))**2
Write(15,FM3)'A+1 B+9 ',abs(S_AB(lumoA+1,lumoB+9)),abs(fock((n_MO+3),(n_MOmax/2+11+n_MO)))**2&
,w_A(2+n_MOmax/4)*abs(fock((n_MO+3),(n_MOmax/2+11+n_MO)))**2
                                                                                    
Write(15,FM3)'A+2 B+0 ',abs(S_AB(lumoA+2,lumoB))  ,abs(fock((n_MO+4),(n_MOmax/2+2+n_MO)))**2 &
,w_A(3+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+2+n_MO)))**2
Write(15,FM3)'A+2 B+1 ',abs(S_AB(lumoA+2,lumoB+1)),abs(fock((n_MO+4),(n_MOmax/2+3+n_MO)))**2 &
,w_A(3+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+3+n_MO)))**2
Write(15,FM3)'A+2 B+2 ',abs(S_AB(lumoA+2,lumoB+2)),abs(fock((n_MO+4),(n_MOmax/2+4+n_MO)))**2 &
,w_A(3+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+4+n_MO)))**2
Write(15,FM3)'A+2 B+3 ',abs(S_AB(lumoA+2,lumoB+3)),abs(fock((n_MO+4),(n_MOmax/2+5+n_MO)))**2 &
,w_A(3+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+5+n_MO)))**2
Write(15,FM3)'A+2 B+4 ',abs(S_AB(lumoA+2,lumoB+4)),abs(fock((n_MO+4),(n_MOmax/2+6+n_MO)))**2 &
,w_A(3+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+6+n_MO)))**2
Write(15,FM3)'A+2 B+5 ',abs(S_AB(lumoA+2,lumoB+5)),abs(fock((n_MO+4),(n_MOmax/2+7+n_MO)))**2 &
,w_A(3+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+7+n_MO)))**2
Write(15,FM3)'A+2 B+6 ',abs(S_AB(lumoA+2,lumoB+6)),abs(fock((n_MO+4),(n_MOmax/2+8+n_MO)))**2 &
,w_A(3+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+8+n_MO)))**2
Write(15,FM3)'A+2 B+7 ',abs(S_AB(lumoA+2,lumoB+7)),abs(fock((n_MO+4),(n_MOmax/2+9+n_MO)))**2 &
,w_A(3+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+9+n_MO)))**2
Write(15,FM3)'A+2 B+8 ',abs(S_AB(lumoA+2,lumoB+8)),abs(fock((n_MO+4),(n_MOmax/2+10+n_MO)))**2&
,w_A(3+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+10+n_MO)))**2
Write(15,FM3)'A+2 B+9 ',abs(S_AB(lumoA+2,lumoB+9)),abs(fock((n_MO+4),(n_MOmax/2+11+n_MO)))**2&
,w_A(3+n_MOmax/4)*abs(fock((n_MO+4),(n_MOmax/2+11+n_MO)))**2
                                                                            
Write(15,FM3)'A+3 B+0 ',abs(S_AB(lumoA+3,lumoB))  ,abs(fock((n_MO+5),(n_MOmax/2+2+n_MO)))**2 &
,w_A(4+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+2+n_MO)))**2
Write(15,FM3)'A+3 B+1 ',abs(S_AB(lumoA+3,lumoB+1)),abs(fock((n_MO+5),(n_MOmax/2+3+n_MO)))**2 &
,w_A(4+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+3+n_MO)))**2
Write(15,FM3)'A+3 B+2 ',abs(S_AB(lumoA+3,lumoB+2)),abs(fock((n_MO+5),(n_MOmax/2+4+n_MO)))**2 &
,w_A(4+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+4+n_MO)))**2
Write(15,FM3)'A+3 B+3 ',abs(S_AB(lumoA+3,lumoB+3)),abs(fock((n_MO+5),(n_MOmax/2+5+n_MO)))**2 &
,w_A(4+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+5+n_MO)))**2
Write(15,FM3)'A+3 B+4 ',abs(S_AB(lumoA+3,lumoB+4)),abs(fock((n_MO+5),(n_MOmax/2+6+n_MO)))**2 &
,w_A(4+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+6+n_MO)))**2
Write(15,FM3)'A+3 B+5 ',abs(S_AB(lumoA+3,lumoB+5)),abs(fock((n_MO+5),(n_MOmax/2+7+n_MO)))**2 &
,w_A(4+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+7+n_MO)))**2
Write(15,FM3)'A+3 B+6 ',abs(S_AB(lumoA+3,lumoB+6)),abs(fock((n_MO+5),(n_MOmax/2+8+n_MO)))**2 &
,w_A(4+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+8+n_MO)))**2
Write(15,FM3)'A+3 B+7 ',abs(S_AB(lumoA+3,lumoB+7)),abs(fock((n_MO+5),(n_MOmax/2+9+n_MO)))**2 &
,w_A(4+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+9+n_MO)))**2
Write(15,FM3)'A+3 B+8 ',abs(S_AB(lumoA+3,lumoB+8)),abs(fock((n_MO+5),(n_MOmax/2+10+n_MO)))**2&
,w_A(4+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+10+n_MO)))**2
Write(15,FM3)'A+3 B+9 ',abs(S_AB(lumoA+3,lumoB+9)),abs(fock((n_MO+5),(n_MOmax/2+11+n_MO)))**2&
,w_A(4+n_MOmax/4)*abs(fock((n_MO+5),(n_MOmax/2+11+n_MO)))**2
                                                                                           
Write(15,FM3)'A+4 B+0 ',abs(S_AB(lumoA+4,lumoB))  ,abs(fock((n_MO+6),(n_MOmax/2+2+n_MO)))**2 &
,w_A(5+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+2+n_MO)))**2
Write(15,FM3)'A+4 B+1 ',abs(S_AB(lumoA+4,lumoB+1)),abs(fock((n_MO+6),(n_MOmax/2+3+n_MO)))**2 &
,w_A(5+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+3+n_MO)))**2
Write(15,FM3)'A+4 B+2 ',abs(S_AB(lumoA+4,lumoB+2)),abs(fock((n_MO+6),(n_MOmax/2+4+n_MO)))**2 &
,w_A(5+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+4+n_MO)))**2
Write(15,FM3)'A+4 B+3 ',abs(S_AB(lumoA+4,lumoB+3)),abs(fock((n_MO+6),(n_MOmax/2+5+n_MO)))**2 &
,w_A(5+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+5+n_MO)))**2
Write(15,FM3)'A+4 B+4 ',abs(S_AB(lumoA+4,lumoB+4)),abs(fock((n_MO+6),(n_MOmax/2+6+n_MO)))**2 &
,w_A(5+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+6+n_MO)))**2
Write(15,FM3)'A+4 B+5 ',abs(S_AB(lumoA+4,lumoB+5)),abs(fock((n_MO+6),(n_MOmax/2+7+n_MO)))**2 &
,w_A(5+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+7+n_MO)))**2
Write(15,FM3)'A+4 B+6 ',abs(S_AB(lumoA+4,lumoB+6)),abs(fock((n_MO+6),(n_MOmax/2+8+n_MO)))**2 &
,w_A(5+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+8+n_MO)))**2
Write(15,FM3)'A+4 B+7 ',abs(S_AB(lumoA+4,lumoB+7)),abs(fock((n_MO+6),(n_MOmax/2+9+n_MO)))**2 &
,w_A(5+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+9+n_MO)))**2
Write(15,FM3)'A+4 B+8 ',abs(S_AB(lumoA+4,lumoB+8)),abs(fock((n_MO+6),(n_MOmax/2+10+n_MO)))**2&
,w_A(5+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+10+n_MO)))**2
Write(15,FM3)'A+4 B+9 ',abs(S_AB(lumoA+4,lumoB+9)),abs(fock((n_MO+6),(n_MOmax/2+11+n_MO)))**2&
,w_A(5+n_MOmax/4)*abs(fock((n_MO+6),(n_MOmax/2+11+n_MO)))**2  
                                                                   
Write(15,FM3)'A+5 B+0 ',abs(S_AB(lumoA+5,lumoB))  ,abs(fock((n_MO+7),(n_MOmax/2+2+n_MO)))**2 &
,w_A(6+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+2+n_MO)))**2
Write(15,FM3)'A+5 B+1 ',abs(S_AB(lumoA+5,lumoB+1)),abs(fock((n_MO+7),(n_MOmax/2+3+n_MO)))**2 &
,w_A(6+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+3+n_MO)))**2
Write(15,FM3)'A+5 B+2 ',abs(S_AB(lumoA+5,lumoB+2)),abs(fock((n_MO+7),(n_MOmax/2+4+n_MO)))**2 &
,w_A(6+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+4+n_MO)))**2
Write(15,FM3)'A+5 B+3 ',abs(S_AB(lumoA+5,lumoB+3)),abs(fock((n_MO+7),(n_MOmax/2+5+n_MO)))**2 &
,w_A(6+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+5+n_MO)))**2
Write(15,FM3)'A+5 B+4 ',abs(S_AB(lumoA+5,lumoB+4)),abs(fock((n_MO+7),(n_MOmax/2+6+n_MO)))**2 &
,w_A(6+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+6+n_MO)))**2
Write(15,FM3)'A+5 B+5 ',abs(S_AB(lumoA+5,lumoB+5)),abs(fock((n_MO+7),(n_MOmax/2+7+n_MO)))**2 &
,w_A(6+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+7+n_MO)))**2
Write(15,FM3)'A+5 B+6 ',abs(S_AB(lumoA+5,lumoB+6)),abs(fock((n_MO+7),(n_MOmax/2+8+n_MO)))**2 &
,w_A(6+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+8+n_MO)))**2
Write(15,FM3)'A+5 B+7 ',abs(S_AB(lumoA+5,lumoB+7)),abs(fock((n_MO+7),(n_MOmax/2+9+n_MO)))**2 &
,w_A(6+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+9+n_MO)))**2
Write(15,FM3)'A+5 B+8 ',abs(S_AB(lumoA+5,lumoB+8)),abs(fock((n_MO+7),(n_MOmax/2+10+n_MO)))**2&
,w_A(6+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+10+n_MO)))**2
Write(15,FM3)'A+5 B+9 ',abs(S_AB(lumoA+5,lumoB+9)),abs(fock((n_MO+7),(n_MOmax/2+11+n_MO)))**2&
,w_A(6+n_MOmax/4)*abs(fock((n_MO+7),(n_MOmax/2+11+n_MO)))**2
                                                                                     
Write(15,FM3)'A+6 B+0 ',abs(S_AB(lumoA+6,lumoB))  ,abs(fock((n_MO+8),(n_MOmax/2+2+n_MO)))**2 &
,w_A(7+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+2+n_MO)))**2
Write(15,FM3)'A+6 B+1 ',abs(S_AB(lumoA+6,lumoB+1)),abs(fock((n_MO+8),(n_MOmax/2+3+n_MO)))**2 &
,w_A(7+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+3+n_MO)))**2
Write(15,FM3)'A+6 B+2 ',abs(S_AB(lumoA+6,lumoB+2)),abs(fock((n_MO+8),(n_MOmax/2+4+n_MO)))**2 &
,w_A(7+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+4+n_MO)))**2
Write(15,FM3)'A+6 B+3 ',abs(S_AB(lumoA+6,lumoB+3)),abs(fock((n_MO+8),(n_MOmax/2+5+n_MO)))**2 &
,w_A(7+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+5+n_MO)))**2
Write(15,FM3)'A+6 B+4 ',abs(S_AB(lumoA+6,lumoB+4)),abs(fock((n_MO+8),(n_MOmax/2+6+n_MO)))**2 &
,w_A(7+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+6+n_MO)))**2
Write(15,FM3)'A+6 B+5 ',abs(S_AB(lumoA+6,lumoB+5)),abs(fock((n_MO+8),(n_MOmax/2+7+n_MO)))**2 &
,w_A(7+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+7+n_MO)))**2
Write(15,FM3)'A+6 B+6 ',abs(S_AB(lumoA+6,lumoB+6)),abs(fock((n_MO+8),(n_MOmax/2+8+n_MO)))**2 &
,w_A(7+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+8+n_MO)))**2
Write(15,FM3)'A+6 B+7 ',abs(S_AB(lumoA+6,lumoB+7)),abs(fock((n_MO+8),(n_MOmax/2+9+n_MO)))**2 &
,w_A(7+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+9+n_MO)))**2
Write(15,FM3)'A+6 B+8 ',abs(S_AB(lumoA+6,lumoB+8)),abs(fock((n_MO+8),(n_MOmax/2+10+n_MO)))**2&
,w_A(7+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+10+n_MO)))**2
Write(15,FM3)'A+6 B+9 ',abs(S_AB(lumoA+6,lumoB+9)),abs(fock((n_MO+8),(n_MOmax/2+11+n_MO)))**2&
,w_A(7+n_MOmax/4)*abs(fock((n_MO+8),(n_MOmax/2+11+n_MO)))**2
                                                                              
Write(15,FM3)'A+7 B+0 ',abs(S_AB(lumoA+7,lumoB))  ,abs(fock((n_MO+9),(n_MOmax/2+2+n_MO)))**2 &
,w_A(8+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+2+n_MO)))**2
Write(15,FM3)'A+7 B+1 ',abs(S_AB(lumoA+7,lumoB+1)),abs(fock((n_MO+9),(n_MOmax/2+3+n_MO)))**2 &
,w_A(8+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+3+n_MO)))**2
Write(15,FM3)'A+7 B+2 ',abs(S_AB(lumoA+7,lumoB+2)),abs(fock((n_MO+9),(n_MOmax/2+4+n_MO)))**2 &
,w_A(8+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+4+n_MO)))**2
Write(15,FM3)'A+7 B+3 ',abs(S_AB(lumoA+7,lumoB+3)),abs(fock((n_MO+9),(n_MOmax/2+5+n_MO)))**2 &
,w_A(8+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+5+n_MO)))**2
Write(15,FM3)'A+7 B+4 ',abs(S_AB(lumoA+7,lumoB+4)),abs(fock((n_MO+9),(n_MOmax/2+6+n_MO)))**2 &
,w_A(8+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+6+n_MO)))**2
Write(15,FM3)'A+7 B+5 ',abs(S_AB(lumoA+7,lumoB+5)),abs(fock((n_MO+9),(n_MOmax/2+7+n_MO)))**2 &
,w_A(8+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+7+n_MO)))**2
Write(15,FM3)'A+7 B+6 ',abs(S_AB(lumoA+7,lumoB+6)),abs(fock((n_MO+9),(n_MOmax/2+8+n_MO)))**2 &
,w_A(8+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+8+n_MO)))**2
Write(15,FM3)'A+7 B+7 ',abs(S_AB(lumoA+7,lumoB+7)),abs(fock((n_MO+9),(n_MOmax/2+9+n_MO)))**2 &
,w_A(8+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+9+n_MO)))**2
Write(15,FM3)'A+7 B+8 ',abs(S_AB(lumoA+7,lumoB+8)),abs(fock((n_MO+9),(n_MOmax/2+10+n_MO)))**2&
,w_A(8+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+10+n_MO)))**2
Write(15,FM3)'A+7 B+9 ',abs(S_AB(lumoA+7,lumoB+9)),abs(fock((n_MO+9),(n_MOmax/2+11+n_MO)))**2&
,w_A(8+n_MOmax/4)*abs(fock((n_MO+9),(n_MOmax/2+11+n_MO)))**2
                                                                                
Write(15,FM3)'A+8 B+0 ',abs(S_AB(lumoA+8,lumoB))  ,abs(fock((n_MO+10),(n_MOmax/2+2+n_MO)))**2&
,w_A(9+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+2+n_MO)))**2
Write(15,FM3)'A+8 B+1 ',abs(S_AB(lumoA+8,lumoB+1)),abs(fock((n_MO+10),(n_MOmax/2+3+n_MO)))**2&
,w_A(9+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+3+n_MO)))**2
Write(15,FM3)'A+8 B+2 ',abs(S_AB(lumoA+8,lumoB+2)),abs(fock((n_MO+10),(n_MOmax/2+4+n_MO)))**2&
,w_A(9+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+4+n_MO)))**2
Write(15,FM3)'A+8 B+3 ',abs(S_AB(lumoA+8,lumoB+3)),abs(fock((n_MO+10),(n_MOmax/2+5+n_MO)))**2&
,w_A(9+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+5+n_MO)))**2
Write(15,FM3)'A+8 B+4 ',abs(S_AB(lumoA+8,lumoB+4)),abs(fock((n_MO+10),(n_MOmax/2+6+n_MO)))**2&
,w_A(9+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+6+n_MO)))**2
Write(15,FM3)'A+8 B+5 ',abs(S_AB(lumoA+8,lumoB+5)),abs(fock((n_MO+10),(n_MOmax/2+7+n_MO)))**2&
,w_A(9+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+7+n_MO)))**2
Write(15,FM3)'A+8 B+6 ',abs(S_AB(lumoA+8,lumoB+6)),abs(fock((n_MO+10),(n_MOmax/2+8+n_MO)))**2&
,w_A(9+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+8+n_MO)))**2
Write(15,FM3)'A+8 B+7 ',abs(S_AB(lumoA+8,lumoB+7)),abs(fock((n_MO+10),(n_MOmax/2+9+n_MO)))**2&
,w_A(9+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+9+n_MO)))**2
Write(15,FM3)'A+8 B+8 ',abs(S_AB(lumoA+8,lumoB+8)),abs(fock((n_MO+10),(n_MOmax/2+10+n_MO)))**2&
,w_A(9+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+10+n_MO)))**2
Write(15,FM3)'A+8 B+9 ',abs(S_AB(lumoA+8,lumoB+9)),abs(fock((n_MO+10),(n_MOmax/2+11+n_MO)))**2&
,w_A(9+n_MOmax/4)*abs(fock((n_MO+10),(n_MOmax/2+11+n_MO)))**2

Write(15,FM3)'A+9 B+0 ',abs(S_AB(lumoA+9,lumoB))  ,abs(fock((n_MO+11),(n_MOmax/2+2+n_MO)))**2&
,w_A(10+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+2+n_MO)))**2
Write(15,FM3)'A+9 B+1 ',abs(S_AB(lumoA+9,lumoB+1)),abs(fock((n_MO+11),(n_MOmax/2+3+n_MO)))**2&
,w_A(10+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+3+n_MO)))**2
Write(15,FM3)'A+9 B+2 ',abs(S_AB(lumoA+9,lumoB+2)),abs(fock((n_MO+11),(n_MOmax/2+4+n_MO)))**2&
,w_A(10+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+4+n_MO)))**2
Write(15,FM3)'A+9 B+3 ',abs(S_AB(lumoA+9,lumoB+3)),abs(fock((n_MO+11),(n_MOmax/2+5+n_MO)))**2&
,w_A(10+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+5+n_MO)))**2
Write(15,FM3)'A+9 B+4 ',abs(S_AB(lumoA+9,lumoB+4)),abs(fock((n_MO+11),(n_MOmax/2+6+n_MO)))**2&
,w_A(10+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+6+n_MO)))**2
Write(15,FM3)'A+9 B+5 ',abs(S_AB(lumoA+9,lumoB+5)),abs(fock((n_MO+11),(n_MOmax/2+7+n_MO)))**2&
,w_A(10+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+7+n_MO)))**2
Write(15,FM3)'A+9 B+6 ',abs(S_AB(lumoA+9,lumoB+6)),abs(fock((n_MO+11),(n_MOmax/2+8+n_MO)))**2&
,w_A(10+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+8+n_MO)))**2
Write(15,FM3)'A+9 B+7 ',abs(S_AB(lumoA+9,lumoB+7)),abs(fock((n_MO+11),(n_MOmax/2+9+n_MO)))**2&
,w_A(10+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+9+n_MO)))**2
Write(15,FM3)'A+9 B+8 ',abs(S_AB(lumoA+9,lumoB+8)),abs(fock((n_MO+11),(n_MOmax/2+10+n_MO)))**2&
,w_A(10+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+10+n_MO)))**2
Write(15,FM3)'A+9 B+9 ',abs(S_AB(lumoA+9,lumoB+9)),abs(fock((n_MO+11),(n_MOmax/2+11+n_MO)))**2&
,w_A(10+n_MOmax/4)*abs(fock((n_MO+11),(n_MOmax/2+11+n_MO)))**2
                  


END IF ! n_MO > 9 Drucken der Daten in Datei 15





DEALLOCATE(w_A)
DEALLOCATE(w_B)
!i_max=0
!i_max=0
!j_max=0
!S_AB_max=0.0
!Do i=(homoA-1),(lumoA+1),1
!	Do j=(homoB-1),(lumoB+1),1		
!		if(abs(S_AB(i,j)) > S_AB_max ) then
!			S_AB_max=abs(S_AB(i,j))		
!			i_max=i
!			j_max=j
!		end if
!	End Do
!End Do





CLOSE(15)
CLOSE(14)
CLOSE(11)
Deallocate(energy)	
Deallocate(overlap)
Deallocate(gamma_A)
Deallocate(gamma_B)
Deallocate(J_AB)
Deallocate(S_AB)
Deallocate(e_A)
Deallocate(e_B)
Deallocate(fock)
Deallocate(transmat)
Deallocate(eigval)
Deallocate(work)
Deallocate(S_diag)

DEAllocate(E_Orbitale_A)
DEAllocate(E_Orbitale_B)

write(*,*) "Durchlauf Nr. ",p,"ist beendet"
end do

CLOSE(23)

OPEN(UNIT=25,FILE=TRIM(JAB_filename),STATUS='unknown', access = 'append')
write(25,'(A2,4ES16.6,A40)') "  ",S_AB_HOMO_A_to_HOMO_B,HOMO_A_to_HOMO_B,  S_AB_LUMO_A_to_LUMO_B , LUMO_A_to_LUMO_B, "  "
CLOSE(25)

write(*,*) '!!============!!'
write(*,*) '!! DIPRO Done !!'
write(*,*) '!!============!!'

END SUBROUTINE DImer_PROjection


end module DIPRO_nMO
!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!!   END  DImer  PROjection  Method  (DIPRO)                                                                           !!!
!!! ------------------------------------------------------------------------------------------------------------------- !!!





!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!! START module Molecule_class                                                                                         !!!  
!!! ------------------------------------------------------------------------------------------------------------------- !!!
module Molecule_class
	type subhoppingsite_t
		integer           ::id
		real, dimension(3)::koord
	end type subhoppingsite_t

	type hoppingsite_t
		real, dimension(3)                    :: COM
		integer				                  :: N_subhoppingsites
		type (subhoppingsite_t), allocatable  :: subhoppingsite(:)
		logical:: hasCOM=.false.
		logical:: hasSubhoppingsite=.false.
	end type hoppingsite_t

	type Molecule_t	
		!! counts all the molecules in the system
		integer :: molid 
		!! resid in gro format
		integer :: resid
		!! number of atoms in the molecule
		integer :: NAtoms
		character(len=5)   :: residuename
		character(len=500) :: molname
		!! koordinates (1:NAtoms,1:3)
		real, 	  allocatable, dimension(:,:)             :: koordinates
		!! elementnames (1:NAtoms) in the molecule
		character(len=5), allocatable, dimension(:)       :: elementnames	
		!! center of mass of the molecule
		real, dimension(3)   :: COM
		logical::hasCOM=.false.
		type(hoppingsite_t)  :: hoppingsite 
		logical              :: hasHoppingsite=.false.
	end type Molecule_t

	type COM_t
		REAL, DIMENSION(3) :: COM
		REAL :: COM_x,COM_y,COM_z
		logical::hasCOM=.false.
	end type COM_t

	type atom_t
		REAL, DIMENSION(3)   :: koordinaten
		CHARACTER(Len=5)     :: elementname
		REAL:: mass
	end type

	type hoppingpair_t
		integer::pairid
		integer::molAid
		integer::molBid
		integer::residA,residB
		real, dimension(3) :: COM_A
		real, dimension(3) :: COM_B
		!! minimal appearing distance
		real MA
		!! mean minimal appearing distance
		real MMA
		!! ring center of mass distance
		real RCOM
		real, dimension(3) ::dist_vec
		real::norm_dist_vec
		logical ::has_dist_vec=.false.
		real::S_AB_h,S_AB_e
		real::J_AB_h,J_AB_e
		real::rateAB_h,rateAB_e,rateBA_h,rateBA_e
		real::l_in_h,l_in_e
		real::E_in_h,E_in_e
		real::l_out_h,l_out_e
		real::E_out_h,E_out_e
		real::l_out_h_32mer,l_out_e_32mer
		real::E_out_h_32mer,E_out_e_32mer		
		!! intramolecular angle
		real::theta_intra
		character(len=10)::seq	
		logical::has_rates_h=.false.,has_rates_e=.false.,has_intramolecular=.false.

		!! current calculation
		logical::has_current_h=.false.,has_current_e=.false.
		real, dimension(3) ::J_h,J_e
		logical::path_used_h=.false.,path_used_e=.false.
	end type hoppingpair_t

	type system_t
		type (Molecule_t),     allocatable :: molecules(:)
		type (hoppingpair_t),  allocatable :: hoppingpairs(:)
		integer::N_Resids,N_molecules,N_hopping_pairs
		integer::N_atoms_all
		integer::N_DIPBI,N_PPDI,N_P3HT,N_PBDT_TS1,N_Species
	end type system_t



	contains
	
!!!!!!!!!!!!!!!! SYSTEM START
	subroutine init_system(system)
		type (system_t) :: system  
		!type (Molecule_t), allocatable    :: molecules(:)
		!type (hoppingpair_t), allocatable :: hoppingpairs(:)

		system%N_Resids=0
		system%N_molecules=0
		system%N_atoms_all=0
		system%N_DIPBI=0
		system%N_PPDI=0
		system%N_P3HT=0
		system%N_PBDT_TS1=0
		system%N_Species=0
		system%N_hopping_pairs=0
		
	end subroutine init_system


	subroutine make_new_molecule_for_system(system,residA,NAtomsA,resnameA,molnameA,koordA,elementsA)
		implicit none
		type (system_t)   		 :: system 
		!type (Molecule_t), allocatable  :: molecules(:)
		type (Molecule_t) 		 :: newmolecule
		!! newmolecule with data for molecule A
		integer 			      , intent(in) :: residA,NAtomsA
		character(LEN=*)                      , intent(in) :: resnameA,molnameA
		character(Len=5), dimension(NAtomsA)  , intent(in) :: elementsA
		real, dimension(NAtomsA,3) 	          , intent(in) :: koordA
		integer::molidA
		!!call null_Molecule(newmolecule)
		
		!! increase molid in system
		IF(.not. system_has_molecules(system)) THEN
				molidA=1	
		ELSE	
				molidA=system%N_molecules+1
		END IF
				
		!! initialize newmolecule with data for molecule A
		call init_Molecule(newmolecule,molidA,residA,NAtomsA,resnameA,molnameA,koordA,elementsA)		

		!!! increase number of molecules
		IF( INDEX(resnameA,'DIPBI') /= 0) THEN
			system%N_DIPBI=system%N_DIPBI+1
		ELSE IF( INDEX(resnameA,'PPDI') /= 0) THEN
			system%N_PPDI=system%N_PPDI+1
		ELSE IF( (INDEX(resnameA,'P3') /= 0) .OR. (INDEX(resnameA,'PH') /= 0) .OR. (INDEX(resnameA,'THP') /= 0)) THEN
			system%N_P3HT=system%N_P3HT+1	
		ELSE IF ( (INDEX(resnameA,'8poly') /= 0) .OR. (INDEX(resnameA(1:1),'A') /= 0) &
							&.OR. (INDEX(resnameA(1:1),'B') /= 0) )THEN
			system%N_PBDT_TS1=system%N_PBDT_TS1+1
		ELSE 
			!!! other species, not defined yet / default
			system%N_Species=system%N_Species+1
		ENDIF
		!! general counter
		system%N_Resids=system%N_Resids+1
		system%N_molecules=system%N_molecules+1

		IF(.not. system_has_molecules(system)) THEN
			allocate(system%molecules(1))
			system%molecules(1)=newmolecule
		ELSE
			call append_molecule_to_list(system%molecules,newmolecule)
		ENDIF
			
	end subroutine make_new_molecule_for_system	


	subroutine append_molecule_to_list(moleculelist,newmolecule)
		!! appends the newmolecule to the list of molecules in moleculelist
		implicit none
		type (Molecule_t), intent(in)  ::newmolecule
		type (Molecule_t), ALLOCATABLE, INTENT(INOUT) :: moleculelist(:)
		type (Molecule_t), ALLOCATABLE :: new_moleculelist(:) 
		!! number of molecules
		integer::n

		n=size(moleculelist)
		allocate(new_moleculelist(n+1))

		new_moleculelist(1:n)=moleculelist(1:n)
		new_moleculelist(n+1) = newmolecule

		deallocate(moleculelist)
		allocate(moleculelist(n+1))
		!! transfer molecule
		moleculelist(:) = new_moleculelist(:)

		deallocate(new_moleculelist)
 	end subroutine append_molecule_to_list


	subroutine append_pair_to_hoppingpairlist(hoppingpairlist,new_hoppingpair)
		!! appends the new_hoppingpair to the list of molecules in hoppingpairlist
		implicit none
		type (hoppingpair_t), intent(in)                 :: new_hoppingpair
		type (hoppingpair_t), ALLOCATABLE, INTENT(INOUT) :: hoppingpairlist(:)
		type (hoppingpair_t), ALLOCATABLE                :: new_hoppingpairlist(:) 
		!! number of pairs
		integer::n
		n=size(hoppingpairlist)
		allocate(new_hoppingpairlist(n+1))
		new_hoppingpairlist(1:n)=hoppingpairlist(1:n)
		new_hoppingpairlist(n+1) = new_hoppingpair

		deallocate(hoppingpairlist)
		allocate(hoppingpairlist(n+1))
		!! transfer molecule
		hoppingpairlist(:) = new_hoppingpairlist(:)

		deallocate(new_hoppingpairlist)
 	end subroutine append_pair_to_hoppingpairlist



	!!! prints the coordinates of a molecule "this" in xyz format on the screen, e.g. for debugging
	subroutine print_molecule_xyz(this)
			implicit none
			type (Molecule_t), intent(in)::this
			integer::i
			!Character(len=*), PARAMETER::form2='(2X,A15,1X,A2,1X,3F16.6,1X,A2)'
			WRITE(*,*) this%NAtoms
			WRITE(*,*)
			do i=1,this%NAtoms
				write(*,*) this%elementnames(i),this%koordinates(i,1),this%koordinates(i,2),this%koordinates(i,3)
			end do
 	end subroutine print_molecule_xyz


   	!! Return .true. if the system has a molecules.
   	pure function system_has_molecules( this ) result( hasmolecules )
	      	!! Input: molecule 
	      	type(system_t), intent(in) :: this
	      	!! Output: whether the molecule has molecules
	      	logical                      :: hasmolecules
	      	!!
	      	hasmolecules = Allocated( this%molecules )
   	end function system_has_molecules


   	!! Return .true. if the system has a hoppingpair.
   	pure function system_has_hoppingpairs( this ) result( hashoppingpairs )
	      	!! Input: molecule 
	      	type(system_t), intent(in)   :: this
	      	!! Output: whether the molecule has hoppingpairs
	      	logical                      :: hashoppingpairs
	      	!!
	      	hashoppingpairs = Allocated( this%hoppingpairs )
   	end function system_has_hoppingpairs


!!!!!!!!!!!!!!!! SYSTEM END


!!!!!!!!!!!!!!!!! hopping_pair START
	subroutine init_hoppingpair_in_system(this,system)
		implicit none
		type(hoppingpair_t), intent(out) :: this
		type(system_t), intent(inout) :: system
		!integer::pairid
		!integer::molAid
		!integer::molBid
		!integer::residA,residB
		!real, dimension(3) ::dist_vec
		!real::norm_dist_vec
		!logical ::has_dist_vec=.false.
		!real::S_AB_h,S_AB_e
		!real::J_AB_h,J_AB_e
		!real::rateAB_h,rateAB_e,rateBA_h,rateBA_e
		!real::l_out_h,l_out_e
		!real::E_out_h,E_out_e
		!real::l_out_h_32mer,l_out_e_32mer
		!real::E_out_h_32mer,E_out_e_32mer	
		!real::theta_intra
		!character(len=10)::seq	
		!logical::has_rates_h=.false.,has_rates_e=.false.,has_intramolecular=.false.
		
		this%pairid=system%N_hopping_pairs+1
		system%N_hopping_pairs=system%N_hopping_pairs+1
		
		this%molAid=0
		this%molBid=0
		this%residA=0
		this%residB=0
		this%COM_A=(/0.0,0.0,0.0/)
		this%COM_B=(/0.0,0.0,0.0/)
		this%MA=0
		this%MMA=0
		this%RCOM=0
		this%dist_vec=(/0.0,0.0,0.0/)
		this%norm_dist_vec=0.0
		this%has_dist_vec=.false.
		this%S_AB_h=0.0
		this%S_AB_e=0.0
		this%J_AB_h=0.0
		this%J_AB_e=0.0
		this%rateAB_h=0.0
		this%rateAB_e=0.0
		this%rateBA_h=0.0
		this%rateBA_e=0.0
		this%l_in_h=0.0
		this%l_in_e=0.0
		this%E_in_h=0.0
		this%E_in_e=0.0
		this%l_out_h=0.0
		this%l_out_e=0.0
		this%E_out_h=0.0
		this%E_out_e=0.0
		this%l_out_h_32mer=0.0
		this%l_out_e_32mer=0.0
		this%E_out_h_32mer=0.0
		this%E_out_e_32mer=0.0		
		this%has_rates_h=.false.
		this%has_rates_e=.false.
		this%has_intramolecular=.false.
		this%theta_intra=0.0
		this%seq=''
	end subroutine init_hoppingpair_in_system






	subroutine append_hoppingpair_to_hoppingpairlist(hoppingpairlist,new_hoppingpair)
		!! appends the new_hoppingpair to the list of molecules in hoppingpairlist
		implicit none
		type (hoppingpair_t), intent(in)                 :: new_hoppingpair
		type (hoppingpair_t), ALLOCATABLE, INTENT(INOUT) :: hoppingpairlist(:)
		type (hoppingpair_t), ALLOCATABLE                :: new_hoppingpairlist(:) 
		!! number of pairs
		integer::n
	
		n=size(hoppingpairlist)
		allocate(new_hoppingpairlist(n+1))

		new_hoppingpairlist(1:n)=hoppingpairlist(1:n)

		new_hoppingpairlist(n+1) = new_hoppingpair

		deallocate(hoppingpairlist)
		allocate(hoppingpairlist(n+1))
		!! transfer molecule
		hoppingpairlist(:) = new_hoppingpairlist(:)

		deallocate(new_hoppingpairlist)
 	end subroutine append_hoppingpair_to_hoppingpairlist


!!!!!!!!!!!!!!!!! hopping_pair END



!!!!!!!!!!!!!! SUBHOPPINGSITE START
	subroutine make_new_subhoppingsite_for_hoppingsite(hoppingsite,koordA)
		implicit none
		type (hoppingsite_t) ,  intent(inout) ::hoppingsite				
		real, dimension(3),     intent(in)    ::koordA
		type (subhoppingsite_t)  	          ::newsubhoppingsite
		integer::id

		id=hoppingsite%N_subhoppingsites+1
		call set_subhoppingsite(newsubhoppingsite,id,koordA(1),koordA(2),koordA(3))
		
		IF(.not. Hoppingsite_has_SubHoppingsite(hoppingsite))THEN
			allocate(hoppingsite%subhoppingsite(1))
			hoppingsite%subhoppingsite(1)=newsubhoppingsite
		ELSE
			call append_subhoppingsite_to_hoppingsitelist(hoppingsite%subhoppingsite,newsubhoppingsite)
		END IF

		IF(hoppingsite%N_subhoppingsites .ge. 1) THEN
			hoppingsite%hasSubhoppingsite=.true.
		END IF
		hoppingsite%N_subhoppingsites=hoppingsite%N_subhoppingsites+1
	end subroutine make_new_subhoppingsite_for_hoppingsite


	subroutine append_subhoppingsite_to_hoppingsitelist(hoppingsitelist,newsubhoppingsite)
		!! appends the newhoppingsite to the list of hoppingsites in molecule
		implicit none
		type (subhoppingsite_t), intent(in)::newsubhoppingsite
		type (subhoppingsite_t), allocatable, intent(inout) :: hoppingsitelist(:)
		type (subhoppingsite_t), allocatable :: new_hoppingsitelist(:) 
		integer::nsys

		nsys=size(hoppingsitelist)
		allocate(new_hoppingsitelist(nsys+1))

		new_hoppingsitelist(1:nsys)=hoppingsitelist(1:nsys)

		new_hoppingsitelist(nsys+1) = newsubhoppingsite

		deallocate(hoppingsitelist)
		allocate(hoppingsitelist(nsys+1))
		!! transfer newsubhoppingsite
		hoppingsitelist(:) = new_hoppingsitelist(:)

		deallocate(new_hoppingsitelist)
 	end subroutine append_subhoppingsite_to_hoppingsitelist


	subroutine set_subhoppingsite(this,id,koordx,koordy,koordz)
		type(subhoppingsite_t), intent(inout)   :: this
		integer 	            :: id
		real, intent(in)        ::koordx,koordy,koordz
		this%id=id
		this%koord(1)=koordx
		this%koord(2)=koordy
		this%koord(3)=koordz
	end subroutine set_subhoppingsite


   	!! Return .true. if the Hoppingsite has a SubHoppingsite.
   	pure function Hoppingsite_has_SubHoppingsite( this ) result( hasSubHoppingsite )
	      	!! Input: Hoppingsite 
	      	type(Hoppingsite_t), intent(in) :: this
	      	!! Output: whether the molecule has a gradient
	      	logical                      :: hasSubHoppingsite
	      	!!
	      	hasSubHoppingsite = Allocated( this%subhoppingsite )
   	end function Hoppingsite_has_SubHoppingsite

	subroutine set_COM_in_Hoppingsite(this,COMx,COMy,COMz)
		IMPLICIT NONE
		type(hoppingsite_t), intent(inout) :: this
		REAL::COMx,COMy,COMz
		this%COM(1)=COMx
		this%COM(2)=COMy
		this%COM(3)=COMz
		this%hasCOM=.true.
	end subroutine set_COM_in_Hoppingsite
!!!!!!!!!!!!!! SUBHOPPINGSITE END	


!!!!!!!!!!! ATOM START 
	subroutine null_atom(this)
		IMPLICIT NONE
		type (atom_t), intent (out) :: this
		this%elementname=' '
		this%koordinaten=(/ 0.0, 0.0, 0.0 /)
		this%mass=0.0
	end subroutine null_atom

	subroutine init_atom(this,elementname,koordx,koordy,koordz)
		IMPLICIT NONE
		type (atom_t), intent (out) :: this
		CHARACTER(Len=*)          :: elementname
		REAL, INTENT(IN)::koordx,koordy,koordz
		
		this%elementname=TRIM(elementname)
		this%koordinaten=(/ koordx, koordy, koordz/)
		this%mass=0.0
	end subroutine 

!!!!!!!!!!! ATOM END


!!!!!!!!!  MOLECULE START

   	!! Return .true. if the molecule has a koordinates.
   	pure function Mol_has_koordinates( this ) result( haskoordinates )
	      	!! Input: molecule 
	      	type(Molecule_t), intent(in) :: this
	      	!! Output: whether the molecule has a gradient
	      	logical                      :: haskoordinates
	      	!!
	      	haskoordinates = Allocated( this%koordinates )
   	end function Mol_has_koordinates

   	!! Return .true. if the molecule has a elementnames.
   	pure function Mol_has_elementnames( this ) result( haselementnames )
	      	!! Input: molecule 
	      	type(Molecule_t), intent(in) :: this
	      	!! Output: whether the molecule has a gradient
	      	logical                      :: haselementnames
	      	!!
	      	haselementnames = Allocated( this%elementnames )
   	end function Mol_has_elementnames


	subroutine init_Molecule(this,molidA,residA,NAtomsA,resnameA,molnameA,koordA,elementsA)
		IMPLICIT NONE
		! Constructor
		type (Molecule_t), intent (out) :: this
		integer, intent (in) :: molidA,residA,NAtomsA
		character(LEN=*)                      , intent(in) :: resnameA,molnameA
		character(Len=5), dimension(NAtomsA)  , intent(in) :: elementsA
		real, dimension(NAtomsA,3) 	      , intent(in) :: koordA
		integer::i
			this%molid  = molidA
			this%resid  = residA
			this%NAtoms = NAtomsA
			this%residuename=TRIM(resnameA)
			this%molname=TRIM(molnameA)
			allocate(this%koordinates(this%NAtoms,3))
			this%koordinates=0
			allocate(this%elementnames(this%NAtoms))
			this%elementnames=' '
			DO i=1,this%NAtoms
				this%koordinates(i,1:3)=koordA(i,1:3)
				this%elementnames(i)=elementsA(i)
			END DO
			this%COM=(/ 0.0, 0.0, 0.0 /)
			this%hasHoppingsite=.false.
			!! initialize hoppingsite
			this%hoppingsite%COM=(/ 0.0, 0.0, 0.0 /)
			this%hoppingsite%N_subhoppingsites=0
			this%hoppingsite%hasSubhoppingsite=.false.
	end subroutine init_Molecule


	function get_resid_Molecule(this) result(resid)
		IMPLICIT NONE
		type (Molecule_t), intent (in) :: this
		integer :: resid
		resid = this%resid
	end function get_resid_Molecule

	function get_NAtoms_Molecule(this) result(NAtoms)
		IMPLICIT NONE
		type (Molecule_t), intent (in) :: this
		integer :: NAtoms
		NAtoms = this%NAtoms
	end function get_NAtoms_Molecule


	subroutine set_COM_in_Molecule(this,COMx,COMy,COMz)
		IMPLICIT NONE
		type(Molecule_t), intent(inout) :: this
		REAL::COMx,COMy,COMz
		this%COM(1)=COMx
		this%COM(2)=COMy
		this%COM(3)=COMz
		this%hasCOM=.true.
	end subroutine set_COM_in_Molecule

	subroutine set_COM(this,COMx,COMy,COMz)
		IMPLICIT NONE
		type(COM_t), intent(inout) :: this
		REAL::COMx,COMy,COMz
		this%COM_x=COMx
		this%COM_y=COMy
		this%COM_z=COMz
		this%hasCOM=.true.
	end subroutine set_COM
	
	subroutine print_Molecule(this,printresid)
		IMPLICIT NONE
		type (Molecule_t), intent (in) :: this
		logical, optional, intent (in) :: printresid
		if (present(printresid)) then
			if (printresid) write (*,'(i2,a2)',advance='no') this%resid,': '

		endif
		WRITE(*,*)  this%resid,TRIM(this%molname)
	end subroutine print_Molecule

	subroutine strcpy(s,c)
		IMPLICIT NONE
		character, dimension (:), intent (out) :: s
		character*(*), intent (in) :: c
		integer::i
		do i = 1, max(size(s),len(c))
			s(i) = c(i:i)
		enddo
	end subroutine strcpy

end module Molecule_class
!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!! END   module Molecule_class                                                                                         !!!
!!! ------------------------------------------------------------------------------------------------------------------- !!!





!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!!      START  module gro_to_votca                              
!!!      START  enumerated_gro_to_VOTCA__DIPBI_P3HT_prepare     
!!! ------------------------------------------------------------------------------------------------------------------- !!!
!! PROGRAM to Setup the inputfiles for a votca KMC simulation on DIPBI/P3HT blend
!! Reads gro file, which should be preprocessed to contain the information about the divition of the polymer chain into sites, via adapted resids.
!! Reads Data for the parametization of segments from a lambda_in_all_inputfile. (FORMAT differs!)
!! Adds H atoms to the molecules from an FF to QM representation.
!! Partitioning in DIPBI_K (with chain) P3HT/P3MT with a START segment S, middle M, or terminal segment E. 
!! (eg. Converntion PH06S labels a Polythiophine with 6 units at the chain start. PM01M is a P3MT with a single ring in the middle of a chain.)
!! creates a VOTCA mapping file
!! creates a VOTCA fake_topology file
!! molpol_optionsfiles
!! Can shift the resid index form 0 to 1 to suite VOTCA convention.
!! creates a new gro_outputfile with the new nomenklature
!!
!!
!! molpol:
!! WARNING:     order in polarizability tensor in g09 / votca does not match
!! g09:            xx xy yy xz yz zz
!! Votca/gdma:     xx xy xz yy yz zz
module gro_to_votca 

CONTAINS

 
SUBROUTINE enumerated_gro_to_VOTCA__DIPBI_P3HT_prepare()
	use small_functions
	use Molecule_class
	use KMC_class
	!! System from the Molecule_class
	type (system_t)    :: system
	!! options setup filename 
	type (KMC_setup_t) :: setup
!! Einlesen aus der gro_inputfile.gro Datei und Verschieben der Resid um I_shift in gro_outputfile.gro 
Character(5), ALLOCATABLE, Dimension(:)    :: atomsorteA,residue_names,residue_name_list
Real, ALLOCATABLE, DIMENSION(:,:)          :: koordA,vel
!! reorganization energy
Real*8, ALLOCATABLE, DIMENSION(:,:)        ::lambda_array,lambda_array_all
!! Resid und Index , Resid und anzahl der Schwefelatome
INTEGER, ALLOCATABLE, DIMENSION(:,:)     :: R_u_I,R_u_S 
INTEGER, ALLOCATABLE, DIMENSION(:)       :: residue_numbers,residue_numbersH,atom_numbers,atom_numbersH,iHOMO_list
CHARACTER(5000)             :: gro_inputfile,gro_outputfile,top_all_outputfile,map_filename,neighbourlist_constrains_filename
CHARACTER(5000)             :: lambda_in_all_inputfile,votca_xml_options_filename,mps_tab_filename,votca_sql_name
CHARACTER(5000)             :: MP_FILES_folder,QC_FILES_folder
INTEGER ::N_Resids,Gesamtanzahl
REAL    ::x_box,y_box,z_box
CHARACTER(500) ::dummyname
CHARACTER(10000)::method,line
CHARACTER(10000)::bashline
CHARACTER(5) :: residue_name,lio
INTEGER::i,j,k,k_ind,ierror,residue_number,residue_number_old,start_index,end_index,N_seg_types_all
!REAL::x,y,z,v_x,v_y,v_z
INTEGER::I_shift
LOGICAL::DIPBI_P3HT_calc,DIPBI_P3MT_calc
LOGICAL::Datei_vorhanden,DEBUG=.false.,modify_mol_h_atoms,KETTE,print_coordH_to_xyz,nm_to_Ang,use_I_shift=.false.
LOGICAL::create_mapping_file=.false.,create_fake_topology=.false.,orbs_ZINDO,create_votca_boxfile,read_lambda_files=.false.
LOGICAL::create_jobwriter_single_sites_file=.false.,create_jobwriter_pairs_pewald3d_file=.false.
LOGICAL::add_virtual_H_atoms_to_gro=.false.,exclude_virtual_H_atoms=.false.
LOGICAL::create_molpol_options_files=.false.,create_gromp_mdp_file=.false.,create_mps_tab=.false.
LOGICAL::create_geo_orbs_mps_g09=.false.
LOGICAL::use_votca_global_file_folder=.false.
!!!! MODIFIY H ATOMS 
INTEGER ::ind1,GesamtanzahlH,GesamtanzahlH_precalc,Natoms1H,R_offset,i_offset ! index offset
REAL, ALLOCATABLE, DIMENSION(:,:) 	:: koordH,koord1H,velH
INTEGER, ALLOCATABLE, Dimension(:,:)    :: R_u_I_H ! Resid,Index_fuer_molekuelstart
CHARACTER(LEN=5), ALLOCATABLE, Dimension(:) :: atomsorteH,atomsorte1H,residue_namesH,elementsH
CHARACTER(LEN=500), ALLOCATABLE, Dimension(:) :: MolnameH
INTEGER::N_DIPBI,N_P3HT,N_P3HT_segments,N_Species,N_Schwefel,N_Chlor
INTEGER::i_start,i_ende,iHOMO,N_types_lambda
CHARACTER(LEN=5)::residue_namesH_dummy
CHARACTER(LEN=500) :: Molname,extra_files_modus
LOGICAL, ALLOCATABLE, DIMENSION (:) ::molecule_da
!!! Variables PPDI, PBDT-TS1
LOGICAL:: PPDI_PBDT_TS1_calc,PPDI_Propyl,mol_start_da,mol_ende_da
!! count the subunits
INTEGER::N_CarboxyS2,N_PBDT,N_PPDI,N_PBDT_TS1,N_PBDT_TS1_segments,N_molecules_acceptor

CHARACTER(LEN=1) :: segtype,fin
CHARACTER(LEN=2) :: segtype2
CHARACTER(LEN=50):: sequence 
CHARACTER(LEN=50), ALLOCATABLE, DIMENSION(:)::sequence_list
CHARACTER(LEN=5),ALLOCATABLE, DIMENSION(:)::residue_name_site
!!
INTEGER::trajstep,Numcharged,NCPUS,Mem
!! neighbourlist daten
INTEGER, ALLOCATABLE, Dimension(:,:) ::neighbour_list_Res
INTEGER                              ::N_Neighbours
Character(LEN=500) :: neighbourlist_filename, HOSTNAME
logical            :: use_min_d_COM_vector_list
logical            :: read_options_from_xml 
character(LEN=500) :: input_options_filename_xml
	!!! local array with minimum distance list
REAL, ALLOCATABLE, DIMENSION (:,:,:) :: min_d_COM_arr
CHARACTER(500)                       :: min_d_modus


!! SECTION WHERE THE USER CAN SELECT THE OPTIONS APPLIED IN THE SCRIPT
!! Modify for user
DEBUG=.false.
KETTE=.true.
PPDI_Propyl=.false.

!! System
DIPBI_P3HT_calc=.true.
DIPBI_P3MT_calc=.false.
PPDI_PBDT_TS1_calc=.false.


modify_mol_h_atoms=.true.
create_mapping_file=.true.
create_fake_topology=.true.
create_votca_boxfile=.true.
create_molpol_options_files=.false.
create_gromp_mdp_file=.true.
create_jobwriter_single_sites_file=.true.
create_jobwriter_pairs_pewald3d_file=.true.
create_mps_tab=.true.

print_coordH_to_xyz=.true.
nm_to_Ang=.true.
!! Use the HOMO and LUMO levels for ZINDO orbitals 
!! Adapt this, if other J_AB than VOTCA MOO/iZINDO method is used
orbs_ZINDO=.true.
read_lambda_files=.true.
!! Adds H atoms at the intrachain P3HT junctions between neighbouring segments, for the treatment of each segement as an entire molecule / site 
!! This is relevant for the concordance of the number of atoms in the QM files in *.mps files.
add_virtual_H_atoms_to_gro=.false.

!! exclude_virtual_H_atoms=.true.   sets virtual H atoms to 1 in <virtual_mps> section => Excludes H in Emultipole calculation
!! exclude_virtual_H_atoms=.false.  sets virtual H atoms to 0 in <virtual_mps> section => Includes H in Emultipole calculation
exclude_virtual_H_atoms=.true.


!! make_geo_orbs_mps_g09 
!! extra_files_modus = [false, all, make_g09_for_mps, make_ZINDO, make_xyz, make_folders]    applied in "make_geo_orbs_mps_g09"
!! make_g09_for_mps: creates g09 inputfiles for the geometries to evaluate with data for *.mps files 
!! make_ZINDO: creates g09 input files for the ZINDO calculations, which are needed for *.orbs
!! make_xyz: creates name1_n.xyz for the QC_FILE folder as needed for VOTCA calculations.
!! make_folders: creates folders QC_FILES and MP_FILES, if they are not present in the current directory.
create_geo_orbs_mps_g09=.true.
extra_files_modus="false"


!!! votca_statfile.sql filename: default: state.sql 
votca_sql_name='statefile13.sql' 

!!! mps.tab filename for background polarization.  default: mps_tab_filename='mps.tab'
mps_tab_filename='mps.tab'


!!! default: use_votca_global_file_folder=.false.
!!! default: MP_FILES_folder=MP_FILES
!!! default: QC_FILES_folder=QC_FILES
use_votca_global_file_folder=.false.


!! modus to select the calculated distance vector between two hopping sites
!! Select  min_d_modus = [COM, MA, MMA, RCOM] 
min_d_modus='COM'

!! Number of nearest neighbours in the neighbourlist file
N_Neighbours=12
!! use min distance calculator for the morphology
use_min_d_COM_vector_list=.false.

!!! initialize: 
read_options_from_xml = .false.
input_options_filename_xml = 'options.xml'

CALL HOSTNM(HOSTNAME)
write(*,*) 'Hostname: ',TRIM(HOSTNAME)
IF( TRIM(ADJUSTL(HOSTNAME)) == 'edoras' .AND. use_votca_global_file_folder) THEN
	MP_FILES_folder='MP_FILES'
	QC_FILES_folder='QC_FILES'
	!! crystal *.mps
	
	!!!! ln -s  /opt/files/t_koch08/votca_reference_data/dipbi_p3ht/crystall/QC_FILES_no_explicit_H_crystal   QC_FILES
	!QC_FILES_folder='/opt/files/t_koch08/votca_reference_data/dipbi_p3ht/crystall/QC_FILES_no_explicit_H_crystal'
	!MP_FILES_folder='/opt/files/t_koch08/votca_reference_data/dipbi_p3ht/crystall/MP_FILES_log2mps_CHelpG_PBE0_6-31Gs_rank0_PHxxA_crystal_no_explicit_H'
	
	!!!! amorph *.mps
	!MP_FILES_folder='/opt/files/t_koch08/votca_reference_data/dipbi_p3ht/MP_FILES'
	!QC_FILES_folder='/opt/files/t_koch08/votca_reference_data/dipbi_p3ht/QC_FILES'
ELSE IF( TRIM(ADJUSTL(HOSTNAME)) == 'r06m01' .AND. use_votca_global_file_folder) THEN
	!! crystal *.mps
	MP_FILES_folder='/home/t/t_koch08/votca_reference_data/dipbi_p3ht/crystall/'&
					&//'MP_FILES_log2mps_CHelpG_PBE0_6-31Gs_rank0_PHxxA_crystal_no_explicit_H'
	QC_FILES_folder='/home/t/t_koch08/votca_reference_data/dipbi_p3ht/crystall/QC_FILES_no_explicit_H_crystal'
	!! amorph *.mps
	!!!MP_FILES_folder='/home/t/t_koch08/votca_reference_data/dipbi_p3ht/MP_FILES_log2mps_CHelpG_PBE0_6-31Gs_PHxxA_crystal'
	!!!QC_FILES_folder='/home/t/t_koch08/votca_reference_data/dipbi_p3ht/QC_FILES'
ELSE
	MP_FILES_folder='MP_FILES'
	QC_FILES_folder='QC_FILES'
ENDIF






!!! ggf modifizieren Datei mit allen Daten in eV
!! Format Residue_name  OptS0_n_monomerA	R2=OptS0_el_monomerA	R3=OptS0_lo_monomerA	R7=SCF_el_OptS0_n_monomerA	R8=SCF_lo_OptS0_n_monomerA	R9=SCF_n_OptS0_el_monomerA	R10=SCF_n_OptS0_lo_monomerA
IF(DIPBI_P3HT_calc) THEN
	lambda_in_all_inputfile='./data/lambda_in_all_DIPBI_P3MT_B3LYP_6_311Gss_eV.dat'
	votca_xml_options_filename='./options_cpt_run_DIPBI_P3HT_inter_and_intra_h.xml'
	neighbourlist_filename='data/new_sorted_neighbours_equi_2000ps_500k_def2_theta_75_G0.ngh'
ELSE IF (PPDI_PBDT_TS1_calc) THEN
	lambda_in_all_inputfile='./data/lambda_in_all_PPDI_PBDT-TS1_B3LYP_6_31Gs_eV_V1.dat'
	votca_xml_options_filename='./options_cpt_run_PPDI_PBDT_TS1.xml'
	neighbourlist_filename='./sim_data_12N/new_sorted_neighbours_mischbox_900k_30ns-34ns_60deg_50NN.ngh'
END IF




!!! change the default setting
trajstep=0
Numcharged=0
NCPUS=72
Mem=64     !in GB



!!! Inicialisation
!!!  Shift
I_shift=0
use_I_shift=.false.
IF (command_argument_count() >= 4) THEN	                
        CALL get_command_argument(1,method)
        IF (TRIM(method) == 'gro_to_VOTCA') THEN
		CONTINUE 
	ELSE
		WRITE(*,*) 'USE: gro_to_VOTCA'
		CALL EXIT (1)
	END IF
        CALL get_command_argument(2,gro_inputfile)
        inquire(file=TRIM(gro_inputfile),exist=Datei_vorhanden) ! Abfrage ob gro-Datei vorhanden ist.
	IF (check_filetermination(gro_inputfile,'.gro')) THEN
        	IF( .NOT. Datei_vorhanden) THEN 
            		WRITE(*,*) ' Fehler: Die_gro_Datei_ist_nicht_vorhanden. '//TRIM(gro_inputfile)
            		WRITE(*,*) ' ENDE'
            		CALL EXIT (1)
        	END IF ! gro-file vorhanden  
	ELSE
		WRITE(*,*) 'Fehler: Datei_hat_keine_gro_Endung'//TRIM(gro_inputfile)
		CALL EXIT (1)
	END IF ! check if *.gro
        CALL get_command_argument(3,gro_outputfile)
        inquire(file=TRIM(gro_outputfile),exist=Datei_vorhanden) ! Abfrage ob gro-Datei vorhanden ist.
	IF (check_filetermination(gro_outputfile,'.gro')) THEN
        	IF(Datei_vorhanden) THEN 
            		WRITE(*,*) ' Fehler: Die_gro_Datei_is_bereits_vorhanden. '//TRIM(gro_outputfile)
			WRITE(*,*) ' Stellen_Sie_sicher_dass_diese_nicht_ueberschrieben_wird! '
            		WRITE(*,*) ' ENDE'
            		CALL EXIT (1)
        	END IF ! gro-file vorhanden  
	ELSE
		WRITE(*,*) 'Fehler: Datei_hat_keine_gro_Endung'//TRIM(gro_outputfile)
		CALL EXIT (1)
	END IF ! check if *.gro
	    CALL get_command_argument(4,dummyname)  
		READ(dummyname,'(I10)') I_shift       
		WRITE(*,*) TRIM(dummyname),' I_shift:',I_shift
 		IF( command_argument_count() .ge. 4) THEN
			use_I_shift=.true.
		ELSE
			use_I_shift=.false.
		END IF
		
		!!! read neighbourlist_filename  OR options.xml
		IF( command_argument_count() >= 5) THEN
			
			DO i=5,command_argument_count()
				CALL get_command_argument(i,dummyname)
				IF (check_filetermination_and_continue(dummyname,'.ngh')) THEN
						neighbourlist_filename=dummyname
						inquire(file=TRIM(neighbourlist_filename),exist=Datei_vorhanden) 
						IF(Datei_vorhanden) THEN 
								WRITE(*,*) ' Fehler: Die_Datei_ist_bereits_vorhanden. '//TRIM(neighbourlist_filename)
								WRITE(*,*) ' Stellen_Sie_sicher_dass_diese_nicht_ueberschrieben_wird! '
								WRITE(*,*) ' ENDE'
								CALL EXIT (1)
						ELSE 
								WRITE(*,*) 'use neighbourlist: ',TRIM(neighbourlist_filename)
						END IF ! neighbourlist_filename vorhanden  
				ELSE IF (check_filetermination_and_continue(dummyname,'.xml')) THEN
						input_options_filename_xml = dummyname
						read_options_from_xml =.true.
						inquire(file=TRIM(input_options_filename_xml),exist=Datei_vorhanden) 
						IF(.not. Datei_vorhanden) THEN 
								WRITE(*,*) 'Fehler: Die Datei existiert options.xml für die Input-Steuerung existiert nicht. '
								WRITE(*,*) 'Error the file is not available: ',TRIM(input_options_filename_xml)
								CALL EXIT (1)
						ELSE 
								WRITE(*,*) 'use input_optionsfile.xml:  ',TRIM(input_options_filename_xml)
						END IF 
				ELSE
					WRITE(*,*) 'Fehler: Datei_hat_keine_erwartete_Endung [neighbourlist.ngh, options.xml] '//TRIM(dummyname)
					CALL EXIT (1)
				END IF ! check if suitable files  *.ngh,*.xml	!check_filetermination
			ENDDO !
		END IF 
		
ELSE
	WRITE(*,*) ' mod_resid_index_gro um den index der Resids in der gro datei zu verschieben um I_shift. '
	WRITE(*,*) ' '
	WRITE(*,*) '      mod_resid_index_gro:        method     enumerated_inputfilename.gro    outputfilename.gro  I_shift   '&
	&//'    [ neighbourlist_filename.ngh ] ' 
	WRITE(*,*) ' Use: mod_resid_index_gro   gro_to_VOTCA                	  in.gro               out.gro         1        '&
	&//'    new_sorted_neighbourlist.ngh'
	CALL EXIT (0)
END IF




IF( read_options_from_xml .and. file_exists(input_options_filename_xml) ) THEN
			write(*,*) 'Start reading options from  input_options_filename_xml. '//TRIM(input_options_filename_xml)
			CALL set_defaults_KMC_setup(setup)
			CALL read_votca_optionsfile(input_options_filename_xml,setup,& 
				&" gro_to_votca enumerated_gro_to_VOTCA_DIPBI_P3HT_prepare grotovotca system")
			!! Defaults for enumerated_gro_to_VOTCA_DIPBI_P3HT_prepare
			DIPBI_P3HT_calc    = setup%DIPBI_P3HT_calc                                  
			DIPBI_P3MT_calc    = setup%DIPBI_P3MT_calc                                  
			PPDI_PBDT_TS1_calc = setup%PPDI_PBDT_TS1_calc                             
			KETTE = setup%KETTE   
			
			
			modify_mol_h_atoms   = setup%modify_mol_h_atoms                                        
			create_mapping_file  = setup%create_mapping_file                                                     
			create_fake_topology = setup%create_fake_topology                                                  
			create_votca_boxfile = setup%create_votca_boxfile                                                    
			create_molpol_options_files = setup%create_molpol_options_files                                        
			create_gromp_mdp_file = setup%create_gromp_mdp_file                                               
			create_jobwriter_single_sites_file = setup%create_jobwriter_single_sites_file                                
			create_jobwriter_pairs_pewald3d_file = setup%create_jobwriter_pairs_pewald3d_file                        
			create_mps_tab = setup%create_mps_tab                                                         
		
			print_coordH_to_xyz = setup%print_coordH_to_xyz                                                          
		
			!! Use the HOMO and LUMO levels for ZINDO orbitals  --                                                      
			!! Adapt this, if other J_AB than VOTCA MOO/iZINDO method is used  --                                                    
			orbs_ZINDO = setup%orbs_ZINDO                                                  
			read_lambda_files = setup%read_lambda_files                                               
			!! Adds H atoms at the intrachain P3HT junctions between neighbouring segments, for the treatment of each segement as an entire molecule / site   --                                                      
			!! This is relevant for the concordance of the number of atoms in the QM files in *.mps files.  --                                                      >
			add_virtual_H_atoms_to_gro = setup%add_virtual_H_atoms_to_gro                                              
		
			!! exclude_virtual_H_atoms=.true.   sets virtual H atoms to 1 in <virtual_mps> section => Excludes H in Emultipole calculation   --                                                      
			!! exclude_virtual_H_atoms=.false.  sets virtual H atoms to 0 in <virtual_mps> section => Includes H in Emultipole calculation    --                                                      
			exclude_virtual_H_atoms = setup%exclude_virtual_H_atoms                                 !!!!--	exclude_virtual_H_atoms=.true.   --                                                      
		
		
			!! make_geo_orbs_mps_g09 
			!! extra_files_modus = [false, all, make_g09_for_mps, make_ZINDO, make_xyz, make_folders]    applied in "make_geo_orbs_mps_g09"     --                                                      
			!! make_g09_for_mps: creates g09 inputfiles for the geometries to evaluate with data for *.mps files  --                                                      
			!! make_ZINDO: creates g09 input files for the ZINDO calculations, which are needed for *.orbs  --                                                      
			!! make_xyz: creates name1_n.xyz for the QC_FILE folder as needed for VOTCA calculations.  --                                                      
			!! make_folders: creates folders QC_FILES and MP_FILES
			create_geo_orbs_mps_g09 = setup%create_geo_orbs_mps_g09                                                    
			extra_files_modus = setup%extra_files_modus                            
			
			!! mps.tab filename for background polarization.  default: mps_tab_filename='mps.tab'  
			mps_tab_filename = setup%mps_tab_filename                                              
			
			!! default: use_votca_global_file_folder=.false.    
			!! default: MP_FILES_folder=MP_FILES    
			!! default: QC_FILES_folder=QC_FILES  
			MP_FILES_folder = setup%MP_FILES_folder
			QC_FILES_folder = setup%QC_FILES_folder
			use_votca_global_file_folder = setup%use_votca_global_file_folder
			
			min_d_modus = setup%min_d_modus
			!!! End Defaults for enumerated_gro_to_VOTCA_DIPBI_P3HT_prepare        
			!!! ---------------------------------------------------------------------------
ENDIF ! read_options_from_xml




WRITE(*,*) 'Use a RESID shift: ',I_shift


top_all_outputfile='fake_topology_'//TRIM(gro_inputfile(:LEN_TRIM(gro_inputfile)-4))//'.top'
inquire(file=TRIM(top_all_outputfile),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
IF(Datei_vorhanden) THEN 
            		WRITE(*,*) ' Fehler: Die_top_Datei_ist_bereits_vorhanden. '//TRIM(top_all_outputfile)
			WRITE(*,*) ' Stellen_Sie_sicher_dass_diese_nicht_ueberschrieben_wird! '
            		WRITE(*,*) ' ENDE'
            		CALL EXIT (1)
END IF ! top-file vorhanden  


map_filename='map_'//TRIM(gro_inputfile(:LEN_TRIM(gro_inputfile)-4))//'.xml'
inquire(file=TRIM(map_filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
IF(Datei_vorhanden) THEN 
            		WRITE(*,*) ' Fehler: Die_VOTCA_mapping_Datei_ist_bereits_vorhanden. '//TRIM(map_filename)
			WRITE(*,*) ' Stellen_Sie_sicher_dass_diese_nicht_ueberschrieben_wird! '
            		WRITE(*,*) ' ENDE'
            		CALL EXIT (1)
END IF ! map-file vorhanden  

neighbourlist_constrains_filename='neighbours_constrained_VOTCA__'//TRIM(gro_inputfile(:LEN_TRIM(gro_inputfile)-4))//'.xml'
inquire(file=TRIM(neighbourlist_constrains_filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
IF(Datei_vorhanden) THEN 
					WRITE(*,*) ' Fehler: Die_neighbourlist_constrains_file_ist_bereits_vorhanden. '&
						&//TRIM(neighbourlist_constrains_filename)
					WRITE(*,*) ' Stellen_Sie_sicher_dass_diese_nicht_ueberschrieben_wird! '
					WRITE(*,*) ' ENDE'
					CALL EXIT (1)
END IF ! neighbourlist_constrains_filename-file vorhanden  


votca_sql_name='state_'//TRIM(gro_inputfile(:LEN_TRIM(gro_inputfile)-4))//'.sql'
inquire(file=TRIM(votca_sql_name),exist=Datei_vorhanden) ! Abfrage ob sql-Datei vorhanden ist.
IF(Datei_vorhanden) THEN 
            		WRITE(*,*) ' Fehler: Die_votca_state.sql_Datei_ist_bereits_vorhanden. '&
						&//TRIM(votca_sql_name)
					WRITE(*,*) ' Stellen_Sie_sicher_dass_diese_nicht_ueberschrieben_wird! '
            		WRITE(*,*) ' ENDE'
            		CALL EXIT (1)
END IF ! votca_sql_name vorhanden  


IF(use_votca_global_file_folder) THEN
	inquire(file=TRIM(MP_FILES_folder),exist=Datei_vorhanden) 
	IF(.not. Datei_vorhanden) THEN
		MP_FILES_folder='MP_FILES'
	ELSE
		WRITE(*,*) 'Use: '//TRIM(MP_FILES_folder)
	END IF	 
	
	inquire(file=TRIM(QC_FILES_folder),exist=Datei_vorhanden) 
	IF(.not. Datei_vorhanden) THEN
		QC_FILES_folder='MP_FILES'
	ELSE
		WRITE(*,*) 'Use: '//TRIM(QC_FILES_folder)
	END IF	 
ELSE
	MP_FILES_folder='MP_FILES'
	QC_FILES_folder='QC_FILES'
END IF



IF(read_lambda_files) THEN
	WRITE(*,*) 'use: '//TRIM(lambda_in_all_inputfile)
END IF
WRITE(*,*) 'uses    gro: ',TRIM(gro_inputfile)
WRITE(*,*) 'creates gro: ',TRIM(gro_outputfile)
WRITE(*,*) 'creates topology: ',TRIM(top_all_outputfile)
WRITE(*,*) 'creates map: ',TRIM(map_filename)
WRITE(*,*) 'creates state: ',TRIM(votca_sql_name)


! Einlesen
OPEN(UNIT=17,FILE=TRIM(gro_inputfile),STATUS='OLD',IOSTAT=ierror)
Read(17,*) dummyname                             !Einlesen des Infokopfes im File
Read(17,*) Gesamtanzahl                          !Einlesen der Atomanzahl im File
    !!! Erstelle String lio=Durcheinander, um die Rechnungen mit Hilfe von Zufallszahlen einzigartig zu machen, sodass keine Interferenzen mit anderen Rechnungen ggf. im gleichen Ordner auftreten können. 
    lio=TRIM(make_lio())
    !! Einlesen der Anzahl der Resids=N_Mol aus gro-file
    Bashline="start_index=$(sed -n '3p' "//TRIM(gro_inputfile)//' | cut -c 1-5) ; end_index=$(tail -2 '//TRIM(gro_inputfile)//&
    &' | head -1 | cut -c 1-5) ; echo ${start_index}  ${end_index} >> s2e_'//TRIM(lio)//'.dat'  ! start 2 end 
    CALL execute_command_line(TRIM(Bashline)) 
    OPEN(UNIT=32,FILE='s2e_'//TRIM(lio)//'.dat',STATUS='unknown',IOSTAT=ierror,action='read')
    READ(32,*) start_index,end_index
    CLOSE(32)
    Bashline=' rm s2e_'//TRIM(lio)//'.dat '
    CALL execute_command_line(TRIM(Bashline)) 

    N_Resids=end_index-start_index+1
    WRITE(*,*)'  N_Resids= ',N_Resids,' in ',TRIM(gro_inputfile)
    WRITE(*,*)'  N_Atoms=  ',Gesamtanzahl,' in ',TRIM(gro_inputfile)
ALLOCATE(atomsorteA(Gesamtanzahl))
ALLOCATE(koordA(Gesamtanzahl,3))
ALLOCATE(vel(Gesamtanzahl,3))           ! velocities(:,v_x,v_y,v_z)
ALLOCATE(R_u_I(N_Resids+1,2)) ! einen Eintrag mehr, damit an der letzten Stelle, der R_u_I: Resid_und_start_index(N_Resids,Gesamtanzahl+1,2) stehen kann, um die Schleifenbegrenzungen nicht anpassen zu muessen

ALLOCATE(residue_names(Gesamtanzahl))
ALLOCATE(residue_numbers(Gesamtanzahl))
ALLOCATE(atom_numbers(Gesamtanzahl))


!!! initialize system
call init_system(system)

koordA=0.0
vel=0.0
R_u_I=0
R_u_I(N_Resids+1,1)=-100
R_u_I(N_Resids+1,2)=Gesamtanzahl+1
residue_number_old=-1
i=0
N_DIPBI=0
N_PPDI=0
N_P3HT=0
N_P3HT_segments=0
N_PBDT_TS1=0
N_PBDT_TS1_segments=0
N_Species=0
DO j=1,Gesamtanzahl
    	READ(17, "(a)",IOSTAT=ierror) line
		BACKSPACE(UNIT=17)
        IF(ierror < 0) EXIT
        IF(ierror > 0) THEN
            WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(gro_inputfile),' aufgetreten.'//TRIM(line)
            WRITE(*,*) 'Beende Einlesen !'
            CALL EXIT (1)
        END IF
	!WRITE(*,*) 'laenge',LEN(TRIM(line)),' line: ',TRIM(line)
	IF (LEN(TRIM(line)) .le. 45 ) THEN ! check if no velocities are written
		!WRITE(*,*) 'case 1'
		!READ(17,*) dummyname
		!WRITE(*,*) dummyname
		!READ(17,'(i5,2a5,i5,3f8.3)') residue_number,residue_name,dummyname,i,x,y,z
		!WRITE(*,*) residue_number,residue_name,trim(dummyname),i,x,y,z
    		READ(17,'(i5,2a5,i5,3f8.3)',IOSTAT=ierror) residue_numbers(j),residue_names(j),atomsorteA(j),atom_numbers(j),&
                                            &koordA(j,1),koordA(j,2),koordA(j,3)
    		WRITE(*,'(i5,2a5,i5,3f8.3)',IOSTAT=ierror) residue_numbers(j),residue_names(j),atomsorteA(j),atom_numbers(j),&
                                           &koordA(j,1),koordA(j,2),koordA(j,3)

	ELSE ! ordinary *.gro file
    		Read(17,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) residue_numbers(j),residue_names(j),atomsorteA(j),atom_numbers(j),&
                                           	       &koordA(j,1),koordA(j,2),koordA(j,3),vel(j,1),vel(j,2),vel(j,3)
    		!WRITE(*,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) residue_numbers(j),residue_names(j),atomsorteA(j),atom_numbers(j),&
    		!                                      &koordA(j,1),koordA(j,2),koordA(j,3),vel(j,1),vel(j,2),vel(j,3)
	END IF
    IF(ierror < 0) EXIT
    IF(ierror > 0) THEN
        WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(gro_inputfile),' aufgetreten.'
        WRITE(*,*) 'Beende Einlesen !'
        CALL EXIT (1)
    END IF
    residue_number=residue_numbers(j)
    IF (residue_number /= residue_number_old ) THEN
        i=i+1
        R_u_I(i,1)=residue_number
        R_u_I(i,2)=j
        residue_number_old=residue_number
		IF((residue_names(j) == 'DIPBI') .OR. (residue_names(j) == 'DPBIK'))THEN
			N_DIPBI=N_DIPBI+1
		ELSE IF (residue_names(j)(1:4) == 'PPDI') THEN
			N_PPDI=N_PPDI+1
		ELSE IF (residue_names(j) == '8poly') THEN
			N_PBDT_TS1_segments=N_PBDT_TS1_segments+1
			IF( TRIM(adjustl(atomsorteA(j))) == 'CH3') THEN ! new PBDT_TS1 chain-Start with segment A and a CH3 group.
				N_PBDT_TS1=N_PBDT_TS1+1			
			END IF ! new PBDT_TS1 chain-Start
		ELSE IF ((residue_names(j)(1:3) == 'THP') .OR. (residue_names(j)(1:2) == 'PH') .OR. (residue_names(j)(1:2) == 'PM'))THEN
			N_P3HT_segments=N_P3HT_segments+1
			IF( (residue_names(j)(1:5) == 'THP1A') .OR. (residue_names(j)(5:5) == 'S') )THEN ! 32mer start
				N_P3HT=N_P3HT+1
			END IF ! 32mer start
		ELSE 
			N_Species=N_Species+1
		END IF
    END IF
    IF( i == N_Resids+1) EXIT
    IF (i==0 .and. j==Gesamtanzahl ) THEN
       write(*,*) ' Error: Es ist ein Fehler beim Einlesen ausgetreten: '//TRIM(gro_inputfile)
       write(*,*) ' ENDE '
       CALL EXIT (1)
   END IF  
END DO
Read(17,*,IOSTAT=ierror) x_box,y_box,z_box
IF( ierror > 0) STOP 'Error: Reading_the_boxsize'
CLOSE(17)


!!!! lambda data
IF(read_lambda_files)THEN
	CALL read_lambda_in_all_inputfile(N_types_lambda,lambda_array,lambda_in_all_inputfile)
	IF(DEBUG) THEN
		WRITE(*,*) 'Array with lambda data in eV!'
		DO i=1,N_types_lambda
			WRITE(*,*) lambda_array(i,:)
		END DO
	END IF
ELSE 
	IF (Allocated(lambda_array))  Deallocate(lambda_array)
	N_types_lambda=95
	ALLOCATE(lambda_array(N_types_lambda,7))
	WRITE(*,*) 'WARNING: Set lambda_data to zero!'
END IF
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!!! Ende Einlesen
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!



R_offset=1-residue_numbers(1)
i_offset=1
WRITE(*,*) 'modify_mol_h_atoms:',modify_mol_h_atoms 
WRITE(*,*) 'Resid offset:', R_offset
WRITE(*,*) 'i_offset:',i_offset,' WARINING HARD CODED!'

WRITE(*,*) 'N_Resids: ',N_Resids
IF(N_DIPBI /=0) WRITE(*,*) 'N_DIPBI: ',N_DIPBI
IF(N_PPDI  /=0) WRITE(*,*) 'N_PPDI:  ',N_PPDI
IF(N_P3HT_segments /=0) WRITE(*,*) 'N_P3HT:    ',N_P3HT,' N_P3HT_segments:',N_P3HT_segments      !  Expected  N_P3HT=416   !416  ! Anzahl 32mere
IF(N_PBDT_TS1_segments /=0)  WRITE(*,*) 'N_PBDT_TS1:',N_PBDT_TS1,' N_PBDT_TS1_segments:',N_PBDT_TS1_segments   !N_PBDT_TS1= 464  !464= Anzahl ketten 
IF(N_Species /=0) WRITE(*,*)' N_Species:',N_Species


IF(nm_to_Ang) THEN
	koordA=koordA*10.
	x_box=x_box*10.
	y_box=y_box*10.
	z_box=z_box*10.
END IF



!!! Zaehle die Anzahl der Schwefelatome pro resid
IF ( Allocated(R_u_S))  Deallocate(R_u_S)
!! Residund Schwefel R_u_S(i,j)  i=1,N_Resids   j=1 => Resid ; j=2 N_Schwefel, j=3 Startsegment ==1 sonst 0 ; j==4 Endsegment sonst 0
ALLOCATE(R_u_S(N_Resids+1,4))
!! sequence list for polymers like PBDT-TS1
ALLOCATE(sequence_list(N_Resids))
ALLOCATE(residue_name_site(N_Resids))
residue_name_site=''
sequence_list=''
segtype=''
segtype2=''
R_u_S=0
R_u_S(N_Resids+1,1)=N_Resids+1

IF(DIPBI_P3HT_calc) THEN
	DO i=1,N_Resids
		N_Schwefel=0
		N_Chlor=0
		DO j=R_u_I(i,2),R_u_I(i+1,2)
			   if (TRIM(adjustl(atomsorteA(j)))=='Cl') N_Chlor=N_Chlor+1
			   if (TRIM(adjustl(atomsorteA(j)))=='CL') N_Chlor=N_Chlor+1
		       if (TRIM(adjustl(atomsorteA(j)))=='S') N_Schwefel=N_Schwefel+1
		       if (TRIM(adjustl(atomsorteA(j)))=='S-S_R') N_Schwefel=N_Schwefel+1
		END DO
		R_u_S(i,1)=R_u_I(i,1)
		R_u_S(i,2)=N_Schwefel
		!!! Startsegment 
		IF( (TRIM(adjustl(atomsorteA(R_u_I(i,2)))) == 'HC') .AND. (TRIM(adjustl(atomsorteA(R_u_I(i,2)+1))) == 'CA') ) THEN
			R_u_S(i,3)=1
		ELSE
			R_u_S(i,3)=0
		END IF

		!!! Endsegment
		IF( TRIM(adjustl(atomsorteA(R_u_I(i+1,2)-8))) == 'HC' ) THEN
			R_u_S(i,4)=1
		ELSE
			R_u_S(i,4)=0
		END IF
		
		IF( N_Chlor /= 0 ) THEN ! DIPBI
			IF(KETTE .OR. DIPBI_P3HT_calc) residue_name_site(i)='DPBIK'
			IF(.NOT. KETTE) residue_name_site(i)='DIPBI'
		ELSE
			!!! Segment identification
			fin=''
			IF( (R_u_S(i,3)==1) .and. (R_u_S(i,4)==1) ) THEN
					fin='A'
			ELSE IF ((R_u_S(i,3)==1)) THEN
					fin='S'
			ELSE IF ((R_u_S(i,4)==1)) THEN
					fin='E'
			ELSE
					fin='M'
			END IF
			
			IF(KETTE .OR. DIPBI_P3HT_calc) THEN
				segtype2='PH'
			ELSE IF (DIPBI_P3MT_calc) THEN
				segtype2='PM'
			END IF
			
			IF ( R_u_S(i,2) < 10 ) THEN
				residue_name_site(i)=TRIM(segtype2)//'0'//TRIM(str(R_u_S(i,2)))//TRIM(fin)
			ELSE IF( R_u_S(i,2) < 31 ) THEN
				residue_name_site(i)=TRIM(segtype2)//TRIM(str(R_u_S(i,2)))//TRIM(fin)
			ELSE IF( R_u_S(i,2) == 32 ) THEN
						IF(KETTE .OR. DIPBI_P3HT_calc) THEN
								residue_name_site(i)='P3HTA'
						ELSE 	
								residue_name_site(i)='P3MTA'
						END IF !Kette
			END IF ! N_Schewfel = ??
			segtype2=''
		END IF ! N_Chlor => determine DIPBI
		!WRITE(*,*) R_u_S(i,1),R_u_S(i,2),R_u_S(i,3),R_u_S(i,4),atomsorteA(R_u_I(i+1,2)-8)
	END DO

ELSE IF (PPDI_PBDT_TS1_calc) THEN
     
	!! system2
	sequence=''
	DO i=1,N_Resids

		IF ( TRIM(residue_names(R_u_I(i,2))) == 'PPDI_' ) THEN 
			R_u_S(i,1)=R_u_I(i,1)			
			R_u_S(i,2)=1
			R_u_S(i,3)=0
			R_u_S(i,4)=0
			residue_name_site(i)='PPDI_'
			sequence_list(i)='PPDI'
			CYCLE
		END IF
		mol_start_da=.false.
		mol_ende_da=.false.
		N_Schwefel=0
		N_CarboxyS2=0
		N_PBDT=0
		! polymer
		DO j=R_u_I(i,2),R_u_I(i+1,2)
		       	!IF (TRIM(adjustl(atomsorteA(j)))=='S') N_Schwefel=N_Schwefel+1
		       	!IF (TRIM(adjustl(atomsorteA(j)))=='S-S_R') N_Schwefel=N_Schwefel+1
			IF ( residue_names(j) == '8poly' ) THEN 
	    			IF (TRIM(adjustl(atomsorteA(j)))=='F')  N_CarboxyS2=N_CarboxyS2+1
	    			IF (TRIM(adjustl(atomsorteA(j)))=='HC') N_PBDT=N_PBDT+1
				IF( (TRIM(adjustl(atomsorteA(j-1)))=='CH3') .and. (TRIM(adjustl(atomsorteA(j+3)))=='F') &
									   &.and. (TRIM(adjustl(atomsorteA(j+7)))=='OE')  )THEN  ! Start CarboxyS2 unit
					mol_start_da=.true.
					segtype='A'
					sequence=TRIM(sequence)//TRIM(segtype)
				ELSE IF( (TRIM(adjustl(atomsorteA(j)))=='CH3') .and. (TRIM(adjustl(atomsorteA(j-1)))=='HC') )THEN ! End chain 
					mol_ende_da=.true.
				ELSE IF( TRIM(adjustl(atomsorteA(j+3)))=='F' .and. TRIM(adjustl(atomsorteA(j-1)))=='HC') THEN ! Mittlel CarboxyS2
					segtype='A'
					sequence=TRIM(sequence)//TRIM(segtype)		
				ELSE IF (       (TRIM(adjustl(atomsorteA(j+1)))=='S') .and. (TRIM(adjustl(atomsorteA(j+10)))=='HC') ) THEN  ! PBDT segment
						IF  (   (TRIM(adjustl(atomsorteA(j+1))) =='S') .and. (TRIM(adjustl(atomsorteA(j))) =='C')  &    ! angle theta atoms
						& .and. (TRIM(adjustl(atomsorteA(j-2 ))) =='C') .and. (TRIM(adjustl(atomsorteA(j-1))) == 'S')) THEN 
							segtype='B'
							sequence=TRIM(sequence)//TRIM(segtype)
						END IF ! angle theta atoms
				END IF ! PBDT segment	
			END IF ! 8poly
		END DO !j
		R_u_S(i,1)=R_u_I(i,1)

		!!! Startsegment 
		IF(mol_start_da) THEN
			R_u_S(i,3)=1
		ELSE
			R_u_S(i,3)=0
		END IF

		IF( .NOT. mol_ende_da) THEN
				sequence=TRIM(sequence(:LEN_TRIM(sequence)-1)) 
				R_u_S(i,2)=PBDT_TS1_sequence_to_index(sequence) 
				sequence_list(i)=TRIM(sequence)
				sequence='' 
				R_u_S(i,4)=0
		ELSE !!! Startsegment 
				R_u_S(i,2)=PBDT_TS1_sequence_to_index(sequence) 
				sequence_list(i)=TRIM(sequence)  
				sequence=''
				R_u_S(i,4)=1	
		END IF 		

        IF( mol_start_da .and. mol_ende_da ) THEN
				fin='A'
            	ELSE IF (mol_start_da) THEN
				fin='S'
		ELSE IF (mol_ende_da) THEN
				fin='E'
		ELSE
				fin='M'
		END IF

		IF( TRIM(sequence_list(i)(1:1)) == 'A' ) THEN
				residue_name_site(i)='A'//TRIM(str(N_CarboxyS2))//'B'//TRIM(str(N_PBDT/6))//TRIM(fin)
		ELSE IF( TRIM(sequence_list(i)(1:1)) == 'B' ) THEN
				residue_name_site(i)='B'//TRIM(str(N_PBDT/6))//'A'//TRIM(str(N_CarboxyS2))//TRIM(fin)
		END IF 

		 
		IF(DEBUG) WRITE(*,*) R_u_S(i,1),residue_name_site(i),R_u_S(i,2),R_u_S(i,3),R_u_S(i,4),TRIM(sequence_list(i))
	END DO !i=1,N_Resids
ELSE
	WRITE(*,*) 'Error: selected system is not supported.'
	CALL EXIT (1)
END IF



IF (modify_mol_h_atoms) THEN
	!! Check how much memory needs to be allocated => Result in GesamtanzahlH
	GesamtanzahlH=0
	!CALL how_many_h_atoms_to_mol(R_u_I,atomsorteA,residue_names,Gesamtanzahl,N_Resids,GesamtanzahlH,KETTE,PPDI_Propyl) 
	IF( DIPBI_P3HT_calc .OR. DIPBI_P3MT_calc) THEN
		IF(KETTE) THEN
		    GesamtanzahlH=GesamtanzahlH+N_DIPBI*218
		ELSE
		    GesamtanzahlH=GesamtanzahlH+N_DIPBI*86 ! Anzahl mit Methylgruppen
		END IF
	    
		IF(KETTE) THEN ! P3HT
			GesamtanzahlH=GesamtanzahlH+N_P3HT*802 ! Komplette Ketten
		ELSE IF (DIPBI_P3MT_calc) THEN
			GesamtanzahlH=GesamtanzahlH+N_P3HT*322  ! 32mer mit Methylgruppen
		END IF
	
		IF (add_virtual_H_atoms_to_gro) THEN ! Fuer jedes Bruchstuecke 2 HAtome mehr
			WRITE(*,*) '        GesamtanzahlH: ',GesamtanzahlH
			GesamtanzahlH=GesamtanzahlH+2*abs(N_Resids-N_DIPBI-N_P3HT)
			WRITE(*,*) 'virtual GesamtanzahlH: ',GesamtanzahlH
		END IF! no add_virtual_H_atoms_to_gro
	END IF ! DIPBI_P3HT_calc	

	IF (PPDI_PBDT_TS1_calc) THEN
		IF(KETTE) THEN !
		    GesamtanzahlH=GesamtanzahlH+N_PPDI*144
		ELSE IF(PPDI_Propyl) THEN
		    GesamtanzahlH=GesamtanzahlH+N_PPDI*96
		ELSE 
		    GesamtanzahlH=GesamtanzahlH+N_PPDI*78 ! Anzahl mit H-gruppen
		END IF !PPDI
		
		N_CarboxyS2=8
		N_PBDT=8
		GesamtanzahlH=GesamtanzahlH+N_PBDT_TS1*(38*N_PBDT+22*N_CarboxyS2+2)

		IF (add_virtual_H_atoms_to_gro) THEN ! Fuer jedes Bruchstuecke 2 HAtome mehr
			WRITE(*,*) '        GesamtanzahlH: ',GesamtanzahlH
			GesamtanzahlH=GesamtanzahlH+2*abs(N_Resids-N_PPDI-N_PBDT_TS1)
			WRITE(*,*) 'virtual GesamtanzahlH: ',GesamtanzahlH
		END IF ! no add_virtual_H_atoms_to_gro

	END IF ! PPDI_PBDT_TS1_calc
	GesamtanzahlH_precalc=GesamtanzahlH
ELSE
	GesamtanzahlH=Gesamtanzahl
	GesamtanzahlH_precalc=Gesamtanzahl
END IF  
 
!! Allocate Arrays
IF ( Allocated(R_u_I_H))  Deallocate(R_u_I_H)
IF ( Allocated(residue_numbersH))  Deallocate(residue_numbersH)
IF ( Allocated(residue_namesH))  Deallocate(residue_namesH)
IF ( Allocated(atomsorteH))  Deallocate(atomsorteH)
IF ( Allocated(koordH))  Deallocate(koordH)
IF ( Allocated(MolnameH))  Deallocate(MolnameH)
IF ( Allocated(elementsH))  Deallocate(elementsH)
IF ( Allocated(atom_numbersH))  Deallocate(atom_numbersH)
IF ( Allocated(velH))  Deallocate(velH)



ALLOCATE(R_u_I_H(N_Resids+1,2))
ALLOCATE(residue_numbersH(GesamtanzahlH))
ALLOCATE(residue_namesH(GesamtanzahlH))
ALLOCATE(atomsorteH(GesamtanzahlH))
ALLOCATE(koordH(GesamtanzahlH,3))
ALLOCATE(MolnameH(GesamtanzahlH))
ALLOCATE(elementsH(GesamtanzahlH))
ALLOCATE(atom_numbersH(GesamtanzahlH))
ALLOCATE(velH(GesamtanzahlH,3))


R_u_I_H=0
atomsorteH=''
koordH=0
GesamtanzahlH=0
MolnameH=''
residue_namesH=''
elementsH=''
atom_numbersH=0
velH=0
residue_numbersH=0

! Uebergabe der aller Resids
R_u_I_H(:,1)=R_u_I(:,1)


IF (modify_mol_h_atoms) THEN
    IF(	DIPBI_P3HT_calc .OR. DIPBI_P3MT_calc .OR. PPDI_PBDT_TS1_calc ) THEN
	IF (add_virtual_H_atoms_to_gro) THEN 
		    DO i=1,N_Resids
			ind1=R_u_I(i,1)+i_offset ! offset ggf anpassen !!!
			!WRITE(*,*) ind1,R_u_I(ind1,1),R_u_I(ind1,2)
			CALL add_h_atoms_to_mol(atomsorteA(R_u_I(ind1,2):(R_u_I(ind1+1,2)-1)),koordA(R_u_I(ind1,2):(R_u_I(ind1+1,2)-1),1:3),&
				    &(R_u_I(ind1+1,2)-R_u_I(ind1,2)),residue_names(R_u_I(ind1,2)),KETTE,atomsorte1H,koord1H,NAtoms1H,Molname)
			R_u_I_H(ind1,2)=GesamtanzahlH+1
			DO j=1,NAtoms1H            
				atomsorteH(GesamtanzahlH+j)=atomsorte1H(j)
				koordH(GesamtanzahlH+j,:)=koord1H(j,:)
				residue_namesH(GesamtanzahlH+j)=residue_names(ind1)
				MolnameH(GesamtanzahlH+j)=Molname
			END DO !j
			GesamtanzahlH=GesamtanzahlH+NAtoms1H
		    END DO ! N_Resids
		    R_u_I_H(N_Resids+1,2)=GesamtanzahlH+1
		    R_u_I_H(N_Resids+1,1)=-100
		    WRITE(*,*) 'GesamtanzahlH: ',GesamtanzahlH,' Gesamtanzahl: ',Gesamtanzahl
		    IF(GesamtanzahlH_precalc /= GesamtanzahlH) THEN	
			WRITE(*,*) 'WARNING: Number of estimatesd needed atoms including extra H atoms',GesamtanzahlH_precalc,&
			&',does not match the added number',GesamtanzahlH,'! Revise implementation or input data!'
			CALL EXIT (1)
		    END IF
	ELSE ! DO NOT add_virtual_H_atoms_to_gro => unite polymer chain segments to one entire chain and add H atoms afterwards
 
	  IF(DIPBI_P3HT_calc) THEN !!! DIPBI / PPDI section
		N_molecules_acceptor=N_DIPBI
		WRITE(*,*) 'Start to prepare DIPBI'
	  ELSE IF (PPDI_PBDT_TS1_calc) THEN	
	    	WRITE(*,*) 'Start to prepare PPDI'
		N_molecules_acceptor=N_PPDI
	  ELSE
		N_molecules_acceptor=0
	  END IF ! system 

	    !!! DIPBI / PPDI section
	    DO i=1,N_molecules_acceptor
		ind1=R_u_I(i,1)+i_offset ! offset ggf anpassen !!!
		!WRITE(*,*) ind1,R_u_I(ind1,1),R_u_I(ind1,2)
		CALL add_h_atoms_to_mol(atomsorteA(R_u_I(ind1,2):(R_u_I(ind1+1,2)-1)),koordA(R_u_I(ind1,2):(R_u_I(ind1+1,2)-1),1:3),&
		            &(R_u_I(ind1+1,2)-R_u_I(ind1,2)),residue_names(R_u_I(ind1,2)),KETTE,atomsorte1H,koord1H,NAtoms1H,Molname)
		R_u_I_H(ind1,2)=GesamtanzahlH+1		
		DO j=1,NAtoms1H            
			atomsorteH(GesamtanzahlH+j)=atomsorte1H(j)
			koordH(GesamtanzahlH+j,:)=koord1H(j,:)
			residue_namesH(GesamtanzahlH+j)=residue_names(ind1)
			MolnameH(GesamtanzahlH+j)=Molname
		END DO !j
		GesamtanzahlH=GesamtanzahlH+NAtoms1H
	    END DO ! N_Resids N_molecules_acceptor
	

	  	IF(print_coordH_to_xyz) THEN ! ok
			dummyname='xyz_Acceptor_H.xyz'
			INQUIRE(file=TRIM(dummyname),exist=Datei_vorhanden) 
			IF( .NOT. Datei_vorhanden) THEN
				OPEN(UNIT=8,FILE=TRIM(dummyname),STATUS='NEW',IOSTAT=ierror)
				WRITE(8,*) GesamtanzahlH
				WRITE(8,*)
				DO i=1,GesamtanzahlH
					WRITE(8,*) atomsorteH(i),koordH(i,1),koordH(i,2),koordH(i,3)
				END DO 
			ELSE
				WRITE(*,*) 'Warning: File already exists, so it will not be replaced:'//TRIM(dummyname)
			END IF 
		END IF ! print_coordH_to_xyz

		i_ende=R_u_I(N_molecules_acceptor+1,2)-1  ! offset ggf anpassen !!!
		WRITE(*,*) 'i_ende:',i_ende

	IF(DIPBI_P3HT_calc) THEN !!! unite P3HT or PBDT-TS1 units 
		    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
		    !!!! Section unite all P3HT units to one entire molecule and add H atoms to 32mer  !!!!!!
		    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	
	 	    WRITE(*,*) 'Start to prepare P3HT'
		    DO i=1,N_P3HT !N_Resids
			i_start=i_ende+1
			i_ende=i_start+386-1
			!WRITE(*,*) 'tmp R and I',R_u_I(i,1),R_u_I(i,2)
			!ind1=R_u_I(i,1)+i_offset ! offset ggf anpassen !!!
			!WRITE(*,*) ind1,R_u_I(ind1,1),R_u_I(ind1,2)
			!i_max32_mer=R_u_I(ind1,2)+386 !+386+i_offset  !max index nach 32mer in gro file
			!WRITE(*,*) atomsorteA(R_u_I(1,2)),koordA(R_u_I(1,2),1:3)
			!WRITE(*,*) 'START: ',atomsorteA(i_start),koordA(i_start,1:3)
			!WRITE(*,*) 'ENDE: ',atomsorteA(i_ende),koordA(i_ende,1:3)
			!WRITE(*,*) ind1,R_u_I(ind1,1),R_u_I(ind1,2),ind1,i_max32_mer,residue_names(ind1),residue_names(ind1+1)

			CALL add_h_atoms_to_mol(atomsorteA(i_start:i_ende),koordA(i_start:i_ende,1:3),&
				    &(i_ende-i_start+1),residue_names(i_start),KETTE,atomsorte1H,koord1H,NAtoms1H,Molname)
			!!! HIER EINTEILUNG IN 32mere => wird unten korrigiert
			ind1=ind1+1
			R_u_I_H(ind1,2)=GesamtanzahlH+1
			DO j=1,NAtoms1H            
				atomsorteH(GesamtanzahlH+j)=atomsorte1H(j)
				koordH(GesamtanzahlH+j,:)=koord1H(j,:)
				residue_namesH(GesamtanzahlH+j)=residue_names(ind1)
				MolnameH(GesamtanzahlH+j)=Molname
				!WRITE(*,*)	atomsorte1H(j),koord1H(j,1),koord1H(j,2),koord1H(j,3)
			END DO !j
			GesamtanzahlH=GesamtanzahlH+NAtoms1H
		    END DO ! N_Resids


		    R_u_I_H(N_Resids+1,2)=GesamtanzahlH+1
		    R_u_I_H(N_Resids+1,1)=-100


		   ! WRITE(*,*) 'GesamtanzahlH: ',GesamtanzahlH,' Gesamtanzahl: ',Gesamtanzahl
		   IF(print_coordH_to_xyz) THEN !ok
				WRITE(*,*) ' print_coordH_to_xyz ' 
				dummyname='xyz_output_all_H.xyz'
				INQUIRE(file=TRIM(dummyname),exist=Datei_vorhanden) 
				IF( .NOT. Datei_vorhanden) THEN
					OPEN(UNIT=9,FILE=TRIM(dummyname),STATUS='REPLACE',IOSTAT=ierror)
					WRITE(9,*) GesamtanzahlH
					WRITE(9,*)
					DO i=1,GesamtanzahlH
						WRITE(9,*) atomsorteH(i),koordH(i,1),koordH(i,2),koordH(i,3)
					END DO 
					CLOSE(9)
				ELSE
					WRITE(*,*) 'Warning: File already exists, so it will not be replaced:'//TRIM(dummyname)
				END IF 
		   END IF
		   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
		   !!!! Ende Section unite all P3HT !!!!!!!!!!!!!
		   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	   ELSE IF(PPDI_PBDT_TS1_calc) THEN 
		    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!! 
		    !!!! Section unite all PBDT_TS1 units to one entire molecule and add H atoms to A8B8A chain ABABABABABABABAB  !!!!!!
		    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	
	 	    WRITE(*,*) 'Start to prepare P3HT'
		    DO i=1,N_PBDT_TS1  !N_Resids
			i_start=i_ende+1
			i_ende=i_start+378-1
			!WRITE(*,*) 'tmp R and I',R_u_I(i,1),R_u_I(i,2)
			!ind1=R_u_I(i,1)+i_offset ! offset ggf anpassen !!!
			!WRITE(*,*) ind1,R_u_I(ind1,1),R_u_I(ind1,2)
			!i_max32_mer=R_u_I(ind1,2)+378 !+378+i_offset  !max index nach 32mer in gro file
			!WRITE(*,*) atomsorteA(R_u_I(1,2)),koordA(R_u_I(1,2),1:3)
			!WRITE(*,*) 'START: ',atomsorteA(i_start),koordA(i_start,1:3)
			!WRITE(*,*) 'ENDE: ',atomsorteA(i_ende),koordA(i_ende,1:3)
			!WRITE(*,*) ind1,R_u_I(ind1,1),R_u_I(ind1,2),ind1,i_max32_mer,residue_names(ind1),residue_names(ind1+1)

			CALL add_h_atoms_to_mol(atomsorteA(i_start:i_ende),koordA(i_start:i_ende,1:3),&
				    &(i_ende-i_start+1),residue_names(i_start),KETTE,atomsorte1H,koord1H,NAtoms1H,Molname)
			!!! HIER EINTEILUNG IN A8B8A 
			ind1=ind1+1
			R_u_I_H(ind1,2)=GesamtanzahlH+1
			DO j=1,NAtoms1H            
				atomsorteH(GesamtanzahlH+j)=atomsorte1H(j)
				koordH(GesamtanzahlH+j,:)=koord1H(j,:)
				residue_namesH(GesamtanzahlH+j)=residue_names(ind1)
				MolnameH(GesamtanzahlH+j)=Molname
				!WRITE(*,*)	atomsorte1H(j),koord1H(j,1),koord1H(j,2),koord1H(j,3)
			END DO !j
			GesamtanzahlH=GesamtanzahlH+NAtoms1H
		    END DO ! N_Resids


		    R_u_I_H(N_Resids+1,2)=GesamtanzahlH+1
		    R_u_I_H(N_Resids+1,1)=-100


		   ! WRITE(*,*) 'GesamtanzahlH: ',GesamtanzahlH,' Gesamtanzahl: ',Gesamtanzahl
		   IF(print_coordH_to_xyz) THEN !ok
				WRITE(*,*) ' print_coordH_to_xyz ' 
				dummyname='xyz_output_all_H.xyz'
				INQUIRE(file=TRIM(dummyname),exist=Datei_vorhanden) 
				IF( .NOT. Datei_vorhanden) THEN
					OPEN(UNIT=90,FILE=TRIM(dummyname),STATUS='REPLACE',IOSTAT=ierror)
					WRITE(90,*) GesamtanzahlH
					WRITE(90,*)
					DO i=1,GesamtanzahlH
						WRITE(90,*) atomsorteH(i),koordH(i,1),koordH(i,2),koordH(i,3)
					END DO 
					CLOSE(90)
				ELSE
					WRITE(*,*) 'Warning: File already exists, so it will not be replaced:'//TRIM(dummyname)
				END IF 
		   END IF
	   	    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	   	    !!!! Ende Section unite all PBDT_TS1 !!!!!!!!!!!!!
	   	    !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!	
	   END IF !!! Unite polymer segments to an entire chain.
	END IF !! add virtual H atoms to gro ??!
		
    END IF ! DIPBI_P3HT_calc .OR. DIPBI_P3MT_calc .OR. PPDI_PBDT_TS1_calc

    IF(GesamtanzahlH_precalc /= GesamtanzahlH) THEN	
	WRITE(*,*) 'WARNING: Number of estimated needed atoms including extra H atoms',GesamtanzahlH_precalc,&
	&',does not match the added number',GesamtanzahlH,'! Revise implementation or input data!'
	CALL EXIT (1)
    END IF
 ELSE ! modify_mol_h_atoms
    ! Uebergabe ohne H-Veränderung
    Do i=1,Gesamtanzahl
        atomsorteH(i)=atomsorteA(i)
        koordH(i,:)=koordA(i,:)
    END DO
    DO i=1,N_Resids
		R_u_I_H(i,:)=R_u_I(i,:)
		residue_namesH(i)=residue_names(i)
		MolnameH(i)=residue_names(i)
    END DO
    GesamtanzahlH=Gesamtanzahl
    R_u_I_H(N_Resids+1,2)=GesamtanzahlH+1
    R_u_I_H(N_Resids+1,1)=-100
 END IF ! modify_mol_h_atoms




!!! Ubergabe aller elemente an das elementsH array, da die atomsorteH unten modifiziert wird
elementsH=atomsorteH

!!!!!!!!  Section !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! Residue name list for all possible names !!!!!!!!!!!!!!!!!!!!!!!!!!

IF(DIPBI_P3HT_calc .OR. DIPBI_P3MT_calc) THEN ! DIPBI_P3HT: 95
	N_seg_types_all=95
ELSE IF (PPDI_PBDT_TS1_calc) THEN  ! PPDI_PBDT_TS1: 92
	N_seg_types_all=92
END IF


IF ( Allocated(residue_name_list))  Deallocate(residue_name_list)
IF ( Allocated(molecule_da))  Deallocate(molecule_da)
IF ( Allocated(iHOMO_list))  Deallocate(iHOMO_list)
IF ( Allocated(lambda_array_all))  Deallocate(lambda_array_all)
ALLOCATE(residue_name_list(N_seg_types_all))
ALLOCATE(molecule_da(N_seg_types_all))
ALLOCATE(iHOMO_list(N_seg_types_all))
ALLOCATE(lambda_array_all(N_seg_types_all,7))

residue_name_list=''
molecule_da=.false.
iHOMO_list=0
lambda_array_all=0


IF (PPDI_PBDT_TS1_calc) THEN  !!! Start Residue name list PPDI_PBDT_TS1
	!!! PPDI
	k=1
	residue_name_list(k)='PPDI_'
	iHOMO_list(k)=205
	lambda_array_all(k,:)=lambda_array(1,:)

	!!! PBDT_TS1
	DO j=1,3  !!! Startsegment, Mittelsegment, Ensegment
		IF (j==1) fin='M'	
		IF (j==2) fin='S'
		IF (j==3) fin='E'	
		
		!!! chains starting with segment A
		sequence=''
		iHOMO=0
		DO i=1,8
			k=k+1
			segtype='A'
			sequence=TRIM(sequence)//TRIM(segtype)	
			residue_name_list(k)='A'//TRIM(str(i))//'B'//TRIM(str(i-1))//TRIM(fin)
			IF(i==1) THEN
				iHOMO=40
			ELSE 
				iHOMO=iHOMO+39
			END IF		
			iHOMO_list(k)=iHOMO
			lambda_array_all(k,:)=lambda_array(PBDT_TS1_sequence_to_index(sequence),:) 

			IF (i==8) CYCLE ! exclude case for complete chain
			k=k+1
			segtype='B'
			sequence=TRIM(sequence)//TRIM(segtype)	
			residue_name_list(k)='A'//TRIM(str(i))//'B'//TRIM(str(i))//TRIM(fin)
			iHOMO=iHOMO+64
			iHOMO_list(k)=iHOMO
			lambda_array_all(k,:)=lambda_array(PBDT_TS1_sequence_to_index(sequence),:)
		END DO !i segment A
		
		!!! chains starting with segment B
		sequence=''
		iHOMO=0
		DO i=1,8
			k=k+1
			segtype='B'
			sequence=TRIM(sequence)//TRIM(segtype)	
			residue_name_list(k)='B'//TRIM(str(i))//'A'//TRIM(str(i-1))//TRIM(fin)
			IF(i==1)THEN
				iHOMO=65
			ELSE
				iHOMO=iHOMO+64
			END IF
			iHOMO_list(k)=iHOMO
			lambda_array_all(k,:)=lambda_array(PBDT_TS1_sequence_to_index(sequence),:) 

			IF (i==8) CYCLE ! exclude case for complete chain
			k=k+1
			segtype='A'
			sequence=TRIM(sequence)//TRIM(segtype)	
			residue_name_list(k)='B'//TRIM(str(i))//'A'//TRIM(str(i))//TRIM(fin)
			iHOMO=iHOMO+39
			iHOMO_list(k)=iHOMO
			lambda_array_all(k,:)=lambda_array(PBDT_TS1_sequence_to_index(sequence),:)
		END DO !i segment B
	END DO !j fin= S,M,E
	
	!!! Complete chain
	k=k+1
	i=8
	segtype='A'
	sequence=TRIM(segtype)//TRIM(sequence)	
	residue_name_list(k)='A'//TRIM(str(i))//'B'//TRIM(str(i))//'A'
	iHOMO_list(k)=825
	lambda_array_all(k,:)=lambda_array(PBDT_TS1_sequence_to_index(sequence),:) 
	IF(DEBUG) THEN
		DO k=1,N_seg_types_all
			WRITE(*,*) residue_name_list(k),iHOMO_list(k),lambda_array_all(k,:)
		END DO
	END IF 

      !!! Ende Residue name list PPDI_PBDT_TS1
      
ELSE  !!! START Residue name list for all possible names in DIPBI P3HT/P3MT
	k=0
	DO i=1,32  ! MITTE
		k=k+1
		IF(DIPBI_P3HT_calc) THEN
	 		residue_namesH_dummy='PH'
			iHOMO_list(k)=30*i+1
		ELSE IF (DIPBI_P3MT_calc) THEN
			residue_namesH_dummy='PM'
			iHOMO_list(k)=15*i+1
		END IF
		IF (i .LE. 9) THEN
			residue_namesH_dummy=TRIM(ADJUSTL(residue_namesH_dummy))//TRIM(str(0))//TRIM(str(i))//'M'
		ELSE
			residue_namesH_dummy=TRIM(ADJUSTL(residue_namesH_dummy))//TRIM(str(i))//'M'
		END IF
		lambda_array_all(k,:)=lambda_array(i,:)
		residue_name_list(k)=residue_namesH_dummy
	END DO

	DO i=1,31  ! START
		k=k+1
		IF(DIPBI_P3HT_calc) THEN
	 		residue_namesH_dummy='PH'
			iHOMO_list(k)=30*i+1
		ELSE IF (DIPBI_P3MT_calc) THEN
			residue_namesH_dummy='PM'
			iHOMO_list(k)=15*i+1
		END IF
		IF (i .LE. 9) THEN
			residue_namesH_dummy=TRIM(ADJUSTL(residue_namesH_dummy))//TRIM(str(0))//TRIM(str(i))//'S'
		ELSE
			residue_namesH_dummy=TRIM(ADJUSTL(residue_namesH_dummy))//TRIM(str(i))//'S'
		END IF
		lambda_array_all(k,:)=lambda_array(i,:)
		residue_name_list(k)=residue_namesH_dummy
	END DO

	DO i=1,31  ! ENDE
		k=k+1
		IF(DIPBI_P3HT_calc) THEN
	 		residue_namesH_dummy='PH'
			iHOMO_list(k)=30*i+1
		ELSE IF (DIPBI_P3MT_calc) THEN
			residue_namesH_dummy='PM'
			iHOMO_list(k)=15*i+1
		END IF
		IF (i .LE. 9) THEN
			residue_namesH_dummy=TRIM(ADJUSTL(residue_namesH_dummy))//TRIM(str(0))//TRIM(str(i))//'E'
		ELSE
			residue_namesH_dummy=TRIM(ADJUSTL(residue_namesH_dummy))//TRIM(str(i))//'E'
		END IF
		lambda_array_all(k,:)=lambda_array(i,:)
		residue_name_list(k)=residue_namesH_dummy
	END DO

	IF(DIPBI_P3HT_calc) THEN!!! DIPBI an residue_name_list(95) mit KETTE DPBIK
		residue_name_list(32)='P3HTA'
		residue_name_list(95)='DPBIK'
		lambda_array_all(95,:)=lambda_array(33,:)
		iHOMO_list(95)=293 !PM3 DIPBI Hexyl chains
	ELSE IF (DIPBI_P3MT_calc) THEN
		residue_name_list(32)='P3MTA'
		residue_name_list(95)='DIPBI'
		lambda_array_all(95,:)=lambda_array(33,:)
		iHOMO_list(95)=161 !PM3 DIPBI Methy groups
	END IF
END IF!!! END  Residue name list for all possible names in DIPBI P3HT/P3MT





IF (DEBUG) THEN
	WRITE(*,*) 'List with possible residue names'
	DO i=1,N_seg_types_all
		WRITE(*,*) i,TRIM(residue_name_list(i)),'   iHOMO:',iHOMO_list(i)
	END DO 
END IF


!IF (add_virtual_H_atoms_to_gro) THEN 
!	DO i=1,N_Resids
!		!!! Uebergabe der Resid und Nummerrierung der Elementenamen
!		k=0
!		DO j=R_u_I_H(i,2),R_u_I_H(i+1,2)-1
!			residue_namesH(j)=residue_namesH_dummy
!			k=k+1
!			atomsorteH(j)=TRIM(ADJUSTL(atomsorteH(j)))//TRIM(str(k))
!			residue_numbersH(j)=R_u_I_H(i,1)
!		END DO
!	END DO ! i=1,N_Resids
!ELSE
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	!!!         START  SECTION         !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	!!! Modify new residue_namesH      !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	IF(DIPBI_P3HT_calc) THEN 
		ind1=R_u_I_H(N_DIPBI+1,2) ! Startindex des ersten Molekuels
		
		DO i=1,N_Resids
			IF ( .NOT. add_virtual_H_atoms_to_gro) THEN 
				!!! Modify Resid index R_u_I mit einzelsplitting 
				IF(DIPBI_P3HT_calc .AND. (i .GT. N_DIPBI) ) THEN
					!Startindex fuer das nachste Element ind1 + 25* N_Schwefel + H_Start + H_Ende	
					!WRITE(*,*) R_u_S(i,1),R_u_S(i,2),R_u_S(i,3),R_u_S(i,4)			
					R_u_I_H(i+1,2)=ind1+25*R_u_S(i,2)+R_u_S(i,3)+R_u_S(i,4)
					ind1=R_u_I_H(i+1,2)
				END IF
			END IF !add_virtual_H_atoms_to_gro

			!!! Modify residue_namesH
			IF (R_u_S(i,2) == 0) THEN ! DIPBI
				residue_namesH_dummy=residue_name_list(95)
				IF( .NOT. molecule_da(95)) molecule_da(95)=.true.
			ELSE IF(R_u_S(i,3)==1 .AND. R_u_S(i,4)==1) THEN  !32mer
				residue_namesH_dummy=residue_name_list(32)
				IF( .NOT. molecule_da(32)) molecule_da(32)=.true.
			ELSE
				!!! Schwefel
				IF(R_u_S(i,3)==1) THEN !Start
					residue_namesH_dummy=residue_name_list(R_u_S(i,2)+32)
					IF( .NOT. molecule_da(R_u_S(i,2)+32)) molecule_da(R_u_S(i,2)+32)=.true.
				ELSE IF (R_u_S(i,4)==1) THEN !Ende
					residue_namesH_dummy=residue_name_list(R_u_S(i,2)+63)
					IF( .NOT. molecule_da(R_u_S(i,2)+63)) molecule_da(R_u_S(i,2)+63)=.true.
				ELSE ! Hauptteil Mittelstueck
				 	residue_namesH_dummy=residue_name_list(R_u_S(i,2))
					IF( .NOT. molecule_da(R_u_S(i,2))) molecule_da(R_u_S(i,2))=.true.
				END IF		
			END IF
	
			!!! Uebergabe der Resid und Nummerrierung der Elementenamen
			k=0
			DO j=R_u_I_H(i,2),R_u_I_H(i+1,2)-1
				residue_namesH(j)=residue_namesH_dummy
				k=k+1
				atomsorteH(j)=TRIM(ADJUSTL(atomsorteH(j)))//TRIM(str(k))
				residue_numbersH(j)=R_u_I_H(i,1)
			END DO
			IF(i == N_Resids) THEN
				WRITE(*,*)  'Schwefel: ',R_u_S(i,1),R_u_S(i,2),R_u_S(i,3),R_u_S(i,4)	
				WRITE(*,*)  'last Resid:   ',i,R_u_I_H(i,1),residue_numbersH(R_u_I_H(i,1)),TRIM(residue_namesH_dummy)
			END IF
		END DO
	ELSE IF	(PPDI_PBDT_TS1_calc) THEN
		ind1=R_u_I_H(N_PPDI+1,2) ! Startindex des ersten Molekuels
		WRITE(*,*) 'START PBDT_TS1 ind:',ind1
		DO i=1,N_Resids
				IF ( .NOT. add_virtual_H_atoms_to_gro) THEN 
					!!! Modify Resid index R_u_I mit einzelsplitting 
					IF(PPDI_PBDT_TS1_calc .AND. (i .GT. N_PPDI) ) THEN
						!!!   22*N_CarboxyS2 +38 N_PBDT + H_Start + H_Ende
						k=22*countsubstring(sequence_list(i), 'A')+38*countsubstring(sequence_list(i), 'B')	
						R_u_I_H(i+1,2)=ind1+k+R_u_S(i,3)+R_u_S(i,4)
						ind1=R_u_I_H(i+1,2)
					END IF
				END IF !add_virtual_H_atoms_to_gro

				!!! Modify residue_namesH
				IF (R_u_S(i,2) == 1) THEN ! PPDI
					residue_namesH_dummy=residue_name_list(1)
					IF( .NOT. molecule_da(1)) molecule_da(1)=.true.
				ELSE IF(R_u_S(i,3)==1 .AND. R_u_S(i,4)==1) THEN  ! PBDT_TS1 complete chain A8B8A
					residue_namesH_dummy=residue_name_list(92)
					IF( .NOT. molecule_da(92)) molecule_da(92)=.true.
				ELSE
				
				!!! Schwefel
				IF(R_u_S(i,3)==1) THEN !Start
					k_ind=seq_to_k_ind(sequence_list(i),'S')
					residue_namesH_dummy=residue_name_list(k_ind)
					IF( .NOT. molecule_da(k_ind)) molecule_da(k_ind)=.true.
					!WRITE(*,*) 'TMP:',"  ",molecule_da(k_ind),k_ind,residue_namesH_dummy,'  ',TRIM(sequence_list(i))
					!CALL EXIT
				ELSE IF (R_u_S(i,4)==1) THEN !Ende
					k_ind=seq_to_k_ind(sequence_list(i),'E')
					residue_namesH_dummy=residue_name_list(k_ind)
					IF( .NOT. molecule_da(k_ind)) molecule_da(k_ind)=.true.
				ELSE ! Hauptteil Mittelstueck
					k_ind=seq_to_k_ind(sequence_list(i),'M')
				 	residue_namesH_dummy=residue_name_list(k_ind)
					IF( .NOT. molecule_da(k_ind)) molecule_da(k_ind)=.true.
				END IF		
			END IF

			IF(DEBUG) WRITE(*,*) i,residue_namesH_dummy
			!!! Uebergabe der Resid und Nummerrierung der Elementenamen
			k=0
			DO j=R_u_I_H(i,2),R_u_I_H(i+1,2)-1
				residue_namesH(j)=residue_namesH_dummy
				k=k+1
				atomsorteH(j)=TRIM(ADJUSTL(atomsorteH(j)))//TRIM(str(k))
				residue_numbersH(j)=R_u_I_H(i,1)
				
			END DO !j
			IF(i == N_Resids) THEN
				WRITE(*,*)  'Schwefel:',R_u_S(i,1),R_u_S(i,2),R_u_S(i,3),R_u_S(i,4)	
				WRITE(*,*)  'Resid: ',i,R_u_I_H(i,1),residue_numbersH(R_u_I_H(i,1)),TRIM(residue_namesH_dummy)
				!CALL EXIT (1)
			END IF
		END DO ! i=1,N_Resids

	END IF ! DIPBI_P3HT_calc or  PPDI_PBDT_TS1_calc

	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!		
	!!!  		Modify new residue_namesH   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	!!!!!!!!!!!!!    END SECTION   !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!							
!END IF !add_virtual_H_atoms_to_gro



IF(DEBUG) THEN
		WRITE(*,*) GesamtanzahlH
		WRITE(*,*) ' '
		DO j=1,GesamtanzahlH
			WRITE(*,*) atomsorteH(j),koordH(j,1),koordH(j,2),koordH(j,3)
		END DO 
END IF




!!! SETUP data in system_d
IF( use_min_d_COM_vector_list) THEN
	WRITE(*,*) 'WARNING: Implementation not finished!  Set use_min_d_COM_vector_list=.false.'
	call make_min_d_COM_vector_list(min_d_modus,min_d_COM_arr,system,N_Resids,R_u_I_H,GesamtanzahlH,&
		& residue_numbersH,residue_namesH,elementsH,koordH,&
		&neighbourlist_filename,gro_inputfile,N_DIPBI,N_P3HT,N_PPDI,N_PBDT_TS1,N_Species,N_Neighbours,neighbour_list_Res,&
		&x_box,y_box,z_box)
ENDIF




IF(use_I_shift) THEN !!! Shift ggf the index as VOTCA does not allow to start with resid 0
	R_u_I(:,1)=R_u_I(:,1)+I_shift
	R_u_I_H(:,1)=R_u_I_H(:,1)+I_shift
	residue_numbersH(:)=residue_numbersH(:)+I_shift
	WRITE(*,*) 'Use I_shift: ',I_shift
ELSE
	IF( R_u_I(1,1) == 0) THEN
		WRITE(*,*) 'WARNING: Votca needs to start with resid 1, apply I_shift=1!!'
	END IF
END IF







IF(create_fake_topology) THEN
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	!! START create fake topology files !!
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	OPEN(UNIT=20,FILE=TRIM(top_all_outputfile),STATUS='REPLACE',IOSTAT=ierror)

	WRITE(20,*) '[ defaults ]                                                    '
	WRITE(20,*) '; nbfunc        comb-rule       gen-pairs       fudgeLJ fudgeLJ '
	WRITE(20,*) '       1                3             yes           0.5     0.5 '
	WRITE(20,*) '                                                                '
	WRITE(20,*) '[ atomtypes ]                                                   '
	WRITE(20,*) '; name       mass      charge    ptype        sigma          eps'
	!!! Element section
	WRITE(20,*) '     C     12.000       0.000        A  0.00000e+00  0.00000e+00'
	WRITE(20,*) '     N     14.000       0.000        A  0.00000e+00  0.00000e+00'
	WRITE(20,*) '     O     16.000       0.000        A  0.00000e+00  0.00000e+00'
	WRITE(20,*) '     H      1.000       0.000        A  0.00000e+00  0.00000e+00'
	WRITE(20,*) '     S     32.000       0.000        A  0.00000e+00  0.00000e+00'
	IF ( N_DIPBI .GT. 0 ) THEN
		WRITE(20,*) '    Cl     35.000       0.000        A  0.00000e+00  0.00000e+00'
	END IF
	IF ( (N_PBDT_TS1 .GT. 0 ) .AND. PPDI_PBDT_TS1_calc) THEN
		WRITE(20,*) '     F     19.000       0.000        A  0.00000e+00  0.00000e+00'
	END IF

	WRITE(20,*) '                                                                '
	DO i=1,size(residue_name_list)
		IF(molecule_da(i)) THEN
			WRITE(20,*) '#include "'//TRIM(residue_name_list(i))//'_raw.itp"'
		END IF
	END DO 
	WRITE(20,*) '                                                                '
	WRITE(20,*) '[ system ]                                                      '
	WRITE(20,*) '; Name                                                          '
	WRITE(20,*) 'Protein                                                         '
	WRITE(20,*) '                                                                '
	WRITE(20,*) '[ molecules ]                                                   '
	WRITE(20,*) '; Compound        #mols                                         '

	IF(DIPBI_P3HT_calc .OR. DIPBI_P3MT_calc) THEN
		IF (N_DIPBI .GT. 0 ) THEN
			WRITE(20,*) TRIM(residue_name_list(95))//'   ',N_DIPBI
		END IF
		DO i=N_DIPBI+1,N_Resids
			WRITE(20,*) TRIM(residue_namesH(R_u_I_H(i,2)))//'   ',1
		END DO
	ELSE IF (PPDI_PBDT_TS1_calc) THEN
		IF (N_PPDI .GT. 0 ) THEN
			WRITE(20,*) TRIM(residue_name_list(1))//'   ',N_PPDI
		END IF
		DO i=N_PPDI+1,N_Resids
			WRITE(20,*) TRIM(residue_namesH(R_u_I_H(i,2)))//'   ',1
		END DO
	END IF
	WRITE(20,*) '                                                                '
	CLOSE(20)
END IF ! create_fake_topology



!! Create VOTCA mapping file
IF(create_mapping_file) THEN
	OPEN(UNIT=22,FILE=TRIM(map_filename),STATUS='replace', access = 'append')
	WRITE(22,'(g0)') '<topology>'
	WRITE(22,'(g0)') '	<molecules>'
	!WRITE(22,'(g0)') '		<molecule>'
	CLOSE(22)
END IF !create_mapping_file



IF(create_fake_topology .OR. create_mapping_file .OR. create_geo_orbs_mps_g09) THEN
	!!! Make fake *.itp Dateien erzeugen
	DO j=1,size(molecule_da)
		IF (molecule_da(j)) THEN
			DO i=1,N_Resids
				IF( residue_name_list(j) == residue_namesH(R_u_I_H(i,2)) ) THEN
					IF(create_fake_topology) THEN
			 			CALL make_fake_itp(R_u_I_H(i+1,2)-R_u_I_H(i,2),residue_name_list(j),&
						&elementsH(R_u_I_H(i,2):R_u_I_H(i+1,2)-1),atomsorteH(R_u_I_H(i,2):R_u_I_H(i+1,2)-1))
						WRITE(*,*) 'ADDED: ',residue_name_list(j)//'_raw.itp'
					END IF !create_fake_topology				

					IF(create_mapping_file) THEN
						CALL make_votca_kmc_mapfile(map_filename,R_u_I_H(i+1,2)-R_u_I_H(i,2),&
						&residue_namesH(R_u_I_H(i,2):R_u_I_H(i+1,2)-1),&
						&elementsH(R_u_I_H(i,2):R_u_I_H(i+1,2)-1),atomsorteH(R_u_I_H(i,2):R_u_I_H(i+1,2)-1),&
						&iHOMO_list(j),lambda_array_all(j,:),orbs_ZINDO,add_virtual_H_atoms_to_gro,&
						&exclude_virtual_H_atoms,MP_FILES_folder,QC_FILES_folder)
					END IF ! create_mapping_file
	
					IF(create_geo_orbs_mps_g09) THEN ! make inputfiles if selected in extra_files_modus
						CALL  make_geo_orbs_mps_g09(extra_files_modus,R_u_I_H(i+1,2)-R_u_I_H(i,2),&
							& residue_namesH(R_u_I_H(i,2)),elementsH(R_u_I_H(i,2):R_u_I_H(i+1,2)-1),&
							& koordH(R_u_I_H(i,2):R_u_I_H(i+1,2)-1,1:3),NCPUS,Mem)
					END IF ! create_geo_orbs_mps_g09

					EXIT 
				END IF
			END DO
			!WRITE(*,*) 'Checked Molecule: ',TRIM(residue_name_list(j))
		END IF 
	END DO
END IF !create_fake_topology OR:1 create_mapping_file
!!!HIER WEITER!!! 


IF(create_mapping_file) THEN
	OPEN(UNIT=22,FILE=TRIM(map_filename),STATUS='unknown', access = 'append')
	!WRITE(22,'(g0)') '		</molecule>'
	WRITE(22,'(g0)') '	</molecules>'
	WRITE(22,'(g0)') '</topology>'
	CLOSE(22)
	WRITE(*,*) 'Votca mapping file generated: ',TRIM(map_filename)
END IF !create_mapping_file


!!!! ENDE create fake topology file
!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!

IF(create_gromp_mdp_file) THEN
	CALL make_gromp_mdp_file()
END IF

IF(create_mapping_file) THEN
	! Creates a file for the constrain requirements, needs to be included into the VOTCA options.xml file 
	! to build the neighbourlist in VOTCA
	CALL make_votca_neighbourlist_constrains(N_seg_types_all,residue_name_list,molecule_da,neighbourlist_constrains_filename)
END IF


IF(create_jobwriter_single_sites_file) THEN
!! make_votca_jobwriter_single_sites
!! jobwriter for xqmultipoles and pewald3d, if single molecules are embeded (n,h,e)
	call make_votca_jobwriter_single_sites(N_Resids,residue_name_site)
END IF 


IF(create_jobwriter_pairs_pewald3d_file) THEN
	call make_votca_jobwriter_pairs_pewald3d(N_Resids,R_u_I_H,residue_namesH,&
	&I_shift,use_I_shift,neighbourlist_filename,N_Neighbours,neighbour_list_Res)
END IF ! create_jobwriter_pairs_pewald3d_file

IF(create_mps_tab)THEN
	call make_mps_tab(N_Resids,R_u_I_H,residue_namesH,mps_tab_filename)
END IF ! create_mps_tab



!!! Create molpol options files for:    ctp_tools -e molpol -o options_molpol.xml !!!
IF(create_molpol_options_files) THEN
	DO i=1,size(molecule_da)
		IF(molecule_da(i)) THEN
			residue_name=TRIM(residue_name_list(i))			
			IF ((residue_name(:2) == 'PM') .OR. (residue_name(:2) == 'PH')) THEN ! P3MT oder P3HT to All "A"
				residue_name=TRIM(residue_name(1:4))//'A'
			ELSE IF((residue_name(1:1) == 'A') .OR. (residue_name(1:1) == 'B')) THEN  ! PBDT-TS1
				residue_name=TRIM(residue_name(1:4))//'A'
			END IF
			!WRITE(*,*) TRIM(residue_name)
			CALL make_votca_molpol_optionsfiles(residue_name)
		END IF
	END DO
	WRITE(*,*) 'Use:  ctp_tools -e molpol -o options_molpol_RESNAME_C.xml '
	WRITE(*,*) 'make_votca_molpol_optionsfiles: done'
END IF



!!! Convert back to nm
IF(nm_to_Ang) THEN ! Zurueck zu nm
	koordA=koordA*0.1
	koordH=koordH*0.1
	x_box=x_box*0.1
	y_box=y_box*0.1
	z_box=z_box*0.1
	IF(create_votca_boxfile) THEN ! in nm!
		CALL make_votca_boxfile(x_box,y_box,z_box,gro_inputfile)
	END IF
END IF





WRITE(*,*) 'N_Resids: ',N_Resids
!! Output GROMACS DATEI *.gro
OPEN(UNIT=18,FILE=TRIM(gro_outputfile),STATUS='REPLACE',IOSTAT=ierror)
WRITE(18,*) 'enumerated_gro_to_VOTCA__'//TRIM(gro_inputfile)
WRITE(18,*) GesamtanzahlH 
DO j=1,GesamtanzahlH
	atom_numbersH(j)=mod(j,100000)
    WRITE(18,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) residue_numbersH(j),residue_namesH(j),adjustr(atomsorteH(j)),&
					   &atom_numbersH(j),&
                                           &koordH(j,1),koordH(j,2),koordH(j,3),velH(j,1),velH(j,2),velH(j,3)
    IF(ierror > 0) THEN
        WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(gro_outputfile),' aufgetreten.'
    END IF
END DO
WRITE(18,'(3f8.3)',IOSTAT=ierror) x_box,y_box,z_box
IF(ierror > 0) THEN
        WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(gro_outputfile),' aufgetreten.'
END IF
WRITE(*,*) '#New gro file created: '//TRIM(gro_outputfile)
WRITE(*,*) ' '



WRITE(*,*) '###Next Steps TO DO: '
WRITE(*,*) '#!/bin/bash'
WRITE(*,*) ' '
WRITE(*,*) ' ### 1) create GROMACS *.tpr'
WRITE(*,*) ' /opt/gromacs-5.0.4-d-WP/bin/grompp_d  -c '//TRIM(gro_outputfile)//' -p '//TRIM(top_all_outputfile)//' -f gromp.mdp'
WRITE(*,*) ' ### 2) GROMACS *.tpr'
WRITE(*,*) ' /opt/gromacs-5.0.4-d-WP/bin/mdrun_d  -s topol.tpr -x '//TRIM(gro_inputfile(:LEN_TRIM(gro_inputfile)-4))//'.xtc'
WRITE(*,*) ' '
WRITE(*,*) ' ### 3a) Mapping'
WRITE(*,*) ' ctp_map -t topol.tpr -c '//TRIM(gro_inputfile(:LEN_TRIM(gro_inputfile)-4))//'.xtc -s '//&
									&TRIM(map_filename)//' -f '//TRIM(votca_sql_name)
WRITE(*,*) ' ### 3b) System.xml'
WRITE(*,*) ' cp '//TRIM(map_filename)//' system.xml'
WRITE(*,*) ' ### 4) Neighbor list'
WRITE(*,*) ' ctp_run -e neighborlist -o '//TRIM(neighbourlist_constrains_filename)//' -f '//TRIM(votca_sql_name)
WRITE(*,*) ' '




WRITE(*,*) ' ### 5)  Site energies'
WRITE(*,*) ' ctp_run -e emultipole -o  '//TRIM(votca_xml_options_filename)//' -f '//TRIM(votca_sql_name)//' -t 72 '
WRITE(*,*) ' ctp_run -e einternal -o  '//TRIM(votca_xml_options_filename)//' -f '//TRIM(votca_sql_name)//' -t 72 '
WRITE(*,*) ' ctp_run -e eoutersphere -o  '//TRIM(votca_xml_options_filename)//' -f '//TRIM(votca_sql_name)//' -t 72 '
WRITE(*,*) ' '
WRITE(*,*) ' ### 6) Transfer integrals'
WRITE(*,*) ' ctp_run -e izindo -o  '//TRIM(votca_xml_options_filename)//' -f '//TRIM(votca_sql_name)//' -t 72 '
WRITE(*,*) ' '
WRITE(*,*) ' ### 7)  Rates'
WRITE(*,*) ' ctp_run -e rates -o  '//TRIM(votca_xml_options_filename)//' -f '//TRIM(votca_sql_name)//' -t 72 '
WRITE(*,*) ' '
WRITE(*,*) ' ### 9) Charge Transport'
WRITE(*,*) ' # kmc_run -e kmcmultiple -o  '//TRIM(votca_xml_options_filename)//' -f '//TRIM(votca_sql_name)


WRITE(*,*) ' '
WRITE(*,*) ' '
WRITE(*,*) ' ### optional: pewald3D '
WRITE(*,*) ' # where required: create mps files ctp_tools -e log2mps -o options.xml  and  ctp_tools -e molpol -o options.xml '
WRITE(*,*) ' ### 10) stateserver' 
WRITE(*,*) ' # ctp_run -e stateserver -o options_stateserver.xml -f '//TRIM(votca_sql_name)
WRITE(*,*) ' ### 11) jobwriter '
WRITE(*,*) ' # ctp_run -e jobwriter -o options_jobwriter.xml -f '//TRIM(votca_sql_name)
WRITE(*,*) ' ### 12) ewald3D background polarization  '
WRITE(*,*) ' # ctp_run -e ewdbgpol -o options_ewdbgpol.xml -f '//TRIM(votca_sql_name)//' -t 72  '
WRITE(*,*) ' ### 13) pewald3D '
WRITE(*,*) ' # ctp_parallel -e pewald3d -o options_pewald3d.xml -f /absolute/path/to/state.sql -s 0 -t 72  -c 8 '
WRITE(*,*) ' ### 14) xqmultipole '
WRITE(*,*) ' # xtp_parallel -e xqmultipole -f '//TRIM(votca_sql_name)//&
										&' -o xqmultipole.xml -s 0 -t 1 -c 1000 -j "run" > xqmultipole.log '

WRITE(*,*) ' ### 15) xmultipole '
WRITE(*,*) ' xtp_run -e xmultipole -o  '//TRIM(votca_xml_options_filename)//' -f '//TRIM(votca_sql_name)
WRITE(*,*) ' '
WRITE(*,*) '##enumerated_gro_to_VOTCA__DIPBI_P3HT_prepare: Done'
WRITE(*,*) '## Normal Termination'

END SUBROUTINE enumerated_gro_to_VOTCA__DIPBI_P3HT_prepare



!#setup jobfile xqmultipole has no own jobfile thus wehave to use the jobwriter

!cp $VOTCASHARE/xtp/xml/jobwriter.xml OPTIONFILES/

!changeoption keys "mps.monomer mps.background" OPTIONFILES/jobwriter.xml 
!changeoption states "n e h" OPTIONFILES/jobwriter.xml 

!xtp_run -e jobwriter -o OPTIONFILES/jobwriter.xml -f state.sql -s 0
!mv jobwriter.mps.background.tab mps.tab
!mv jobwriter.mps.monomer.xml xqmultipole.jobs
!#Only run the first 3 jobs and set the rest to complete
!sed -i "s/AVAILABLE/COMPLETE/g" xqmultipole.jobs
!sed -i '0,/COMPLETE/s/COMPLETE/AVAILABLE/' xqmultipole.jobs
!sed -i '0,/COMPLETE/s/COMPLETE/AVAILABLE/' xqmultipole.jobs
!sed -i '0,/COMPLETE/s/COMPLETE/AVAILABLE/' xqmultipole.jobs


!#running xqmultipole

!cp $VOTCASHARE/ctp/xml/xqmultipole.xml OPTIONFILES/

!changeoption job_file xqmultipole.jobs OPTIONFILES/xqmultipole.xml
!changeoption emp_file mps.tab OPTIONFILES/xqmultipole.xml
!#switch polarisation off for tutorial
!changeoption induce 0 OPTIONFILES/xqmultipole.xml

!changeoption pdb_check 0 OPTIONFILES/xqmultipole.xml
!deleteoption write_chk OPTIONFILES/xqmultipole.xml
!echo "Running xqmultipole, rerouting output to xqmultipole.log"
!xtp_parallel -e xqmultipole -f state.sql -o xqmultipole.xml -s 0 -t 1 -c 1000 -j "run" > xqmultipole.log

!# xqmultipole has no parser to read the siteenergies into the sql file, write a python script or look at https://github.com/JensWehner/votca-scripts/blob/master/xtp/xtp_parseewald.py






!! create votca mapping file e.g. with virtual sites. For DIPBI/P3HT
SUBROUTINE make_votca_kmc_mapfile(map_filename,N_atoms_in_segment,residue_namesH,elementsH,atomsorteH,&
					&iHOMO_list,lambda_array,orbs_ZINDO,add_virtual_H_atoms_to_gro,&
					&exclude_virtual_H_atoms,MP_FILES_folder,QC_FILES_folder)
	use small_functions
	IMPLICIT NONE		
	INTEGER, INTENT(IN)::N_atoms_in_segment,iHOMO_list
	CHARACTER(5), INTENT(IN), DIMENSION(N_atoms_in_segment)  ::residue_namesH
	CHARACTER(5), INTENT(IN), DIMENSION(N_atoms_in_segment)  :: elementsH,atomsorteH
	CHARACTER(5000), INTENT(IN)::map_filename,MP_FILES_folder,QC_FILES_folder
	REAL*8, DIMENSION (7), INTENT(IN)::lambda_array
	LOGICAL, INTENT(IN)::orbs_ZINDO,add_virtual_H_atoms_to_gro,exclude_virtual_H_atoms
	INTEGER::i,i_start,i_QM,iHOMO
	LOGICAL::Datei_vorhanden
	CHARACTER(5) ::mod_residue_namesH,residue_name,mod_mpsfilename
	CHARACTER(8) ::string
 	!! Strings to store the data for the atoms in the given representation
	CHARACTER(50000), ALLOCATABLE, DIMENSION(:):: l_mdatoms,l_qmatoms,l_mpoles,l_weights,l_weights_mps,l_virtual_mps
	CHARACTER(50000), ALLOCATABLE, DIMENSION(:):: localframe,l_seg_map,localframe_mps
	CHARACTER(50000) ::l_seg_map_all
	!! N_fragments: Number of all fragments, f is a index, which referes to the current fragment.
	INTEGER::k_atoms_in_seg,N_fragments,N_fragments_A,N_fragments_B,f
	LOGICAL::seg_ende
	
	! Modify residue name
	mod_residue_namesH=residue_namesH(1)
	residue_name=residue_namesH(1)
	mod_mpsfilename=residue_namesH(1)	
	
	
	!!! determine number of fragments, inside a molecule/ conjugated segment
	N_fragments=1
	f=0 ! default
	k_atoms_in_seg=0 ! default 
	IF((mod_residue_namesH(:2) == 'PH') .OR. (mod_residue_namesH(:2) == 'PM')) THEN ! P3HT / P3MT
		READ(mod_residue_namesH(3:4),'(I2)') N_fragments
		!WRITE(*,*) TRIM(mod_residue_namesH),'    ',N_fragments
	ELSE IF((mod_residue_namesH(1:1) == 'A') .OR. (mod_residue_namesH(1:1)== 'B' ) )THEN  ! PBDT_TS1
		READ(mod_residue_namesH(2:2),'(I2)') N_fragments_A
		READ(mod_residue_namesH(4:4),'(I2)') N_fragments_B
		N_fragments=N_fragments_A+N_fragments_B
	END IF
	
	ALLOCATE(l_mdatoms(N_fragments),l_qmatoms(N_fragments),l_mpoles(N_fragments),l_weights(N_fragments),l_seg_map(N_fragments))
	ALLOCATE(l_weights_mps(N_fragments),l_virtual_mps(N_fragments),localframe(N_fragments),localframe_mps(N_fragments))
	
	l_mdatoms=''
	l_qmatoms=''
	l_mpoles=''
	l_weights=''
	l_weights_mps=''
	l_virtual_mps=''
	localframe=''
	localframe_mps=''
	l_seg_map=''
	l_seg_map_all=''
	
	i_start=1
	seg_ende=.false.

	!WRITE(*,*) 'tmp ',mod_residue_namesH,lambda_array
	IF ( (mod_residue_namesH(:2) == 'PH')   .OR. (mod_residue_namesH(:2) == 'PM') .OR. & ! P3HT / P3MT
	   & (mod_residue_namesH(1:1) == 'A')   .OR. (mod_residue_namesH(1:1)== 'B' ) )THEN  ! PBDT_TS1
		IF (mod_residue_namesH(5:) == 'M') THEN
			i_start=2
		ELSE IF (mod_residue_namesH(5:) == 'E') THEN
			i_start=2
			seg_ende=.true.
		END IF
		mod_residue_namesH=TRIM(mod_residue_namesH(:4))//'A'
		!WRITE(*,*) 'Modified:',mod_residue_namesH
	END IF


	!!!! Modify string for additional virtual atoms
	IF (add_virtual_H_atoms_to_gro) THEN 
		i_start=1
		DO i=1,N_atoms_in_segment
			!! checks if new fragment f is reached and sets localframe,localframe_mps
			CALL i_segment_to_f_fragment(f,i,i_start,k_atoms_in_seg,N_atoms_in_segment,mod_residue_namesH,localframe,localframe_mps)

			!WRITE(*,*) 'tmp f:',f, ' i=',i,'    k_atoms_in_seg=',k_atoms_in_seg,'     N_atoms_in_segment:',N_atoms_in_segment
			IF(.NOT. exclude_virtual_H_atoms) THEN
				l_virtual_mps(f)=TRIM(l_virtual_mps(f))//' 0'
			ELSE  !!! TREAT VIRTUAL H-ATOMS = 1
				IF( (i == N_atoms_in_segment) .AND. ( (residue_name(5:) == 'S') ))THEN !!! letztes H virtuell am ersten segment , S= start segment 
					l_virtual_mps(f)=TRIM(l_virtual_mps(f))//' 1'
				ELSE IF ((residue_name(5:) == 'M') .AND. ((i==N_atoms_in_segment) .OR. (i==1))) THEN ! letzte H Atome am Mittelstueck 
					l_virtual_mps(f)=TRIM(l_virtual_mps(f))//' 1'
				ELSE IF ((residue_name(5:) == 'E') .AND. (i==1) ) THEN
					l_virtual_mps(f)=TRIM(l_virtual_mps(f))//' 1'
				ELSE ! Normalfall Aktivierung!
					l_virtual_mps(f)=TRIM(l_virtual_mps(f))//' 0'
				END IF
			END IF
		END DO
	END IF
				
	k_atoms_in_seg=0
	f=0
	IF(seg_ende) THEN
		i_QM=i_start
		DO i=1,N_atoms_in_segment
			!! checks if new fragment f is reached and sets localframe,localframe_mps
			
			CALL i_segment_to_f_fragment(f,i,i_start,k_atoms_in_seg,N_atoms_in_segment,mod_residue_namesH,localframe,localframe_mps)
			
			l_mdatoms(f)=TRIM(l_mdatoms(f))//'  1:'//TRIM(adjustl(residue_namesH(i)))//':'//TRIM(adjustl(atomsorteH(i)))  !!!!'//TRIM(str(f))//'
			IF( mod_residue_namesH(:2) == 'PH' .AND.  (i==N_atoms_in_segment-20) ) THEN ! modify index endsegment P3HT
				IF(add_virtual_H_atoms_to_gro) THEN
					l_qmatoms(f)=TRIM(l_qmatoms(f))//'  '//TRIM(str(N_atoms_in_segment))//':'//TRIM(adjustl(elementsH(i)))
					l_mpoles(f)=TRIM(l_mpoles(f))//'  '//TRIM(str(N_atoms_in_segment))//':'//TRIM(adjustl(elementsH(i)))
					l_seg_map(f)=TRIM(l_seg_map(f))//'  '//TRIM(str(N_atoms_in_segment))
				ELSE
					l_qmatoms(f)=TRIM(l_qmatoms(f))//'  '//TRIM(str(N_atoms_in_segment+1))//':'//TRIM(adjustl(elementsH(i)))
					l_mpoles(f)=TRIM(l_mpoles(f))//'  '//TRIM(str(N_atoms_in_segment+1))//':'//TRIM(adjustl(elementsH(i)))
					l_seg_map(f)=TRIM(l_seg_map(f))//'  '//TRIM(str(N_atoms_in_segment+1))
				END IF
			ELSE IF( mod_residue_namesH(:2) == 'PM' .AND.  (i==N_atoms_in_segment-5) ) THEN ! modify index endsegment P3MT
				IF(add_virtual_H_atoms_to_gro) THEN					
					l_qmatoms(f)=TRIM(l_qmatoms(f))//'  '//TRIM(str(N_atoms_in_segment))//':'//TRIM(adjustl(elementsH(i)))
					l_mpoles(f)=TRIM(l_mpoles(f))//'  '//TRIM(str(N_atoms_in_segment))//':'//TRIM(adjustl(elementsH(i)))
					l_seg_map(f)=TRIM(l_seg_map(f))//'  '//TRIM(str(N_atoms_in_segment)) ! Setzen des letzten Atoms
				ELSE
					l_qmatoms(f)=TRIM(l_qmatoms(f))//'  '//TRIM(str(N_atoms_in_segment+1))//':'//TRIM(adjustl(elementsH(i)))
					l_mpoles(f)=TRIM(l_mpoles(f))//'  '//TRIM(str(N_atoms_in_segment+1))//':'//TRIM(adjustl(elementsH(i)))
					l_seg_map(f)=TRIM(l_seg_map(f))//'  '//TRIM(str(N_atoms_in_segment+1))
				END IF			
			ELSE
				l_qmatoms(f)=TRIM(l_qmatoms(f))//'  '//TRIM(str(i_QM))//':'//TRIM(adjustl(elementsH(i)))
				l_mpoles(f)=TRIM(l_mpoles(f))//'  '//TRIM(str(i_QM))//':'//TRIM(adjustl(elementsH(i)))
				l_seg_map(f)=TRIM(l_seg_map(f))//'  '//TRIM(str(i_QM))
				i_QM=i_QM+1
			END IF
			l_weights(f)=TRIM(l_weights(f))//'  '//TRIM(str(NINT(element_to_mass(elementsH(i),.false.))))
			l_weights_mps(f)=TRIM(l_weights_mps(f))//'  '//str(NINT(element_to_mass(elementsH(i),.false.)))
			IF (.NOT. add_virtual_H_atoms_to_gro) THEN 
				l_virtual_mps(f)=TRIM(l_virtual_mps(f))//' 0'
			END IF
		END DO
		! Orbitals
		IF(orbs_ZINDO) THEN
			iHOMO=iHOMO_list
		ELSE
			iHOMO=Calc_N_electrons_in(elementsH,N_atoms_in_segment,.false.)/2
		END IF ! Orbitals

	ELSE ! NORMAL
		i_QM=i_start
		DO i=1,N_atoms_in_segment
			!! checks if new fragment f is reached and sets localframe,localframe_mps
			CALL i_segment_to_f_fragment(f,i,i_start,k_atoms_in_seg,N_atoms_in_segment,mod_residue_namesH,localframe,localframe_mps)
			
			
			l_mdatoms(f)=TRIM(l_mdatoms(f))//'  1:'//TRIM(adjustl(residue_namesH(i)))//':'//TRIM(adjustl(atomsorteH(i)))
			l_qmatoms(f)=TRIM(l_qmatoms(f))//'  '//TRIM(str(i_QM))//':'//TRIM(adjustl(elementsH(i)))
			l_mpoles(f)=TRIM(l_mpoles(f))//'  '//TRIM(str(i_QM))//':'//TRIM(adjustl(elementsH(i)))
			l_seg_map(f)=TRIM(l_seg_map(f))//'  '//TRIM(str(i_QM))
			l_weights(f)=TRIM(l_weights(f))//'  '//TRIM(str(NINT(element_to_mass(elementsH(i),.false.))))
			l_weights_mps(f)=TRIM(l_weights_mps(f))//'  '//str(NINT(element_to_mass(elementsH(i),.false.)))
			IF (.NOT. add_virtual_H_atoms_to_gro) THEN 
				l_virtual_mps(f)=TRIM(l_virtual_mps(f))//' 0'
			END IF
			i_QM=i_QM+1
		END DO
		! Orbitals
		IF(orbs_ZINDO) THEN
			iHOMO=iHOMO_list
		ELSE
			iHOMO=Calc_N_electrons_in(elementsH,N_atoms_in_segment,.false.)/2
		END IF ! Orbitals
	END IF

!!! Create mapfile
INQUIRE(file=TRIM(map_filename),exist=Datei_vorhanden) ! Abfrage ob map-Datei vorhanden ist.
IF(.NOT. Datei_vorhanden) THEN 
	WRITE(*,*) 'Error File does not exist:'//TRIM(map_filename)
	CALL EXIT(1)	
ELSE
OPEN(UNIT=21,FILE=TRIM(map_filename),STATUS='unknown', access = 'append')
!WRITE(21,'(g0)') '<topology>'
!WRITE(21,'(g0)') '	<molecules>'
WRITE(21,'(g0)') '		<molecule>'
WRITE(21,'(g0)') '			<name>'//TRIM(adjustl(residue_namesH(1)))//'</name>'
WRITE(21,'(g0)') '			<mdname>'//TRIM(adjustl(residue_namesH(1)))//'</mdname>'
WRITE(21,'(g0)') '			<segments>'
WRITE(21,'(g0)') '				<segment>'
WRITE(21,'(g0)') '					<name>'//TRIM(adjustl(residue_namesH(1)))//'</name>'
WRITE(21,'(g0)') '					<qmcoords>'//TRIM(QC_FILES_folder)//'/'//TRIM(adjustl(mod_residue_namesH))//'_n.xyz</qmcoords>'
WRITE(21,'(g0)') '					<orbitals>'//TRIM(QC_FILES_folder)//'/'//TRIM(adjustl(mod_residue_namesH))//'.orbs</orbitals>'
WRITE(21,'(g0)') '					<basisset>INDO</basisset>'
WRITE(string,'(1I7)') iHOMO
WRITE(21,*) '					<torbital_h>'//TRIM(adjustl(string))//'</torbital_h>'
WRITE(string,'(1f6.3)') Real(lambda_array(3)-lambda_array(1))
WRITE(21,*) '					<U_cC_nN_h>'//TRIM(adjustl(string))//'</U_cC_nN_h>'
WRITE(string,'(1f6.3)') Real(lambda_array(7)-lambda_array(1))
WRITE(21,*) '					<U_nC_nN_h>'//TRIM(adjustl(string))//'</U_nC_nN_h>'
WRITE(string,'(1f6.3)') Real(lambda_array(5)-lambda_array(3))
WRITE(21,*) '					<U_cN_cC_h>'//TRIM(adjustl(string))//'</U_cN_cC_h>'
WRITE(string,'(1I7)') iHOMO+1
WRITE(21,*) '					<torbital_e>'//TRIM(adjustl(string))//'</torbital_e>'
WRITE(string,'(1f6.3)') Real(lambda_array(2)-lambda_array(1))
WRITE(21,*) '					<U_cC_nN_e>'//TRIM(adjustl(string))//'</U_cC_nN_e>'
WRITE(string,'(1f6.3)') Real(lambda_array(6)-lambda_array(1))
WRITE(21,*) '					<U_nC_nN_e>'//TRIM(adjustl(string))//'</U_nC_nN_e>'
WRITE(string,'(1f6.3)') Real(lambda_array(4)-lambda_array(2))
WRITE(21,*) '					<U_cN_cC_e>'//TRIM(adjustl(string))//'</U_cN_cC_e>'

IF(exclude_virtual_H_atoms) THEN  ! use united atom type mps files, with original names S_,M_,E_ , which contained summed H partial charges into C atoms. 
	WRITE(21,'(g0)') '					<multipoles_n>'//TRIM(MP_FILES_folder)//'/'//TRIM(adjustl(mod_mpsfilename))//'_n.mps</multipoles_n>'
	WRITE(21,'(g0)') '					<multipoles_h>'//TRIM(MP_FILES_folder)//'/'//TRIM(adjustl(mod_mpsfilename))//'_h.mps</multipoles_h>'
	WRITE(21,'(g0)') '					<multipoles_e>'//TRIM(MP_FILES_folder)//'/'//TRIM(adjustl(mod_mpsfilename))//'_e.mps</multipoles_e>'
ELSE  ! use A_ fole format for all P3HT
	WRITE(21,'(g0)') '					<multipoles_n>'//TRIM(MP_FILES_folder)//'/'//TRIM(adjustl(mod_residue_namesH))//'_n.mps</multipoles_n>'
	WRITE(21,'(g0)') '					<multipoles_h>'//TRIM(MP_FILES_folder)//'/'//TRIM(adjustl(mod_residue_namesH))//'_h.mps</multipoles_h>'
	WRITE(21,'(g0)') '					<multipoles_e>'//TRIM(MP_FILES_folder)//'/'//TRIM(adjustl(mod_residue_namesH))//'_e.mps</multipoles_e>'
END IF ! modify mps filenames


WRITE(21,'(g0)') '					<map2md>1</map2md>'

IF(N_fragments==1) THEN ! Standard no fragments
	WRITE(21,'(g0)') '					<map>'//TRIM(l_seg_map(f))//' </map>'
	WRITE(21,'(g0)') '					<weights>'//TRIM(l_weights(f))//' </weights>'
ELSE ! Standard including fragments

	WRITE(21,'(g0)') '					<map>'  !!! <!−− rigid  fragments  separated by a colon −−>	
	DO f=1,N_fragments
			IF( f==N_fragments) THEN
				WRITE(21,'(g0)') '					     '//TRIM(l_seg_map(f))
			ELSE 
				WRITE(21,'(g0)') '					     '//TRIM(l_seg_map(f))//':' 
			END IF
	END DO
	WRITE(21,'(g0)') '					</map>'

	WRITE(21,'(g0)') '					<weights>'  !!! <!−− for  centers of rigid fragments −−>
	DO f=1,N_fragments
			IF( f==N_fragments) THEN
				WRITE(21,'(g0)') '					     '//TRIM(l_weights(f))
			ELSE
				WRITE(21,'(g0)') '					     '//TRIM(l_weights(f))//':' 
			END IF
	END DO
	WRITE(21,'(g0)') '					</weights>'	
	
END IF ! map with fragments.
	

WRITE(21,'(g0)') '					<fragments>'
!!! loop fragments
DO f=1,N_fragments
		WRITE(21,'(g0)') '						<fragment>'
		WRITE(21,'(g0)') '							<name>'//TRIM(adjustl(residue_namesH(1)))//'_'//TRIM(str(f))//'</name>'
		WRITE(21,'(g0)') '							<mdatoms>'//TRIM(adjustl(l_mdatoms(f)))//'</mdatoms>'
		WRITE(21,'(g0)') '							<qmatoms>'//TRIM(l_qmatoms(f))//' </qmatoms>'
		WRITE(21,'(g0)') '							<mpoles>'//TRIM(l_mpoles(f))//' </mpoles>'
		WRITE(21,'(g0)') '							<weights>'//TRIM(l_weights(f))//' </weights>'
		WRITE(21,'(g0)') '							<localframe> '//TRIM(localframe(f))//' </localframe>'
		WRITE(21,'(g0)') '							<localframe_mps> '//TRIM(localframe(f))//' </localframe_mps>'
		WRITE(21,'(g0)') '							<weights_mps>'//TRIM(l_weights_mps(f))//' </weights_mps>'
		WRITE(21,'(g0)') '							<virtual_mps>'//TRIM(l_virtual_mps(f))//' </virtual_mps>'
		WRITE(21,'(g0)') '						</fragment>'
END DO ! loop fragents
WRITE(21,'(g0)') '					</fragments>'
WRITE(21,'(g0)') '				</segment>'
WRITE(21,'(g0)') '			</segments>'
WRITE(21,'(g0)') '		</molecule>'
!WRITE(21,'(g0)') '	</molecules>'
!WRITE(21,'(g0)') '</topology>'
END IF 
CLOSE(21)
END SUBROUTINE make_votca_kmc_mapfile



!! Function that returns the fragment index f for an atom index for type residue_nameH
!! i is integer in the atom loop per segment and f returns the corresponding fragment number
!! localframe,localframe_mps are set, if a new fragment emerges
SUBROUTINE  i_segment_to_f_fragment(f,i,i_start,k_atoms_in_seg,N_atoms_in_segment,residue_nameH,localframe,localframe_mps)
	use small_functions
	IMPLICIT NONE
	INTEGER, INTENT(INOUT)::f,k_atoms_in_seg
	CHARACTER(LEN=*), ALLOCATABLE,DIMENSION(:), INTENT(INOUT)::localframe,localframe_mps
	INTEGER, INTENT(IN):: i,i_start,N_atoms_in_segment
	CHARACTER(LEN=5), INTENT(IN)::residue_nameH
	LOGICAL::check_A=.false.,check_B=.false.

	
	IF(f==0) THEN  !! reset
		check_A=.false.
		check_B=.false.
	END IF
	
	IF((i+1 == N_atoms_in_segment) .OR. (i+2 == N_atoms_in_segment)  )THEN
		RETURN
	END IF
	
	!!! count atoms k in the segment
	k_atoms_in_seg=k_atoms_in_seg+1
	IF (residue_nameH(:2) == 'PH') THEN
		IF ((f==0) .OR. (k_atoms_in_seg == 25 .AND. (i+1 /= N_atoms_in_segment))) THEN 
			IF(f==0 .AND. i_start==1 ) THEN
				k_atoms_in_seg=-1 ! correct first H Atom
			ELSE IF(f==0 .AND. i_start==2 ) THEN
				k_atoms_in_seg=0 ! correct first H Atom
			ELSE
				k_atoms_in_seg=0
			END IF
			
			f=f+1
			localframe(f)=TRIM(str(i+4))//' '//TRIM(str(i+5))//' '//TRIM(str(i+6))
			localframe_mps(f)=TRIM(str(i+4))//' '//TRIM(str(i+5))//' '//TRIM(str(i+6))
		END IF	
	ELSE IF (residue_nameH(:2) == 'PM') THEN
		IF ( (f==0) .OR. (k_atoms_in_seg == 10 .AND. (i+1 /= N_atoms_in_segment)))THEN 
			IF(f==0 .AND. i_start==1 ) THEN
				k_atoms_in_seg=-1 ! correct first H Atom
			ELSE IF(f==0 .AND. i_start==2 ) THEN
				k_atoms_in_seg=0 ! correct first H Atom
			ELSE
				k_atoms_in_seg=0
			END IF
			
			f=f+1
			localframe(f)=TRIM(str(i+4))//' '//TRIM(str(i+5))//' '//TRIM(str(i+6))
			localframe_mps(f)=TRIM(str(i+4))//' '//TRIM(str(i+5))//' '//TRIM(str(i+6))
		END IF	
	ELSE IF (residue_nameH(1:1) == 'A') THEN
		IF ((f==0) .AND. (residue_nameH(1:1) == 'A')) check_B=.true.
		IF ((f==0) .AND. (residue_nameH(1:1) == 'B')) check_A=.true.
		
		IF(check_A) THEN !find cycle segement B and find new A
				IF( (f==0) .OR. (k_atoms_in_seg == 38 .AND. (i+1 /=N_atoms_in_segment))) THEN 
						IF(f==0 .AND. i_start==1 ) THEN
							k_atoms_in_seg=-1 ! correct first H Atom
						ELSE IF(f==0 .AND. i_start==2 ) THEN
							k_atoms_in_seg=0 ! correct first H Atom
						ELSE
							k_atoms_in_seg=0
						END IF
						f=f+1
						localframe(f)=TRIM(str(k_atoms_in_seg+5))//' '//TRIM(str(k_atoms_in_seg+6))//' '//TRIM(str(k_atoms_in_seg+7))
						localframe_mps(f)=TRIM(str(k_atoms_in_seg+5))//' '//TRIM(str(k_atoms_in_seg+6))//' '//TRIM(str(k_atoms_in_seg+7))
						check_A=.false.
						check_B=.true.
				END IF 
		ELSE IF (check_B) THEN  !find cycle segement A and find new B
				IF( (f==0) .OR. (k_atoms_in_seg == 22 .AND. (i+1 /=N_atoms_in_segment))) THEN 
						IF(f==0 .AND. i_start==1 ) THEN
							k_atoms_in_seg=-1 ! correct first H Atom
						ELSE IF(f==0 .AND. i_start==2 ) THEN
							k_atoms_in_seg=0 ! correct first H Atom
						ELSE
							k_atoms_in_seg=0
						END IF
						f=f+1
						localframe(f)=TRIM(str(k_atoms_in_seg+5))//' '//TRIM(str(k_atoms_in_seg+6))//' '//TRIM(str(k_atoms_in_seg+7))
						localframe_mps(f)=TRIM(str(k_atoms_in_seg+5))//' '//TRIM(str(k_atoms_in_seg+6))//' '//TRIM(str(k_atoms_in_seg+7))
						check_A=.true.
						check_B=.false.
				END IF 
		END IF 
	
	ELSE 
		  IF(f==0) THEN						
						f=1
						localframe(f)=TRIM(str(2))//' '//TRIM(str(3))//' '//TRIM(str(4))
						localframe_mps(f)=TRIM(str(2))//' '//TRIM(str(3))//' '//TRIM(str(4))
		  END IF
	END IF

END SUBROUTINE i_segment_to_f_fragment



!! make_votca_jobwriter_single_sites
!! jobwriter for xqmultipoles and pewald3d, if single molecules are embeded (n,h,e)
SUBROUTINE make_votca_jobwriter_single_sites(N_Resids,residue_name_site)
	use small_functions
	IMPLICIT NONE
	INTEGER, 							  INTENT(IN) ::N_Resids 
	CHARACTER(len=5), ALLOCATABLE, DIMENSION(:), INTENT(IN)::residue_name_site
	CHARACTER(len=500)::jobwriter_single_filename
	CHARACTER(len=1) :: charge_type
	INTEGER::i,j,job_id
	LOGICAL::Datei_vorhanden
	
	
	jobwriter_single_filename='xjobwriter.mps.single.all.resids.xml'
	INQUIRE(file=TRIM(jobwriter_single_filename),exist=Datei_vorhanden)
	IF( Datei_vorhanden)THEN
		WRITE(*,*) 'WARNING: jobwriter_single_filename file already exists. '//TRIM(jobwriter_single_filename)
		return
	ELSE
		OPEN(UNIT=26,FILE=TRIM(jobwriter_single_filename),STATUS='REPLACE')
		WRITE(26,*) '<jobs>'
	END IF
	
	
	job_id=0
	DO j=1,N_Resids
		DO i=1,3 ! loop charges
			job_id=job_id+1
			if ( i==1) charge_type='n'
			if ( i==2) charge_type='h'
			if ( i==3) charge_type='e'
			WRITE(26,*) '	<job>'
			WRITE(26,*) '		<id>'//TRIM(str(job_id))//'</id>'
			WRITE(26,*) '		<tag>'//TRIM(str(j))//':'//TRIM(residue_name_site(j))//':'//TRIM(charge_type)//'</tag>'
			WRITE(26,*) '		<input>'//TRIM(str(j))//':'//TRIM(residue_name_site(j))//&
										 &':MP_FILES/'//TRIM(residue_name_site(j))//'_'//TRIM(charge_type)//'.mps</input>'
			WRITE(26,*) '		<status>AVAILABLE</status>'
			WRITE(26,*) '	</job>'
		END DO ! i charges 
	END DO ! j=1,N_Resids
	
	WRITE(26,*) '</jobs>'
	CLOSE(26)
	
	WRITE(*,*) 'votca xjobfile generated: '//TRIM(jobwriter_single_filename)
END SUBROUTINE make_votca_jobwriter_single_sites
!###################################




!##########################################
SUBROUTINE make_mps_tab(N_Resids,R_u_I_H,residue_namesH,mps_tab_filename)
			use small_functions
			IMPLICIT NONE
			CHARACTER(len=*)::mps_tab_filename
			INTEGER, INTENT(IN) ::N_Resids 
			LOGICAL::Datei_vorhanden
			INTEGER, ALLOCATABLE, Dimension(:,:) , INTENT(IN)   :: R_u_I_H ! Resid,Index_fuer_molekuelstart
			Character(5), ALLOCATABLE, Dimension(:), INTENT(IN) :: residue_namesH
			Character(5) ::residue_name
			INTEGER::i

			INQUIRE(file=TRIM(mps_tab_filename),exist=Datei_vorhanden)
			IF( Datei_vorhanden)THEN
				WRITE(*,*) 'WARNING: mps_tab_filename file already exists. '//TRIM(mps_tab_filename)
				return
			ELSE
				OPEN(UNIT=27,FILE=TRIM(mps_tab_filename),STATUS='REPLACE')
				WRITE(27,*) '# ID   TYPE    _n.mps    _e.mps    _h.mps'
				!!!  1           DPBIK MP_FILES/DPBIK_n.mps           MP_FILES/DPBIK_e.mps           MP_FILES/DPBIK_h.mps
				DO i=1,N_Resids				
					residue_name=TRIM(residue_namesH(R_u_I_H(i,2)))
				 WRITE(27,*) TRIM(str(R_u_I_H(i,1)))//'           '//TRIM(residue_name)//' MP_FILES/'//TRIM(residue_name)//'_n.mps'&
				 	     &//'           MP_FILES/'//TRIM(residue_name)//'_e.mps           MP_FILES/'//TRIM(residue_name)//'_h.mps'										
				END DO
			
				WRITE(*,*) 'Votca mps.tab file was generated: '//TRIM(mps_tab_filename)
	
			END IF ! mps.tab  Datei_vorhanden ?
				
END SUBROUTINE make_mps_tab
!##########################################


!! make_votca_jobwriter_pairs_pewald3d_sites
!! jobwriter for xqmultipoles and pewald3d, if single molecules are embeded (n,h,e)
SUBROUTINE make_votca_jobwriter_pairs_pewald3d(N_Resids,R_u_I_H,residue_namesH,&
	&I_shift,use_I_shift,neighbourlist_filename,N_Neighbours,neighbour_list_Res)
	use small_functions
	INTEGER, 							  INTENT(IN) ::N_Resids 
	CHARACTER(LEN=*),                     INTENT(IN) ::neighbourlist_filename
	!!! read neighbours
	REAL, ALLOCATABLE, DIMENSION(:,:)                ::neighbour_list_COM
	INTEGER, ALLOCATABLE, DIMENSION(:,:)             ::neighbour_list_Res
	INTEGER, INTENT(IN)                              ::N_Neighbours,I_shift
	!!! Index shift gro to votca
	LOGICAL::use_I_shift
	
	INTEGER, ALLOCATABLE, Dimension(:,:), INTENT(IN)   :: R_u_I_H ! Resid,Index_fuer_molekuelstart
	CHARACTER(len=5), ALLOCATABLE, DIMENSION(:), INTENT(IN)::residue_namesH
	
	CHARACTER(len=500)::jobwriter_pairs_filename
	CHARACTER(len=1) :: charge_type1,charge_type2
	INTEGER::Resid1,Resid2
	CHARACTER(len=5)::residue_name1,residue_name2
	INTEGER::i,j,k,l,job_id
	LOGICAL::Datei_vorhanden,make_single,make_pairs
	
	make_single=.false.
	make_pairs=.true.
	

	
	IF( .NOT. allocated(neighbour_list_Res)) THEN
		ALLOCATE(neighbour_list_COM(N_Resids,N_Neighbours+1))
		ALLOCATE(neighbour_list_Res(N_Resids,N_Neighbours+1))
		CALL Read_neighbourlist(neighbourlist_filename,N_Resids,N_Neighbours,neighbour_list_COM,neighbour_list_Res)
		!! add the index shift gro => to Votca, if it is necessary
		IF(use_I_shift) THEN
			DO i=1,N_Resids
				DO j=2,N_Neighbours+1 !!neighbour_list_Res(i,1)
					neighbour_list_Res(i,j)=neighbour_list_Res(i,j)+I_shift
				END DO 
			END DO
		END IF
	END IF
	
	
	jobwriter_pairs_filename='xjobwriter.mps.pairs.all.resids.xml'
	INQUIRE(file=TRIM(jobwriter_pairs_filename),exist=Datei_vorhanden)
	IF( Datei_vorhanden)THEN
		WRITE(*,*) 'WARNING: jobwriter_pairs_filename file already exists. '//TRIM(jobwriter_pairs_filename)
		return
	ELSE
		OPEN(UNIT=26,FILE=TRIM(jobwriter_pairs_filename),STATUS='REPLACE')
		WRITE(26,*) '<jobs>'
	END IF
	
	
	
	job_id=0
	DO i=1,N_Resids
		DO k=1,3 ! loop charges
			
			if (k==1) charge_type1='n'
			if (k==2) charge_type1='h'
			if (k==3) charge_type1='e'
			Resid1=R_u_I_H(i,1)
			residue_name1=residue_namesH(R_u_I_H(i,2))
			
			IF(make_single) THEN ! make_single site
					job_id=job_id+1
					WRITE(26,*) '	<job>'
					WRITE(26,*) '		<id>'//TRIM(str(job_id))//'</id>'
					WRITE(26,*) '		<tag>'//TRIM(str(Resid1))//':'//TRIM(residue_name1)//':'//TRIM(charge_type1)//'</tag>'
					WRITE(26,*) '		<input>'//TRIM(str(Resid1))//':'//TRIM(residue_name1)//&
												 &':MP_FILES/'//TRIM(residue_name1)//'_'//TRIM(charge_type1)//'.mps</input>'
					WRITE(26,*) '		<status>AVAILABLE</status>'
					WRITE(26,*) '	</job>'
			END IF ! make_single site
			
			IF(make_pairs) THEN
				DO j=2,N_Neighbours+1 !!neighbour_list_Res(i,1)
					
					Resid2=neighbour_list_Res(i,j)
					l_loop: DO l=1,size(R_u_I_H)/2
						IF( Resid2 ==R_u_I_H(l,1)) THEN
							residue_name2=residue_namesH(R_u_I_H(l,2))
							EXIT l_loop 
						END IF
					END DO l_loop
					
					charge_type2='n'
					job_id=job_id+1
					WRITE(26,*) '	<job>'
					WRITE(26,*) '		<id>'//TRIM(str(job_id))//'</id>'
					WRITE(26,*) '		<tag>'//TRIM(str(Resid1))//TRIM(charge_type1)//':'//&
											   &TRIM(str(Resid2))//TRIM(charge_type2)//'</tag>'
					WRITE(26,*) '		<input>'//TRIM(str(Resid1))//':'//TRIM(residue_name1)//&
												 &':MP_FILES/'//TRIM(residue_name1)//'_'//TRIM(charge_type1)//'.mps '//&
												 &TRIM(str(Resid2))//':'//TRIM(residue_name2)//&
												 &':MP_FILES/'//TRIM(residue_name2)//'_'//TRIM(charge_type2)//'.mps'//'</input>'
					WRITE(26,*) '		<status>AVAILABLE</status>'
					WRITE(26,*) '	</job>'					
					
					
				END DO  !j - neighbours
			END IF ! make_pairs
			
		END DO ! i charges 
	END DO ! j=1,N_Resids
	
	WRITE(26,*) '</jobs>'
	CLOSE(26)
	
	WRITE(*,*) 'votca make_votca_jobwriter_pairs_pewald3d generated: '//TRIM(jobwriter_pairs_filename)
END SUBROUTINE make_votca_jobwriter_pairs_pewald3d
!###################################






!! make_votca_molpol_optionsfiles
!! Keep in mind: g09 polarizabilities are given in bohr^3 and votca molpol uses Angstroem^3
!! Also the order of the polarizability tensor is reversed!.
!! WARNING:     order in polarizability tensor in g09 / votca does not match
!! g09:            xx xy yy xz yz zz
!! Votca/gdma:     xx xy xz yy yz zz
SUBROUTINE make_votca_molpol_optionsfiles(residue_name)
	IMPLICIT NONE
	CHARACTER(5),INTENT(IN)::residue_name
	CHARACTER(5000)::mps_filename,molpol_options_filename
	CHARACTER(5)::charge
	CHARACTER(7)::mol_c ! residue_name_charge
	INTEGER::i
	LOGICAL::Datei_vorhanden
DO i=1,3	
	charge=''
	IF(i==1)THEN
		charge='n'
	ELSE IF(i==2)THEN
		charge='e'
	ELSE IF(i==3)THEN
		charge='h'
	END IF
	mol_c=TRIM(residue_name)//'_'//TRIM(charge)
	mps_filename=TRIM(mol_c)//'.mps'
	INQUIRE(file='MP_FILES'//TRIM(mps_filename),exist=Datei_vorhanden)
	IF( .NOT. Datei_vorhanden)THEN
		WRITE(*,*) 'WARNING: mps file for residue name is not available: MP_FILES/'//TRIM(mps_filename)
	END IF
	molpol_options_filename='options_molpol_'//TRIM(mol_c)//'.xml'
	INQUIRE(file=TRIM(molpol_options_filename),exist=Datei_vorhanden) ! Abfrage ob molpol_options_filename-Datei vorhanden ist.
	IF(Datei_vorhanden) THEN 
		WRITE(*,*) 'File does already exist:'//TRIM(molpol_options_filename)
	ELSE
		OPEN(UNIT=25,FILE=TRIM(molpol_options_filename),STATUS='REPLACE')	
		WRITE(25,*) '<options>'
		WRITE(25,*) '   <log2mps>'
		WRITE(25,*) '      <package>gaussian</package>'
		WRITE(25,*) '      <logfile>MP_FILES/'//TRIM(mol_c)//'.log</logfile>'
		WRITE(25,*) '      <mpsfile>MP_FILES/'//TRIM(mps_filename)//'</mpsfile>'
		WRITE(25,*) '   </log2mps>'
		WRITE(25,*) '   <molpol>'
		WRITE(25,*) '      <mpsfiles>'
		WRITE(25,*) '         <input>MP_FILES/'//TRIM(mps_filename)//'</input>'
		WRITE(25,*) '         <output>output_'//TRIM(mps_filename)//'</output>'
		WRITE(25,*) '         <polar>polar_'//TRIM(mol_c)//'.xml</polar>'
		WRITE(25,*) '      </mpsfiles>'
		WRITE(25,*) '         <induction>'
		WRITE(25,*) '            <expdamp>0.39000</expdamp>'
		WRITE(25,*) '            <wSOR>0.30000</wSOR>'
		WRITE(25,*) '            <maxiter>1024</maxiter>'
		WRITE(25,*) '            <tolerance>0.00001</tolerance>'
		WRITE(25,*) '         </induction>'
		WRITE(25,*) '            <target>'
		WRITE(25,*) '            <optimize>true</optimize>'
		WRITE(25,*) '            <molpol>77 0 0 77 0 77</molpol>'
		WRITE(25,*) '            <tolerance>0.00001</tolerance>'
		WRITE(25,*) '      </target>'
		WRITE(25,*) '   </molpol>'
		WRITE(25,*) '</options>'
		CLOSE(25)
	END IF
END DO ! loop mps files charges n, e, h
END SUBROUTINE make_votca_molpol_optionsfiles


!! create a votca boxfile from the *gro imput data
SUBROUTINE make_votca_boxfile(x_box,y_box,z_box,gro_inputfile)
	! Creates the VOTCA boxfile in formated output.
	IMPLICIT NONE
	REAL ::x_box,y_box,z_box
	CHARACTER(5000)::gro_inputfile
	LOGICAL::Datei_vorhanden
	CHARACTER(5000)::boxfilename
	CHARACTER(7)::formated_boxsize
	boxfilename='box.xml'
	INQUIRE(file=TRIM(boxfilename),exist=Datei_vorhanden) ! Abfrage ob itp-Datei vorhanden ist.
	IF(Datei_vorhanden) THEN 
		WRITE(*,*) 'WARINING: File for votca box file allready exist: '&
				&//TRIM(boxfilename)
		WRITE(*,*) 'NO new file is produced: '//TRIM(boxfilename)
		CONTINUE
	ELSE
		WRITE(*,*) 'Boxsize:',x_box,y_box,z_box
		OPEN(UNIT=24,FILE=TRIM(boxfilename),STATUS='REPLACE')	
		WRITE(24,*) '<options>'
		WRITE(formated_boxsize,'(1f7.3)') x_box 
		WRITE(24,*) '	<boxX>'//TRIM(adjustl(formated_boxsize))//'</boxX>   <!-- '//TRIM(gro_inputfile)//' -->'
		WRITE(formated_boxsize,'(1f7.3)') y_box 
		WRITE(24,*) '	<boxY>'//TRIM(adjustl(formated_boxsize))//'</boxY>'
		WRITE(formated_boxsize,'(1f7.3)') z_box 
		WRITE(24,*) '	<boxZ>'//TRIM(adjustl(formated_boxsize))//'</boxZ>'
		WRITE(24,*) '	<boxXY>0</boxXY>'
		WRITE(24,*) '	<boxXZ>0</boxXZ>'
		WRITE(24,*) '	<boxYZ>0</boxYZ>'
		WRITE(24,*) '</options>'	
		CLOSE(24)
		WRITE(*,*) 'Votca boxfile was generated: '//TRIM(boxfilename) 
	END IF
END SUBROUTINE make_votca_boxfile


!! Create a neighbourlist file, here you can modify the cutoffs for the pairs in kmc simulations
SUBROUTINE make_votca_neighbourlist_constrains(N_seg_types_all,residue_name_list,molecule_da,neighbourlist_constrains_filename)
		! Creates a file for the constrain requirements, needs to be included into the VOTCA options.xml file 
		! to build the neighbourlist in VOTCA
		IMPLICIT NONE
		INTEGER, INTENT(IN) ::N_seg_types_all
		CHARACTER(5), DIMENSION(N_seg_types_all), INTENT(IN)  :: residue_name_list
		LOGICAL, DIMENSION(N_seg_types_all), INTENT(IN)  :: molecule_da
		CHARACTER(5000)::neighbourlist_constrains_filename
		INTEGER::i,j
		LOGICAL::Datei_vorhanden
		CHARACTER(3)::NNcutoff_1,NNcutoff_2,NNcutoff_3,NNcutoff_4
	!!! Cutoff fuer nearest neighbour list, 1) P3HT /P3MT segment
	NNcutoff_1='0.9' !! 0.9
       !higher value for DPBIK '1.3'
	NNcutoff_2='1.3'
       ! cutoff  PPDI '1.3'
	NNcutoff_3='1.3'
       ! cutoff  PBDT-TS1 '3.0'
	NNcutoff_4='3.0'

	INQUIRE(file=TRIM(neighbourlist_constrains_filename),exist=Datei_vorhanden) ! Abfrage ob itp-Datei vorhanden ist.
	IF(Datei_vorhanden) THEN 
		WRITE(*,*) 'WARINING: File for neighbourlist_constrains_filename allready exist: '&
				&//TRIM(neighbourlist_constrains_filename)
		WRITE(*,*) 'NO new file is produced.'
		CONTINUE
	ELSE
	OPEN(UNIT=23,FILE=TRIM(neighbourlist_constrains_filename),STATUS='REPLACE', access = 'append')
	WRITE(23,'(g0)') '<options>'
	WRITE(23,'(g0)') '    <neighborlist>  <!--  Standard <cutoff>0.7</cutoff>   -->'
	DO j=1,N_seg_types_all
		IF(molecule_da(j)) THEN
			DO i=j,N_seg_types_all
				IF(molecule_da(i)) THEN
					WRITE(23,'(g0)') '	     <segments>'
					WRITE(23,'(g0)') '               <type> '//TRIM(adjustl(residue_name_list(j)))//&
									&' '//TRIM(adjustl(residue_name_list(i)))//'</type>'
					!!! Cutoffs for neighbour search 
					IF ((residue_name_list(j) == 'DPBIK') .OR. (residue_name_list(j) == 'DIPBI') .OR. & 
					  & (residue_name_list(i) == 'DPBIK') .OR. (residue_name_list(i) == 'DIPBI')) THEN
					       WRITE(23,'(g0)') '               <cutoff>'//TRIM(adjustl(NNcutoff_2))//'</cutoff>'
					ELSE IF( (residue_name_list(j)(1:4) == 'PPDI') .OR. (residue_name_list(i)(1:4) == 'PPDI')) THEN
						WRITE(23,'(g0)') '               <cutoff>'//TRIM(adjustl(NNcutoff_3))//'</cutoff>'
					ELSE IF( (residue_name_list(j)(1:1) == 'A') .OR. (residue_name_list(j)(1:1) == 'B') .OR. & 
						 (residue_name_list(i)(1:1) == 'A') .OR. (residue_name_list(i)(1:1) == 'B') ) THEN !!! PBDT-TS1 poleymer segment
						WRITE(23,'(g0)') '               <cutoff>'//TRIM(adjustl(NNcutoff_4))//'</cutoff>'
					ELSE ! Standard
						WRITE(23,'(g0)') '               <cutoff>'//TRIM(adjustl(NNcutoff_1))//'</cutoff>'
					END IF

					WRITE(23,'(g0)') '            </segments>'
				END IF! i molecule_da
			END DO !i
		END IF ! j molecule_da
	END DO !j
	WRITE(23,'(g0)') '	 </neighborlist>'
	WRITE(23,'(g0)') '</options>'
	WRITE(*,*) 'votca neighbourlist constrained file was generated: ',TRIM(neighbourlist_constrains_filename)	
	END IF
END SUBROUTINE make_votca_neighbourlist_constrains



!! make fake itp files that will be linked in the topology file to produce a gromacs inputfiles
SUBROUTINE make_fake_itp(N_atoms_in_segment,residue_name,elementsH,atomsorteH)
	use small_functions
	IMPLICIT NONE
	INTEGER, INTENT(IN)::N_atoms_in_segment
	CHARACTER(5), INTENT(IN)  ::residue_name
	CHARACTER(5), INTENT(IN), DIMENSION(N_atoms_in_segment) :: elementsH,atomsorteH
	INTEGER::i,ierror
	LOGICAL::Datei_vorhanden
	CHARACTER(5000)::itp_filename
	itp_filename=TRIM(residue_name)//'_raw.itp'	
	INQUIRE(file=TRIM(itp_filename),exist=Datei_vorhanden) ! Abfrage ob itp-Datei vorhanden ist.
	IF(Datei_vorhanden) THEN 
		CONTINUE
	ELSE
		OPEN(UNIT=21,FILE=TRIM(itp_filename),STATUS='REPLACE',IOSTAT=ierror)
		WRITE(21,'(g0)') '[ moleculetype ]'
		WRITE(21,'(g0)') '; Name            nrexcl                                                        '
		WRITE(21,'(g0)') TRIM(residue_name)//'             3'
		WRITE(21,'(g0)') '                                                                                '
		WRITE(21,'(g0)') '[ atoms ]                                                                       '
		WRITE(21,'(g0)') ';       nr      type     resnr   residue      atom      cgnr    charge      mass'
		WRITE(21,'(g0)') '; res '//TRIM(adjustl(residue_name))//'_1'     
		!!!    FORMATIERTE AUSGABE
		!!	WRITE(21,*) '         1         H         1     P3MTA        H1         1     0.000     1.000'
		DO i=1,N_atoms_in_segment
			WRITE(21,'(I10,A10,I10,2A10,I10,2f10.3)') i,ADJUSTR(TRIM(elementsH(i))),1,ADJUSTR(TRIM(residue_name)),&
			&ADJUSTR(TRIM(atomsorteH(i))),i,0.0,element_to_mass(elementsH(i),.false.)
		END DO                                                              
		WRITE(21,'(g0)') ' '
	END IF

END SUBROUTINE make_fake_itp


!! read lambda_in_all_inputfile
SUBROUTINE read_lambda_in_all_inputfile(N_types,array,lambda_in_all_inputfile)
		!! Reads lambda in data in eV!!!!
		!!	R1=OptS0_n_${monomerA}	R2=OptS0_el_${monomerA}	R3=OptS0_lo_${monomerA}	R7=SCF_el_OptS0_n_${monomerA}	R8=SCF_lo_OptS0_n_${monomerA}	R9=SCF_n_OptS0_el_${monomerA}	R10=SCF_n_OptS0_lo_${monomerA}
		IMPLICIT NONE
		CHARACTER(5000), INTENT(IN)::lambda_in_all_inputfile
		REAL*8, ALLOCATABLE, DIMENSION(:,:), INTENT(OUT) ::array
		INTEGER, INTENT(OUT)::N_types
		CHARACTER (5):: residue_name
		CHARACTER (500)::dummy
		INTEGER::i,N_lines,N_skip_line,ierror
		LOGICAL::Datei_vorhanden

		INQUIRE(file=TRIM(lambda_in_all_inputfile),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
		IF( .NOT. Datei_vorhanden) THEN
		      WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(lambda_in_all_inputfile)
		      WRITE(*,*) ' ENDE'
		      CALL EXIT (1)
		END IF ! Datei-file vorhanden  

		OPEN(UNIT=20,FILE=TRIM(lambda_in_all_inputfile),STATUS='OLD',IOSTAT=ierror)
		WRITE(*,*) 'Reading data from: ',TRIM(lambda_in_all_inputfile)
		ierror=0
		N_skip_line=0
		N_lines=0
		DO WHILE ( ierror == 0 ) 
		    Read(20,*,IOSTAT=ierror) dummy
		    IF(ierror < 0) EXIT
		    IF(ierror > 0) THEN
			WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(lambda_in_all_inputfile),' aufgetreten.'
			WRITE(*,*) 'Beende Einlesen !'
			CALL EXIT (1)
		    END IF
		    IF ( dummy(1:1) == '#' ) THEN ! Check ob erster Buchstabe ein #-Zeichen ist, um kommentare zu lesen
			N_skip_line=N_skip_line+1
		    ELSE
			N_lines=N_lines+1
		    END IF
		END DO       
		CLOSE(20)        
		WRITE(*,*) 'N_lines=',N_lines,'N_skip_line',N_skip_line        

		OPEN(UNIT=20,FILE=TRIM(lambda_in_all_inputfile),STATUS='OLD',IOSTAT=ierror)
		IF (N_skip_line > 0 ) THEN
		    DO i =1,N_skip_line 
			Read(20,*,IOSTAT=ierror) dummy
		    END DO
		END IF
		
		N_types=N_lines
		ALLOCATE(array(N_types,7))		

		DO i=1,N_types
		    Read(20,*,IOSTAT=ierror) residue_name,array(i,1),array(i,2),array(i,3),array(i,4),array(i,5), & 
			    &  array(i,6),array(i,7) !,array(i,8),array(i,9),array(i,10), &
			    !&  array(i,11),array(i,12),array(i,13),array(i,14),array(i,15), &
			    !&  array(i,16),array(i,17),array(i,18),array(i,19),array(i,20), &
			    !&  array(i,21),array(i,22),array(i,23),array(i,24),array(i,25), &
			    !&  array(i,26),array(i,27),array(i,28),array(i,29),array(i,30), &
			    !&  array(i,31),array(i,32),array(i,33)
		   	    !!! !WRITE(*,*) array(i,1),array(i,2),array(i,3),array(i,4),array(i,5)
		    IF(ierror < 0) EXIT
		    IF(ierror > 0) THEN
			WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von '//TRIM(lambda_in_all_inputfile)//' aufgetreten.'
			WRITE(*,*) 'Beende Einlesen !'
			CALL EXIT (1)
		    END IF
		END DO
		CLOSE(20)

END SUBROUTINE read_lambda_in_all_inputfile

!! make gromp mdp file, for an infinitisimal set in gromacs to check if all the inputfiles match the gromacs format.
SUBROUTINE make_gromp_mdp_file()
	IMPLICIT NONE
	CHARACTER (LEN=500)::gromp_filename
	LOGICAL::Datei_vorhanden
	INTEGER::ierror
	!!! Creates a minimal gromp.mdp file for gmx for an infinitisimal step
	gromp_filename='gromp.mdp'
	inquire(file=TRIM(gromp_filename),exist=Datei_vorhanden) ! Abfrage ob gro-Datei vorhanden ist.
	IF(Datei_vorhanden) THEN 
		    		WRITE(*,*) ' Warning: Die_VOTCA_gromp.mdp_Datei_is_bereits_vorhanden. '//TRIM(gromp_filename)
				WRITE(*,*) ' Stellen_Sie_sicher_dass_diese_nicht_ueberschrieben_wird! '
		    		WRITE(*,*) ' ENDE'
		    		CALL EXIT (1)
	ELSE
			! Erstell gromp_filename
		OPEN(UNIT=27,FILE=TRIM(gromp_filename),STATUS='REPLACE',IOSTAT=ierror)
		WRITE(27,*) 'integrator               = md       '
		WRITE(27,*) 'dt                       = 0.0002   '
		WRITE(27,*) 'nsteps                   = 1        '
		WRITE(27,*) 'nstxout                  = 1        '
		WRITE(27,*) 'nstvout                  = 1        '
		WRITE(27,*) 'nstlog                   = 1        '
		WRITE(27,*) 'nstenergy                = 300      '
		WRITE(27,*) 'nstxout-compressed       = 500      '
		WRITE(27,*) 'nstlist                  = 10       '
		WRITE(27,*) 'ns-type                  = grid     '
		WRITE(27,*) 'rlist                    = 0.8      '
		WRITE(27,*) 'coulombtype              = cut-off  '
		WRITE(27,*) 'rcoulomb                 = 1.4      '
		WRITE(27,*) 'rvdw                     = 1.4      '
		WRITE(27,*) 'tcoupl                   = V-rescale'
		WRITE(27,*) 'tc-grps                  = system   '
		WRITE(27,*) 'tau-t                    = 0.1      '
		WRITE(27,*) 'ref-t                    = 300      '
		WRITE(27,*) 'gen-vel                  = yes      '
		WRITE(27,*) 'gen-temp                 = 300      '
		WRITE(27,*) 'gen-seed                 = 173529   '
		WRITE(27,*) 'constraints              = all-bonds'

	END IF ! gromp-file vorhanden  


END SUBROUTINE make_gromp_mdp_file



SUBROUTINE make_geo_orbs_mps_g09(modus,NAtoms,residue_name,elements,koord,NCPUS,Mem)
	!! creates the QM input geometries, which are needed to generate the name1_n.xyz, ZINDO name1.orbs files name1.mps files.
	!! extra_files_modus / modus = "all" selects the evaluation or one method.
	!! modus = [all, make_g09_for_mps, make_ZINDO, make_xyz, make_folders]
	!! make_g09_for_mps: creates g09 inputfiles for the geometries to evaluate with data for *.mps files 
	!! make_ZINDO: creates g09 input files for the ZINDO calculations, which are needed for *.orbs
 	!! make_xyz: creates name1_n.xyz in a QC_FILE folder as needed for VOTCA calculations.
 	!! make_folders: creates folders QC_FILES and MP_FILES, if they are not present in the current directory.
	!!
	!! g09: select: e.g. trajstep=0, Numcharged=0, NCPUS=8, Mem=8
	use small_functions
	IMPLICIT NONE
	INTEGER, INTENT (IN):: NAtoms,NCPUS,Mem
	CHARACTER(LEN=5), DIMENSION(NAtoms), INTENT (IN)  :: elements
	REAL, DIMENSION(NAtoms,3), INTENT (IN)            :: koord
	CHARACTER(LEN=5)  , INTENT (IN)                   :: residue_name
	CHARACTER(LEN=500), INTENT (IN)                   :: modus
	!!! Local variables
	CHARACTER(LEN=500) :: foldername,xyz_filename,ZINDO_orbs_filename,mps_filename,filename
	CHARACTER(LEN=10000) :: bashline
	Character(500) :: molA,g09inputline,calculation_method
	Character(5)   ::mod_residue_name
	Character(1)   ::charge_name
	LOGICAL :: folder_vorhanden,Datei_vorhanden,make_folders,make_g09_inp_for_mps,make_g09_inp_ZINDO,make_xyz
	INTEGER :: i

	folder_vorhanden=.false.
	make_xyz=.false.
	make_folders=.false.
	make_g09_inp_ZINDO=.false.
	make_g09_inp_for_mps=.false.

	IF( (INDEX(TRIM(modus), 'false') /= 0) .OR. (INDEX(TRIM(modus), 'False') /= 0) )THEN  
		RETURN
	ELSE IF( TRIM(modus) == 'all') THEN
		make_xyz=.true.
		make_folders=.true.
		make_g09_inp_ZINDO=.true.
		make_g09_inp_for_mps=.true.
	ELSE IF ( TRIM(modus) == 'make_g09_for_mps') THEN 
		make_g09_inp_for_mps=.true.
	ELSE IF( TRIM(modus) == 'make_ZINDO') THEN 
		make_g09_inp_ZINDO=.true.
	ELSE IF( TRIM(modus) == 'make_xyz') THEN
		make_xyz=.true.
	ELSE IF( TRIM(modus) == 'make_folders') THEN
		make_folders=.true.
	ELSE
		WRITE(*,*) 'ERROR: Modus not found.'//TRIM(modus)
		CALL EXIT (1)
	END IF ! modus ?
	
	mod_residue_name=TRIM(residue_name)
	IF ( (mod_residue_name(:2) == 'PH')   .OR. (mod_residue_name(:2) == 'PM') .OR. & ! P3HT / P3MT
	   & (mod_residue_name(1:1) == 'A')   .OR. (mod_residue_name(1:1)== 'B' ) )THEN  ! PBDT_TS1
		mod_residue_name=mod_residue_name(:4)//'A'
		!WRITE(*,*) 'Modified:',mod_residue_name
	END IF




	IF(make_folders) THEN
		foldername='QC_FILES'
                INQUIRE(file=TRIM(foldername),exist=folder_vorhanden)               
                IF (.NOT. folder_vorhanden) THEN
                        write(bashline,*) 'mkdir '//TRIM(foldername)
                        CALL execute_command_line(TRIM(bashline)) 
			WRITE(*,*) TRIM(bashline)
                END IF ! folder 
                
                foldername='MP_FILES'
                INQUIRE(file=TRIM(foldername),exist=folder_vorhanden)               
                IF (.NOT. folder_vorhanden) THEN
                        write(bashline,*) 'mkdir '//TRIM(foldername)
                        CALL execute_command_line(TRIM(bashline)) 
			WRITE(*,*) TRIM(bashline)
                END IF ! folder      
                make_folders=.false.          
	END IF ! make folders
	
	IF(make_xyz) THEN
		foldername='QC_FILES'
                INQUIRE(file=TRIM(foldername),exist=folder_vorhanden)               
                IF (folder_vorhanden) THEN
					molA=TRIM(mod_residue_name)//'_n'
					xyz_filename=TRIM(foldername)//'/'//TRIM(molA)//'.xyz'
					INQUIRE(file=TRIM(xyz_filename),exist=Datei_vorhanden)
					IF( .NOT. Datei_vorhanden) THEN
						call make_coord_to_xyz_in_dir(elements,koord,NAtoms,molA,foldername)
						WRITE(*,*) "New file created: "//TRIM(xyz_filename)
					END IF 
		ELSE
					WRITE(*,*) 'Warning: QC_FILES folder does not exist. No *.xyz file produced.'
		END IF
	END IF ! make_xyz
	
	IF(make_g09_inp_ZINDO) THEN
		foldername='QC_FILES'
                INQUIRE(file=TRIM(foldername),exist=folder_vorhanden)               
                IF (folder_vorhanden) THEN
					ZINDO_orbs_filename=TRIM(mod_residue_name)//'.orbs'
					filename=TRIM(foldername)//'/'//TRIM(ZINDO_orbs_filename)
					INQUIRE(file=TRIM(filename),exist=Datei_vorhanden)
					IF( .NOT. Datei_vorhanden) THEN
						molA=TRIM(mod_residue_name)
						g09inputline=" ZINDO  punch=mo  iop(7/33=1) SCF(XQC,MaxConventionalCycles=400,MaxCycle=800) "
						g09inputline=TRIM(g09inputline)//" pop=minimal  iop(6/80=1)  nosymm IOp(6/7=3)"
						calculation_method="ZINDO"
						CALL make_coord_to_g09_charged_inp(elements,koord,NAtoms,calculation_method,&
							&g09inputline,molA,0,0,0,NCPUS,Mem)
						WRITE(*,*) "New g09_ZINDO.inp file created for: "//TRIM(molA)
					END IF ! orbs Datei_vorhanden
                ELSE
					WRITE(*,*) 'Warning: QC_FILES folder does not exist. No g09.inp file produced.'
		END IF !  folder_vorhanden
	END IF ! make_g09_inp_ZINDO
	
	
	IF(make_g09_inp_for_mps) THEN
		foldername='MP_FILES'
                INQUIRE(file=TRIM(foldername),exist=folder_vorhanden)               
                IF (folder_vorhanden) THEN
					DO i=-1,1,1  ! charge states for mps files
						IF(i ==0) charge_name='n'
						IF(i ==1) charge_name='h'
						IF(i ==-1) charge_name='e'
						
						mps_filename=TRIM(mod_residue_name)//'_'//TRIM(charge_name)//'.mps'
						filename=TRIM(foldername)//'/'//TRIM(mps_filename)
						INQUIRE(file=TRIM(filename),exist=Datei_vorhanden)
						IF( .NOT. Datei_vorhanden) THEN
							molA=TRIM(mod_residue_name)
							g09inputline=" PBE1PBE/6-31G*  SCF(XQC,MaxConventionalCycles=600,MaxCycle=1200) " 
							g09inputline=TRIM(g09inputline)//" pop(full,CHelpG) polar(dipole) nosymm punch=mo IOp(6/7=3) "
							calculation_method="PBE0_6-31Gs"
							CALL make_coord_to_g09_charged_inp(elements,koord,NAtoms,calculation_method,&
								&g09inputline,molA,0,0,i,NCPUS,Mem)
							WRITE(*,*) "New g09_to_mps.inp file created for: "//TRIM(molA)
						END IF ! orbs Datei_vorhanden
					END DO  ! charge states for mps files
		ELSE
						WRITE(*,*) 'Warning: MP_FILES folder does not exist. No g09.inp file produced.'					
		END IF !  folder_vorhanden			
	END IF ! make_g09_for_mps
	
	
END SUBROUTINE make_geo_orbs_mps_g09




SUBROUTINE make_coord_to_g09_charged_inp(atomsorte,koord,MAXATM,calculation_method,&
                &g09inputline,molA,trajstep,Numcharged,charge,NCPUS,Mem)
    !! creates g09.inp files for a given geometry
    use small_functions
    IMPLICIT NONE
    Integer, INTENT (IN):: MAXATM,charge,trajstep,Numcharged,NCPUS,Mem
    Real, Dimension(MAXATM,3), INTENT (IN) :: koord
    Character(5), Dimension(MAXATM), INTENT(IN) :: atomsorte
    Character(500), INTENT (IN) :: molA
    Character(500),INTENT (IN) :: calculation_method,g09inputline
    Character(500) ::filename
    Character(2) ::charge_name
    Integer :: i,ierror,multiplicity
    LOGICAL::file_available=.false.
    
    IF(charge < 0) THEN
        charge_name='el'
        multiplicity=2
    ELSE IF(charge == 0 ) THEN    
        charge_name='n'
        multiplicity=1
    ELSE
        charge_name='lo'
        multiplicity=2
    END IF
    filename='SCF_'//TRIM(molA)//'_'//TRIM(charge_name)//'_'//TRIM(calculation_method)&
                       &//'_G'//TRIM(str(trajstep))//'_N'//TRIM(str(Numcharged))//'.inp'
    
    INQUIRE(file=TRIM(filename),exist=file_available)
    IF (.NOT. file_available) THEN
		OPEN(UNIT=78,FILE=TRIM(filename),STATUS='REPLACE',IOSTAT=ierror)
		  
		write(78,*) '%NProcShared='//TRIM(str(NCPUS))
		write(78,*) '%Mem='//TRIM(str(Mem))//'GB'
		write(78,*) '# '//TRIM(g09inputline)//' NoSymm ' 
		write(78,*) '# GFINPUT 6D 10F' 
		write(78,*) ' '
		write(78,*) ' with '//TRIM(filename) 
		write(78,*) ' '
		write(78,*) TRIM(str(charge))//'  '//TRIM(str(multiplicity))
				DO i=1,MAXATM
						write(78,'(2X,A3,1X,3F16.6)') atomsorte(i),koord(i,1),koord(i,2),koord(i,3)
				END DO 
		write(78,*) ' '
		CLOSE(78)
	END IF ! file exists

END SUBROUTINE make_coord_to_g09_charged_inp 


FUNCTION countsubstring(s1, s2) result(c)
	!!  counts number of substrings s2 in a string s1
        !!  n = countsubstring("the three truths", "th")
 	!!  => n=3
	  character(*), intent(in) :: s1, s2
	  integer :: c, p, posn
	 
	  c = 0
	  if(len(s2) == 0) return
	  p = 1
	  do 
	    posn = index(s1(p:), s2)
	    if(posn == 0) return
	    c = c + 1
	    p = p + posn + len(s2)
	  end do
END FUNCTION countsubstring


!!!!!!!!!!!!! START SUBROUTINES FOR PPDI / PBDT-TS1!!!!!!!!!!
INTEGER FUNCTION PBDT_TS1_sequence_to_index(sequence)
	!! index to access the reference lambda value
	CHARACTER(LEN=50), INTENT(IN)::sequence
	LOGICAL::DEBUG=.false.
	INTEGER::i
	
	IF( TRIM(adjustl(sequence)) == 'A') THEN
		i=2
	ELSE IF ( TRIM(adjustl(sequence)) == 'B')THEN
		i=3
	ELSE IF ( (TRIM(adjustl(sequence)) == 'AB') .OR. (TRIM(adjustl(sequence)) == 'BA') )THEN
		i=4
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABA')THEN
		i=5
	ELSE IF ( TRIM(adjustl(sequence)) == 'BAB')THEN
		i=6		
	ELSE IF ( (TRIM(adjustl(sequence)) == 'ABAB') .OR. (TRIM(adjustl(sequence)) == 'BABA') )THEN
		i=7	
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABABA')THEN
		i=8		
	ELSE IF ( TRIM(adjustl(sequence)) == 'BABAB')THEN
		i=9		
	ELSE IF ( (TRIM(adjustl(sequence)) == 'ABABAB') .OR. (TRIM(adjustl(sequence)) == 'BABABA') )THEN
		i=10	
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABABABA')THEN
		i=11		
	ELSE IF ( TRIM(adjustl(sequence)) == 'BABABAB')THEN
		i=12			
	ELSE IF ( (TRIM(adjustl(sequence)) == 'ABABABAB') .OR. (TRIM(adjustl(sequence)) == 'BABABABA') )THEN
		i=13		
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABABABABA')THEN
		i=14		
	ELSE IF ( TRIM(adjustl(sequence)) == 'BABABABAB')THEN
		i=14
	ELSE IF ( (TRIM(adjustl(sequence)) == 'ABABABABAB') .OR. (TRIM(adjustl(sequence)) == 'BABABABABA') )THEN
		i=15
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABABABABABA')THEN
		i=15		
	ELSE IF ( TRIM(adjustl(sequence)) == 'BABABABABAB')THEN
		i=15
	ELSE IF ( (TRIM(adjustl(sequence)) == 'ABABABABABAB') .OR. (TRIM(adjustl(sequence)) == 'BABABABABABA') )THEN ! 6mer
		i=16
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABABABABABABA')THEN ! 6mer
		i=16		
	ELSE IF ( TRIM(adjustl(sequence)) == 'BABABABABABAB')THEN ! 7mer
		i=17	
	ELSE IF ( (TRIM(adjustl(sequence)) == 'ABABABABABABAB') .OR. (TRIM(adjustl(sequence)) == 'BABABABABABABA') )THEN ! 7mer
		i=17
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABABABABABABABA')THEN ! 7mer
		i=17		
	ELSE IF ( TRIM(adjustl(sequence)) == 'BABABABABABABAB')THEN ! 8mer
		i=17
	ELSE IF ( (TRIM(adjustl(sequence)) == 'ABABABABABABABAB') .OR. (TRIM(adjustl(sequence)) == 'BABABABABABABABA') )THEN ! 8mer
		i=17
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABABABABABABABABA')THEN								  
		i=17		
	ELSE IF ( TRIM(adjustl(sequence)) == 'BABABABABABABABAB')THEN
		i=17					
	ELSE IF ( TRIM(adjustl(sequence)) == 'PPDI' .OR. TRIM(adjustl(sequence)) == 'PPDI_') THEN
		i=1
	ELSE
		WRITE(*,*) 'Error: string input to PBDT_TS1_sequence_to_index was not determined: '//TRIM(sequence)
		CALL EXIT (1)
	END IF
	IF (DEBUG) WRITE(*,*) 'PBDT_TS1_sequence_to_index sequence:   ',TRIM(sequence),' index:',i	
	PBDT_TS1_sequence_to_index=i
	
END FUNCTION PBDT_TS1_sequence_to_index


INTEGER FUNCTION seq_to_k_ind(sequence,fin)
	!! Subroutine to determine the k index, when given the polymer sequence of PDBT-TS1 /PPDI 
	!! input  :: sequence = 'ABABAB', fin='M' (middle segment)
	!! output :: k = 7
	CHARACTER(LEN=20), INTENT(IN) ::  sequence
	CHARACTER(LEN=1), INTENT(IN)  :: fin
	INTEGER::k,N_A,N_B
	k=0
	N_A=countsubstring(sequence, 'A')
	N_B=countsubstring(sequence, 'B')
	
	IF( INDEX(sequence,'PPDI') /= 0) THEN
		k=1
	ELSE IF (fin == 'M') THEN
		IF( sequence(1:1) == 'A') THEN
			k=N_A+N_B+1
		ELSE 
			k=N_A+N_B+16
		END IF
	ELSE IF (fin == 'S') THEN
		IF( sequence(1:1) == 'A') THEN
			k=N_A+N_B+31
		ELSE 
			k=N_A+N_B+46
		END IF
	ELSE IF (fin == 'E') THEN
		IF( sequence(1:1) == 'A') THEN
			k=N_A+N_B+61
		ELSE 
			k=N_A+N_B+76
		END IF
	ELSE IF ( (N_A==8) .AND. (N_B==8))THEN
		k=92
	END IF
	seq_to_k_ind=k
END FUNCTION seq_to_k_ind



!!!!!!!!!!!!! END SUBROUTINES FOR PPDI / PBDT-TS1!!!!!!!!!!




!!!!!!!!!!!!!!! START make_min_d_COM_vector_list !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
!!! subroutine which  calculates the center of masses for subhopping sites on DIPBI, P3HT, PPDI, PBDT_TS1
!!! min_d_modus = COM, MA, MMA, RCOM
!!! It also sets a new data structure for system_d using a module
SUBROUTINE make_min_d_COM_vector_list(min_d_modus,min_d_COM_arr,system,N_Resids,R_u_I,MAXATM,residue_number,&
				  & residue_names,atom,koordA, neighbourlist_filename,gro_inputfile,N_DIPBI,N_P3HT,N_PPDI,N_PBDT_TS1,N_Species,&
				  & N_Neighbours,neighbour_list_Res,x_box,y_box,z_box)
	use small_functions
	use Molecule_class
	IMPLICIT NONE
	!!! local array with minimum distance list  
	CHARACTER(500)                       , INTENT(IN)        :: min_d_modus
	REAL, ALLOCATABLE, DIMENSION (:,:,:) , INTENT(OUT)       :: min_d_COM_arr
	INTEGER, INTENT(IN)                                      :: MAXATM,N_Resids
	INTEGER, DIMENSION(N_Resids+1,2), INTENT(IN)             :: R_u_I
	REAL,        DIMENSION(MAXATM,3), INTENT(IN)             :: koordA
	CHARACTER(LEN=5), DIMENSION(MAXATM), INTENT(IN)          :: residue_names,atom
	INTEGER         , DIMENSION(MAXATM), INTENT(IN)          :: residue_number
	INTEGER, INTENT(IN) ::N_DIPBI,N_P3HT,N_PPDI,N_PBDT_TS1
	CHARACTER(LEN=500), INTENT(IN)                             ::gro_inputfile,neighbourlist_filename
	INTEGER, ALLOCATABLE, DIMENSION(:,:), INTENT(OUT)        ::neighbour_list_Res
	REAL , INTENT(IN)   ::x_box,y_box,z_box
	INTEGER, INTENT(OUT)  ::N_Neighbours
	!!!!!!!!!!!! contains all system information after initialization
	type (system_t) , INTENT(INOUT):: system

	!!! read d_COM of neighbours
	REAL, ALLOCATABLE, DIMENSION(:,:)::neighbour_list_COM
	!!! DIPBI
	CHARACTER(LEN=5), ALLOCATABLE, DIMENSION(:)  :: DIPBI_atom
	REAL, ALLOCATABLE, DIMENSION(:,:)            :: DIPBI_koord,DIPBI_COM
	!! P3HT
	REAL, DIMENSION(6,3) ::Ringe_atome
	CHARACTER(5), DIMENSION(6) :: Ringe_atomsorte
	REAL, ALLOCATABLE, DIMENSION(:,:)::P3HT_COM
	!! PPDI
	CHARACTER(LEN=5), ALLOCATABLE, DIMENSION(:)      :: PPDI_atom
	REAL, ALLOCATABLE, DIMENSION(:,:)    		 :: PPDI_koord,PPDI_COM	
	!! PBDT_TS1
	CHARACTER(LEN=5), ALLOCATABLE, DIMENSION(:)      :: CarboxyS2_atom, PBDT_atom
	REAL, ALLOCATABLE, DIMENSION(:,:)                :: CarboxyS2_koord,PBDT_koord,PBDT_TS1_COM		
	INTEGER, ALLOCATABLE, DIMENSION(:)	:: ind_CarboxyS2,ind_PBDT
	!! Other species, all atoms are inclueded in COM determination
	INTEGER::N_Species,m_Spec
	CHARACTER(LEN=5), ALLOCATABLE, DIMENSION(:)  :: Spec_atom
	REAL, ALLOCATABLE, DIMENSION(:,:)    		 :: Spec_koord,Spec_COM	
	!! variables to determine nearest neighbour vector between (sub)-hopping sites.
	REAL, DIMENSION (3) ::dist_vec, dist_vec_min, d_MA, d_MMA
	REAL::norm_dist_vec, norm_dist_vec_min
	INTEGER::molAid,molBid,ResidA,ResidB,i_offset
	
	INTEGER :: n_local_sites
	REAL :: MA, MMA
	CHARACTER(LEN=500)  ::COM_filename
	REAL, DIMENSION(3)  ::COM,COM_A,COM_B
	INTEGER::N_Schwefel_all,m_CarboxyS2,m_PBDT,n_CarboxyS2,n_PBDT
	INTEGER::i,j,k,k_max,l,l_max,m,ierror,i_resid,i_COM,ind,indS,N_mini_sites
	LOGICAL::gro_format,print_COM_molecules_to_xyz=.true.
	LOGICAL:: DEBUG
	
	DEBUG=.false.
	print_COM_molecules_to_xyz=.true.
	IF(DEBUG)	WRITE(*,*) 'start:   make_min_d_COM_vector_list: N_Neighbours: ',N_Neighbours
	! Einlesen der Daten aus der Nachbarschaftsliste
	IF( .NOT. allocated(neighbour_list_Res)) THEN
			ALLOCATE(neighbour_list_COM(N_Resids,N_Neighbours+1))
			ALLOCATE(neighbour_list_Res(N_Resids,N_Neighbours+1))
			CALL Read_neighbourlist(neighbourlist_filename,N_Resids,N_Neighbours,neighbour_list_COM,neighbour_list_Res)
	END IF
	
N_Schwefel_all=0
DO j=1,MAXATM
				IF (TRIM(adjustl(atom(j)))=='S') THEN
					N_Schwefel_all=N_Schwefel_all+1
				ELSE IF (TRIM(adjustl(atom(j)))=='S-S_R') THEN
					N_Schwefel_all=N_Schwefel_all+1
				ELSE IF (atom(j)(1:1)=='S') THEN
					N_Schwefel_all=N_Schwefel_all+1
				ENDIF
END DO

IF (N_P3HT /= 0)  THEN
	N_mini_sites=N_Schwefel_all
ELSE IF (N_PBDT_TS1 /= 0) THEN
	N_mini_sites=464*(8+8)
	n_local_sites=16 !! Maximum Number of segments A and B
ELSE
	N_mini_sites=0
END IF

WRITE(*,*) "N_mini_sites:", N_mini_sites

IF( (N_mini_sites /= 416*32) .AND. (N_P3HT /= 0) ) THEN
	WRITE(*,*) '# S atoms: ',N_Schwefel_all
	WRITE(*,*) 'Only for 416 P3HT in the box!'
	CALL EXIT(1)
ELSE IF( (N_mini_sites /= 464*(8+8)) .AND. (N_PBDT_TS1 /= 0) ) THEN
	WRITE(*,*) '# S atoms: ',N_Schwefel_all
	WRITE(*,*) 'Only for 464 PBDT_TS1 in the box!'
	CALL EXIT(1)
ELSE
	WRITE(*,*) ' N_DIPBI: ',N_DIPBI,' N_P3HT: ',N_P3HT,' N_PPDI: ',N_PPDI,' N_PBDT_TS1: ',N_PBDT_TS1,' N_Species:',N_Species
END IF

IF (        TRIM(ADJUSTL(min_d_modus)) == 'COM' .OR. TRIM(ADJUSTL(min_d_modus)) == 'MA'  & 
	 & .OR. TRIM(ADJUSTL(min_d_modus)) == 'MMA' .OR. TRIM(ADJUSTL(min_d_modus)) == 'RCOM' &
	 & .OR. TRIM(ADJUSTL(min_d_modus)) == 'd_COM' .OR. TRIM(ADJUSTL(min_d_modus)) == 'd_MA'  & 
	 & .OR. TRIM(ADJUSTL(min_d_modus)) == 'd_MMA' .OR. TRIM(ADJUSTL(min_d_modus)) == 'd_RCOM' ) THEN
	WRITE(*,*) 'Selected distance modus: ', TRIM(min_d_modus)
ELSE
	WRITE(*,*) 'Error: The min_d_modus is not available: ', TRIM(min_d_modus)
	WRITE(*,*) '       Select  min_d_modus = [COM, MA, MMA, RCOM]      '
	CALL EXIT(1)
END IF

i_resid=0
!! Get COM for centers nur fur DIPBI
IF( N_DIPBI /= 0 ) THEN
		!! Center of Masses in DIPBI subunits
		ALLOCATE(DIPBI_COM(N_DIPBI,3))
		ALLOCATE(DIPBI_koord(74,3))
		ALLOCATE(DIPBI_atom(74))
                
		i_COM=0   ! index fuer die Anzahl der Schwerpunkt von DIPBI
		DO i=1,MAXATM
			IF(  ((i == 1) .OR. (residue_number(i) /= residue_number(i-1))) .AND. & !New resid 
			&	  ((TRIM(adjustl(residue_names(i)))=='DIPBI') .OR. (TRIM(adjustl(residue_names(i)))=='DPBIK') &
			& .OR. (TRIM(adjustl(residue_names(i)))=='dipbi')) )THEN ! New DIPBI			
					i_COM=i_COM+1
					DO k=1,74
									DIPBI_atom(k)=atom(i+k-1)
                        	        DIPBI_koord(k,1:3)=koordA(i+k-1,1:3)
                    END DO !k
					CALL Massenschwerpunkt(DIPBI_atom,DIPBI_koord,74,COM,.false.)
                    DIPBI_COM(i_COM,:)=COM(:)
                    
                    !!!! ADD data to system
					!!!                 system,residA,NAtomsA,resnameA,molnameA,koordA,elementsA
					i_resid=i_resid+1
					call make_new_molecule_for_system(system,R_u_I(i_resid,1),R_u_I(i_resid+1,2)-R_u_I(i_resid,2),residue_names(R_u_I(i_resid,2))&
				&,residue_names(R_u_I(i_resid,2)),koordA(R_u_I(i_resid,2):R_u_I(i_resid+1,2)-1,1:3),atom(R_u_I(i_resid,2):R_u_I(i_resid+1,2)-1))
					call set_COM_in_Molecule(system%molecules(i_resid),COM(1),COM(2),COM(3))
					call set_COM_in_Hoppingsite(system%molecules(i_resid)%hoppingsite,COM(1),COM(2),COM(3))
			END IF ! new DIPBI ?
		END DO ! loop all atoms
				
		IF (i_COM /= N_DIPBI) THEN
			WRITE(*,*) 'Error: Missmatch in number of evaluated DIPBI: ',i_COM,' N_DIPBI:',N_DIPBI
			CALL EXIT(1)
		END IF		
END IF !N_DIPBI



!! Get COM for centers nur fur P3HT
IF( N_P3HT /= 0 ) THEN
				!! Center of Masses in thiophene subunits
				IF(DEBUG) WRITE(*,*) 'START P3HT  N_mini_sites:',N_mini_sites
                ALLOCATE(P3HT_COM(N_mini_sites,3))
                ind=0 		! index fur die Atome in den Ringen von Mol A
				i_COM=0   ! index fuer die Anzahl der Schwerpunkt von A
                DO i=1,MAXATM

						IF ( (TRIM(adjustl(residue_names(i)(1:2)))=='PH') .OR. (TRIM(adjustl(residue_names(i)(1:2)))=='PM' ) .OR. &
						&    (TRIM(adjustl(residue_names(i)(1:2)))=='P3') .OR. (TRIM(adjustl(residue_names(i)(1:3)))=='THP') ) THEN  !!! FIND P3HT/P3MT/THP
							IF( (i == 1) .OR. (residue_number(i) /= residue_number(i-1)) ) THEN ! New segment AND P3HT segment
									!WRITE(*,*) 'TMP:',residue_number(i),residue_names(i)
									!!!! ADD data to system
									!!!                 system,residA,NAtomsA,resnameA,molnameA,koordA,elementsA
									i_resid=i_resid+1
									call make_new_molecule_for_system(system,R_u_I(i_resid,1),R_u_I(i_resid+1,2)-R_u_I(i_resid,2),&
									&residue_names(R_u_I(i_resid,2)),residue_names(R_u_I(i_resid,2)),&
									&koordA(R_u_I(i_resid,2):R_u_I(i_resid+1,2)-1,1:3),atom(R_u_I(i_resid,2):R_u_I(i_resid+1,2)-1))						 
							END IF !!! add new segment
                
							!!! Evaluate sub-unit Center of Masses and add them to sub-Hopping-sites
							IF( (TRIM(adjustl(atom(i)))=='S') .OR. (TRIM(adjustl(atom(i)))=='S-S_R') )THEN
									DO j=(i-5),i,1
											ind=ind+1
											Ringe_atomsorte(ind)=atom(j)
											Ringe_atome(ind,:)=koordA(j,:)
											!WRITE(*,*) ind,'Ringsystem: ',Ringe_atomsorte(ind),Ringe_atome(ind,:)
									END DO
									! Abspeichern des COM des Ringes
									IF (ind == 6) THEN
											! Korrektur, wenn das Ende der THP Kette erreicht ist, da hier die Reihung geaendert ist,
											! ersetze End HC durch CA in der Liste 
											IF( (TRIM(adjustl(atom(i-1)))=='H') .OR. (TRIM(adjustl(atom(i-1)))=='HC') .OR.&
													& (TRIM(adjustl(atom(i-1)))=='H-H_') ) THEN
													Ringe_atomsorte(5)=atom(j-7)
													Ringe_atome(5,:)=koordA(j-7,:)
													!WRITE(*,*) 'Ersetzt CA:', Ringe_atomsorte(5),Ringe_atome(5,:)
											END IF

											ind=0
											i_COM=i_COM+1
											CALL Massenschwerpunkt(Ringe_atomsorte,Ringe_atome,6,COM,.false.)
											P3HT_COM(i_COM,:)=COM(:)
											!!! Add subhoppingsite to molecule
											call make_new_subhoppingsite_for_hoppingsite(system%molecules(i_resid)%hoppingsite,COM)
									END IF ! calc COM_1
							END IF !!! END  Evaluate sub-unit Center of Masses and add them to sub-Hopping-sites     
                        
							IF ( i == R_u_I(i_resid+1,2)-1) THEN !!! Last atom in segment
													!!! Select COM from subsegment COMs
													!!! set middle segment as COM for all with selected id = N_subhoppingsites/2+1
													ind=int(int(system%molecules(i_resid)%hoppingsite%N_subhoppingsites)/2+1)
													COM=system%molecules(i_resid)%hoppingsite%subhoppingsite(ind)%koord(1:3)  
													call set_COM_in_Molecule(system%molecules(i_resid),COM(1),COM(2),COM(3))
													call set_COM_in_Hoppingsite(system%molecules(i_resid)%hoppingsite,COM(1),COM(2),COM(3))      
													ind=0     
													!WRITE(*,*) ' This COM ',i_resid,' was added to the hopping site !', COM               
							END IF      !!! Last atom in segment        
                                                
                        ENDIF !P3HT/P3MT/THP found
                END DO ! i=,1,MAXATM
                         
                
 				IF (i_COM /= N_mini_sites) THEN
					WRITE(*,*) 'Error: Missmatch in number of evaluated P3HT: ',i_COM,' N_mini_sites: ', N_mini_sites
					CALL EXIT(1)
				END IF
          
END IF


!! Get COM for centers nur fur PPDI
IF( N_PPDI /= 0 ) THEN
				!! Center of Masses in PPDI subunits, PPDI ohne Seitenketten!
                ALLOCATE(PPDI_COM(N_PPDI,3))
                ALLOCATE(PPDI_koord(76,3))
                ALLOCATE(PPDI_atom(76))
                
				i_COM=0   ! index fuer die Anzahl der Schwerpunkt von DIPBI
                DO i=1,MAXATM
					IF( (TRIM(adjustl(residue_names(i)(1:4)))=='PPDI') .AND. ( (i == 1) .OR. (residue_number(i) /= residue_number(i-1)) ) )THEN ! New PPDI
						i_COM=i_COM+1
						 
						IF( TRIM(adjustl(atom(i)(1:1))) == 'N' ) THEN !!Koordinaten an neuen Array übergeben nicht die Seitenketten! N=1 wurde vorher schon abgeschnitten 
							ind=-1 ! Starte mit N atom an position 1
						ELSE ! Seitenkette ueberspringen starte mit atom 7
							ind=6
						END IF
						DO k=1,76
									PPDI_atom(k)=atom(i+k+ind)
                                    PPDI_koord(k,1:3)=koordA(i+k+ind,1:3)
                        END DO
						CALL Massenschwerpunkt(PPDI_atom,PPDI_koord,76,COM,.false.)
                        PPDI_COM(i_COM,:)=COM(:)	
                        

						!!!! ADD data to system
						!!!                 system,residA,NAtomsA,resnameA,molnameA,koordA,elementsA
						i_resid=i_resid+1
						call make_new_molecule_for_system(system,R_u_I(i_resid,1),R_u_I(i_resid+1,2)-R_u_I(i_resid,2),&
						&residue_names(R_u_I(i_resid,2)),residue_names(R_u_I(i_resid,2)),&
						&koordA(R_u_I(i_resid,2):R_u_I(i_resid+1,2)-1,1:3),atom(R_u_I(i_resid,2):R_u_I(i_resid+1,2)-1))
					
						call set_COM_in_Molecule(system%molecules(i_resid),COM(1),COM(2),COM(3))
						call set_COM_in_Hoppingsite(system%molecules(i_resid)%hoppingsite,COM(1),COM(2),COM(3))     
											                   	
					END IF ! new PPDI ?
				END DO ! loop all atoms
				
				IF (i_COM /= N_PPDI) THEN
					WRITE(*,*) 'Error: Missmatch in number of evaluated PPDI'
					CALL EXIT(1)
				END IF		
				
				write(*,*) 'PPDI loaded for make_min_d_COM_vector_list.'
END IF !N_PPDI



!! Get COM for centers just for PBDT_TS1
!! No H-Atoms adde before.
IF( N_PBDT_TS1 /= 0 ) THEN 
		!! Center of Masses in thiophene subunits
				write(*,*) 'PBDT_TS1 load ...'
                ALLOCATE(PBDT_TS1_COM(N_mini_sites,3))
                m_CarboxyS2=9
				ALLOCATE(CarboxyS2_koord(m_CarboxyS2,3))
				ALLOCATE(CarboxyS2_atom(m_CarboxyS2))
				ALLOCATE(ind_CarboxyS2(m_CarboxyS2))

                m_PBDT=16
				ALLOCATE(PBDT_koord(m_PBDT,3))
				ALLOCATE(PBDT_atom(m_PBDT))
				ALLOCATE(ind_PBDT(m_PBDT))
 			
				gro_format=.false.
				DO j=1,size(atom)/5	
					IF (TRIM(adjustl(atom(j)))=='CH3') gro_format=.true.
					IF (TRIM(adjustl(atom(j)))=='CH2') gro_format=.true.
					IF (TRIM(adjustl(atom(j)))=='CH1') gro_format=.true.
					IF (TRIM(adjustl(atom(j)))=='HC')  gro_format=.true.
					IF (TRIM(adjustl(atom(j)))=='NR')  gro_format=.true.
					IF (TRIM(adjustl(atom(j)))=='OE')  gro_format=.true.
					IF(gro_format) EXIT
				END DO ! find gro format ?
 			
				IF ( gro_format) THEN
					! gro format
					ind_CarboxyS2= (/ 1,2,3,4,5,12,13,14,15 /)
					ind_PBDT= (/ 1,2,3,4,5, 14,15,16,17, 26,27,28,29,30,31,32 /)

				ELSE ! H atoms added 
					ind_CarboxyS2= (/ 1,2,3,4,5,19,20,21,22 /)
					ind_PBDT= (/ 1,2,3,4,5, 17,18,19,20, 32,33,34, 35,36,37,38/)
				END IF
				
				write(*,*) 'tmp: gro_format, ',gro_format
                ind=0 		! index fur die Atome in den Ringen von Mol A
				i_COM=0     ! index fuer die Anzahl der Schwerpunkt von A
				DO l=1,N_Resids
					DO i=R_u_I(l,2),R_u_I(l+1,2)-1  ! atom indizes in single resids
							IF( (.NOT. gro_format) .AND. &
							&( (TRIM(adjustl(residue_names(i)(1:1)))=='A') .OR. (TRIM(adjustl(residue_names(i)(1:1)))=='B') )) THEN
										! NEUES SEGMENT POSITION 
										IF(i==R_u_I(l,2)) THEN
												!!!! ADD data to system
												!!!                 system,residA,NAtomsA,resnameA,molnameA,koordA,elementsA
												i_resid=i_resid+1
												call make_new_molecule_for_system(system,R_u_I(i_resid,1),R_u_I(i_resid+1,2)-R_u_I(i_resid,2),&
													&residue_names(R_u_I(i_resid,2)),residue_names(R_u_I(i_resid,2)),&
													&koordA(R_u_I(i_resid,2):R_u_I(i_resid+1,2)-1,1:3),atom(R_u_I(i_resid,2):R_u_I(i_resid+1,2)-1))  										
												
												!!! START and determine subsegment COMs
												READ(residue_names(i)(2:2),'(I10)') n_CarboxyS2   
												READ(residue_names(i)(4:4),'(I10)') n_PBDT
												ind=0 
												DO WHILE ( n_CarboxyS2 + n_PBDT > 0)
												
														IF( ind /= 0 .OR. (TRIM(adjustl(residue_names(i)(1:1)))=='A') ) THEN 
															! segment A
															DO k=1,m_CarboxyS2
																!! select the index j = i_startindex_resid   +  ind_start_index_sub_segment  + ind_atom_in_CarboxyS2 inside the ring system selected via  ind_CarboxyS2(k) , where m_CarboxyS2 is the number of atom in the selecte ring-subsystem 
																j = i+ ind + ind_CarboxyS2(k)
																CarboxyS2_koord(k,1:3)=koordA(j,1:3) 
																CarboxyS2_atom(k)=atom(j)
														
															END DO !k
															ind=ind+ind_CarboxyS2(m_CarboxyS2)
															
															i_COM=i_COM+1
															CALL Massenschwerpunkt(CarboxyS2_atom,CarboxyS2_koord,m_CarboxyS2,COM,.false.)
															PBDT_TS1_COM(i_COM,:)=COM(:)
															IF(DEBUG) WRITE(*,*) 'COM_A',COM
															!!! Add subhoppingsite to molecule
															call make_new_subhoppingsite_for_hoppingsite(system%molecules(i_resid)%hoppingsite,COM)
															
															n_CarboxyS2=n_CarboxyS2-1
														END IF ! find segment A
														
														IF(n_CarboxyS2==0 .AND. n_PBDT==0 ) EXIT
														IF(DEBUG) WRITE(*,*) 'START PBDT'
														! segment B
														DO k=1,m_PBDT
																j= i + ind + ind_PBDT(k)
																PBDT_koord(k,1:3)=koordA(j,1:3)
																PBDT_atom(k)=atom(j)
														END DO !k
														ind=ind+ind_PBDT(m_PBDT)
																							
														i_COM=i_COM+1
														CALL Massenschwerpunkt(PBDT_atom,PBDT_koord,m_PBDT,COM,.false.)
														PBDT_TS1_COM(i_COM,:)=COM(:)
														IF(DEBUG) WRITE(*,*) 'COM_B',COM
														!!! Add subhoppingsite to molecule
														call make_new_subhoppingsite_for_hoppingsite(system%molecules(i_resid)%hoppingsite,COM)														
														
														n_PBDT=n_PBDT-1
													
												END DO ! WHILE loop all mini segments in Resid
												
												!!! Select COM from subsegment COMs
												!!! set middle segment as COM for all with selected id = N_subhoppingsites/2+1
												indS=int(int(system%molecules(i_resid)%hoppingsite%N_subhoppingsites)/2+1)
												COM=system%molecules(i_resid)%hoppingsite%subhoppingsite(indS)%koord(1:3)   
												call set_COM_in_Molecule(system%molecules(i_resid),COM(1),COM(2),COM(3))
												call set_COM_in_Hoppingsite(system%molecules(i_resid)%hoppingsite,COM(1),COM(2),COM(3))   
																																			
												IF(DEBUG) THEN
													WRITE(*,*) 'N_subhoppingsites: ',system%molecules(i_resid)%hoppingsite%N_subhoppingsites						
													call print_molecule_xyz(system%molecules(i_resid))
													WRITE(*,*) 'Final Selected Hopping site: Ag',system%molecules(i_resid)%hoppingsite%COM(1:3)
												END IF !DEBUG
															
									 END IF  !i==R_u_I(l,2) segmentstart 	
							
							ELSE IF( (TRIM(adjustl(residue_names(i)(1:5)))=='8poly') ) THEN  !!!! DETERMINATION FOR gromacs data input format.
							
										IF(    ((TRIM(adjustl(atom(i)))=='CH3') .AND. (TRIM(adjustl(atom(i-1)))=='CH3'))  &
											& .AND. ( (i == 1) .OR. (residue_number(i) /= residue_number(i-1)) ) .OR.	  &
											&  ((TRIM(adjustl(atom(i)))=='CH3') .AND. (TRIM(adjustl(atom(i-1)(1:4))) =='PPDI')) )THEN ! New PDBT_TS1 chains start
												if(debug) write(*,*) ' START NEW CHAIN '
												!! New chain start => Then evaluate data for entire chain
												!!
												!! Number of local sites (AB)_8 = 16  n_local_sites
												n_local_sites=16
												ind=0   
												DO WHILE ( n_local_sites > 0 ) 
													!!!! ADD data to system
													!!!                 system,residA,NAtomsA,resnameA,molnameA,koordA,elementsA
													i_resid=i_resid+1
													call make_new_molecule_for_system(system,R_u_I(i_resid,1),R_u_I(i_resid+1,2)-R_u_I(i_resid,2),&
														&residue_names(R_u_I(i_resid,2)),residue_names(R_u_I(i_resid,2)),&
														&koordA(R_u_I(i_resid,2):R_u_I(i_resid+1,2)-1,1:3),atom(R_u_I(i_resid,2):R_u_I(i_resid+1,2)-1))  		
																								
													
													loop_m: DO m=1,16    ! segments
															if (MOD(n_local_sites,2) .eq. 0) then ! gerade anzahl des index  => Segment type A
																n_local_sites = n_local_sites - 1
																! segment A
																DO k=1,m_CarboxyS2
																	j= i + ind + ind_CarboxyS2(k)
																	CarboxyS2_koord(k,1:3)=koordA(j,1:3) 
																	CarboxyS2_atom(k)=atom(j)
																END DO 
																ind=ind+ind_CarboxyS2(m_CarboxyS2)
																
																i_COM=i_COM+1
																CALL Massenschwerpunkt(CarboxyS2_atom,CarboxyS2_koord,m_CarboxyS2,COM,.false.)
																PBDT_TS1_COM(i_COM,:)=COM(:)
																if(debug) WRITE(*,*) j,R_u_I(i_resid+1,2),ind,n_local_sites+1,i_resid,i_COM,'COM_A ',COM,atom(j),koordA(j,1:3) 
																!!! Add subhoppingsite to molecule
																CALL make_new_subhoppingsite_for_hoppingsite(system%molecules(i_resid)%hoppingsite,COM)	
																IF ( j == R_u_I(i_resid+1,2)-1 .OR. j == R_u_I(i_resid+1,2)-2  ) THEN
																	
																	if(debug) write(*,*) 'Exit A ',j
																	EXIT loop_m
																ENDIF
															else  ! ungerade anzahl des index  => Segment type B	
																n_local_sites = n_local_sites - 1
																! segment B
																DO k=1,m_PBDT
																		j= i + ind + ind_PBDT(k)
																		PBDT_koord(k,1:3)=koordA(j,1:3)
																		PBDT_atom(k)=atom(j)
																END DO !k
																ind=ind+ind_PBDT(m_PBDT)
																									
																i_COM=i_COM+1
																CALL Massenschwerpunkt(PBDT_atom,PBDT_koord,m_PBDT,COM,.false.)
																PBDT_TS1_COM(i_COM,:)=COM(:)
																if(debug) WRITE(*,*) j,R_u_I(i_resid+1,2),ind,n_local_sites+1,i_resid,i_COM,'COM_B ',COM,atom(j),koordA(j,1:3) 
																!!! Add subhoppingsite to molecule
																!!! Add subhoppingsite to molecule
																CALL make_new_subhoppingsite_for_hoppingsite(system%molecules(i_resid)%hoppingsite,COM)		
																
																IF ( j == R_u_I(i_resid+1,2)-1 .OR. j == R_u_I(i_resid+1,2)-2  ) THEN
																	if(debug) write(*,*) 'Exit B ',j
																	EXIT loop_m
																ENDIF	
															endif !! n_local_sites = gerade oder ungerade -- also segment A oder B											
													END DO loop_m ! m=1,8 segments
												
												
													!!! Select COM from subsegment COMs
													!!! set middle segment as COM for all with selected id = N_subhoppingsites/2+1
													indS=int(int(system%molecules(i_resid)%hoppingsite%N_subhoppingsites)/2+1)
													COM=system%molecules(i_resid)%hoppingsite%subhoppingsite(indS)%koord(1:3)   
													call set_COM_in_Molecule(system%molecules(i_resid),COM(1),COM(2),COM(3))
													call set_COM_in_Hoppingsite(system%molecules(i_resid)%hoppingsite,COM(1),COM(2),COM(3))   
												
												END DO ! -> WHILE ( n_local_sites > 0 ) => loop entite chain 												


										END IF ! New PDBT_TS1 chains start

									END IF ! 8poly
									
							END DO ! i=,1,MAXATM in den Resid abschnitten
							
                   END DO ! l=1,N_Resids       
                
 				IF (i_COM /= N_mini_sites) THEN
					WRITE(*,*) 'Error: Missmatch in number of evaluated PBDT_TS1: ',i_COM,' N_mini_sites: ', N_mini_sites
					CALL EXIT(1)
				END IF   
				
				write(*,*) 'PBDT_TS1 loaded for make_min_d_COM_vector_list.'      
END IF ! N_PBDT_TS1





IF((N_DIPBI == 0) .AND. (N_PPDI==0) .AND. (N_P3HT==0) .AND. (N_PBDT_TS1==0)) THEN
	N_Species=(size(R_u_I(:,:))-2)/2
	IF( N_Species /= 0 ) THEN 
					ALLOCATE(Spec_COM(N_Species,3))
					i_COM=0     ! index fuer die Anzahl der Schwerpunkt von A			    
					DO i=1,N_Species
						m_Spec=R_u_I(i+1,2)-R_u_I(i,2)
						ALLOCATE(Spec_koord(m_Spec,3))
						ALLOCATE(Spec_atom(m_Spec))
						ind=0
						DO k=R_u_I(i,2),R_u_I(i+1,2)-1
							ind=ind+1
							Spec_atom(ind)=atom(k)
							Spec_koord(ind,1:3)=koordA(k,1:3)
						END DO ! index 
						i_COM=i_COM+1
						CALL Massenschwerpunkt(Spec_atom,Spec_koord,m_Spec,COM,.false.)
						Spec_COM(i_COM,:)=COM(:)
						
						!!!! ADD data to system
						!!!                 system,residA,NAtomsA,resnameA,molnameA,koordA,elementsA
						i_resid=i_resid+1
						call make_new_molecule_for_system(system,R_u_I(i_resid,1),R_u_I(i_resid+1,2)-R_u_I(i_resid,2),&
							&residue_names(R_u_I(i_resid,2)),residue_names(R_u_I(i_resid,2)),&
							&koordA(R_u_I(i_resid,2):R_u_I(i_resid+1,2)-1,1:3),atom(R_u_I(i_resid,2):R_u_I(i_resid+1,2)-1))
							
						call set_COM_in_Molecule(system%molecules(i_resid),COM(1),COM(2),COM(3))
						call set_COM_in_Hoppingsite(system%molecules(i_resid)%hoppingsite,COM(1),COM(2),COM(3))    						
											
						DEALLOCATE(Spec_koord)
						DEALLOCATE(Spec_atom)
					END DO !  i=1,N_Species
	END IF ! N_Species
END IF ! No other Molecules


IF( print_COM_molecules_to_xyz) THEN

				COM_filename=trim(make_tmp_readfilename('COM_subHopping_sites_',gro_inputfile,0))//'.xyz'
				!COM_filename='tmp_COM_subHopping_sites_'//TRIM(gro_inputfile(:(INDEX(gro_inputfile, '.gro')-1)))//'.xyz'
				write(*,*) 'Hopping sites in COM_filename: ',trim(COM_filename)
				OPEN(UNIT=52,FILE=TRIM(COM_filename),STATUS='unknown',ACTION='write',IOSTAT=ierror)
				
				!!! COM to *.xyz
				WRITE(52,*) N_DIPBI+N_mini_sites+N_PPDI+N_Species
				WRITE(52,*) ' '
				IF( N_DIPBI /= 0 ) THEN
					DO i=1,N_DIPBI
						WRITE(52,*)  'Se ',DIPBI_COM(i,:)
					END DO 	
				ENDIF
                IF( N_P3HT /= 0 ) THEN
					DO i=1,N_mini_sites
							WRITE(52,*)  'F ',P3HT_COM(i,:)
					END DO 
				END IF
                DO i=1,N_PPDI
					WRITE(52,*)  'I ',PPDI_COM(i,:)
				END DO 
				IF(N_PBDT_TS1 /= 0 ) THEN
					DO i=1,N_mini_sites
						WRITE(52,*)  'Br ',PBDT_TS1_COM(i,:)
					END DO 
				END IF
				
				IF(N_Species /= 0 ) THEN
					DO i=1,N_Species
						WRITE(52,*)  'Cl ',Spec_COM(i_COM,:)
					END DO 
				END IF
				CLOSE(52)
END IF

!! Get the distance Vector between two centre of masse, in the reduced description. (e.g. Centre of ringes in polymer chain)
!! i =1,N_Resids,   j= 1=  Nearest neighbour_1,Nearest neighbour_2,Nearest neighbour_3...N_Neighbours      k= koordinates 1= dist_x,2=dist_y,3=dist_z  = COM_Resid2 - COM_Resid1 ;
!! 	min_d_COM_arr(i,1,1:3) = RCOM
!!  min_d_COM_arr(i,1,4) = ResidA  
!!  min_d_COM_arr(i,1,5) = ResidB 
!!  min_d_COM_arr(i,1,6) = norm_dist_vec_min 

WRITE(*,*) 'Start calculation for minimal |d_COM|=COM_B-COM_A nearest neighbours: ',N_Neighbours
ALLOCATE(min_d_COM_arr(N_Resids,N_Neighbours,6))

!init_hoppingpair_in_system(this,system)
i_offset=1-neighbour_list_Res(1,1)
min_d_COM_arr=0.0
DO i=1,N_Resids
	ResidA=neighbour_list_Res(i,1) 
	!min_d_COM_arr(i,1,4)=ResidA
	molAid=ResidA+i_offset
	DO j=1,N_Neighbours ! nearest neighbours
		ResidB=neighbour_list_Res(i,j+1) !NN
		!min_d_COM_arr(i,1,5)=ResidB
		molBid=ResidB+i_offset
		! dummy
		dist_vec_min=(/1000.0, 1000.0 ,1000./)
		norm_dist_vec_min=50000
		
		IF( TRIM(ADJUSTL(min_d_modus)) ==  'd_COM' .OR.  TRIM(ADJUSTL(min_d_modus)) == 'COM' )  THEN 
			!! Distance for the centre of mass between two molecules  d_COM = d_COM_B  - d_COM_A
			dist_vec_min=(system%molecules(molBid)%COM - system%molecules(molAid)%COM )
			norm_dist_vec_min = norm(dist_vec_min)
			
		ELSE IF( TRIM(ADJUSTL(min_d_modus)) ==  'd_MA'  .OR.  TRIM(ADJUSTL(min_d_modus)) ==  'MA' )  THEN 
			!! Distance for the minimal appearing distance d_MA = d_B - d_A
			call calc_min_dist_MA_dimer( &
				&system%molecules(molAid)%elementnames,system%molecules(molAid)%koordinates,system%molecules(molAid)%NAtoms,&
				&system%molecules(molBid)%elementnames,system%molecules(molBid)%koordinates,system%molecules(molBid)%NAtoms,MA,d_MA)
			norm_dist_vec_min=MA
			dist_vec_min=d_MA
			
		ELSE IF( TRIM(ADJUSTL(min_d_modus)) ==  'd_MMA' .OR.  TRIM(ADJUSTL(min_d_modus)) ==  'MMA' )  THEN 
			!! Distance for the mean minimal appearing distance d_MMA  = d_B - d_A
			CALL calc_mittlerer_minimal_Abstand_MMA_dimer(system%molecules(molAid)%koordinates,system%molecules(molAid)%NAtoms,&
					&system%molecules(molBid)%koordinates,system%molecules(molBid)%NAtoms,MMA,d_MMA)
			norm_dist_vec_min=MMA
			dist_vec_min=d_MMA
			
		ELSE IF( TRIM(ADJUSTL(min_d_modus)) ==  'd_RCOM' .OR.  TRIM(ADJUSTL(min_d_modus)) ==  'RCOM' )  THEN 
			!!! Calculate  d_RCOM the minimal distance between two sub-Hopping sites in the system
			
			!! Get the maximum mnumber of subhoppingsites in   A  => loop k_max
			IF(system%molecules(molAid)%hoppingsite%hasSubhoppingsite)THEN
				k_max=system%molecules(molAid)%hoppingsite%N_subhoppingsites    !k = N_subhoppingsites in A
			ELSE
				k_max=1
			END IF
			
			!! Get the maximum mnumber of subhoppingsites in   B => loop l_max
			IF(system%molecules(molBid)%hoppingsite%hasSubhoppingsite)THEN	
				l_max=system%molecules(molBid)%hoppingsite%N_subhoppingsites
			ELSE
				l_max=1
			END IF 
				
			
			DO k=1,k_max	
					!!! get COM for A 
					IF(k_max==1) THEN
						IF(system%molecules(molAid)%hoppingsite%hasCOM) THEN !hoppingsite%hasCOM
							COM_A=system%molecules(molAid)%hoppingsite%COM(1:3)
						ELSE !hoppingsite%hasCOM
							IF(system%molecules(molAid)%hasCOM) THEN
								COM_A=system%molecules(molAid)%COM(1:3)
							ELSE
								!! calc COM if not available for all coordinates
								CALL Massenschwerpunkt(atom(R_u_I(molAid,2):R_u_I(molAid+1,2)-1),&
										&koordA(R_u_I(molAid,2):R_u_I(molAid+1,2)-1,1:3),R_u_I(molAid+1,2)-R_u_I(molAid,2),COM,.false.)
									
								call set_COM_in_Molecule(system%molecules(molAid),COM(1),COM(2),COM(3))
								call set_COM_in_Hoppingsite(system%molecules(molAid)%hoppingsite,COM(1),COM(2),COM(3)) 
								COM_A=COM   								
							ENDIF !molecule%hasCOM
						ENDIF !hoppingsite%hasCOM
					ELSE !k_max=1
						COM_A=system%molecules(molAid)%hoppingsite%subhoppingsite(k)%koord(1:3)			
					END IF !k_max=1
					IF(DEBUG) WRITE(*,*) 'COM_A: ',COM_A						

					!!! get COM for B 	
					DO l=1,l_max
					!!! get COM for B 
							IF(l_max==1) THEN
									IF(system%molecules(molBid)%hoppingsite%hasCOM) THEN !hoppingsite%hasCOM
											COM_B=system%molecules(molBid)%hoppingsite%COM(1:3)
									ELSE !hoppingsite%hasCOM
											IF(system%molecules(molBid)%hasCOM) THEN
												COM_B=system%molecules(molBid)%COM(1:3)
											ELSE
												!! calc COM if not available for all coordinates
												call Massenschwerpunkt(atom(R_u_I(molBid,2):R_u_I(molBid+1,2)-1),&
														&koordA(R_u_I(molBid,2):R_u_I(molBid+1,2)-1,1:3),R_u_I(molBid+1,2)-R_u_I(molBid,2),COM,.false.)
													
												call set_COM_in_Molecule(system%molecules(molBid),COM(1),COM(2),COM(3))
												call set_COM_in_Hoppingsite(system%molecules(molBid)%hoppingsite,COM(1),COM(2),COM(3)) 
												COM_B=COM   								
											ENDIF !molecule%hasCOM
									ENDIF !hoppingsite%hasCOM
							ELSE !l_max=1
										COM_B=system%molecules(molBid)%hoppingsite%subhoppingsite(l)%koord(1:3)		

							END IF !l_max=1
							
							!!! Finally calc the distance vector
							dist_vec(1:3)=COM_B(1:3)-COM_A(1:3)
							!!! correct periodic boundary conditions
							CALL distance_PBC_correction(dist_vec,x_box,y_box,z_box)
							norm_dist_vec=norm(dist_vec)
							
							!!! check if it is the smallest
							IF( norm_dist_vec  < norm_dist_vec_min ) THEN
								dist_vec_min(1:3)=dist_vec(1:3)
								norm_dist_vec_min=norm_dist_vec
							END IF
							IF(DEBUG) WRITE(*,*) 'COM_B: ',COM_B,'|d|:',norm_dist_vec,' dist_vec_min:',dist_vec_min(1:3)
					END DO ! l = N_subhoppingsites in B
			END DO !k = N_subhoppingsites in A
		END IF !!!   Select the d_vector to calculate   d_COM,  d_MA, d_MMA,  d_RCOM
		min_d_COM_arr(i,j,1:3)=dist_vec_min(1:3)
		min_d_COM_arr(i,j,4)=ResidA
		min_d_COM_arr(i,j,5)=ResidB
		min_d_COM_arr(i,j,6)=norm_dist_vec_min
		!WRITE(*,*) min_d_COM_arr(i,j,:)
		IF( norm_dist_vec_min==50000) THEN
			WRITE(*,*) 'ResidA:',ResidA,' ResidB:',ResidB,' |d|=',norm_dist_vec_min
			WRITE(*,*) 'd: ',dist_vec_min(1:3)
			WRITE(*,*) 'Error: no norm_dist_vec encountered, revise input or implementation!'
			CALL EXIT(1)
		END IF
			
	END DO !j Nearest neighbours
END DO !i =1,N_Resids


WRITE(*,*) 'tmp ENDE N_PBDT_TS1:',i_resid ,system%molecules(i_resid)%hoppingsite%COM(1)
!CALL EXIT (2)  !MY EXIT
DO j=1,3
	WRITE(*,*) 'TMP FIRST ',min_d_COM_arr(1,j,:)
ENDDO
DO j=N_Neighbours-3,N_Neighbours
	WRITE(*,*) 'TMP LAST ',min_d_COM_arr(N_Resids,j,:)
ENDDO
END SUBROUTINE make_min_d_COM_vector_list


SUBROUTINE Read_neighbourlist(filename,N_Residues,N_Neighbours,COM_Daten,Res_Daten)
        IMPLICIT NONE
        CHARACTER(500), INTENT(IN) :: filename
        INTEGER, INTENT(IN)::N_Residues,N_Neighbours
        REAL, DIMENSION(N_Residues,N_Neighbours+1), INTENT(OUT)::COM_Daten
        INTEGER, DIMENSION(N_Residues,N_Neighbours+1), INTENT(OUT)::Res_Daten
        INTEGER::i,NR,dummy,ierror
		LOGICAL::Datei_vorhanden
		
		
        !residue_offset=33 !DIPBI Residue offset um wieder auf die Residuennuemmer zu kommen
        INQUIRE(file=TRIM(filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
        IF( .NOT. Datei_vorhanden) THEN
            WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(filename)
            WRITE(*,*) ' ENDE'
            CALL EXIT (1)
        END IF ! Datei-file vorhanden  

        OPEN(UNIT=11,FILE=TRIM(filename),STATUS='OLD',IOSTAT=ierror)

        !Daten mit dem Residuumsindex Nr_Abstand 1 Abstand1 Nr_Abstand 2 Abstand 2 ...bis ... Nr_Abstand 6 Abstand 6
            ! Einlesen der Daten aus der Datei neighbours.ngh
            NR=1
            DO i=1,N_Residues

READ(11,*,IOSTAT=ierror) COM_Daten(NR,1),dummy,COM_Daten(NR,2),COM_Daten(NR,3),COM_Daten(NR,4),COM_Daten(NR,5),COM_Daten(NR,6),&
            & COM_Daten(NR,7),COM_Daten(NR,8),COM_Daten(NR,9),COM_Daten(NR,10),COM_Daten(NR,11),COM_Daten(NR,12),COM_Daten(NR,13)
!WRITE(*,*) COM_Daten(NR,1),dummy,COM_Daten(NR,2),COM_Daten(NR,3),COM_Daten(NR,4),COM_Daten(NR,5),COM_Daten(NR,6)            
!WRITE(*,*) COM_Daten(NR,7),COM_Daten(NR,8),COM_Daten(NR,9),COM_Daten(NR,10),COM_Daten(NR,11),COM_Daten(NR,12),COM_Daten(NR,13)
            
READ(11,*,IOSTAT=ierror) Res_Daten(NR,1),dummy,Res_Daten(NR,2),Res_Daten(NR,3),Res_Daten(NR,4),Res_Daten(NR,5),Res_Daten(NR,6),&
            & Res_Daten(NR,7),Res_Daten(NR,8),Res_Daten(NR,9),Res_Daten(NR,10),Res_Daten(NR,11),Res_Daten(NR,12),Res_Daten(NR,13)
!WRITE(*,*) 'Resids:',Res_Daten(NR,1),dummy,Res_Daten(NR,2),Res_Daten(NR,3),Res_Daten(NR,4),Res_Daten(NR,5),Res_Daten(NR,6),&
!            & Res_Daten(NR,7),Res_Daten(NR,8),Res_Daten(NR,9),Res_Daten(NR,10),Res_Daten(NR,11),Res_Daten(NR,12),Res_Daten(NR,13)	
                NR=NR+1
                IF(ierror < 0) EXIT
                IF(ierror > 0) THEN
			NR=NR-1
WRITE(*,*) 'COM:',COM_Daten(NR,1),dummy,COM_Daten(NR,2),COM_Daten(NR,3),COM_Daten(NR,4),COM_Daten(NR,5),COM_Daten(NR,6)            
WRITE(*,*) COM_Daten(NR,7),COM_Daten(NR,8),COM_Daten(NR,9),COM_Daten(NR,10),COM_Daten(NR,11),COM_Daten(NR,12),COM_Daten(NR,13)

WRITE(*,*) 'Resids:',Res_Daten(NR,1),dummy,Res_Daten(NR,2),Res_Daten(NR,3),Res_Daten(NR,4),Res_Daten(NR,5),Res_Daten(NR,6),&
            & Res_Daten(NR,7),Res_Daten(NR,8),Res_Daten(NR,9),Res_Daten(NR,10),Res_Daten(NR,11),Res_Daten(NR,12),Res_Daten(NR,13)			
                    WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(filename),' aufgetreten.'
		    WRITE(*,*) 'Anzahl der nachbarn nicht 12 ? '
                    WRITE(*,*) 'Beende Einlesen !'
                    CALL EXIT (1)
                END IF
            END DO
            CLOSE(11)
            !NR=1
            !WRITE(*,*) COM_Daten(NR,1),COM_Daten(NR,2),COM_Daten(NR,3),COM_Daten(NR,4),COM_Daten(NR,5),COM_Daten(NR,6)&
            !&,COM_Daten(NR,7),COM_Daten(NR,8),COM_Daten(NR,9),COM_Daten(NR,10),COM_Daten(NR,11),COM_Daten(NR,12),COM_Daten(NR,13)
            !WRITE(*,*) Res_Daten(NR,1),Res_Daten(NR,2),Res_Daten(NR,3),Res_Daten(NR,4),Res_Daten(NR,5),Res_Daten(NR,6)&
            !&,Res_Daten(NR,7),Res_Daten(NR,8),Res_Daten(NR,9),Res_Daten(NR,10),Res_Daten(NR,11),Res_Daten(NR,12),Res_Daten(NR,13)
            !
            !NR=N_Residues
            !WRITE(*,*) COM_Daten(NR,1),COM_Daten(NR,2),COM_Daten(NR,3),COM_Daten(NR,4),COM_Daten(NR,5),COM_Daten(NR,6)&
            !&,COM_Daten(NR,7),COM_Daten(NR,8),COM_Daten(NR,9),COM_Daten(NR,10),COM_Daten(NR,11),COM_Daten(NR,12),COM_Daten(NR,13)
            !WRITE(*,*) Res_Daten(NR,1),Res_Daten(NR,2),Res_Daten(NR,3),Res_Daten(NR,4),Res_Daten(NR,5),Res_Daten(NR,6)&
            !&,Res_Daten(NR,7),Res_Daten(NR,8),Res_Daten(NR,9),Res_Daten(NR,10),Res_Daten(NR,11),Res_Daten(NR,12),Res_Daten(NR,13)

END SUBROUTINE Read_neighbourlist

end module gro_to_votca 
!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!!   END       module gro_to_votca                                                                                     !!!           
!!! ------------------------------------------------------------------------------------------------------------------- !!!







!!!!-------------------------------------------------------------------------------------------------------------------!!!
!!!! START module  my_rates_to_votca_sql.out                                                                           !!!
!!!!-------------------------------------------------------------------------------------------------------------------!!!
!!!!-------------------------------------------------------------------------------------------------------------------!!!

module  rates_to_votca_sqlfile 
!! my_rates_to_votca_sql()
!! 
!! collects data for parametization of marcus charge transfer rates and creates 
!! files that can be converted to a votca state.sql file for the rates. 
!! OUTPUT: votca_segfile.dat, votca_pairfile.dat 
!!
!! Next step => xtp_createStatefile_fromtxt_t_koch08.py => VOTCA_statefile.sql
!!
!! use rate_type = "marcus", "jortner", "weiss-dorsey"
!!
!! NEEDED FILES HERE
!! dE_in_el_file='data/lambda_in_matrix/Mat_dE_in_el_P3MT_S1_S32_B3LYP_6-311Gss.dat'
!! dE_in_lo_file='data/lambda_in_matrix/Mat_dE_in_lo_P3MT_S1_S32_B3LYP_6-311Gss.dat'
!! lambda_in_el_file='data/lambda_in_matrix/Mat_lambda_in_el_P3MT_S1_S32_B3LYP_6-311Gss.dat'
!! lambda_in_lo_file='data/lambda_in_matrix/Mat_lambda_in_lo_P3MT_S1_S32_B3LYP_6-311Gss.dat'
!!
!! Read_J_AB=.true.
!! J_AB_file='/data/Datenauswertung_SAB_H_H0_Jab_H0_H0_SAB_L0_L0_Jab_L0_L0_G0.dat'
!! Alternatively, one can read a votca state.sql file from the command line and read in the jeff2h and jeff2e data, which should have been evaluated using ZINDO/MOO in advance.
!! The number of hopping pairs can differ due to the choice of cutoff radii and nearest neighbour criterion.
!! The program will produce automaticly a temporaty  state_J_AB_ZINDO_MOO_votca.dat file to read the data, as the binary *.sql file can non be read directly.
!! J_AB_file='state.sql'
!! 
!! gro_inputfile='sim_data_12N/equi_2000ps_500k_def2_theta_75_G0.gro'
!! sorted_neigbour_list_file='sim_data_12N/sorted_neighbours_equi_2000ps_500k_def2_theta_75_G0.ngh'
!! zielfile='DIPBI_P3MT_Resid_Molname_Schwefel.dat'
!!
!! KEYS
!! print_data_collection_files=.false.
!! mobility_estimate=.false.
!! make_Histogramm=.false.
!! DEBUG=.false.
!!
!! Intramolecular data: 
!! 
!! read_intramolecular_data=.true.
!! uses cosfit for | J_AB(el)| and scaled dE_intra_el=-0.65* dE_intra_lo
!! use_fit_intramolecular=.true.  
!!
!! P3HT_dE_intr_in_el_file='data/energie_p3mt_daten_electron'
!! P3HT_dE_intr_in_lo_file='data/energie_p3mt_daten_hole'
!! P3HT_intr_in_el_file='data/spline_interp_2mere_P3HT_electron'
!! P3HT_intr_in_lo_file='data/spline_interp_2mere_P3HT_hole'
!!
!! Outer-sphere-data
!! lambda_out_files prepare files with
!! sqlite3 statefile.sql ' SELECT id,seg1,seg2,lOh,lOe  FROM pairs ' >> l_out_filename
!!
!! reading read_E_multipole_out_file, with the format from sql file: id,eCation,eAnion
!! sqlite3 statefile.sql " SELECT id,eCation,eNeutral,eAnion FROM segments " >> E_out_emultipoles_DIPBI_P3HT32mers.dat
!! Replace "|" with "whitespace" beforehand; 
!! The program takes the index shift between votca (starts with i==1) and my_kmc (starts with i==0) into account! 
!!
!! PPDI /PBDT-TS1 or P3DT-TS1 can be handled as well. 
!! The polymer segmentation pattern is stored in the sequence_list. (A=CarboxS2 and B=PBDT type)
!! 
!!  Determine the distance vector d in charge transfer rate as  min_d_modus = [COM, MA, MMA, RCOM]
!!  COM: Center of mass distrance
!!  MA:  Minimal appearing distance
!!  MMA: Mean Minimal Appearing distance
!!  RCOM: ring center of masses ( e.g. for sequences in the polymere chains)
!!	<use_min_d_COM_vector_list>1</use_min_d_COM_vector_list>  <!-- use_min_d_COM_vector_list   default= .false. -->
!!	<min_d_modus>COM</min_d_modus>  <!-- min_d_modus = [COM, MA, MMA, RCOM] Calculate the intermolecular distance e.g. in rates default: min_d_modus = COM  -->
CONTAINS

SUBROUTINE my_rates_to_votca_sql_main()
	use Molecule_class
	use gro_to_votca
	use small_functions
	use KMC_class
	IMPLICIT NONE
	type (system_t) :: system2
	type(KMC_setup_t)  :: setup
	type (gro_data_t)  :: gro_data
	type(hoppingpair_t) :: new_hoppingpair
! Einlesen aus der .gro Datei und Umrechnung in .xyz Format (Ang)
Character(3), ALLOCATABLE, Dimension(:) :: atomsorteA
Character(5), ALLOCATABLE, Dimension(:) :: molname
Real,ALLOCATABLE,Dimension(:,:) ::koordA,velocities,no_box_koord,neighbour_list_COM,Inter,J_AB_Daten,intra_theta_E,k_inter
Real, ALLOCATABLE, Dimension(:) :: dist_COM_inter
Real, Dimension(33,33) :: dE_in_el_mat,dE_in_lo_mat,lambda_in_el_mat,lambda_in_lo_mat
Character(500)  :: gro_inputfile,sorted_neigbour_list_file,no_box_COM_file,zielfile,zielfile_intra,J_AB_file
Character(500)  :: dummyname,dE_in_el_file,dE_in_lo_file,lambda_in_el_file,lambda_in_lo_file
Character(5), ALLOCATABLE, DIMENSION(:)    :: residue_name,residue_name_site
Character(5), ALLOCATABLE, DIMENSION(:,:)  :: residue_names_pair
Character(3), ALLOCATABLE, DIMENSION(:)    :: atom
Character(LEN=2) :: segtype2
LOGICAL, ALLOCATABLE, DIMENSION(:) :: J_AB_da
REAL, DIMENSION(3):: U_ext=[0.0,0.0 ,0.001],COM_1,COM_2,dist
INTEGER, ALLOCATABLE, DIMENSION(:)   ::residue_number,atom_number
INTEGER, ALLOCATABLE, DIMENSION(:,:) ::neighbour_list_Res,Resid_and_S,R_u_S,R_intra
INTEGER::i,j,k,ierror,NA,N_Schwefel,N_Resids,N_Neighbours,N_Pairs,count_pair
INTEGER::MAXATM,MAX_COM,Offset_Resid,N_P3HT_Intra,N_JAB_inter_da
INTEGER::Resid_A,Resid_last
LOGICAL::Datei_vorhanden,thiophene_found=.false.
LOGICAL ::read_intramolecular_data,use_fit_intramolecular,use_dE_in_AB__approx__dE_vert_CDFT

!REAL:: marcus_rate_lo_AB=0.0,marcus_rate_lo_BA=0.0
!REAL:: marcus_rate_el_AB=0.0,marcus_rate_el_BA=0.0
REAL:: lambda_out_e=0.0,lambda_out_h=0.0,dE_U_ext=0.0 ! Startenergien
!REAL:: dE_out_e=0.0,dE_out_h=0.0
REAL:: D_inter_el=0.0,D_inter_lo=0.0  ! diffusion constants
REAL:: sum_k_el=0.0,sum_k_lo=0.0,mu_inter_el=0.0,mu_inter_lo=0.0 ! mobility (poor estimate)
!! Kondor parameter alpha for weiss-dorsey rate: default Kondo=4.0 for P3HT
REAL:: Kondo=4.0 
!! averager_vibrational_mode_energy [eV] e.g. for Jortner rate
REAL ::average_omegaVib=0.0 
REAL:: x_box,y_box,z_box,theta
INTEGER, PARAMETER         :: doubleprecision = SELECTED_REAL_KIND(12, 60)
REAL (doubleprecision), ALLOCATABLE, DIMENSION(:)    :: x_Hist
INTEGER, ALLOCATABLE , DIMENSION(:):: y_Hist
INTEGER::N_Points_Hist
REAL::lambda_in_el_AB,lambda_in_lo_AB,lambda_in_el_BA,lambda_in_lo_BA,k_AB_el,k_AB_lo,k_BA_el,k_BA_lo
!!! DATA FOR GEOMETRIC FIT
REAL,    ALLOCATABLE, DIMENSION(:,:)     	     :: Geo_Data_pairs
INTEGER, ALLOCATABLE, DIMENSION(:,:)		     :: seg1_seg2_Geo_Data_pairs
LOGICAL, ALLOCATABLE, DIMENSION(:)		          :: Geo_Data_da
INTEGER:: N_Geo_Data_lines
LOGICAL::Read_J_AB,Read_J_AB_from_sql_file,scale_dipro_results,linear_scaling_J_AB,Read_COM_COM_H_MA_MMA_theta_Data_from_J_AB_file
    !! Array for hole    seg1_seg2_J_AB_data(i,1) and    electron seg1_seg2_J_AB_data(i,2)
    REAL, ALLOCATABLE, DIMENSION(:,:)    :: pairs_seg1_seg2_J_AB_data 
    !! Resids of segment 1 and segment 2 in votca 
    INTEGER, ALLOCATABLE, DIMENSION(:,:):: seg1_seg2_J_AB_data
    INTEGER::N_sql_JAB_lines
	CHARACTER(LEN=50)   :: y_scale_method,x_scale_method,j_ab_fit_method_geometry
	LOGICAL ::DIPBI_P3HT_calc,DIPBI_P3MT_calc,P3HT_pur_calc,P3MT_pur_calc
	LOGICAL ::print_data_collection_files,mobility_estimate,make_Histogramm,Read_l_out
    !! filename to read lambda_out data
    CHARACTER(500) :: l_out_filename,E_multipole_filename
    !! Read the input settings form the  options.xml input file
    CHARACTER(500) :: input_options_filename_xml
    !! Array for hole lambda_out_h N_l_out_data(i,1) and    electron lambda_out_e  N_l_out_data(i,2)
    REAL, ALLOCATABLE, DIMENSION(:,:)  :: N_l_out_data 
    !! Resids of segment 1 and segment 2 in votca 
    INTEGER, ALLOCATABLE, DIMENSION(:,:) :: seg1_seg2_l_out,ResidX_in_32mer
    INTEGER::  N_l_out_lines,N_E_out_lines,N_DIPBI,N_P3HT_segments,A32mer,B32mer
    LOGICAL:: found_A32mer,found_B32mer,Read_E_multipole_out,use_lambda_out_random_number_Gauss_distribution_data

    !! Array for hole E_out_h     E_out_data(i,1) and eNeutral  E_out_data(i,2)      and    electron E_out_e  E_out_data(i,3)
    REAL, ALLOCATABLE, DIMENSION(:,:)   :: E_out_data
    !! Array for the outersphere contributions
    REAL, ALLOCATABLE, DIMENSION(:,:)   :: dE_out_pairs,dE_out_pairs_intra 
    !! Resids of molecule id in segments
    INTEGER, ALLOCATABLE, DIMENSION(:) :: id_E_out
    !! Default lambda_out and E_multipole_out values and sigma
    REAL::def_E_multi_h,sig_E_multi_h,def_E_multi_e,sig_E_multi_e,def_lam_out_h,sig_lam_out_h,def_lam_out_e,sig_lam_out_e
    REAL::def_DIPBI_E_multi_h,sig_DIPBI_E_multi_h,def_DIPBI_E_multi_e,sig_DIPBI_E_multi_e
    REAL::def_DIPBI_lam_out_h,sig_DIPBI_lam_out_h,def_DIPBI_lam_out_e,sig_DIPBI_lam_out_e
    REAL::randomnumber
    LOGICAL::E_out_randomized_distribution,Use_reference_data_from_P3HT32mer
    LOGICAL::set_dE_out_and_l_out_to_zero
    !! Temperature [K] in marcus_rates
    REAL   ::T=300.0                             
CHARACTER (500) ::P3HT_intr_in_lo_file,P3HT_intr_in_el_file,P3HT_dE_intr_in_lo_file,P3HT_dE_intr_in_el_file
REAL, PARAMETER::PI=ATAN(1.0)*4.0,k_b=8.6173303E-5          !! eV/K
!!!
REAL, PARAMETER::hbar=6.582119514E-16       !! eV*s
REAL, PARAMETER::q_elementar=1.0 ! da k_b in eV 1.6021766208 !! E-19 Coulomb
!!!!!! VOTCA output
LOGICAL::data_to_votca_KMC=.true.,TEST_RATES=.false.
Character(500)  ::votca_pairfile_name,votca_segfile_name,votca_sqlfile_name
LOGICAL, ALLOCATABLE, DIMENSION(:) ::J_AB_da_single,Pair_AB_da_intra
INTEGER::segid,pair_id,votca_ind,Resid1,Resid2
REAL::drX,drY,drZ
!!!! PPDI_PBDT_TS1
LOGICAL:: PPDI_PBDT_TS1_calc,mol_start_da,mol_ende_da
!! count the subunits
INTEGER::N_CarboxyS2,N_PBDT,N_PPDI
!! Intramolecular data files for J_AB and dE_in fuer AB und BA Reihenfolge der Segmente
Character(LEN=500)::PBDT_TS1_AB_dE_intr_in_el_file,PBDT_TS1_BA_dE_intr_in_el_file
Character(LEN=500)::PBDT_TS1_AB_dE_intr_in_lo_file,PBDT_TS1_BA_dE_intr_in_lo_file
Character(LEN=500)::PBDT_TS1_AB_J_intra_in_el_file,PBDT_TS1_BA_J_intra_in_el_file
Character(LEN=500)::PBDT_TS1_AB_J_intra_in_lo_file,PBDT_TS1_BA_J_intra_in_lo_file
Character(LEN=1) :: segtype,fin
CHARACTER(LEN=50):: sequence,rate_type 
CHARACTER(LEN=50), ALLOCATABLE, DIMENSION(:)::sequence_list
!!!
!! Multigeometry / Multimorphology treatment with _G${Geo_Step}
LOGICAL::multigeo_setup=.false.
LOGICAL::set_J_AB_intermolecular_to_zero=.false.
INTEGER :: read_index_shift, Geo_Step
LOGICAL :: read_options_from_xml, set_filenames
 !! use_min_d_COM_vector_list
 !! temporary koordinate file
 LOGICAL:: use_min_d_COM_vector_list
 REAL, DIMENSION(3) :: dr
 REAL, ALLOCATABLE, DIMENSION(:,:)  :: Koords
 LOGICAL :: DEBUG=.false., KETTE=.false.
 INTEGER :: NAtoms,N_P3HT,N_PBDT_TS1,N_Species,N_PBDT_TS1_segments
 CHARACTER(LEN=50000) :: Bashline
 INTEGER, ALLOCATABLE, DIMENSION(:,:)           :: R_u_I
 CHARACTER(LEN=500)::line,lio
 INTEGER:: start_index,end_index
 REAL, PARAMETER :: nm2Ang=10.0,Ang2nm=0.1
 LOGICAL:: use_Molecular_class=.true.  ! default is false
 LOGICAL:: WARNING=.false.
 !!! local array with minimum distance list
 CHARACTER(500)                       :: min_d_modus
 REAL, ALLOCATABLE, DIMENSION (:,:,:) :: min_d_COM_arr
 REAL, DIMENSION(3)                   :: dist_vec


 if(use_Molecular_class) then
	call init_system(system2)
endif
 
write(*,*) '================================='
write(*,*) '|       rates_to_votca_sql      |'
write(*,*) '================================='

!! Debug modus: Print extra information
DEBUG=.false.

!! System 
DIPBI_P3HT_calc=.true.
DIPBI_P3MT_calc=.false.
P3HT_pur_calc=.false.
P3MT_pur_calc=.false.
PPDI_PBDT_TS1_calc=.false.



read_options_from_xml =.true.
!! Number of neighbours in the neighbourlistfile
N_Neighbours=13

!! multigeo dafault: multigeo_setup=.false.
multigeo_setup=.false. 

!! default: Geo_Step=0 for multigeo_setup. Usually parameter is extracted from input data _G${Geo_step} in *.gro file
Geo_Step=0

!rate_type = "jortner" or "marcus" or "weiss_dorsey"
rate_type="marcus"

!! set all outer_sphere contributions to zero dE_out und lambda_out, overrides all other cases. [default: set_dE_out_and_l_out_to_zero=.false.]
set_dE_out_and_l_out_to_zero=.false.
!! set all J_AB_intermolecular zero. Only check intramolecular transport. [default: set_J_AB_intermolecular_to_zero=.false.]
set_J_AB_intermolecular_to_zero=.false.

!! Kondo parameter alpha for weiss-dorsey rate
!! Asadi. et A. Nature Com. 2013
!! default: Votca Kondo=4.0 ; rr-P3HT = 3.6 ; rr-P3HT doped 6.75  
Kondo=3.6 

!!! Default: TEST_RATES=.false. only evaluates rates with selected properties.
TEST_RATES=.false.



Use_reference_data_from_P3HT32mer=.false.
use_lambda_out_random_number_Gauss_distribution_data=.false.
Read_l_out=.false.



!! E_multiiplote with Thole model for electrostatic contributions dE
Read_E_multipole_out=.false.
!! Gaussian distribution for P3HT or DIPBI data for lam_out and E_out:  E_out_randomized_distribution=.true.
E_out_randomized_distribution=.false.


!!   J_AB DIPRO data file for the charge transfer integral 
Read_J_AB=.true.
J_AB_file='data/Datenauswertung_SAB_H_H0_Jab_H0_H0_SAB_L0_L0_Jab_L0_L0_G0.dat'
!!   Read the charge transfer integral from the statefile.sql
Read_J_AB_from_sql_file=.false.

!! Parametrized for DIPBI:P3MT [3mer,5mer,7mer]
!! Scaling J_AB(y) = f(x) * J_AB
!! Available methods:   y_scale_method=[CDFT,PBE/6-311G**,B3LYP/3-21G,PM3]
!! Available methods:   x_scale_method=[PBE/6-311G**,ZINDO,PM3,DFTB/MIO,DFTB/3OB,B3LYP/3-21G*,B3LYP/6-31G*,B3LYP/6-311G**]
!! Caution, not all combinations are implemented.
scale_dipro_results=.true.
linear_scaling_J_AB=.true.
x_scale_method='PM3'
y_scale_method='CDFT'


!! Can read the geometric data from the J_AB_file and evaluate the matrix element J_AB via a linear fit from the geomentic data
!!  
!! Use a method in the list: J_AB_fit_method_geometry=[MA,MMA,COM_H,Lin_Combi]
!! MA = minimal distance, MMA = mean minimal distance,  COM = center of mass distance, COM_H = center of mass distance with hydrogen atoms included,
!! Lin_Combi: Use a linear combination for a fit of MA,MMA,COM_H to obtain a value for J_AB_hole, J_AB_elec 
Read_COM_COM_H_MA_MMA_theta_Data_from_J_AB_file=.false.
J_AB_fit_method_geometry='Lin_Combi'

!!! min distvector with subhopping sites
use_min_d_COM_vector_list=.false.
!! modus to select the calculated distance vector between two hopping sites
!! Select  min_d_modus = [COM, MA, MMA, RCOM] 
min_d_modus='COM'

print_data_collection_files=.false.
mobility_estimate=.false.
make_Histogramm=.false.


!! Intramolecular 
read_intramolecular_data=.true.
!! uses cosfit for | J_AB(el)| and scaled dE_intra_el=-0.65* dE_intra_lo  !!! default=.false.
use_fit_intramolecular=.false.  
!! use vertical energy gap from CDFT dE_vert_CDFT to approximate the dE_in_AB=dE_A_in -dE_B_in  !!! default=.false.
use_dE_in_AB__approx__dE_vert_CDFT=.true.

!! the input options filename to modify the setting parameters.
input_options_filename_xml='options.xml'

!! Include side chains
KETTE=.false.

!!! Default: do not change here
set_filenames=.false.

!! Suche options.xml filename
DO i=5,command_argument_count()
			CALL get_command_argument(i,dummyname)
			IF (check_filetermination_and_continue(dummyname,'.xml')) THEN
				input_options_filename_xml=dummyname
				inquire(file=TRIM(input_options_filename_xml),exist=Datei_vorhanden) 
				IF( .not. Datei_vorhanden) THEN 
					WRITE(*,*) ' Fehler: Die_Datei_existiert_nicht. '//TRIM(input_options_filename_xml)
					WRITE(*,*) ' ENDE'
					CALL EXIT (1)
				ELSE 
					WRITE(*,*) 'use input_options_filename_xml: ',TRIM(input_options_filename_xml)
					read_options_from_xml=.true.
				END IF ! input_options_filename_xml   vorhanden. 
			END IF !!! suche *.xml file
ENDDO


IF( read_options_from_xml .and. file_exists_and_continue(input_options_filename_xml) .and. &
	& check_filetermination_and_continue(input_options_filename_xml,'.xml')) THEN
		write(*,*) 'Start reading options from  input_options_filename_xml. '//TRIM(input_options_filename_xml)
		call set_defaults_KMC_setup(setup)
		call read_votca_optionsfile(input_options_filename_xml,setup,&
				&" rates_to_votca_sqlfile  rates_to_votca_sql_file rates_to_VOTCA_sqlfile  system")
		!!! Use data from setup in options.xml file.
		DIPBI_P3HT_calc = setup%DIPBI_P3HT_calc 
		write(*,*) 'tmp: DIPBI_P3HT_calc: ',DIPBI_P3HT_calc
		DEBUG = setup%DEBUG
		DIPBI_P3MT_calc = setup%DIPBI_P3MT_calc 
		P3HT_pur_calc = setup%P3HT_pur_calc 
		P3MT_pur_calc = setup%P3MT_pur_calc
		PPDI_PBDT_TS1_calc = setup%PPDI_PBDT_TS1_calc 
		N_Neighbours= setup%N_Neighbours
		multigeo_setup = setup%multigeo_setup 
		Geo_Step= setup%Geo_Step
		rate_type = setup%rate_type                                         !!! default [rate_type="marcus"]
		set_dE_out_and_l_out_to_zero = setup%set_dE_out_and_l_out_to_zero 
		set_J_AB_intermolecular_to_zero = setup%set_J_AB_intermolecular_to_zero 
		T = setup%temperature
		Kondo= setup%Kondo
		TEST_RATES = setup%TEST_RATES 
		set_filenames = setup%set_filenames 
		if(set_filenames) then
			l_out_filename                            = setup%l_out_filename                                  !!! l_out_filename='data/l_out_filename.dat'    !!!'l_out_filename_P3HT_pur_1000ps_900K_65_G0_add_H_not_virtual.dat'
			E_multipole_filename                      = setup%E_multipole_filename                        !!! E_multipole_filename='data/E_out_filename.dat'  
			J_AB_file                             = setup%J_AB_filename                                   !!! J_AB_filename='data/Datenauswertung_SAB_H_H0_Jab_H0_H0_SAB_L0_L0_Jab_L0_L0_G0.dat'
		endif ! set_filename
		Read_J_AB_from_sql_file = setup%Read_J_AB_from_sql_file 
		Read_J_AB = setup%Read_J_AB 
		linear_scaling_J_AB = setup%linear_scaling_J_AB 
		J_AB_fit_method_geometry = setup% J_AB_fit_method_geometry               !!! J_AB_fit_method_geometry='Lin_Combi'
		scale_dipro_results = setup%scale_dipro_results 
		x_scale_method= setup%x_scale_method                               !!!  x_scale_method='PM3'
		y_scale_method= setup%y_scale_method                                   !!!  y_scale_method='CDFT'
		Read_COM_COM_H_MA_MMA_theta_Data_from_J_AB_file = setup%Read_COM_COM_H_MA_MMA_theta_Data_from_J_AB_file 
		use_min_d_COM_vector_list = setup%use_min_d_COM_vector_list 
		min_d_modus = setup%min_d_modus
		print_data_collection_files = setup%print_data_collection_files 
		mobility_estimate = setup%mobility_estimate 
		make_Histogramm = setup%make_Histogramm 
		read_intramolecular_data = setup%read_intramolecular_data 
		use_fit_intramolecular   = setup%use_fit_intramolecular   
		use_dE_in_AB__approx__dE_vert_CDFT = setup%use_dE_in_AB__approx__dE_vert_CDFT
		Use_reference_data_from_P3HT32mer  = setup%Use_reference_data_from_P3HT32mer 
		use_lambda_out_random_number_Gauss_distribution_data = setup%use_lambda_out_random_number_Gauss_distribution_data
		Read_l_out = setup%Read_l_out
		!! E_multiiplote with Thole model for electrostatic contributions dE
		Read_E_multipole_out = setup%Read_E_multipole_out
		!! Gaussian distribution for P3HT or DIPBI data for lam_out and E_out:  E_out_randomized_distribution=.true.
		E_out_randomized_distribution = setup%E_out_randomized_distribution
		
		def_E_multi_h= setup%def_E_multi_h      
		sig_E_multi_h= setup%sig_E_multi_h      
		def_E_multi_e= setup%def_E_multi_e      
		sig_E_multi_e= setup%sig_E_multi_e      

		def_lam_out_h= setup%def_lam_out_h      
		sig_lam_out_h= setup%sig_lam_out_h      
		def_lam_out_e= setup%def_lam_out_e      
		sig_lam_out_e= setup%sig_lam_out_e 
ENDIF



IF (Use_reference_data_from_P3HT32mer) THEN
	E_multipole_filename='data/E_out_emultipoles_DIPBI_P3HT32mers.dat'
ELSE IF(set_filenames) THEN
	E_multipole_filename= setup%E_multipole_filename 
ELSE
	E_multipole_filename='data/E_out_emultipoles_DIPBI_P3HT_500K_virtual_H_atoms.dat'
END IF

IF (Use_reference_data_from_P3HT32mer) THEN
		l_out_filename='data/lambda_out_id_seg1_seg2_lOh_lOe_DIPBI_P3HT32mer.dat'
ELSE IF(set_filenames) THEN
		l_out_filename = setup%l_out_filename
ELSE
		l_out_filename='data/lambda_out_no_virtual_H_id_seg1_seg2_lOh_lOe_votca_equi_2000ps_500k_def2_theta_75_G0.dat'
END IF

IF(P3HT_pur_calc) THEN
	l_out_filename='data/l_out_P3HT_pur_1000ps_900K_65_G0_no_virtual_H.dat'    !!!'l_out_filename_P3HT_pur_1000ps_900K_65_G0_add_H_not_virtual.dat'
	E_multipole_filename='data/E_out_emultipoles_P3HT_pur_1000ps_900K_65_G0_add_H_not_virtual.dat'
	IF(Use_reference_data_from_P3HT32mer) THEN
		l_out_filename='data/l_out_P3HT_pur_1000ps_900K_65_G0_32mers.dat'
		E_multipole_filename='data/E_out_emultipoles_P3HT_pur_1000ps_900K_65_G0_32mers.dat'
	END IF
END IF 


IF( P3HT_pur_calc .OR. DIPBI_P3HT_calc .OR. P3MT_pur_calc .OR. DIPBI_P3MT_calc  ) THEN
	dE_in_el_file='data/lambda_in_matrix/Mat_dE_in_el_P3MT_S1_S32_B3LYP_6-311Gss.dat'
	dE_in_lo_file='data/lambda_in_matrix/Mat_dE_in_lo_P3MT_S1_S32_B3LYP_6-311Gss.dat'
	lambda_in_el_file='data/lambda_in_matrix/Mat_lambda_in_el_P3MT_S1_S32_B3LYP_6-311Gss.dat'
	lambda_in_lo_file='data/lambda_in_matrix/Mat_lambda_in_lo_P3MT_S1_S32_B3LYP_6-311Gss.dat'
ELSE IF (PPDI_PBDT_TS1_calc) THEN
	dE_in_el_file='data/lambda_in_matrix/Mat_dE_in_el_PPDI_PBDT-TS1_S1_S17_B3LYP_6-31Gs.dat'
	dE_in_lo_file='data/lambda_in_matrix/Mat_dE_in_lo_PPDI_PBDT-TS1_S1_S17_B3LYP_6-31Gs.dat'
	lambda_in_el_file='data/lambda_in_matrix/Mat_lambda_in_el_PPDI_PBDT-TS1_S1_S17_B3LYP_6-31Gs.dat'
	lambda_in_lo_file='data/lambda_in_matrix/Mat_lambda_in_lo_PPDI_PBDT-TS1_S1_S17_B3LYP_6-31Gs.dat'
ELSE IF(set_filenames) THEN
		dE_in_el_file = setup%dE_in_el_filename
		dE_in_lo_file = setup%dE_in_lo_filename
		lambda_in_el_file = setup%lambda_in_el_filename
		lambda_in_lo_file = setup%lambda_in_lo_filename
ELSE
	WRITE(*,*) 'Error: no suitable system selected  for lambda_in matrix!'
	CALL EXIT (1)
END IF 

!!!!! Data for intramolecular charge transport
!! 1= theta , 2=dE_in_el,   3=dE_in_lo, 4=|J_AB(el)| , 5=|J_AB(lo)|  6=k_intra_el 7=k_intra_lo 
IF( P3HT_pur_calc .OR. DIPBI_P3HT_calc .OR. P3MT_pur_calc .OR. DIPBI_P3MT_calc ) THEN
	P3HT_dE_intr_in_el_file='data/energie_p3mt_daten_electron'
	P3HT_dE_intr_in_lo_file='data/energie_p3mt_daten_hole'
	P3HT_intr_in_el_file='data/spline_interp_2mere_P3HT_electron'
	P3HT_intr_in_lo_file='data/spline_interp_2mere_P3HT_hole'
ELSE IF (PPDI_PBDT_TS1_calc) THEN
	!! dE_intra aus CDFT
	PBDT_TS1_AB_dE_intr_in_el_file='data/dE_intra_el_spline_3600_pbdt-TS1_CDFT_PBE_AB_electrons.dat'
	PBDT_TS1_BA_dE_intr_in_el_file='data/dE_intra_el_spline_3600_pbdt-TS1_CDFT_PBE_BA_electrons.dat'
	PBDT_TS1_AB_dE_intr_in_lo_file='data/dE_intra_lo_spline_3600_pbdt-TS1_CDFT_PBE_AB_Loch.dat'
	PBDT_TS1_BA_dE_intr_in_lo_file='data/dE_intra_lo_spline_3600_pbdt-TS1_CDFT_PBE_BA_Loch.dat'
	!! J_AB_intra aus CDFT fuer PBDT_TS1
	PBDT_TS1_AB_J_intra_in_el_file='data/spline_3600_JAB_intra_pbdt-TS1_CDFT_PBE_AB_electrons.dat'
	PBDT_TS1_BA_J_intra_in_el_file='data/spline_3600_JAB_intra_pbdt-TS1_CDFT_PBE_BA_electrons.dat'
	PBDT_TS1_AB_J_intra_in_lo_file='data/spline_3600_JAB_intra_pbdt-TS1_CDFT_PBE_AB_Loch.dat'  
	PBDT_TS1_BA_J_intra_in_lo_file='data/spline_3600_JAB_intra_pbdt-TS1_CDFT_PBE_BA_Loch.dat'
ELSE IF(set_filenames) THEN
	write(*,*) 'P3HT_pur_calc .OR. DIPBI_P3HT_calc .OR. PPDI_PBDT_TS1_calc '
	write(*,*) 'No other intramolecular data is implemented yet.'
	CALL EXIT(1)
END IF 



!!! VOTCA
votca_pairfile_name='votca_pairfile.dat'
votca_segfile_name='votca_segfile.dat'
votca_sqlfile_name='state.sql'


!! OUTER SPHERE P3HT default values from 32mer box
!! Mean values: $E_{\text{multipole}}^{h} = -0.131 \pm 0.146$ eV,  $E_{\text{multipole}}^{e} = 0.120 \pm 0.126$ eV
!! Gaussian distribution for P3HT or DIPBI data for lam_out and E_out:  E_out_randomized_distribution=.true.

def_E_multi_h=-0.131
sig_E_multi_h=0.146

def_E_multi_e=0.120
sig_E_multi_e=0.126

!! Mean values: $ \lambda_{ \text{out}}^{h} =0.157 \pm 0.014$ eV, $ \lambda_{ \text{out}}^{e} =0.132 \pm 0.012$ eV
def_lam_out_h=0.157
sig_lam_out_h=0.014

def_lam_out_e=0.132
sig_lam_out_e=0.012


!! DIPBI Mean values: $E_{\text{multipole}}^{h} = -0.038 \pm 0.189$ eV,  $E_{\text{multipole}}^{e} = 0.041 \pm 0.188$ eV
!! DIPBI Mean values: $ \lambda_{ \text{out}}^{h} =0.074 \pm 0.048 $ eV, $ \lambda_{ \text{out}}^{e} =0.073 \pm 0.048$ eV
def_DIPBI_E_multi_h=-0.038
sig_DIPBI_E_multi_h=0.189

def_DIPBI_E_multi_e=0.041 
sig_DIPBI_E_multi_e=0.188

def_DIPBI_lam_out_h=0.074 
sig_DIPBI_lam_out_h=0.048

def_DIPBI_lam_out_e=0.073 
sig_DIPBI_lam_out_e=0.048


!!! dummy names for inputfiles: are usually replaced as read from inpuline
gro_inputfile='sim_data_12N/equi_2000ps_500k_def2_theta_75_G0.gro'
sorted_neigbour_list_file='sim_data_12N/sorted_neighbours_equi_2000ps_500k_def2_theta_75_G0.ngh'
zielfile='DIPBI_P3MT_Resid_Molname_Schwefel.dat'




!! Random seed
CALL init_random_seed()


WRITE(*,*) ' Calculates lists with Data for Resids '
WRITE(*,*) ' Use: ',TRIM(dE_in_el_file),' ',TRIM(dE_in_lo_file),' ',TRIM(lambda_in_el_file),' ',TRIM(lambda_in_lo_file)
IF( read_intramolecular_data ) THEN
	IF(P3HT_pur_calc .OR. DIPBI_P3HT_calc) THEN
		WRITE(*,*) 'Intramolecular: ',TRIM(P3HT_dE_intr_in_el_file),' ',TRIM(P3HT_dE_intr_in_lo_file),&
								 &' ',TRIM(P3HT_intr_in_el_file),' ',TRIM(P3HT_intr_in_lo_file)
	ELSE IF ( PPDI_PBDT_TS1_calc) THEN
		WRITE(*,*) 'Intramolecular: ',TRIM(PBDT_TS1_AB_dE_intr_in_el_file),TRIM(PBDT_TS1_BA_dE_intr_in_el_file),&
									& TRIM(PBDT_TS1_AB_dE_intr_in_lo_file),TRIM(PBDT_TS1_BA_dE_intr_in_lo_file),&
									& TRIM(PBDT_TS1_AB_J_intra_in_el_file),TRIM(PBDT_TS1_BA_J_intra_in_el_file),&
									& TRIM(PBDT_TS1_AB_J_intra_in_lo_file),TRIM(PBDT_TS1_BA_J_intra_in_lo_file)
	END IF 
	WRITE(*,*) 'use_fit_intramolecular: ',use_fit_intramolecular 
END IF



read_index_shift=0
CALL get_command_argument(1,dummyname)
if( INDEX(dummyname,'rates_to_VOTCA_sql') /= 0) THEN
	read_index_shift=1
endif

IF(command_argument_count() >= 4+read_index_shift) THEN         !Einlesen der Flags
        CALL get_command_argument(1+read_index_shift,gro_inputfile)  
        CALL get_command_argument(2+read_index_shift,sorted_neigbour_list_file) 
        CALL get_command_argument(3+read_index_shift,no_box_COM_file)
        CALL get_command_argument(4+read_index_shift,zielfile)
        IF(command_argument_count() >= 4+read_index_shift ) THEN
            IF ( read_intramolecular_data) THEN
                IF ( INDEX(zielfile, '.dat') /= 0 ) THEN   ! Benennung zielfile_intra
                        zielfile_intra=zielfile(:(INDEX(zielfile, '.dat')-1))//'_intra.dat'
                ELSE
                        zielfile_intra='Daten_intra.dat'
                END IF ! Benennung Zielfile
                WRITE(*,*) 'Erstelle Daten fuer intramolekularen Ladungstransport in: ', TRIM(zielfile_intra)
            END IF
        END IF
	IF(command_argument_count() >= 5+read_index_shift ) THEN
		CALL get_command_argument(5+read_index_shift,J_AB_file)
		inquire(file=TRIM(J_AB_file),exist=Datei_vorhanden) ! Abfrage ob J_AB_file-Datei vorhanden ist.
        IF( .NOT. Datei_vorhanden) THEN 
            WRITE(*,*) ' Fehler: Die_J_AB_file_Datei_ist_nicht_vorhanden. '//TRIM(J_AB_file)
            WRITE(*,*) ' ENDE'
            CALL EXIT (1)
	     ELSE IF (Datei_vorhanden) THEN		
			Read_J_AB=.true.
        END IF ! J_AB_file-file vorhanden  
        
        IF( INDEX(J_AB_file, '.sql') /= 0 ) THEN
			votca_sqlfile_name=TRIM(J_AB_file)
			Read_J_AB=.true.
			Read_J_AB_from_sql_file=.true.
			WRITE(*,*) 'Using votca sql file to read Jeff2: '//TRIM(votca_sqlfile_name)
		END IF
        
	END IF

	IF(command_argument_count() >= 8+read_index_shift ) THEN 
		!!! Read U_ext in V/m
		CALL get_command_argument(6+read_index_shift,dummyname)
		READ(dummyname,'(f16.4)') U_ext(1)
		CALL get_command_argument(7+read_index_shift,dummyname)
		READ(dummyname,'(f16.4)') U_ext(2)
		CALL get_command_argument(8+read_index_shift,dummyname)
		READ(dummyname,'(f16.4)') U_ext(3)
		WRITE(*,*) 'Read U_ext    [V/m] Ux: ',U_ext(1),' Uy: ',U_ext(2),' Uz: ',U_ext(3)
		U_ext=U_ext*1.0E-10
		WRITE(*,*) ' Converted  [V/Ang] Ux: ',U_ext(1),' Uy: ',U_ext(2),' Uz: ',U_ext(3)
	END IF
	IF(command_argument_count() >= 9+read_index_shift ) THEN 
		CALL get_command_argument(9+read_index_shift,dummyname)
		READ(dummyname,'(f16.0)') T	
		WRITE(*,*) 'Use Temperature [K]  T:',T
	END IF 
    

	IF(command_argument_count() >= 10+read_index_shift ) THEN 
		!!! rate_type= "marcus", "jortner, "weiss_dorsey"
		CALL get_command_argument(10+read_index_shift,dummyname)
		rate_type=TRIM(adjustl(dummyname))
	END IF 

	IF(command_argument_count() >= 11+read_index_shift ) THEN 
		!!! rate_type= options.xml filename
		CALL get_command_argument(11+read_index_shift,dummyname)
		input_options_filename_xml=TRIM(adjustl(dummyname))
	END IF 


        !CALL get_command_argument(6,dummyname)
        !READ(dummyname,'(f8.2)') z_max 
        IF(check_filetermination(gro_inputfile,'.gro'))THEN
			inquire(file=TRIM(gro_inputfile),exist=Datei_vorhanden) ! Abfrage ob gro-Datei vorhanden ist.
			IF( .NOT. Datei_vorhanden) THEN 
				WRITE(*,*) ' Fehler: Die_gro_Datei_ist_nicht_vorhanden. '//TRIM(gro_inputfile)
				WRITE(*,*) ' ENDE'
				CALL EXIT (1)
			END IF ! gro-file vorhanden  
		END IF ! *.gro?

		IF(check_filetermination(sorted_neigbour_list_file,'.ngh'))THEN			
			inquire(file=TRIM(sorted_neigbour_list_file),exist=Datei_vorhanden) ! Abfrage ob sorted_neigbour_list_file-Datei vorhanden ist.
			IF( .NOT. Datei_vorhanden) THEN
						WRITE(*,*) ' Fehler: Die_sorted_neigbour_list_file_Datei_ist_nicht_vorhanden. '//TRIM(sorted_neigbour_list_file)
						WRITE(*,*) ' ENDE'
						CALL EXIT (1)
			END IF ! sorted_neigbour_list_file-file vorhanden 
        END IF ! ?.ngh
        
        IF(check_filetermination(no_box_COM_file,'.xyz'))THEN			
			inquire(file=TRIM(no_box_COM_file),exist=Datei_vorhanden) ! Abfrage ob no_box_COM_file-Datei vorhanden ist.
			IF( .NOT. Datei_vorhanden) THEN
						WRITE(*,*) ' Fehler: Die_no_box_COM_file_Datei_ist_nicht_vorhanden. '//TRIM(no_box_COM_file)
						WRITE(*,*) ' ENDE'
						CALL EXIT (1)
			END IF ! no_box_COM_file-file vorhanden 
		END IF ! ?.xyz

        inquire(file=TRIM(zielfile),exist=Datei_vorhanden) ! Abfrage ob no_box_COM_file-Datei vorhanden ist.
        IF(Datei_vorhanden) THEN
                    WRITE(*,*) ' Fehler: Die_zielfile_file_Datei_ist_bereits_vorhanden. '//TRIM(zielfile)
					WRITE(*,*) ' Stellen Sie sicher, dass diese nicht ueberschrieben wird.'
                    WRITE(*,*) ' ENDE'
                    CALL EXIT (1)
        END IF ! zielfile-file vorhanden 
        
ELSE
    WRITE(*,*) ' J_AB_file/state.sql (intermolekular) ; use in KMC-folder to allow the use of folder ./data/*           '&
		&//'                                    [V/m] [V/m] [V/m]  [K]  '    
    WRITE(*,*)  ' Input: rates_to_VOTCA_sql    gro_inputfile.gro   sorted_neigbour_list_file.ngh  no_box_COM_file.xyz '//&
			&   ' outputname.dat  J_AB_file.dat  '&
			& //'        Ux    Uy    Uz   Temp    rate_type '
    
        CALL EXIT (0)
END IF ! Lese input


!!! multigeo_setup _G${Geo_Step}  
IF(multigeo_setup) THEN
		write(*,*) 'multigeo_setup: ',multigeo_setup
		!! determine _G${Geo_Step} from the file name  as in indexed_G12.gro or indexed_G12_N23.dat => Geo_Step=12
		Geo_Step=get_Geo_Step_from_filename(gro_inputfile)
		J_AB_file='data/Datenauswertung_SAB_H_H0_Jab_H0_H0_SAB_L0_L0_Jab_L0_L0_G'//TRIM(str(Geo_Step))//'.dat'
		IF(Use_reference_data_from_P3HT32mer) THEN
			l_out_filename='data/l_out_dipbi_p3ht_900K_6ns_to_300K_500ps_32mer_G'//TRIM(str(Geo_Step))//'.dat'
			E_multipole_filename='data/E_out_emultipoles_dipbi_p3ht_900K_6ns_to_300K_500ps_32mer_G'//TRIM(str(Geo_Step))//'.dat'
		ELSE IF (set_dE_out_and_l_out_to_zero) THEN
			WRITE(*,*) 'set_dE_out_and_l_out_to_zero: ',set_dE_out_and_l_out_to_zero
		ELSE
			WRITE(*,*) 'Error: Case not implemented for multigeo_setup: Use_reference_data_from_P3HT32mer AND multigeo_setup '
			CALL EXIT(1)
		ENDIF
END IF



!!!!  Check rate  "jortner" or "marcus" or "weiss_dorsey"
IF((TRIM(adjustl(rate_type)) =="jortner") .OR. (TRIM(adjustl(rate_type)) =="Jortner") &
	&.OR.(TRIM(adjustl(rate_type)) =="JORTNER")) THEN 
	rate_type="jortner"
ELSE IF( (TRIM(adjustl(rate_type)) =="marcus") .OR. (TRIM(adjustl(rate_type)) =="Marcus") &
	&.OR. (TRIM(adjustl(rate_type)) =="MARCUS")) THEN
	rate_type="marcus"
ELSE IF(   (TRIM(adjustl(rate_type)) =="weiss_dorsey") .OR. (TRIM(adjustl(rate_type)) =="Weiss_Dorsey") &
	& .OR. (TRIM(adjustl(rate_type)) =="weiss-dorsey") .OR. (TRIM(adjustl(rate_type)) =="Weiss-Dorsey") )THEN
	rate_type="weiss_dorsey"
ELSE
	WRITE(*,*) 'Error: Rate is "'//TRIM(rate_type)//'" not available, choose  "marcus", "jortner" or "weiss_dorsey"  !'
	CALL EXIT(1)
ENDIF !!!!    "jortner" or "marcus" or "weiss_dorsey"
	WRITE(*,*) 'Selected rate_type: ', TRIM(rate_type)
	
	
IF(set_dE_out_and_l_out_to_zero) THEN
	WRITE(*,*) 'Set all dE_out and lambda_out data to zero in rate calculations: ',set_dE_out_and_l_out_to_zero
	IF(TRIM(adjustl(rate_type)) =="jortner" ) then
		WRITE(*,*) 'Outer sphere contributions can not be selected for jortner rates. ' 
		WRITE(*,*) TRIM(adjustl(rate_type)),' revise input set_dE_out_and_l_out_to_zero: ',set_dE_out_and_l_out_to_zero
		CALL EXIT(1)
	END IF
END IF

	write(*,*) "!!!!----------------------------------------------------------------------------!!!!"
	write(*,*) "!!!! selected options  rates_to_votca_sql_file                                  !!!!"
	write(*,*) "!!!!----------------------------------------------------------------------------!!!!"
	write(*,*) "DEBUG:             ",DEBUG 
	write(*,*) "DIPBI_P3HT_calc:   ",DIPBI_P3HT_calc 
	write(*,*) "DIPBI_P3MT_calc:   ",DIPBI_P3MT_calc 
	write(*,*) "P3HT_pur_calc:     ",P3HT_pur_calc 
	write(*,*) "P3MT_pur_calc:     ",P3MT_pur_calc 
	write(*,*) "PPDI_PBDT_TS1_calc:",PPDI_PBDT_TS1_calc 
	write(*,*) "N_Neighbours:  ",N_Neighbours
	write(*,*) "multigeo_setup :  ",multigeo_setup 
	write(*,*) "Geo_Step:  ",Geo_Step
	write(*,*) "rate_type :  ",TRIM(rate_type)                                   
	write(*,*) "set_dE_out_and_l_out_to_zero :  ",set_dE_out_and_l_out_to_zero 
	write(*,*) "set_J_AB_intermolecular_to_zero :  ",set_J_AB_intermolecular_to_zero 
	write(*,*) "Kondo:  ",Kondo
	write(*,*) "temperature: ",T
	write(*,*) "TEST_RATES:  ",TEST_RATES 
	write(*,*) "set_filenames:  ",set_filenames 
	write(*,*) "l_out_filename:  ",TRIM(l_out_filename)                                 
	write(*,*) "E_multipole_filename:  ",TRIM(E_multipole_filename)                    
	write(*,*) "J_AB_filename:  ",TRIM(J_AB_file)                            
	write(*,*) "Read_J_AB_from_sql_file:  ",Read_J_AB_from_sql_file 
	write(*,*) "Read_J_AB :  ",Read_J_AB 
	write(*,*) "linear_scaling_J_AB:  ",linear_scaling_J_AB 
	write(*,*) "J_AB_fit_method_geometry:  ", TRIM(J_AB_fit_method_geometry)               !!! J_AB_fit_method_geometry='Lin_Combi'
	write(*,*) "scale_dipro_results :  ",scale_dipro_results 
	write(*,*) "x_scale_method:  ",TRIM(x_scale_method)                                   !!!  x_scale_method='PM3'
	write(*,*) "y_scale_method:  ",TRIM(y_scale_method)                                   !!!  y_scale_method='CDFT'
	write(*,*) "Read_COM_COM_H_MA_MMA_theta_Data_from_J_AB_file :  ",Read_COM_COM_H_MA_MMA_theta_Data_from_J_AB_file 
	write(*,*) "use_min_d_COM_vector_list :  ",use_min_d_COM_vector_list 
	write(*,*) "min_d_modus : ",TRIM(min_d_modus)
	write(*,*) "print_data_collection_files :  ",print_data_collection_files 
	write(*,*) "mobility_estimate :  ",mobility_estimate 
	write(*,*) "make_Histogramm :  ",make_Histogramm 
	write(*,*) "read_intramolecular_data :  ",read_intramolecular_data 
	write(*,*) "use_fit_intramolecular :  ",use_fit_intramolecular   
	write(*,*) "use_dE_in_AB__approx__dE_vert_CDFT :  ",use_dE_in_AB__approx__dE_vert_CDFT 
	write(*,*) "Use_reference_data_from_P3HT32mer: ",Use_reference_data_from_P3HT32mer
	write(*,*) "use_lambda_out_random_number_Gauss_distribution_data: ",use_lambda_out_random_number_Gauss_distribution_data
	if(use_lambda_out_random_number_Gauss_distribution_data) then
		write(*,*) 'Gauss lambda_out_h=: ',def_lam_out_h,' +/- ',sig_lam_out_h
		write(*,*) 'Gauss lambda_out_e=: ',def_lam_out_e,' +/- ',sig_lam_out_e
	endif
	write(*,*) "Read_l_out: ",Read_l_out
	write(*,*) "Read_E_multipole_out: ",Read_E_multipole_out
	write(*,*) "E_out_randomized_distribution: ",E_out_randomized_distribution
	if(E_out_randomized_distribution) then
		write(*,*) 'Gauss def_E_out_h=: ',def_E_multi_h,' +/- ',sig_E_multi_h
		write(*,*) 'Gauss def_E_out_e=: ',def_E_multi_e,' +/- ',sig_E_multi_e
	endif
	
	write(*,*) "!!!!----------------------------------------------------------------------------!!!!"



IF(data_to_votca_KMC) then
	INQUIRE(file=TRIM(votca_pairfile_name),exist=Datei_vorhanden) ! Abfrage ob votca_pairfile_name-Datei vorhanden ist.
        IF(Datei_vorhanden) THEN 
            WRITE(*,*) ' Fehler: Die_votca_pairfile_name_Datei_ist_vorhanden. '//TRIM(votca_pairfile_name)
            WRITE(*,*) ' Stelle_sicher_dass_diese_nicht_ueberschrieben_wird!'
            WRITE(*,*) ' ENDE'
            CALL EXIT (1)
        END IF ! votca_pairfile_name-file vorhanden  
        
        
        INQUIRE(file=TRIM(votca_segfile_name),exist=Datei_vorhanden) ! Abfrage ob votca_segfile_name-Datei vorhanden ist.
        IF(Datei_vorhanden) THEN 
            WRITE(*,*) ' Fehler: Die_votca_segfile_name_Datei_ist_vorhanden. '//TRIM(votca_segfile_name)
            WRITE(*,*) ' Stelle_sicher_dass_diese_nicht_ueberschrieben_wird!'
            WRITE(*,*) ' ENDE'
            CALL EXIT (1)
        END IF ! votca_segfile_name-file vorhanden  
ENDIF




! Einlesen der Daten aus gro
IF(file_exists(gro_inputfile)) THEN
!!! Bestimmung der Anzahl der Resids: N_Resis
			N_Resids=0 ! counts the number of Resids in the file
			!!! Erstelle String lio=Durcheinander, um die Rechnungen mit Hilfe von Zufallszahlen einzigartig zu machen, sodass keine Interferenzen mit anderen Rechnungen ggf. im gleichen Ordner auftreten können. 
			lio=TRIM(make_lio())
			!! Einlesen der Anzahl der Resids=N_Mol aus gro-file
			Bashline="start_index=$(sed -n '3p' "//TRIM(gro_inputfile)//' | cut -c 1-5) ; end_index=$(tail -2 '//TRIM(gro_inputfile)//&
			&' | head -1 | cut -c 1-5) ; echo ${start_index}  ${end_index} >> s2e_'//TRIM(lio)//'.dat'  ! start 2 end 
			write(*,*) 'tmp: ',trim(Bashline) 
			CALL execute_command_line(TRIM(Bashline)) 
			OPEN(UNIT=32,FILE='s2e_'//TRIM(lio)//'.dat',STATUS='unknown',IOSTAT=ierror,action='read')
			READ(32,*) start_index,end_index
			CLOSE(32)
			Bashline=' rm s2e_'//TRIM(lio)//'.dat '
			CALL execute_command_line(TRIM(Bashline)) 

			N_Resids=end_index-start_index+1
			WRITE(*,*)'  N_Resids= ',N_Resids,' in ',TRIM(gro_inputfile)
			if( N_Resids <=0 ) THEN
				WRITE(*,*) 'Error: Reading the number of resids in: '//TRIM(gro_inputfile)
				CALL EXIT(1)
			endif
!!! Bestimmung der Anzahl der Resids: N_Resis
END IF
OPEN(UNIT=79,FILE=TRIM(gro_inputfile),STATUS='OLD',IOSTAT=ierror)
Read(79,*) dummyname                             !Einlesen des Infokopfes im File
Read(79,*) MAXATM                      !Einlesen der Atomanzahl im File
!WRITE(*,*) 'Anzahl der Atome in *.gro= ', MAXATM
ALLOCATE(atomsorteA(MAXATM))
ALLOCATE(koordA(MAXATM,3))
ALLOCATE(velocities(MAXATM,3))
ALLOCATE(atom(MAXATM))
ALLOCATE(atom_number(MAXATM))
ALLOCATE(residue_number(MAXATM))
ALLOCATE(residue_name(MAXATM))
ALLOCATE(R_u_I(N_Resids+1,2)) ! einen Eintrag mehr, damit an der letzten Stelle, der R_u_I: Resid_und_start_index(N_Resids,Gesamtanzahl+1,2) stehen kann, um die Schleifenbegrenzungen nicht anpassen zu muessen

!!! Defaults
koordA=0
velocities=0
atomsorteA=''
atom=""
atom_number=0
residue_number=-1
residue_name="NoNam"
R_u_I=0
R_u_I(N_Resids+1,1)=-100
R_u_I(N_Resids+1,2)=MAXATM+1

i=0

N_DIPBI=0
N_PPDI=0
N_P3HT=0
N_P3HT_segments=0
N_PBDT_TS1=0
N_PBDT_TS1_segments=0
N_Species=0
! Start to read gro Data
DO j=1,MAXATM 
	READ(79, "(a)",IOSTAT=ierror) line
	BACKSPACE(UNIT=79)
	IF(ierror < 0) EXIT
	IF(ierror > 0) THEN
		WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(gro_inputfile),' aufgetreten.'//TRIM(line)
		WRITE(*,*) 'Beende Einlesen !'
		CALL EXIT (1)
	END IF
	 
	IF (LEN(TRIM(line)) .le. 45 ) THEN ! check if no velocities are written
					READ(79,'(i5,2a5,i5,3f8.3)',IOSTAT=ierror) residue_number(j),residue_name(j),atom(j),atom_number(j),&
													&koordA(j,1),koordA(j,2),koordA(j,3)
					!WRITE(*,'(i5,2a5,i5,3f8.3)',IOSTAT=ierror) residue_numbers(j),residue_names(j),atom(j),atom_numbers(j),&
					!							   &koordA(j,1),koordA(j,2),koordA(j,3)
	ELSE
					READ(79,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) residue_number(j),residue_name(j),atom(j),atom_number(j),&
												 &koordA(j,1),koordA(j,2),koordA(j,3),velocities(j,1),velocities(j,2),velocities(j,3)
					!write(*,*) residue_number(j),residue_name(j),atom(j),atom_number(j),&
					!!         &koordA(j,1),koordA(j,2),koordA(j,3),velocities(j,1),velocities(j,2),velocities(j,3)
	END IF
	
    IF(ierror < 0) THEN
		EXIT
    ELSE IF(ierror > 0) THEN
        WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(gro_inputfile),' aufgetreten.'
        WRITE(*,*) 'Beende Einlesen !'
        CALL EXIT (1)
    END IF
    IF ( (j ==  1) .OR. (residue_number(j) /= residue_number(j-1)) .OR. (j == MAXATM)) THEN
        i=i+1
		R_u_I(i,1)=residue_number(j)
		R_u_I(i,2)=j
		IF((residue_name(j) == 'DIPBI') .OR. (residue_name(j) == 'DPBIK'))THEN
			N_DIPBI=N_DIPBI+1
		ELSE IF (residue_name(j)(1:4) == 'PPDI') THEN
			N_PPDI=N_PPDI+1
		ELSE IF (residue_name(j) == '8poly') THEN
			N_PBDT_TS1_segments=N_PBDT_TS1_segments+1
			IF( TRIM(adjustl(atom(j))) == 'CH3' .and. (j /= MAXATM) ) THEN ! new PBDT_TS1 chain-Start with segment A and a CH3 group.
				N_PBDT_TS1=N_PBDT_TS1+1			
			END IF ! new PBDT_TS1 chain-Start
		ELSE IF ( (residue_name(j)(1:1) == 'A' .and. residue_name(j)(3:3) == 'B') .OR.  &
				& (residue_name(j)(1:1) == 'B' .and. residue_name(j)(3:3) == 'A') ) THEN
			N_PBDT_TS1_segments=N_PBDT_TS1_segments+1
			IF( (TRIM(adjustl(residue_name(j)(5:5))) == 'S') .and. (j /= MAXATM) ) THEN ! new PBDT_TS1 chain-Start with segment A and a CH3 group.
				N_PBDT_TS1=N_PBDT_TS1+1			
			END IF ! new PBDT_TS1 chain-Start
		ELSE IF ((residue_name(j)(1:3) == 'THP') .OR. (residue_name(j)(1:2) == 'PH') .OR. (residue_name(j)(1:2) == 'PM')) THEN
			N_P3HT_segments=N_P3HT_segments+1
			IF( (residue_name(j)(1:5) == 'THP1A') .OR. (residue_name(j)(5:5) == 'S') )THEN ! 32mer start
				N_P3HT=N_P3HT+1
			END IF ! 32mer start
		ELSE 
			N_Species=N_Species+1
		END IF
    END IF
    IF (i==0 .and. j==MAXATM ) THEN
			   write(*,*) ' Error: Es ist ein Fehler beim Einlesen ausgetreten: '//TRIM(gro_inputfile)
			   write(*,*) ' ENDE '
			   CALL EXIT (1)
	END IF  
END DO

write(*,*)  'N_DIPBI: ',N_DIPBI,' N_P3HT: ',N_P3HT,'N_P3HT_segments: ',N_P3HT_segments,&
		 & ' N_PPDI:  ',N_PPDI,'  N_PBDT_TS1: ',N_PBDT_TS1,' N_PBDT_TS1_segments: ',N_PBDT_TS1_segments,' N_Species: ',N_Species
!WRITE(*,*) 'Read boxsize'
READ(79,*,IOSTAT=ierror) x_box,y_box,z_box
IF( ierror > 0) STOP 'Error: Reading_the_boxsize'
WRITE(*,*) 'Boxsize nm:  ',x_box,y_box,z_box
x_box=x_box*10.0
y_box=y_box*10.0
z_box=z_box*10.0
WRITE(*,*) 'Boxsize Ang: ',x_box,y_box,z_box
CLOSE(79)
WRITE(*,*) 'Anzahl der Resids:',N_Resids





INQUIRE(file=TRIM(no_box_COM_file),exist=Datei_vorhanden) ! Abfrage ob no_box_COM_file-Datei vorhanden ist.
IF( .NOT. Datei_vorhanden) THEN
        WRITE(*,*) ' Anmerkung: Die_no_box_COM_file_Datei_ist_nicht_vorhanden.'//TRIM(no_box_COM_file)
		CALL EXIT (1)                                                                               
ELSE 
		IF(check_filetermination(no_box_COM_file,'.xyz'))THEN
			WRITE(*,*) 'Read Data from no_box_COM_file: ',TRIM(no_box_COM_file)
		END IF
        OPEN(UNIT=78,FILE=TRIM(no_box_COM_file),STATUS='OLD',IOSTAT=ierror)

        READ(78,'(I8,/)') MAX_COM                !Einlesen der Atomanzahl / Center of Masses im COM-File.xyz

        !Read(78,*) dummyname              !Einlesen des Infokopfes im File
        !WRITE(*,*) dummyname
        ALLOCATE(no_box_koord(MAX_COM,3))
        i=0
        DO j=1,MAX_COM
            Read(78,*,IOSTAT=ierror) dummyname,no_box_koord(j,1),no_box_koord(j,2),no_box_koord(j,3)
                !WRITE(*,*) no_box_koord(j,1),no_box_koord(j,2),no_box_koord(j,3)
                    IF(ierror < 0) EXIT
                    IF(ierror > 0) THEN
                        WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(no_box_COM_file),'aufgetreten.'
                        WRITE(*,*) 'Beende Einlesen !'
                        CALL EXIT (1)
                    END IF
        END DO
        CLOSE(78)
END IF ! no_box_COM_file.xyz vorhanden 



! Einlesen der Daten aus der Nachbarschaftsliste
ALLOCATE(neighbour_list_COM(N_Resids,N_Neighbours+1))
ALLOCATE(neighbour_list_Res(N_Resids,N_Neighbours+1))
neighbour_list_COM=0
neighbour_list_Res=0
CALL Read_neighbourlist(sorted_neigbour_list_file,N_Resids,N_Neighbours,neighbour_list_COM,neighbour_list_Res)
Offset_Resid=neighbour_list_Res(1,1)  ! Falls die Resids nicht bei 0 starten mit dem Zählen, wie fuer DIPBI 33

IF( P3HT_pur_calc .OR. DIPBI_P3HT_calc ) THEN
	! Einlesen der 33 x 33 Matrizen 
	CALL Read_Matrix_from_file(dE_in_el_file,dE_in_el_mat)
	CALL Read_Matrix_from_file(dE_in_lo_file,dE_in_lo_mat)
	CALL Read_Matrix_from_file(lambda_in_el_file,lambda_in_el_mat)
	CALL Read_Matrix_from_file(lambda_in_lo_file,lambda_in_lo_mat)
ELSE IF (PPDI_PBDT_TS1_calc) THEN
	! Einlesen der 17 x 17 Matrizen 
	CALL Read_Matrix_17x17_from_file(dE_in_el_file,dE_in_el_mat)
	CALL Read_Matrix_17x17_from_file(dE_in_lo_file,dE_in_lo_mat)
	CALL Read_Matrix_17x17_from_file(lambda_in_el_file,lambda_in_el_mat)
	CALL Read_Matrix_17x17_from_file(lambda_in_lo_file,lambda_in_lo_mat)
END IF 


!!! Change definition for dE_AB = dE_A - dE_B  (in Matrix) to   dE_AB = dE_B-dE_A => as marcus rate here goes with (dE_AB + lammbda)**2
dE_in_el_mat=transpose(dE_in_el_mat)
dE_in_lo_mat=transpose(dE_in_lo_mat) 

! Erstelle Array mit der Anzahl der Schwefelatome im Abschnitt, fuer DIPBI wird 33 gewaehlt
ALLOCATE(Resid_and_S(2,N_Resids))
ALLOCATE(residue_name_site(N_Resids))
ALLOCATE(sequence_list(N_Resids))
Resid_and_S=-1
residue_name_site='noMol'
i=1
N_Schwefel=0
 ! Zaehle die Anzahl der Elemente im Molekuel N_CarboxyS2 ueber Anzahl der F-Atome und N_PBDT=(N_HC-Gruppen/6) uber die Anzahl der HC-Gruppen
N_CarboxyS2=0
N_PBDT=0
mol_start_da=.false.
mol_ende_da=.false.
thiophene_found=.false. 
fin=''
segtype=''
segtype2=''
sequence=''
sequence_list=''
DO j=2,MAXATM
    IF (TRIM(adjustl(atom(j)))=='S')  N_Schwefel=N_Schwefel+1
    IF (TRIM(adjustl(atom(j)))=='F')  N_CarboxyS2=N_CarboxyS2+1
    IF (TRIM(adjustl(atom(j)))=='HC') N_PBDT=N_PBDT+1
    !! Check start P3HT
    

	IF ( (TRIM(adjustl(residue_name(j-1)(1:2)))=='PH') .OR. (TRIM(adjustl(residue_name(j-1)(1:2)))=='PM' ) .OR. &
		&    (TRIM(adjustl(residue_name(j-1)(1:2)))=='P3') .OR. (TRIM(adjustl(residue_name(j-1)(1:3)))=='THP') ) THEN  !!! FIND P3HT/P3MT/THP  
		thiophene_found=.true. 
		!!! Startsegment 
		IF( (TRIM(adjustl(atom(j-1))) == 'HC') .AND. (TRIM(adjustl(atom(j))) == 'CA') .OR. &
		&	(TRIM(adjustl(atom(j-1))) == 'HC') .AND. ((TRIM(adjustl(residue_name(j-1))) == 'DIPBI') &
		&   .OR. (TRIM(adjustl(residue_name(j-1))) == 'DPBIK'))  ) THEN
			mol_start_da=.true.
		END IF

	END IF
    
    
    
    !! Check start and end of polymer chain
    IF( residue_name(j) == '8poly' ) THEN ! Determine start / end and sequence of polymer chain and the index
		IF( (TRIM(adjustl(atom(j-1)))=='CH3') .and. (TRIM(adjustl(atom(j+3)))=='F') .and. (TRIM(adjustl(atom(j+7)))=='OE')  )THEN  ! Start CarboxyS2 unit
			mol_start_da=.true.
			segtype='A'
			sequence=TRIM(sequence)//TRIM(segtype)
		ELSE IF( (TRIM(adjustl(atom(j)))=='CH3') .and. (TRIM(adjustl(atom(j-1)))=='HC') )THEN ! End chain 
			mol_ende_da=.true.
		ELSE IF( TRIM(adjustl(atom(j+3)))=='F' .and. TRIM(adjustl(atom(j-1)))=='HC') THEN ! Mittlel CarboxyS2
			segtype='A'
			sequence=TRIM(sequence)//TRIM(segtype)		
		ELSE IF (       (TRIM(adjustl(atom(j+1)))=='S') .and. (TRIM(adjustl(atom(j+10)))=='HC') ) THEN  ! PBDT segment
				IF  (   (TRIM(adjustl(atom(j+1))) =='S') .and. (TRIM(adjustl(atom(j))) =='C')  &    ! angle theta atoms
				& .and. (TRIM(adjustl(atom(j-2 ))) =='C') .and. (TRIM(adjustl(atom(j-1))) == 'S')) THEN 
					segtype='B'
					sequence=TRIM(sequence)//TRIM(segtype)
				END IF ! angle theta atoms
		END IF ! PBDT segment
    END IF ! 8poly
    
    IF ( (j /= 1) .AND. (residue_number(j) /= residue_number(j-1)) ) THEN ! Neue Residue_number ?
        IF( residue_name(j-1) == 'DIPBI' .OR. residue_name(j-1) == 'DPBIK' ) THEN
            Resid_and_S(2,i)=33
            residue_name_site(i)=residue_name(j-1)
        ELSE IF( residue_name(j-1) == 'PPDI_' ) THEN
            Resid_and_S(2,i)=1
            residue_name_site(i)=residue_name(j-1)
        ELSE IF( residue_name(j-1) == '8poly' ) THEN
			IF( .not. mol_ende_da) THEN
				sequence=TRIM(sequence(:LEN_TRIM(sequence)-1)) 
				Resid_and_S(2,i)=PBDT_TS1_sequence_to_index(sequence)  
				sequence_list(i)=TRIM(sequence) 
				sequence=TRIM(segtype)
			ELSE ! END CHAIN
				Resid_and_S(2,i)=PBDT_TS1_sequence_to_index(sequence) 
				sequence_list(i)=TRIM(sequence)  
				sequence=''			
			END IF
                 
            IF( mol_start_da .and. mol_ende_da ) THEN
				fin='A'
            ELSE IF (mol_start_da) THEN
				fin='S'
			ELSE IF (mol_ende_da) THEN
				fin='E'
			ELSE
				fin='M'
			END IF
			IF( TRIM(sequence_list(i)(1:1)) == 'A' ) THEN
				residue_name_site(i)='A'//TRIM(str(N_CarboxyS2))//'B'//TRIM(str(N_PBDT/6))//TRIM(fin)
			ELSE IF( TRIM(sequence_list(i)(1:1)) == 'B' ) THEN
				residue_name_site(i)='B'//TRIM(str(N_PBDT/6))//'A'//TRIM(str(N_CarboxyS2))//TRIM(fin)
			END IF 
            IF (DEBUG) WRITE(*,*)  residue_number(j-1),TRIM(sequence_list(i)),Resid_and_S(2,i),residue_name_site(i) 
            
        ELSE IF (thiophene_found) THEN !!! P3HT / P3MT
         		!!! Endsegment
			IF( TRIM(adjustl(atom(j-8))) == 'HC' ) THEN
				mol_ende_da=.true.
			END IF
        	fin=''
			IF( (mol_start_da) .and. (mol_ende_da) ) THEN
					fin='A'
			ELSE IF (mol_start_da) THEN
					fin='S'
			ELSE IF (mol_ende_da) THEN
					fin='E'
			ELSE
					fin='M'
			END IF
			
			IF(KETTE .OR. DIPBI_P3HT_calc .OR. P3HT_pur_calc) THEN
				segtype2='PH'
			ELSE IF (DIPBI_P3MT_calc .OR. P3MT_pur_calc) THEN
				segtype2='PM'
			ELSE
				segtype2='xx'
			END IF
			
			IF ( N_Schwefel < 10 ) THEN
				residue_name_site(i)=TRIM(segtype2)//'0'//TRIM(str(N_Schwefel))//TRIM(fin)
			ELSE IF( N_Schwefel < 31 ) THEN
				residue_name_site(i)=TRIM(segtype2)//TRIM(str(N_Schwefel))//TRIM(fin)
			ELSE IF( N_Schwefel == 32 ) THEN
						IF(KETTE .OR. DIPBI_P3HT_calc .OR. P3HT_pur_calc) THEN
								residue_name_site(i)='P3HTA'
						ELSE IF( P3MT_pur_calc) THEN
								residue_name_site(i)='P3MTA'
						ELSE 
								residue_name_site(i)='xxxxA'
						END IF !Kette
			END IF ! N_Schwefel = ??
			segtype2=''
			!!! P3HT / P3MT
			Resid_and_S(2,i)=N_Schwefel
        ELSE
            Resid_and_S(2,i)=N_Schwefel
            residue_name_site(i)=residue_name(j-1)
        END IF ! Residue_name == DIPBI
        Resid_and_S(1,i)=residue_number(j-1)
        
        N_Schwefel=0
		N_CarboxyS2=0
		N_PBDT=0
		mol_start_da=.false.
		mol_ende_da=.false.
        i=i+1
    ELSE IF( (j == MAXATM) ) THEN ! Letztes Element
        IF( residue_name(j) == 'DIPBI' .OR. residue_name(j) == 'DPBIK' ) THEN
            Resid_and_S(1,i)=residue_number(j)
            Resid_and_S(2,i)=33
            residue_name_site(i)=residue_name(j)
        ELSE IF( residue_name(j-1) == 'PPDI_' ) THEN
            Resid_and_S(1,i)=residue_number(j)
            Resid_and_S(2,i)=1
            residue_name_site(i)=residue_name(j)
        ELSE IF( residue_name(j-1) == '8poly' ) THEN
			Resid_and_S(1,i)=residue_number(j)
            Resid_and_S(2,i)=PBDT_TS1_sequence_to_index(sequence)
            sequence_list(i)=TRIM(sequence) 
            IF( mol_start_da .and. mol_ende_da ) THEN
				fin='A'
            ELSE IF (mol_start_da) THEN
				fin='S'
			ELSE IF (mol_ende_da) THEN
				fin='E'
			ELSE
				fin='M'
			END IF
			IF( TRIM(sequence_list(i)(1:1)) == 'A' ) THEN
				residue_name_site(i)='A'//TRIM(str(N_CarboxyS2))//'B'//TRIM(str(N_PBDT/6))//TRIM(fin)
			ELSE IF( TRIM(sequence_list(i)(1:1)) == 'B' ) THEN
				residue_name_site(i)='B'//TRIM(str(N_PBDT/6))//'A'//TRIM(str(N_CarboxyS2))//TRIM(fin)
			END IF 
			!!! END PBDT_TS1 = 8poly			
			IF (DEBUG) WRITE(*,*) Resid_and_S(1,i),TRIM(sequence_list(i)),Resid_and_S(2,i),residue_name_site(i),'END PBDT-TS1'
			
        ELSE IF  (thiophene_found) THEN !!! P3HT / P3MT!P3HT
				
				IF(KETTE .OR. DIPBI_P3HT_calc .OR. P3HT_pur_calc) THEN
					segtype2='PH'
				ELSE IF (DIPBI_P3MT_calc .OR. P3MT_pur_calc) THEN
					segtype2='PM'
				ELSE
					segtype2='xx'
				END IF
			
				IF ( N_Schwefel < 10 ) THEN
					residue_name_site(i)=TRIM(segtype2)//'0'//TRIM(str(N_Schwefel))//'E'
				ELSE IF( N_Schwefel < 31 ) THEN
					residue_name_site(i)=TRIM(segtype2)//TRIM(str(N_Schwefel))//'E'
				ELSE IF( N_Schwefel == 32 ) THEN
						IF(KETTE .OR. DIPBI_P3HT_calc .OR. P3HT_pur_calc) THEN
								residue_name_site(i)='P3HTA'
						ELSE IF (DIPBI_P3MT_calc .OR. P3MT_pur_calc) THEN
								residue_name_site(i)='P3MTA'
						ELSE 
								residue_name_site(i)='xxxxA'
						END IF !Kette
				END IF ! N_Schwefel = ??
				Resid_and_S(1,i)=residue_number(j)
				Resid_and_S(2,i)=N_Schwefel
				
				!!! !!  P3HT / P3MT!P3HT 
        ELSE !! END ! Letztes Element
            Resid_and_S(1,i)=residue_number(j)
            Resid_and_S(2,i)=N_Schwefel
            residue_name_site(i)=residue_name(j)
        END IF ! Residue_name == DIPBI
        
        N_Schwefel=0  
		N_CarboxyS2=0
		N_PBDT=0
		mol_start_da=.false.
		mol_ende_da=.false.
		thiophene_found=.false. 
		sequence=''
        i=i+1
    END IF ! Neue Residue_number ?
END DO


IF(DEBUG) THEN
	WRITE(*,*) 'Resid: ',Resid_and_S(1,1),' Index_S:',Resid_and_S(2,1)
	WRITE(*,*) Resid_and_S(1,2),Resid_and_S(2,2)
	!WRITE(*,*) Resid_and_S(:,:)
	WRITE(*,*) Resid_and_S(1,N_Resids-1),Resid_and_S(2,N_Resids-1)
	WRITE(*,*) Resid_and_S(1,N_Resids),Resid_and_S(2,N_Resids)
END IF
!!! Ende Erstellung der Resid-Schwefel-Index-Array




!! Erstelle Datensammlung in 
!! i = 1 bis Anzahl der Paare 
!! j = { 1= dE_in_el, 2=dE_in_lo, 3=lambda_in_el, 4=lambda_in_lo, 5=J_AB_in_el,6=J_AB_lo, 7=k_KMC } ! von 1 bis 7
N_Pairs=N_Neighbours*N_Resids 
ALLOCATE(R_u_S(N_Pairs,4))
ALLOCATE(Inter(N_Pairs,7))
ALLOCATE(residue_names_pair(N_Pairs,2))

R_u_S=0  ! Nullsetzen
Inter=0.0 ! Nullsetzen
count_pair=1         !(i-1)*N_Neighbours+j)
residue_names_pair='noMol'
NA=0 ! N zum Durchzaehlen der Nachbarn
DO i=1,N_Resids,1
    DO j=1,N_Neighbours,1
        R_u_S(count_pair,1)=INT(neighbour_list_Res(i,1))    ! Resid A
        R_u_S(count_pair,2)=INT(neighbour_list_Res(i,j+1))  ! Nachbarn Uebergeben fuer indizes 2 bis 13
        R_u_S(count_pair,3)=Resid_and_S(2,i)
		residue_names_pair(count_pair,1)=residue_name_site(i)
        DO k=1,N_Resids,1
            IF( R_u_S(count_pair,2) == Resid_and_S(1,k) ) THEN
                R_u_S(count_pair,4)=Resid_and_S(2,k)
                residue_names_pair(count_pair,2)=residue_name_site(k)
                EXIT ! Aus Do k -Loop raus 
            END IF
        END DO
        Inter(count_pair,1)=dE_in_el_mat(R_u_S(count_pair,3),R_u_S(count_pair,4))
        Inter(count_pair,2)=dE_in_lo_mat(R_u_S(count_pair,3),R_u_S(count_pair,4))
        Inter(count_pair,3)=lambda_in_el_mat(R_u_S(count_pair,3),R_u_S(count_pair,4))
        Inter(count_pair,4)=lambda_in_lo_mat(R_u_S(count_pair,3),R_u_S(count_pair,4))
        !WRITE(*,*) R_u_S(count_pair,1),R_u_S(count_pair,2),R_u_S(count_pair,3),R_u_S(count_pair,4)
        !WRITE(*,*) Inter(count_pair,1),Inter(count_pair,2),Inter(count_pair,3),Inter(count_pair,4)
        count_pair=count_pair+1
    END DO
END DO ! Schleife ueber N_Resids






count_pair=N_Pairs
IF(DEBUG) THEN
	WRITE(*,*) 'Resid_A   Resid_B     S_A  S_B  dE_in_el, 2=dE_in_lo, 3=lambda_in_el, 4=lambda_in_lo, 5=J_AB_in_el,6=J_AB_lo, 7=k_KMC '
	WRITE(*,*) R_u_S(count_pair,1),R_u_S(count_pair,2),R_u_S(count_pair,3),R_u_S(count_pair,4), &
		&Inter(count_pair,1),Inter(count_pair,2),Inter(count_pair,3),Inter(count_pair,4)
		
	count_pair=1 
	WRITE(*,*) 'Pair       :',count_pair
	WRITE(*,*) R_u_S(count_pair,1),R_u_S(count_pair,2),R_u_S(count_pair,3),R_u_S(count_pair,4), &
		&Inter(count_pair,1),Inter(count_pair,2),Inter(count_pair,3),Inter(count_pair,4)
	count_pair=12
	WRITE(*,*) 'Pair       :',count_pair
	WRITE(*,*) R_u_S(count_pair,1),R_u_S(count_pair,2),R_u_S(count_pair,3),R_u_S(count_pair,4), &
		&Inter(count_pair,1),Inter(count_pair,2),Inter(count_pair,3),Inter(count_pair,4)
	count_pair=13
	WRITE(*,*) 'Pair       :',count_pair
	WRITE(*,*) R_u_S(count_pair,1),R_u_S(count_pair,2),R_u_S(count_pair,3),R_u_S(count_pair,4), &
		&Inter(count_pair,1),Inter(count_pair,2),Inter(count_pair,3),Inter(count_pair,4)
END IF



IF ((Read_J_AB) .AND. ( .NOT. (Read_J_AB_from_sql_file)) )THEN ! Einlesen der Uebergangsmatrixelemente aus DIPRO
    ALLOCATE(J_AB_Daten(N_Resids*N_Neighbours,4))
    ALLOCATE(J_AB_da(N_Resids*N_Neighbours))
    ALLOCATE(k_inter(N_Resids*N_Neighbours,4))  ! 1=k_el_inter_AB   2=k_lo_inter_AB  3=k_el_inter_BA   4=k_lo_inter_BA 
    k_inter=0.0
    ALLOCATE(dist_COM_inter(N_Resids*N_Neighbours))
    dist_COM_inter=0.0
    CALL Read_J_AB_from_file(J_AB_file,N_Resids,N_Neighbours,neighbour_list_Res,J_AB_Daten,J_AB_da)
ELSE IF ((Read_J_AB) .AND. (Read_J_AB_from_sql_file))THEN 
    ALLOCATE(J_AB_Daten(N_Resids*N_Neighbours,4))
    ALLOCATE(J_AB_da(N_Resids*N_Neighbours))
    ALLOCATE(k_inter(N_Resids*N_Neighbours,4))  ! 1=k_el_inter_AB   2=k_lo_inter_AB  3=k_el_inter_BA   4=k_lo_inter_BA 
    k_inter=0.0
    ALLOCATE(dist_COM_inter(N_Resids*N_Neighbours))
    dist_COM_inter=0.0
	!!! read J_AB data from *.sql file to J_AB_daten and J_AB_da
	CALL get_J_AB_from_sql_file(votca_sqlfile_name,seg1_seg2_J_AB_data,pairs_seg1_seg2_J_AB_data,N_sql_JAB_lines,&
												&N_Resids,N_Neighbours,neighbour_list_Res,J_AB_Daten,J_AB_da)
    
ELSE IF(Read_COM_COM_H_MA_MMA_theta_Data_from_J_AB_file) THEN
		ALLOCATE(J_AB_Daten(N_Resids*N_Neighbours,4))
    	ALLOCATE(J_AB_da(N_Resids*N_Neighbours))
    	ALLOCATE(k_inter(N_Resids*N_Neighbours,4))  ! 1=k_el_inter_AB   2=k_lo_inter_AB  3=k_el_inter_BA   4=k_lo_inter_BA 
    	k_inter=0.0
    	ALLOCATE(dist_COM_inter(N_Resids*N_Neighbours))
    	dist_COM_inter=0.0
		CALL get_JAB_from_Geo_Data_for_neighbourlist(J_AB_file,N_Resids,N_Neighbours,neighbour_list_Res,J_AB_Daten,J_AB_da,&
							&residue_names_pair,dist_COM_inter,& 
							&J_AB_fit_method_geometry,N_Geo_Data_lines,seg1_seg2_Geo_Data_pairs,Geo_Data_pairs,Geo_Data_da) !! DATA from Read_COM_COM_H_MA_MMA_theta_from_J_AB_from_file
	
END IF ! Read_J_AB



IF(set_J_AB_intermolecular_to_zero) THEN
		WRITE(*,*) 'WARNING:  Set all intermolecular |J_AB| to zero!!  set_J_AB_intermolecular_to_zero:', set_J_AB_intermolecular_to_zero
		J_AB_Daten(:,4)=0.0
		J_AB_Daten(:,2)=0.0
END IF



IF(scale_dipro_results) THEN  
		WRITE(*,*) 'Use scaling method for |J_AB|: y:',TRIM(y_scale_method),' x: ',TRIM(x_scale_method),&
				&'  linear_scaling_J_AB:',linear_scaling_J_AB
		DO i=1,N_Resids*N_Neighbours
			IF (J_AB_da(i)) THEN
				J_AB_Daten(i,2)=scale_dipro_function_hole(y_scale_method,x_scale_method,J_AB_Daten(i,2),linear_scaling_J_AB)
				J_AB_Daten(i,4)=scale_dipro_function_electron(y_scale_method,x_scale_method,J_AB_Daten(i,4),linear_scaling_J_AB)
			END IF ! J_AB_da
		 END DO ! loop all J_AB
END IF ! select scale_dipro_results	




IF(Read_l_out .AND. (.NOT. set_dE_out_and_l_out_to_zero)) THEN
	!! reading read_lambda_out_file data 
        !! with the format from sql file: id,seg1,seg2,lOh,lOe
	!! sqlite3 statefile.sql ' SELECT id,seg1,seg2,lOh,lOe  FROM pairs ' >> l_out_filename
	CALL read_lambda_out_file(l_out_filename,seg1_seg2_l_out,N_l_out_data,N_l_out_lines)
   	!! shift index for resids VOTCA -> to OUZO
	j=seg1_seg2_l_out(1,1)-residue_number(1)
	seg1_seg2_l_out(:,1)=seg1_seg2_l_out(:,1)-j
	seg1_seg2_l_out(:,2)=seg1_seg2_l_out(:,2)-j
	WRITE(*,*) 'SEG1SEG2 shifted: ',seg1_seg2_l_out(1,1),seg1_seg2_l_out(1,2),' j_Shift: ',j
ELSE 
	WRITE(*,*) 'Set l_out to zero: ',set_dE_out_and_l_out_to_zero
	N_l_out_lines=0
	ALLOCATE(seg1_seg2_l_out(1,2))
	ALLOCATE(N_l_out_data(1,2))
	seg1_seg2_l_out=0
	N_l_out_data=0
END IF





IF(Read_E_multipole_out .AND. (.NOT. set_dE_out_and_l_out_to_zero)) THEN
		CALL read_E_multipole_out_file(E_multipole_filename,id_E_out,E_out_data,N_E_out_lines)
	   	!!! shift index for resids VOTCA -> to OUZO
		j=id_E_out(1)-residue_number(1)
		id_E_out(:)=id_E_out(:)-j
		WRITE(*,*) 'E_out index shifted: ',id_E_out(1),' j_Shift: ',j
ELSE
		WRITE(*,*) 'Set E_out to zero: ',set_dE_out_and_l_out_to_zero
		ALLOCATE(dE_out_pairs(N_Pairs,4))
		dE_out_pairs=0.0
		ALLOCATE(id_E_out(N_Pairs))
		id_E_out=0
		ALLOCATE(E_out_data(N_Pairs,2))
		E_out_data=0
		N_E_out_lines=0
END IF



if(use_Molecular_class) then
	!! adapt the hopping pairs
	write(*,*) "use_Molecular_class  adapt the hopping pairs: ",N_Pairs
	if( .not. allocated(system2%hoppingpairs) ) then
		allocate(system2%hoppingpairs(N_Pairs))
	endif
	DO i=1,N_Pairs

		CALL init_hoppingpair_in_system(new_hoppingpair,system2)

		new_hoppingpair%residA=R_u_S(i,1)
		new_hoppingpair%residB=R_u_S(i,2)
		new_hoppingpair%E_in_e =Inter(i,1)
		new_hoppingpair%E_in_h =Inter(i,2)
		new_hoppingpair%l_in_e =Inter(i,3)
		new_hoppingpair%l_in_h =Inter(i,4)
		new_hoppingpair%has_intramolecular=.false.
		
		system2%hoppingpairs(i)=new_hoppingpair

	ENDDO ! i to N_Pairs
	write(*,*) "Initialize hopping pairs done."
endif !  use_Molecular_class


!!! SETUP data in system_d
IF( use_min_d_COM_vector_list) THEN
		WRITE(*,*) 'DATA for system with H atoms is not available here'

		!!! Read and modify gro data
		setup%gro_inputfile=gro_inputfile
		!setup%gro_inputfile='data/out_mischbox_900k_30ns-34ns_60deg_G0.gro'
		write(*,*) 'read gro_inputfile: ',trim(gro_inputfile)
		!write(*,*) 'read setup%gro_inputfile: ',trim(setup%gro_inputfile)
 		CALL  read_grofile_data(gro_data,setup)
		
		!! Delete the numbers in the atom string for P3HT and DIPBI
		IF( (N_DIPBI > 0) .or. (N_P3HT > 0) .or. (N_Species > 0) ) then
			DO i=1,gro_data%N_Atoms
				gro_data%atomsorte(i)=TRIM(ADJUSTL(delete_numbers_from_string(gro_data%atomsorte(i))))
			ENDDO
		endif
						!! convert koord data to Angstroem
		if(trim(adjustl(gro_data%koord_unit)) == 'nm') then
				gro_data%koord=gro_data%koord*nm2Ang	
		
				gro_data%x_box=gro_data%x_box  *nm2Ang
				gro_data%y_box=gro_data%y_box  *nm2Ang
				gro_data%z_box=gro_data%z_box  *nm2Ang
				gro_data%koord_unit= 'Ang'
		endif
		
		write(*,*) 'wrap_all_molecules_into_the_box: ',setup%wrap_all_molecules_into_the_box
		IF(KMC_setup%wrap_all_molecules_into_the_box) THEN
			DO i=1,gro_data%N_Atoms
					dr=gro_data%koord(i,:)
					CALL position_PBC_correction(dr,gro_data%x_box,gro_data%y_box,gro_data%z_box)
					DO k=1,3
						gro_data%koord(i,k)=1.0*dr(k)
					END DO 
			END DO
		END IF
		
		write(*,*) 'unite_PBC_split_molecule: ',setup%unite_PBC_split_molecule
		IF(setup%unite_PBC_split_molecule) then
			DO i=1, gro_data%N_Resids
				NAtoms=gro_data%R_u_I(i+1,2)-gro_data%R_u_I(i,2)
				if( allocated(Koords)) deallocate(Koords) 
				allocate(Koords(NAtoms,3))
				k=0
				DO j = gro_data%R_u_I(i,2), gro_data%R_u_I(i+1,2)-1
					k = k + 1
					Koords(k,1:3) = gro_data%koord(j,1:3)
				END DO
				!write(*,*) 'Resid: ', gro_data%R_u_I(i,1),' NAtoms: ',NAtoms
				CALL PBC_center_molecule(NAtoms,Koords,gro_data%x_box, gro_data%y_box, gro_data%z_box)
				k=0
				DO j = gro_data%R_u_I(i,2), gro_data%R_u_I(i+1,2)-1
					k = k + 1
					gro_data%koord(j,1:3) = Koords(k,1:3)
				ENDDO ! j=?
			ENDDO  ! i=?
		ENDIF ! unite_PBC_split_molecule
		
		write(*,*) 'cut_side_chains_in_gro: ',setup%cut_side_chains_in_gro
		IF(setup%cut_side_chains_in_gro .and. gro_data%has_side_chains) then
			call cut_side_chains(gro_data)
		END IF
		call update_KMC_system_gro_data(gro_data)
	
		!call make_min_d_COM_vector_list(min_d_COM_arr,system,N_Resids,R_u_I_H,GesamtanzahlH,residue_numbersH,residue_namesH,elementsH,koordH,&
		!&neighbourlist_filename,gro_inputfile,N_DIPBI,N_P3HT,N_PPDI,N_PBDT_TS1,N_Species,N_Neighbours,neighbour_list_Res,&
		!&x_box,y_box,z_box
		
		call make_min_d_COM_vector_list(min_d_modus,min_d_COM_arr,system2,gro_data%N_Resids,&
		& gro_data%R_u_I,gro_data%N_Atoms,gro_data%residue_numbers,&
		& gro_data%residue_names, gro_data%atomsorte, gro_data%koord,&
		& sorted_neigbour_list_file, setup%gro_inputfile,N_DIPBI,N_P3HT,N_PPDI,N_PBDT_TS1,N_Species,N_Neighbours,neighbour_list_Res,&
		& x_box,y_box,z_box)
		
ENDIF !!! SETUP data in system_d



!!!!!!!!!!!!!!!! INTRAMOLECULAR DATA ANALYSIS !!!!!!!!!!!!!!!!!!!!!!!!!!!!
IF (read_intramolecular_data) THEN

	IF( P3HT_pur_calc .OR. DIPBI_P3HT_calc .OR. P3MT_pur_calc .OR. DIPBI_P3MT_calc  ) THEN
	     CALL winkel_intramolekular(residue_number,residue_name,atom,atom_number,koordA,MAXATM,N_Resids,ResidX_in_32mer,&
   		&intra_theta_E,N_P3HT_Intra,N_DIPBI,N_P3HT_segments,R_intra,read_intramolecular_data,use_fit_intramolecular,&
                &P3HT_intr_in_lo_file,P3HT_intr_in_el_file,P3HT_dE_intr_in_lo_file,P3HT_dE_intr_in_el_file)
	ELSE IF (PPDI_PBDT_TS1_calc) THEN
	  CALL winkel_intra_PBDT_TS1(residue_number,residue_name,atom,atom_number,koordA,MAXATM,N_Resids,ResidX_in_32mer,&
                       &intra_theta_E,N_P3HT_Intra,N_PPDI,N_P3HT_segments,R_intra,read_intramolecular_data,use_fit_intramolecular,& 
    & PBDT_TS1_AB_dE_intr_in_el_file,PBDT_TS1_BA_dE_intr_in_el_file,PBDT_TS1_AB_dE_intr_in_lo_file,PBDT_TS1_BA_dE_intr_in_lo_file,&
    & PBDT_TS1_AB_J_intra_in_el_file,PBDT_TS1_BA_J_intra_in_el_file,PBDT_TS1_AB_J_intra_in_lo_file,PBDT_TS1_BA_J_intra_in_lo_file)
    
    WRITE(*,*) 'PPDI_PBDT_TS1_calc: N_P3HT_Intra:',N_P3HT_Intra,'N_P3HT_segments:',N_P3HT_segments,' N_PPDI:',N_PPDI
		
	END IF 
	
	IF (Read_E_multipole_out) THEN
	!! Create R_u_S_intra

 	CALL dE_out_for_pairs(R_intra,N_P3HT_Intra,N_P3HT_segments,N_DIPBI,E_out_data,id_E_out,N_E_out_lines,ResidX_in_32mer,&
	  	&E_out_randomized_distribution,def_E_multi_h,sig_E_multi_h,def_E_multi_e,sig_E_multi_e,&
		&Use_reference_data_from_P3HT32mer,&
	  	&def_DIPBI_E_multi_h,sig_DIPBI_E_multi_h,def_DIPBI_E_multi_e,sig_DIPBI_E_multi_e,dE_out_pairs_intra)
	ELSE 
		ALLOCATE(dE_out_pairs_intra(N_P3HT_segments,4))
		dE_out_pairs_intra=0.0
		N_E_out_lines=0
	END IF






!!! useless defaults
A32mer=-1
B32mer=-1
!!!!!!!!!!!!! WRITE intramolecular Data!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
IF(print_data_collection_files) THEN
	 OPEN(UNIT=76,FILE=TRIM(zielfile_intra),STATUS='REPLACE',IOSTAT=ierror)

	WRITE(76,*) '### Datensammlung  aus '//TRIM(gro_inputfile)//' '//TRIM(sorted_neigbour_list_file)//' '//TRIM(no_box_COM_file)//' '&
		    &//TRIM(P3HT_intr_in_lo_file)//' '//TRIM(P3HT_intr_in_el_file)//' '&
		    &//TRIM(P3HT_dE_intr_in_lo_file)//' '//TRIM(P3HT_dE_intr_in_el_file)
	!index in intra_theta_E(i,j):: i=1,M_P3HT_Intra j== 1= theta , 2=dE_in_el,   3=dE_in_lo, 4=|J_AB(el)| , 5=|J_AB(lo)|   

	WRITE(*,*) '###  1=index;   2=R1        3=R2      4=theta,     5=dE_in_el,       6=dE_in_lo,   7=lambda_in_el,   8=lambda_in_lo  '& 
		&'  9=|J_AB(el)|,     10=|J_AB(lo)| ||    11=k_intra_el(AB)    12=k_intra_lo(AB)    13=k_intra_el(BA)   14=k_intra_lo(BA)'&
		&'  15 =lambda_in_el_BA   16=lambda_in_el_BA  '
	WRITE(76,*) '###  1=index;   2=R1       3=R2      4=theta,     5=dE_in_el,       6=dE_in_lo,   7=lambda_in_el,   8=lambda_in_lo  '& 
		&'  9=|J_AB(el)|,     10=|J_AB(lo)| ||    11=k_intra_el(AB)    12=k_intra_lo(AB)    13=k_intra_el(BA)   14=k_intra_lo(BA)'&
		&'  15 =lambda_in_el_BA   16=lambda_in_el_BA  '
END IF !   print_data_collection_files

    DO j=1,N_P3HT_Intra    ! Schleife uber Anzahl SCCS-Winkel die in P3HT als Unterabschnitte dienen.
			
			COM_1=no_box_koord(R_intra(j,1)-Offset_Resid+1,:)   !index_i=(Resid_1-Offset_Resid+1)
			COM_2=no_box_koord(R_intra(j,2)-Offset_Resid+1,:)
			IF(  use_min_d_COM_vector_list) THEN
				!! bestimmt dE_U_ext
				CALL calc_dE_U_ext_min_d_COM_vector_list(U_ext,N_Resids,N_Neighbours,R_intra(j,1),R_intra(j,2), &
															&min_d_COM_arr,x_box,y_box,z_box,dE_U_ext,dist_vec,WARNING)
				IF(WARNING) THEN ! BACKUP -> COM differenz!
					dE_U_ext=calc_dE_U_ext(U_ext,COM_1,COM_2,x_box,y_box,z_box)
					!??? dist_COM_intra(j)=norm(dist_vec)
				ENDIF 
			ELSE
				!WRITE(*,*) R_intra(j,1),R_intra(j,2) 
				!WRITE(*,*) ' COM_1: ',COM_1,' COM_2: ',COM_2
				!dist_COM_intra(i)=norm(COM_2-COM_1)
				dE_U_ext=calc_dE_U_ext(U_ext,COM_1,COM_2,x_box,y_box,z_box)
			ENDIF

        ! Lambdas aus der Matrix- aus der Resid wird erst S bestimmt und aus der Matrix dann das entsprechende Element gewaehlt
        lambda_in_el_AB=lambda_in_el_mat(Resid_and_S(2,(R_intra(j,1)-Offset_Resid+1)),Resid_and_S(2,(R_intra(j,2)-Offset_Resid+1)))
        lambda_in_lo_AB=lambda_in_lo_mat(Resid_and_S(2,(R_intra(j,1)-Offset_Resid+1)),Resid_and_S(2,(R_intra(j,2)-Offset_Resid+1)))
        !! Rueckrichtung der Rate  B-> A
        lambda_in_el_BA=lambda_in_el_mat(Resid_and_S(2,(R_intra(j,2)-Offset_Resid+1)),Resid_and_S(2,(R_intra(j,1)-Offset_Resid+1)))
        lambda_in_lo_BA=lambda_in_lo_mat(Resid_and_S(2,(R_intra(j,2)-Offset_Resid+1)),Resid_and_S(2,(R_intra(j,1)-Offset_Resid+1)))
        
        !! 
		IF(.NOT. use_dE_in_AB__approx__dE_vert_CDFT) THEN
			!!! dE_AB_in  =  dE_A_in - dE_B_in
			intra_theta_E(j,2)=dE_in_el_mat(Resid_and_S(2,(R_intra(j,1)-Offset_Resid+1)),Resid_and_S(2,(R_intra(j,2)-Offset_Resid+1)))
			intra_theta_E(j,3)=dE_in_lo_mat(Resid_and_S(2,(R_intra(j,1)-Offset_Resid+1)),Resid_and_S(2,(R_intra(j,2)-Offset_Resid+1)))
		END IF
		
		
		!!! Read_l_out ??? 
		IF(set_dE_out_and_l_out_to_zero) THEN!! Read_l_out ??? 
			lambda_out_h=0.0
			lambda_out_e=0.0
	    ELSE IF(Read_l_out) THEN
			lambda_out_h=0.0
			lambda_out_e=0.0
			found_A32mer=.false.
			found_B32mer=.false.
			IF(Use_reference_data_from_P3HT32mer) THEN
				!WRITE(*,*) 'R_intra: ',R_intra(j,1),R_intra(j,2)
				!!! find the corresponding 32mer 
				k_loop1: DO k=1,N_P3HT_segments+N_DIPBI
					IF (ResidX_in_32mer(k,1) == R_intra(j,1))THEN
						A32mer=ResidX_in_32mer(k,2)
						found_A32mer=.true.
					ELSE IF (ResidX_in_32mer(k,1) == R_intra(j,2)) THEN
						B32mer=ResidX_in_32mer(k,2)
						found_B32mer=.true.
					END IF
					IF(found_A32mer .AND. found_B32mer) THEN
						!write(*,*) 'tmp found both: ',A32mer,' ',B32mer
						EXIT k_loop1
					END IF
				END DO k_loop1
			ELSE !!! get data from individual segments 
				k_loop2: DO k=1,N_l_out_lines
					  IF(  ( (R_intra(j,1) == seg1_seg2_l_out(k,1)) .AND. (R_intra(j,2) == seg1_seg2_l_out(k,2)) ) .OR. &
					  &    ( (R_intra(j,2) == seg1_seg2_l_out(k,1)) .AND. (R_intra(j,1) == seg1_seg2_l_out(k,2)) )  )THEN
						lambda_out_h=N_l_out_data(k,1)
						lambda_out_e=N_l_out_data(k,2)
						A32mer=seg1_seg2_l_out(k,1)
						B32mer=seg1_seg2_l_out(k,2)
						IF (DEBUG) THEN
					           WRITE(*,*) 'FOUND intra lambda_out_pair: ',R_intra(j,1),R_intra(j,2),lambda_out_h,lambda_out_e
						END IF ! DEBUG
						! exit k_loop2
						EXIT k_loop2
					END IF
				END DO k_loop2
			END IF ! Use_reference_data_from_P3HT32mer
			!WRITE(*,*) 'A32mer  B32mer :',A32mer,B32mer
			!! Use random numbers also, if both sites are at the same 32mer -> lambda_out is needed for e.g. for jortner rates 
			!! So one need l_out data for intramolecular transport
			IF( ((A32mer == B32mer) .AND. ( Use_reference_data_from_P3HT32mer)) .AND. &
				&(use_lambda_out_random_number_Gauss_distribution_data)) THEN

				CALL RANDOM_NUMBER(randomnumber)
				lambda_out_h=def_lam_out_h+(randomnumber-0.5)*sig_lam_out_h
				CALL RANDOM_NUMBER(randomnumber)
				lambda_out_e=def_lam_out_e+(randomnumber-0.5)*sig_lam_out_e
				!WRITE(*,*) 'RAND intra lambda_out: ',randomnumber,lambda_out_h,lambda_out_e
			ELSE IF(Use_reference_data_from_P3HT32mer) THEN
					k_loop3: DO k=1,N_l_out_lines
						IF(  ( (A32mer == seg1_seg2_l_out(k,1)) .AND. (B32mer == seg1_seg2_l_out(k,2)) ) .OR. &
						&    ( (B32mer == seg1_seg2_l_out(k,1)) .AND. (A32mer == seg1_seg2_l_out(k,2)) )  )THEN
							lambda_out_h=N_l_out_data(k,1)
							lambda_out_e=N_l_out_data(k,2)
							IF (DEBUG) THEN
						WRITE(*,*) 'FOUND intra lambda_out_pair: ',R_u_S(i,1),R_u_S(i,2),lambda_out_h,lambda_out_e
							END IF ! DEBUG
							! exit k_loop
							EXIT k_loop3
						END IF
					END DO k_loop3
				!Use_reference_data_from_P3HT32mer
			ELSE ! lambda_out=0.0
				lambda_out_h=0.0
				lambda_out_e=0.0				
			END IF
	    ELSE IF (use_lambda_out_random_number_Gauss_distribution_data) THEN
				CALL RANDOM_NUMBER(randomnumber)
				lambda_out_h=def_lam_out_h+(randomnumber-0.5)*sig_lam_out_h
				CALL RANDOM_NUMBER(randomnumber)
				lambda_out_e=def_lam_out_e+(randomnumber-0.5)*sig_lam_out_e
				!WRITE(*,*) 'RAND intra lambda_out: ',randomnumber,lambda_out_h,lambda_out_e
	    ELSE ! lambda_out=0.0
			lambda_out_h=0.0
			lambda_out_e=0.0
	    END IF ! Read_l_out


		IF( (TRIM(rate_type) == "jortner") .OR. (TRIM(rate_type) == "JORTNER") .OR. (TRIM(rate_type) == "Jortner") )THEN
		
			average_omegaVib=(omegaVib(Resid_and_S(2,(R_intra(j,1)-Offset_Resid+1))) +  &
						 &    omegaVib(Resid_and_S(2,(R_intra(j,2)-Offset_Resid+1))) )/2.0
			! Electrons 
			CALL JORTNER_RATE(intra_theta_E(j,4),lambda_in_el_AB,lambda_in_el_BA, intra_theta_E(j,2), lambda_out_e,&
												& dE_out_pairs_intra(j,3),dE_U_ext,T,average_omegaVib,k_AB_el,k_BA_el)
			! Loecher
			CALL JORTNER_RATE(intra_theta_E(j,5),lambda_in_lo_AB,lambda_in_lo_BA, intra_theta_E(j,3), lambda_out_h,&
										&  dE_out_pairs_intra(j,1),(-1.0*dE_U_ext),T,average_omegaVib,k_AB_lo,k_BA_lo)
			  
        ELSE IF (TRIM(rate_type) == "marcus" .OR. (TRIM(rate_type)== "MARCUS") .OR. (TRIM(rate_type)== "Marcus")  )THEN
			k_AB_el=marcus_rate(intra_theta_E(j,4),lambda_in_el_AB,intra_theta_E(j,2),lambda_out_e,&
												&dE_out_pairs_intra(j,3),dE_U_ext,T) 
			!WRITE(*,*) intra_theta_E(j,4),lambda_in_el_AB, intra_theta_E(j,2), lambda_out_e, dE_out_pairs_intra(j,3),dE_U_ext,intra_theta_E(j,6)
			
			!!! Loecher
			k_AB_lo=marcus_rate(intra_theta_E(j,5),lambda_in_lo_AB,intra_theta_E(j,3),lambda_out_h,&
												&dE_out_pairs_intra(j,1),(-1.0*dE_U_ext),T)
			k_BA_el=marcus_rate(intra_theta_E(j,4),lambda_in_el_BA,-1.0*intra_theta_E(j,2), lambda_out_e,&
												&dE_out_pairs_intra(j,4),(-1.0*dE_U_ext),T)    
			k_BA_lo=marcus_rate(intra_theta_E(j,5),lambda_in_lo_BA,-1.0*intra_theta_E(j,3), lambda_out_h,&
												&dE_out_pairs_intra(j,2),(dE_U_ext),T) 
											  										
        ELSE IF (TRIM(rate_type) == "weiss_dorsey" )THEN								
			! CALL weiss_dorsey_rate(J_AB,lambda_in_AB,lambda_in_BA,dE_in,lambda_out,dE_out,dE_U_ext,Temperature,alpha,rate12,rate21)	
			! Electrons 
			CALL weiss_dorsey_rate(intra_theta_E(j,4),lambda_in_el_AB,lambda_in_el_BA, intra_theta_E(j,2), lambda_out_e,&
												& dE_out_pairs_intra(j,3),dE_U_ext,T,Kondo,k_AB_el,k_BA_el)
			! Loecher
			CALL weiss_dorsey_rate(intra_theta_E(j,5),lambda_in_lo_AB,lambda_in_lo_BA, intra_theta_E(j,3), lambda_out_h, &
										& dE_out_pairs_intra(j,1),(-1.0*dE_U_ext),T,Kondo,k_AB_lo,k_BA_lo)			
				
        END IF ! jortner or Marcus rate
        intra_theta_E(j,6)=k_AB_el 
        intra_theta_E(j,7)=k_AB_lo
        intra_theta_E(j,8)=k_BA_el
        intra_theta_E(j,9)=k_BA_lo
       	
        IF ( intra_theta_E(j,1) < 0 ) then
             theta=360+intra_theta_E(j,1)
        ELSE
             theta=intra_theta_E(j,1)
        END IF 
        
!WRITE(*,*) j,R_intra(j,1),R_intra(j,2),theta,'  ',intra_theta_E(j,2),intra_theta_E(j,3),lambda_in_el_AB,lambda_in_lo_AB,&
!&intra_theta_E(j,4),intra_theta_E(j,5),' || ',intra_theta_E(j,6),intra_theta_E(j,7),k_BA_el,k_BA_lo,lambda_in_el_BA,lambda_in_lo_BA
	IF(print_data_collection_files) THEN	
		WRITE(76,*) j,R_intra(j,1),R_intra(j,2),theta,'  ',intra_theta_E(j,2),intra_theta_E(j,3),lambda_in_el_AB,lambda_in_lo_AB,&
		&intra_theta_E(j,4),intra_theta_E(j,5),'||',intra_theta_E(j,6),intra_theta_E(j,7),intra_theta_E(j,8),intra_theta_E(j,9),&
		&lambda_in_el_BA,lambda_in_lo_BA
	END IF !print_data_collection_files
   END DO
END IF !read_intramolecular_data

IF(DEBUG) THEN
	DO j=1,N_P3HT_intra
		IF ( R_intra(j,1) == 5 ) THEN ! == 5706 ??
		WRITE(*,*) 'j,R_intra(j,1),R_intra(j,2),intra_theta_E(j,1) | intra_theta_E(j,2),intra_theta_E(j,3),intra_theta_E(j,4),&
		& intra_theta_E(j,5), || ,intra_theta_E(j,6),intra_theta_E(j,7)'
		WRITE(*,*) j,R_intra(j,1),R_intra(j,2),intra_theta_E(j,1),' |',intra_theta_E(j,2),intra_theta_E(j,3),intra_theta_E(j,4),&
		& intra_theta_E(j,5),' || ',intra_theta_E(j,6),intra_theta_E(j,7),intra_theta_E(j,8),intra_theta_E(j,9)
		END IF
	END DO
END IF


IF(Read_E_multipole_out) THEN
		IF ( (.NOT. allocated(R_u_S)) ) THEN
			WRITE(*,*) ' R_u_S is needed for subroutine: dE_out_for_pairs'
			CALL EXIT(1)
		END IF
		!IF ( (.NOT. allocated(ResidX_in_32mer)) .AND. (.NOT. E_out_randomized_distribution)) THEN
		!	WRITE(*,*) ' ResidX_in_32mer is needed for subroutine: dE_out_for_pairs'
		!	CALL EXIT(1)
		!ELSE 
		!!! Output data for each pair is stored in: dE_out_pairs
		CALL dE_out_for_pairs(R_u_S,N_Pairs,N_P3HT_segments,N_DIPBI,E_out_data,id_E_out,N_E_out_lines,ResidX_in_32mer,&
	    	  &E_out_randomized_distribution,def_E_multi_h,sig_E_multi_h,def_E_multi_e,sig_E_multi_e,&
		  &Use_reference_data_from_P3HT32mer,&
		  &def_DIPBI_E_multi_h,sig_DIPBI_E_multi_h,def_DIPBI_E_multi_e,sig_DIPBI_E_multi_e,dE_out_pairs)
		!END IF
		IF(set_dE_out_and_l_out_to_zero) THEN
			dE_out_pairs=0.0
		END IF
		
END IF ! Read_E_multipole_out



!!!!! INTERMOLECUALR DATA
IF( Read_J_AB ) THEN
	IF(print_data_collection_files) THEN
		OPEN(UNIT=60,FILE=TRIM(zielfile),STATUS='REPLACE',IOSTAT=ierror)
	    !WRITE(*,*) '   Resid_A      Resid_B         S_A         S_B    1=dE_in_el,   2=dE_in_lo, '&
	    !        &'  3=lambda_in_el,   4=lambda_in_lo    '&
	    !        &'  5=S_AB_in_el,    6=J_AB_in_el,      7=S_AB_lo,       8=J_AB_lo,    |  9=k_KMC_el    10=k_KMC_lo '
	   WRITE(60,*) '### Datensammlung  aus '//TRIM(gro_inputfile)//' '//TRIM(sorted_neigbour_list_file)//' '&
	   &//TRIM(no_box_COM_file)//' '//&
	  &TRIM(dE_in_el_file)//' '//TRIM(dE_in_lo_file)//' '//TRIM(lambda_in_el_file)//' '//TRIM(lambda_in_lo_file)//' '//TRIM(J_AB_file)
	   WRITE(60,*) '### Paar_NR(index)   Resid_A      Resid_B         S_A         S_B    1=dE_in_el,   2=dE_in_lo, '&
		    &'  3=lambda_in_el,   4=lambda_in_lo    '&
		    &'  5=S_AB_in_el,     6=J_AB_in_el,      7=S_AB_lo,       8=J_AB_lo,    |  9=k_KMC_el    10=k_KMC_lo '
	END IF 	! print_data_collection_files 


    N_JAB_inter_da=0
    DO i=1,N_Pairs
        IF ( J_AB_da(i) ) THEN
            COM_1=no_box_koord(R_u_S(i,1)-Offset_Resid+1,:)   !index_i=(Resid_1-Offset_Resid+1)
            COM_2=no_box_koord(R_u_S(i,2)-Offset_Resid+1,:)
			!! Richtung der Rate  A-> B
			IF(  use_min_d_COM_vector_list) THEN
				!! bestimmt dE_U_ext
				CALL calc_dE_U_ext_min_d_COM_vector_list(U_ext,N_Resids,N_Neighbours,R_u_S(i,1),R_u_S(i,2), &
															&min_d_COM_arr,x_box,y_box,z_box,dE_U_ext,dist_vec,WARNING)
				IF(WARNING) THEN !! Backup if pair is not in neighbour list.
					dist_COM_inter(i)=norm(COM_2-COM_1)
					dE_U_ext=calc_dE_U_ext(U_ext,COM_1,COM_2,x_box,y_box,z_box)
				ELSE
					dist_COM_inter(i)=norm(dist_vec)
				ENDIF
			ELSE
				dist_COM_inter(i)=norm(COM_2-COM_1)
				dE_U_ext=calc_dE_U_ext(U_ext,COM_1,COM_2,x_box,y_box,z_box)
			endif
			
            ! Lambdas aus der Matrix- aus der Resid wird erst S bestimmt und aus der Matrix dann das entsprechende Element gewaehlt
			lambda_in_el_AB=lambda_in_el_mat(R_u_S(i,3),R_u_S(i,4)) 
			lambda_in_lo_AB=lambda_in_lo_mat(R_u_S(i,3),R_u_S(i,4)) 
			! Rueckrichtung der Rate  B-> A        
            lambda_in_el_BA=lambda_in_el_mat(R_u_S(i,4),R_u_S(i,3))
            lambda_in_lo_BA=lambda_in_lo_mat(R_u_S(i,4),R_u_S(i,3))

		IF(set_dE_out_and_l_out_to_zero) THEN
			lambda_out_h=0.0
			lambda_out_e=0.0
	    ELSE IF(Read_l_out) THEN
			!! use_lambda_out_random_number_Gauss_distribution_data centered around reference data 
			IF (use_lambda_out_random_number_Gauss_distribution_data) THEN
				! DIPBI
				IF( (R_u_S(i,3) == 33) .OR. (R_u_S(i,4) == 33)) THEN
					CALL RANDOM_NUMBER(randomnumber)
					lambda_out_h=def_DIPBI_lam_out_h+(randomnumber-0.5)*sig_DIPBI_lam_out_h
					CALL RANDOM_NUMBER(randomnumber)
					lambda_out_e=def_DIPBI_lam_out_e+(randomnumber-0.5)*sig_DIPBI_lam_out_e
					!WRITE(*,*) 'RAND DIPBI lambda_out: ',randomnumber,lambda_out_h,lambda_out_e
				ELSE ! P3HT
					CALL RANDOM_NUMBER(randomnumber)
					lambda_out_h=def_lam_out_h+(randomnumber-0.5)*sig_lam_out_h
					CALL RANDOM_NUMBER(randomnumber)
					lambda_out_e=def_lam_out_e+(randomnumber-0.5)*sig_lam_out_e
					!WRITE(*,*) 'RAND P3HT lambda_out: ',randomnumber,lambda_out_h,lambda_out_e
				END IF
			ELSE
				lambda_out_h=0.0
				lambda_out_e=0.0
			END IF ! use_lambda_out_random_number_Gauss_distribution_data)

			found_A32mer=.false.
			found_B32mer=.false.
			IF(Use_reference_data_from_P3HT32mer) THEN
				!!! find the corresponding 32mer 
				!WRITE(*,*) 'inter: ',R_u_S(i,1),R_u_S(i,2)
				k_loopA: DO k=1,N_P3HT_segments+N_DIPBI
					IF (ResidX_in_32mer(k,1) == R_u_S(i,1)) THEN
						A32mer=ResidX_in_32mer(k,2)
						found_A32mer=.true.
					ELSE IF (ResidX_in_32mer(k,1) == R_u_S(i,2)) THEN
						B32mer=ResidX_in_32mer(k,2)
						found_B32mer=.true.
					END IF
					IF(found_A32mer .AND. found_B32mer) THEN
						EXIT k_loopA
					END IF
				END DO k_loopA
				IF(found_A32mer .AND. found_B32mer) THEN
					k_loopC: DO k=1,N_l_out_lines
					 IF(  ( (A32mer == seg1_seg2_l_out(k,1)) .AND. (B32mer == seg1_seg2_l_out(k,2)) ) .OR. &
					 &    ( (B32mer == seg1_seg2_l_out(k,1)) .AND. (A32mer == seg1_seg2_l_out(k,2)) )  )THEN
							lambda_out_h=N_l_out_data(k,1)
							lambda_out_e=N_l_out_data(k,2)
							IF (DEBUG) THEN
							 WRITE(*,*) 'FOUND lambda_out_pair: ',R_u_S(i,1),R_u_S(i,2),A32mer,B32mer,&
							       &seg1_seg2_l_out(k,1),seg1_seg2_l_out(k,2),lambda_out_h,lambda_out_e
							END IF ! DEBUG
							! exit k_loop
							EXIT k_loopC
						END IF
					END DO k_loopC
				END IF ! found_A32mer .AND. found_B32mer


			!WRITE(*,*) 'A32mer,B32mer: ', A32mer,B32mer
			ELSE !!! get data from individual segments 
				k_loopB: DO k=1,N_l_out_lines
					  IF(  ( (R_u_S(i,1) == seg1_seg2_l_out(k,1)) .AND. (R_u_S(i,2) == seg1_seg2_l_out(k,2)) ) .OR. &
					  &    ( (R_u_S(i,2) == seg1_seg2_l_out(k,1)) .AND. (R_u_S(i,1) == seg1_seg2_l_out(k,2)) )  )THEN
						lambda_out_h=N_l_out_data(k,1)
						lambda_out_e=N_l_out_data(k,2)
						IF (DEBUG) THEN
					           WRITE(*,*) 'FOUND inter lambda_out_pair: ',R_u_S(i,1),R_u_S(i,2),lambda_out_h,lambda_out_e
						END IF ! DEBUG
						!exit k_loopB
						EXIT k_loopB
					END IF
				END DO k_loopB
			END IF ! Use_reference_data_from_P3HT32mer or get data from individual segments 


	    ELSE IF (use_lambda_out_random_number_Gauss_distribution_data) THEN
				! DIPBI
				IF( (R_u_S(i,3) == 33) .OR. (R_u_S(i,4) == 33)) THEN
					CALL RANDOM_NUMBER(randomnumber)
					lambda_out_h=def_DIPBI_lam_out_h+(randomnumber-0.5)*sig_DIPBI_lam_out_h
					CALL RANDOM_NUMBER(randomnumber)
					lambda_out_e=def_DIPBI_lam_out_e+(randomnumber-0.5)*sig_DIPBI_lam_out_e
					!WRITE(*,*) 'RAND DIPBI lambda_out: ',randomnumber,lambda_out_h,lambda_out_e
				ELSE ! P3HT
					CALL RANDOM_NUMBER(randomnumber)
					lambda_out_h=def_lam_out_h+(randomnumber-0.5)*sig_lam_out_h
					CALL RANDOM_NUMBER(randomnumber)
					lambda_out_e=def_lam_out_e+(randomnumber-0.5)*sig_lam_out_e
					!WRITE(*,*) 'RAND P3HT lambda_out: ',randomnumber,lambda_out_h,lambda_out_e
				END IF
	    ELSE 
			lambda_out_h=0.0
			lambda_out_e=0.0
	    END IF ! Read_l_out
	    
	    IF( TEST_RATES) THEN
					dE_U_ext=0.0
					lambda_out_h=def_lam_out_h
					lambda_out_e=def_lam_out_e
					R_u_S(i,3)=33
					R_u_S(i,4)=i
					J_AB_Daten(i,4)=1.0
					J_AB_Daten(i,2)=1.0
					dE_out_pairs(i,:)=0.0
					! Lambdas aus der Matrix- aus der Resid wird erst S bestimmt und aus der Matrix dann das entsprechende Element gewaehlt
					lambda_in_el_AB=lambda_in_el_mat(R_u_S(i,3),R_u_S(i,4)) 
					lambda_in_lo_AB=lambda_in_lo_mat(R_u_S(i,3),R_u_S(i,4)) 
					! Rueckrichtung der Rate  B-> A        
					lambda_in_el_BA=lambda_in_el_mat(R_u_S(i,4),R_u_S(i,3))
					lambda_in_lo_BA=lambda_in_lo_mat(R_u_S(i,4),R_u_S(i,3))					
					
	    END IF !TEST_RATES
	    
	    IF( (TRIM(rate_type) == "jortner") .OR. (TRIM(rate_type) == "JORTNER") .OR. (TRIM(rate_type) == "Jortner") )THEN
		
			average_omegaVib=(omegaVib(R_u_S(i,3)) +  &
						 &    omegaVib(R_u_S(i,4)) )/2.0
			!!! Electrons 

			CALL JORTNER_RATE(J_AB_Daten(i,4),lambda_in_el_AB,lambda_in_el_BA, dE_in_el_mat(R_u_S(i,3),R_u_S(i,4)), lambda_out_e,&
												& dE_out_pairs(i,3),dE_U_ext,T,average_omegaVib,k_AB_el,k_BA_el)
			!!! Loecher
			CALL JORTNER_RATE(J_AB_Daten(i,2),lambda_in_lo_AB,lambda_in_lo_BA, dE_in_lo_mat(R_u_S(i,3),R_u_S(i,4)),lambda_out_h, &
												& dE_out_pairs(i,1),(-1.0*dE_U_ext),T,average_omegaVib,k_AB_lo,k_BA_lo)
			
        ELSE IF (TRIM(rate_type) == "marcus" .OR. (TRIM(rate_type)== "MARCUS") .OR. (TRIM(rate_type)== "Marcus")  )THEN
	    
            !WRITE(*,*) ' COM_1: ',COM_1,' COM_2: ',COM_2,dE_U_ext
            k_AB_el=marcus_rate(J_AB_Daten(i,4),lambda_in_el_AB, dE_in_el_mat(R_u_S(i,3),R_u_S(i,4)),& 
								&lambda_out_e,dE_out_pairs(i,3),dE_U_ext, T)
            k_AB_lo=marcus_rate(J_AB_Daten(i,2),lambda_in_lo_AB, dE_in_lo_mat(R_u_S(i,3),R_u_S(i,4)),& 
								&lambda_out_h,dE_out_pairs(i,1),(-1.0*dE_U_ext),T)
            
			!WRITE(*,*) 'SUMME:',marcus_rate_el_AB,J_AB_Daten(i,4),Inter(i,3), Inter(i,1), lambda_out_h, lambda_out_e, dE_out_pairs(i,1),dE_out_pairs(i,2),dE_out_e,dE_U_ext, T
			dE_U_ext=calc_dE_U_ext(U_ext,COM_2,COM_1,x_box,y_box,z_box)
			k_BA_el=marcus_rate(J_AB_Daten(i,4),lambda_in_el_BA, dE_in_el_mat(R_u_S(i,4),R_u_S(i,3)), &
									&lambda_out_e, dE_out_pairs(i,4),(-1.0*dE_U_ext),T)
			k_BA_lo=marcus_rate(J_AB_Daten(i,2),lambda_in_lo_BA, dE_in_lo_mat(R_u_S(i,4),R_u_S(i,3)), &
								&lambda_out_h, dE_out_pairs(i,2),(dE_U_ext),T) 
								
        ELSE IF (TRIM(rate_type) == "weiss_dorsey" )THEN								
			!CALL weiss_dorsey_rate(J_AB,lambda_in_AB,lambda_in_BA,dE_in,lambda_out,dE_out,dE_U_ext,Temperature,alpha,rate12,rate21)	
			!! Select the Kondo parameter: alpha weiss_dorsey
			!!! Electrons 
			CALL weiss_dorsey_rate(J_AB_Daten(i,4),lambda_in_el_AB,lambda_in_el_BA, dE_in_el_mat(R_u_S(i,3),R_u_S(i,4)), lambda_out_e,&
												& dE_out_pairs(i,3),dE_U_ext,T,Kondo,k_AB_el,k_BA_el)
			!!! Loecher
			CALL weiss_dorsey_rate(J_AB_Daten(i,2),lambda_in_lo_AB,lambda_in_lo_BA, dE_in_lo_mat(R_u_S(i,3),R_u_S(i,4)),lambda_out_h, &
												& dE_out_pairs(i,1),(-1.0*dE_U_ext),T,Kondo,k_AB_lo,k_BA_lo)		
		ELSE	
				WRITE(*,*) 'Error: No rate selected: '//TRIM(rate_type)
				CALL EXIT(1)
		END IF ! Jortner or Marcus or Weiss-Dorsey
             !Ubergabe der Raten
			 k_inter(i,1)=k_AB_el
             k_inter(i,2)=k_AB_lo
             k_inter(i,3)=k_BA_el
             k_inter(i,4)=k_BA_lo

			IF(TEST_RATES .OR. DEBUG) THEN
					WRITE(*,*) 'my_rates:',i, k_AB_lo,k_BA_lo,k_AB_el,k_BA_el
					WRITE(*,*) 'R and S: ',R_u_S(i,1),R_u_S(i,2),R_u_S(i,3),R_u_S(i,4),'  J_AB_h',J_AB_Daten(i,2),J_AB_Daten(i,4)
					WRITE(*,*) '________________________________________________________________________________________________'
					IF( i == 33 .AND. TEST_RATES )  THEN
						CALL EXIT(1)
					END IF 
			END IF		!TEST_RATES
            !WRITE(*,*)i,R_u_S(i,1),R_u_S(i,2),R_u_S(i,3),R_u_S(i,4),Inter(i,1),Inter(i,2),Inter(i,3),Inter(i,4),&
            !& J_AB_Daten(i,3),J_AB_Daten(i,4),J_AB_Daten(i,1),J_AB_Daten(i,2),' | ',marcus_rate_el_AB,marcus_rate_lo_AB,marcus_rate_el_BA,marcus_rate_lo_BA
	   IF(print_data_collection_files) THEN	
            WRITE(60,*)i,R_u_S(i,1),R_u_S(i,2),R_u_S(i,3),R_u_S(i,4),Inter(i,1),Inter(i,2),Inter(i,3),Inter(i,4),&
            & J_AB_Daten(i,3),J_AB_Daten(i,4),J_AB_Daten(i,1),J_AB_Daten(i,2),' | ',&
            & k_inter(i,1),k_inter(i,2), k_inter(i,3), k_inter(i,4)
	   END IF

            N_JAB_inter_da=N_JAB_inter_da+1 ! Zaehlt die Anzahl der Paare mit berechnetem J_AB
        END IF
    END DO ! Schleife zum Datendrucken
ELSE
	IF(print_data_collection_files) THEN	
   	!	WRITE(*,*) '### Paar_NR(index)   Resid_A   Resid_B  S_A  S_B  1=dE_in_el, 2=dE_in_lo, 3=lambda_in_el, 4=lambda_in_lo '
   		WRITE(60,*) '### Paar_NR(index)   Resid_A      Resid_B         S_A         S_B    1=dE_in_el,   2=dE_in_lo, '&
                &'  3=lambda_in_el,   4=lambda_in_lo    '
    		DO count_pair=1,N_Pairs
    		!WRITE(*,*)count_pair,R_u_S(count_pair,1),R_u_S(count_pair,2),R_u_S(count_pair,3),R_u_S(count_pair,4), &
     		!&Inter(count_pair,1),Inter(count_pair,2),Inter(count_pair,3),Inter(count_pair,4)
        		WRITE(60,*)count_pair,R_u_S(count_pair,1),R_u_S(count_pair,2),R_u_S(count_pair,3),R_u_S(count_pair,4), &
       		 &Inter(count_pair,1),Inter(count_pair,2),Inter(count_pair,3),Inter(count_pair,4)
    		END DO ! Schleife zum Datendrucken
	END IF
END IF 




IF(Read_J_AB) THEN
	IF(DEBUG) THEN
		WRITE(*,*) 'Daten J_AB'
		WRITE(*,*) J_AB_Daten(1,:),J_AB_da(1)
		WRITE(*,*) J_AB_Daten(N_Pairs,:),J_AB_da(N_Pairs),' N_Pairs',N_Pairs
	END IF
END IF






IF(make_Histogramm) THEN
	WRITE(*,*) 'Start Histogramm Auswertung 1=dE_in_el'
	N_Points_Hist=25

	CALL Histogramm_start(Inter(1:N_Pairs,1),N_Pairs,N_Points_Hist,x_Hist,y_Hist)
	WRITE(*,*) 'Histogramm'
	DO i=1,N_Points_Hist
		WRITE(*,*) x_Hist(i),y_Hist(i)
	END DO

	!CALL four_parameter_fit(x_Hist,y_Hist,N_Points_Hist)
	!CALL logistic4()
END IF ! make_Histogramm





IF( Read_J_AB ) THEN
	IF(mobility_estimate) THEN
		!!!! Analyse mobility in assumtion of a spartilly isotropic system and calculcat the diffusion constant
		WRITE(*,*) '  ------------------------------Mobility estimate ---------------------------------------------------'
		WRITE(*,*) 'Analyse mobility in asumption of a spartilly isotropic system and calculcat the diffusion constant'
		WRITE(*,*) 'WARNING: This diffusion constant/mobility is just a poor asumption'
		WRITE(*,*) 'D= 1/6 * sum_i ( r_i^2 *k_i * p_i)  with probability p_i = k_i/(sum_j k_j) '//&
					&'with j as index for the nearest neighbours'


		D_inter_el=0.0
		D_inter_lo=0.0
		Resid_last=-1
		sum_k_el=0.0
		sum_k_lo=0.0
		DO i=1,N_Pairs
			 IF ( J_AB_da(i) ) THEN ! Nur Paare mit Transferraten!
				  Resid_A=R_u_S(i,1)
				  IF( Resid_A /= Resid_last) THEN  ! Berechne p als aus der Summe über alle Nachbar-Raten
						   j=i
						   sum_k_el=0.0
						   sum_k_lo=0.0
						   DO WHILE ( R_u_S(j,1) == Resid_A )
									sum_k_el=sum_k_el+k_inter(j,1)
									sum_k_lo=sum_k_lo+k_inter(j,2)
									!WRITE(*,*) Resid_A,j,sum_k_el,sum_k_lo
									j=j+1
							END DO
					IF (abs(sum_k_el) <1E-10 .OR. abs(sum_k_lo) <1E-10 ) THEN
						WRITE(*,*) 'ERROR , small sum_el: ',sum_k_el,'  sum_lo: ',sum_k_lo,' for Resid_A',Resid_A
						J_AB_da(i)=.false.
					ELSE
							D_inter_el=D_inter_el+(dist_COM_inter(i)*k_inter(i,1))**2/sum_k_el  
							D_inter_lo=D_inter_lo+(dist_COM_inter(i)*k_inter(i,2))**2/sum_k_lo  
					END IF
				  END IF
				  Resid_last=Resid_A
			 END IF                  
		END DO
		D_inter_el=D_inter_el/(6.0*N_JAB_inter_da) ! Mittelwert über alle D_i
		D_inter_lo=D_inter_lo/(6.0*N_JAB_inter_da) ! Mittelwert über alle D_i

		mu_inter_el=q_elementar*D_inter_el/(k_b*T)
		mu_inter_lo=q_elementar*D_inter_el/(k_b*T)

		WRITE(*,*) ' ---------- RESULTS --------------------------'
		WRITE(*,*) 'D_inter_el= ',D_inter_el,' Ang**2 / s'
		WRITE(*,*) 'mobility intermolecular electrons: ',mu_inter_el,' *E-16 cm**2 /Vs ????'
		WRITE(*,*) 'D_inter_lo= ',D_inter_lo,' Ang**2 /s'
		WRITE(*,*) 'mobility intermolecular holes: ',mu_inter_lo, 'E-16 cm**2/ Vs ????'
		WRITE(*,*) D_inter_el,mu_inter_el*1.0E-16,D_inter_lo,mu_inter_lo*1.0E-16
	END IF !!! mobility_estimate
END IF ! J_AB_read = True 
!!! End calculation for mobility estimation  !!!






!! my_KMC to VOTCA input
IF(data_to_votca_KMC) then
	INQUIRE(file=TRIM(votca_pairfile_name),exist=Datei_vorhanden) ! Abfrage ob votca_pairfile_name-Datei vorhanden ist.
        IF(Datei_vorhanden) THEN 
            WRITE(*,*) ' Fehler: Die_votca_pairfile_name_Datei_ist_vorhanden. '//TRIM(votca_pairfile_name)
            WRITE(*,*) ' Stelle_sicher_dass_diese_nicht_ueberschrieben_wird!'
            WRITE(*,*) ' ENDE'
            CALL EXIT (1)
        END IF ! votca_pairfile_name-file vorhanden  
        
        
        INQUIRE(file=TRIM(votca_segfile_name),exist=Datei_vorhanden) ! Abfrage ob votca_segfile_name-Datei vorhanden ist.
        IF(Datei_vorhanden) THEN 
            WRITE(*,*) ' Fehler: Die_votca_segfile_name_Datei_ist_vorhanden. '//TRIM(votca_segfile_name)
            WRITE(*,*) ' Stelle_sicher_dass_diese_nicht_ueberschrieben_wird!'
            WRITE(*,*) ' ENDE'
            CALL EXIT (1)
        END IF ! votca_segfile_name-file vorhanden  


	!segment ID, molecule_name,posX[nm],posY[nm], posZ[nm], eSinglet[eV]
	!0       Alq3    13.33861355923193       13.310063728922518      3.8008660689739893      -0.12358452013210319
	
	!! CONVERT COM from Angstroem to nm
	no_box_koord=no_box_koord*Ang2nm
	x_box=x_box*Ang2nm
	y_box=y_box*Ang2nm
	z_box=z_box*Ang2nm
	
	ALLOCATE(molname(MAX_COM))
 	IF(DIPBI_P3HT_calc) THEN
		DO i=1,MAX_COM
			IF (i < 1249 ) THEN
				molname(i)='DIPBI'
			ELSE
				molname(i)='P3MTA'
			END IF
		END DO
	ELSE
		IF( MAX_COM == SIZE(residue_name_site))THEN
			molname=residue_name_site
		ELSE
			molname='molNM'
		END IF
	END IF	
	

	!!! Reduce the number of pairs, so a pair A => B and B => A is only listed once
	ALLOCATE(J_AB_da_single(N_Pairs))
	J_AB_da_single=J_AB_da(1:N_Pairs)
	DO i=1,N_Pairs
		IF (J_AB_da_single(i)) THEN ! One pair found 
			! find the reverse pair and set it to false
			Resid1=R_u_S(i,1)
			Resid2=R_u_S(i,2)
			DO j=i+1,N_Pairs
				IF((R_u_S(j,1) == Resid2) .AND. (R_u_S(j,2) == Resid1))THEN
					J_AB_da_single(j)=.false.
					EXIT ! loop exit 
				END IF 
				!!!! unset intermolecular J_AB data, if intramolecular data is available 
				IF(read_intramolecular_data) THEN
					IF ( (R_u_S(i,1) == R_u_S(i,2)+1) .OR. (R_u_S(i,1) == R_u_S(i,2)-1)) THEN
						DO k=1,N_P3HT_Intra 
							IF (((R_intra(k,1) == R_u_S(i,1)) .AND. (R_intra(k,2) == R_u_S(i,2))) .OR. &
							&   ((R_intra(k,1) == R_u_S(i,2)) .AND. (R_intra(k,2) == R_u_S(i,1)))) THEN
								! scip pair 
								J_AB_da_single(i)=.false.
								EXIT
							END IF
						END DO
					END IF
				END IF  !!! read_intramolecular_data				
			END DO !j Pairs
		END IF
	END DO



	!!! Reduce the number of pairs, so a pair A => B and B => A is only listed once
	ALLOCATE(Pair_AB_da_intra(N_P3HT_Intra))
	IF (read_intramolecular_data) THEN
		Pair_AB_da_intra=.true.
		DO i=1,N_P3HT_Intra
			IF (Pair_AB_da_intra(i)) THEN ! One pair found 
				! find the reverse pair and set it to false
				Resid1=R_intra(i,1)
				Resid2=R_intra(i,2)
				DO j=i+1,N_P3HT_Intra
					IF((R_intra(j,1) == Resid2) .AND. (R_intra(j,2) == Resid1))THEN
						Pair_AB_da_intra(j)=.false.
						WRITE(*,*) 'pair disabled:',R_intra(j,1),R_intra(j,2)
						EXIT ! loop exit 
					END IF 
				END DO
			END IF
		END DO
	ELSE
		Pair_AB_da_intra=.false.	
	END IF




	!!! Start Erstelle SEGFILE	
	OPEN(UNIT=70,FILE=TRIM(votca_segfile_name),STATUS='REPLACE',IOSTAT=ierror)
	WRITE(*,*) 'MAX_COM: ',MAX_COM
	IF(use_min_d_COM_vector_list) THEN
		
		segid=0
		DO i=1,system2%N_molecules
			segid=segid+1
			IF( system2%molecules(i)%hoppingsite%hasCOM) THEN
			WRITE(70,'(I8,A,A5,A,3F12.6,1ES14.4)') segid,' ',TRIM(residue_name_site(i)),' ',&
						& system2%molecules(i)%hoppingsite%COM(1)*Ang2nm,&
						& system2%molecules(i)%hoppingsite%COM(2)*Ang2nm,&
						& system2%molecules(i)%hoppingsite%COM(3)*Ang2nm,0.0
			ELSE 
			WRITE(70,'(I8,A,A5,A,3F12.6,1ES14.4)') segid,' ',TRIM(system2%molecules(i)%molname),' ',&
						& system2%molecules(i)%COM(1)*Ang2nm,&
						& system2%molecules(i)%COM(2)*Ang2nm,&
						& system2%molecules(i)%COM(3)*Ang2nm,0.0
			ENDIF
		END DO 
		
	ELSE ! Standard
		segid=0
		DO i=1,MAX_COM
			segid=segid+1
			WRITE(70,'(I8,A,A5,A,3F12.6,1ES14.4)') segid,' ',TRIM(residue_name_site(i)),' ',&
						&no_box_koord(i,1),no_box_koord(i,2),no_box_koord(i,3),0.0
		END DO 
	END IF !  use_min_d_COM_vector_list   OR   standard
	CLOSE(70)
	!!! Ende  Erstelle SEGFILE	



	!!! VOTCA index shift for resids, as votca can not start with resid 0
	IF ( R_u_S(1,1) == 0) THEN
		votca_ind=1
		WRITE(*,*) 'WARNING: Index shift in Resids +1, as votca does not start with Resid=0 :',votca_ind
	ELSE
		votca_ind=0
	END IF
	
	
	
	
	! Erstelle PAIRFILE file
	OPEN(UNIT=71,FILE=TRIM(votca_pairfile_name),STATUS='REPLACE',IOSTAT=ierror)
	pair_id=0
	WRITE(71,*) '###  pair_id,Resid1,Resid2, drX[nm],  drY[nm],  drZ[nm], |J_AB(el)|**2[eV], |J_AB(lo)|**2[eV], k_AB_el '//&
			&'   k_AB_lo	    k_BA_el           k_BA_lo  '
	!!! INTERMOLECUALR DATA
		DO i=1,N_Pairs
			IF ( J_AB_da_single(i) ) THEN
			IF(use_min_d_COM_vector_list) then
				CALL search_d_COM_vector_list(R_u_S(i,1),R_u_S(i,2),N_Resids,N_Neighbours,min_d_COM_arr,dist,WARNING)
				dist=dist*Ang2nm
				IF(WARNING) THEN
					COM_1=no_box_koord(R_u_S(i,1)-Offset_Resid+1,:)   !index_i=(Resid_1-Offset_Resid+1)
					COM_2=no_box_koord(R_u_S(i,2)-Offset_Resid+1,:)
					dist=COM_2-COM_1
				ENDIF
				
			ELSE
				COM_1=no_box_koord(R_u_S(i,1)-Offset_Resid+1,:)   !index_i=(Resid_1-Offset_Resid+1)
				COM_2=no_box_koord(R_u_S(i,2)-Offset_Resid+1,:)
				dist=COM_2-COM_1
			ENDIF
			
			CALL distance_PBC_correction(dist,x_box,y_box,z_box)
			drX=dist(1)
			drY=dist(2)
			drZ=dist(3)
			pair_id=pair_id+1                          
			!!! check if pair needs to be skiped if it occures it will be parametrized via intamolecular data.	
            IF (  ISNAN(k_inter(i,1)) .OR.  ISNAN(k_inter(i,2)) .OR. &
				& ISNAN(k_inter(i,3)) .OR.  ISNAN(k_inter(i,4)) ) THEN  
				WRITE(*,'(3I8,3F12.6,6ES14.4)') pair_id,R_u_S(i,1)+votca_ind,R_u_S(i,2)+votca_ind,drX,drY,drZ,&
				! |J_AB(el)|**2 , |J_AB(lo)|**2 
				&J_AB_Daten(i,4)**2,J_AB_Daten(i,2)**2,&
				!!  	k_AB_el            k_AB_lo	    k_BA_el           k_BA_lo
				& k_inter(i,1), k_inter(i,2),    k_inter(i,3), k_inter(i,4)  
				
				WRITE(71,'(3I8,3F12.6,6ES14.4)') pair_id,R_u_S(i,1)+votca_ind,R_u_S(i,2)+votca_ind,drX,drY,drZ,&
				! |J_AB(el)|**2 , |J_AB(lo)|**2 
				&J_AB_Daten(i,4)**2,J_AB_Daten(i,2)**2,0.0,0.0,0.0,0.0
				
			ELSE
				
				WRITE(71,'(3I8,3F12.6,6ES14.4)') pair_id,R_u_S(i,1)+votca_ind,R_u_S(i,2)+votca_ind,drX,drY,drZ,&
				! |J_AB(el)|**2 , |J_AB(lo)|**2 
				&J_AB_Daten(i,4)**2,J_AB_Daten(i,2)**2,&
				!!  	k_AB_el            k_AB_lo	    k_BA_el           k_BA_lo
				& k_inter(i,1), k_inter(i,2),    k_inter(i,3), k_inter(i,4)
           	END IF	
		END IF ! J_AB_da
	END DO !N_Pairs





	!!! INTRAMOLECULAR DATA
	IF (read_intramolecular_data) THEN
		    DO j=1,N_P3HT_Intra    ! Schleife uber Anzahl SCCS-Winkel die in P3HT als Unterabschnitte dienen.
			IF (Pair_AB_da_intra(j)) THEN ! One pair found 
			
				IF(use_min_d_COM_vector_list) then
					CALL search_d_COM_vector_list(R_intra(j,1),R_intra(j,2),N_Resids,N_Neighbours,min_d_COM_arr,dist,WARNING)
					!! convert to nm 
					dist=dist*Ang2nm
					IF(WARNING) THEN
						COM_1=no_box_koord(R_intra(j,1)-Offset_Resid+1,:)   !index_i=(Resid_1-Offset_Resid+1)
						COM_2=no_box_koord(R_intra(j,2)-Offset_Resid+1,:)
						dist=COM_2-COM_1
					ENDIF
					
				ELSE
						COM_1=no_box_koord(R_intra(j,1)-Offset_Resid+1,:)   !index_i=(Resid_1-Offset_Resid+1)
						COM_2=no_box_koord(R_intra(j,2)-Offset_Resid+1,:)
						dist=COM_2-COM_1
				ENDIF
				CALL distance_PBC_correction(dist,x_box,y_box,z_box)
				drX=dist(1)
				drY=dist(2)
				drZ=dist(3)

				pair_id=pair_id+1
                IF (  ISNAN(intra_theta_E(j,6)) .OR.  ISNAN(intra_theta_E(j,7)) .OR. &
					& ISNAN(intra_theta_E(j,8)) .OR.  ISNAN(intra_theta_E(j,9)) ) THEN     
					WRITE(*,*) 'WARNING Nan found:'
					WRITE(*,'(3I8,3F12.4,6ES18.4)') pair_id,R_intra(j,1)+votca_ind,R_intra(j,2)+votca_ind,drX,drY,drZ,&
					! 4=|J_AB(el)|**2 , 5=|J_AB(lo)|**2 
					&  intra_theta_E(j,4)**2,intra_theta_E(j,5)**2,&
					!!  	k_AB_el            k_AB_lo	    k_BA_el           k_BA_lo
					&  intra_theta_E(j,6),intra_theta_E(j,7),intra_theta_E(j,8),intra_theta_E(j,9)
					
					WRITE(71,'(3I8,3F12.4,6ES18.4)') pair_id,R_intra(j,1)+votca_ind,R_intra(j,2)+votca_ind,drX,drY,drZ,&
					! 4=|J_AB(el)|**2 , 5=|J_AB(lo)|**2 
					&  intra_theta_E(j,4)**2,intra_theta_E(j,5)**2,0.0,0.0,0.0,0.0
					
                ELSE                              				     			
					WRITE(71,'(3I8,3F12.4,6ES18.4)') pair_id,R_intra(j,1)+votca_ind,R_intra(j,2)+votca_ind,drX,drY,drZ,&
					! 4=|J_AB(el)|**2 , 5=|J_AB(lo)|**2 
					&  intra_theta_E(j,4)**2,intra_theta_E(j,5)**2,&
					!!  	k_AB_el            k_AB_lo	    k_BA_el           k_BA_lo
					&  intra_theta_E(j,6),intra_theta_E(j,7),intra_theta_E(j,8),intra_theta_E(j,9)
				END IF 
			END IF ! One pair found 
		END DO !!! N_P3HT_Intra
	END IF !!! read_intramolecular_data

END IF !!! ENDE data_to_votca_KMC
 
	write(*,*) 'rates_to_votca_sql   done.'
END SUBROUTINE my_rates_to_votca_sql_main







SUBROUTINE winkel_intramolekular(residue_number,residue_name,atom,atom_number,koordA,MAXATM,N_Resids,ResidX_in_32mer,&
                                &intra_theta_E,N_P3HT_Intra,N_DIPBI,N_P3HT_segments,R_intra,read_intramolecular_data,use_fit,& 
                                &P3HT_intr_in_lo_file,P3HT_intr_in_el_file,P3HT_dE_intr_in_lo_file,P3HT_dE_intr_in_el_file)
!! Zurodnung der Intramolekularen Daten; Indezierung in Array intra_theta_E(i,j) , i=M_P3HT_intra == Anzahl der Winkel die
!! Intramolekularen Transport erlauben;  j=1-5 intex mit Daten: 
!!  1= theta , 2=dE_in_el,   3=dE_in_lo, 4=|J_AB(el)| , 5=|J_AB(lo)| 
!! use_fit= .true. verwendet den cosfit fuer 4=|J_AB(el)| und den dE_in_el=-65*abs(dE_in_lo)
use small_functions
IMPLICIT NONE
Real, ALLOCATABLE, Dimension(:,:), INTENT(IN) :: koordA
INTEGER, ALLOCATABLE, DIMENSION(:), INTENT(IN)   ::residue_number,atom_number
Character(5), ALLOCATABLE, DIMENSION(:),INTENT(IN)  :: residue_name
Character(3), ALLOCATABLE, DIMENSION(:),INTENT(IN) :: atom
INTEGER, INTENT(IN) ::N_Resids,MAXATM
LOGICAL, INTENT(IN) ::read_intramolecular_data,use_fit
Real, ALLOCATABLE, Dimension(:,:), INTENT(OUT) ::intra_theta_E 
INTEGER, ALLOCATABLE, Dimension(:,:), INTENT(OUT) ::R_intra,ResidX_in_32mer
INTEGER,INTENT (out)::N_P3HT_Intra
CHARACTER (500), INTENT(IN)::P3HT_intr_in_lo_file,P3HT_intr_in_el_file,P3HT_dE_intr_in_lo_file,P3HT_dE_intr_in_el_file

INTEGER::i,j,count_theta,Old_Resid,Count_atoms,N_intra_lines
REAL, ALLOCATABLE, DIMENSION(:,:) :: intra_data
REAL, PARAMETER:: PI=4.0*ATAN(1.0)
REAL ::theta
LOGICAL::calc_theta,DEBUG=.false.
REAL, DIMENSION(3)::a,b,c,d,c_old
INTEGER::i_P3HT32mer,N_DIPBI,N_P3HT_segments,Count_segments,N_Schwefel
!!! contains the angle dependant parametrization for the intramolecular p3ht rates


if(debug) then
	write(*,*) 'Start winkel_intramolekular for N_Resids: ',N_Resids, ' and N_atoms:',size(atom_number)
endif

N_P3HT_Intra=0
N_DIPBI=0
N_P3HT_segments=0
! Schleife zur Bestimmung der Anzahl der intramolekularen Resid-Paare
DO j=1,MAXATM
        IF ( j /= 1 .AND. (residue_number(j) /= residue_number(j-1)) )THEN
		IF (residue_name(j-1)(1:5) == 'DIPBI' .OR. residue_name(j-1)(1:5) == 'DPBIK') THEN
			N_DIPBI=N_DIPBI+1
                END IF
		IF (residue_name(j-1)(1:3) == 'THP'  .OR. residue_name(j)(1:3) == 'PH' .OR. residue_name(j)(1:3) == 'PM') THEN
			N_P3HT_segments=N_P3HT_segments+1
		END IF 
		IF ( ( (residue_name(j)(1:3) == 'THP') .AND. (residue_name(j-1)(1:3) == 'THP'  )) .OR. &
			&( (residue_name(j)(1:2) == 'PH') .AND. (residue_name(j-1)(1:3) == 'PH'    )) .OR. & 
			&( (residue_name(j)(1:2) == 'PM') .AND. (residue_name(j-1)(1:3) == 'PM'    )) ) THEN
		        IF ( (residue_name(j) == 'THP1A' .AND. residue_name(j-1) == 'THP32' ) .OR. &
					& (residue_name(j)(5:5) == 'S' .AND. residue_name(j-1)(5:5) == 'E' ) ) THEN
		                CYCLE
		        ELSE
		                N_P3HT_Intra=N_P3HT_Intra+1
		        END IF
		END IF
        END IF        
	IF(j==MAXATM) THEN
			IF (residue_name(j)(1:5) == 'DIPBI' .OR. residue_name(j)(1:5) == 'DPBIK' ) THEN
				N_DIPBI=N_DIPBI+1
                	END IF
			IF (residue_name(j)(1:3) == 'THP' .OR. residue_name(j)(1:3) == 'PH' .OR. residue_name(j)(1:3) == 'PM' ) THEN
				N_P3HT_segments=N_P3HT_segments+1
			END IF 
	END IF        
END DO

a=0
b=0
c=0
c_old=0
d=0
WRITE(*,*) 'N_P3HT_Intra: ', N_P3HT_Intra,' N_DIPBI: ',N_DIPBI,' N_P3HT_segments: ',N_P3HT_segments
ALLOCATE(intra_theta_E(N_P3HT_Intra,9)) ! 1= theta , 2=dE_in_el,   3=dE_in_lo, 4=|J_AB(el)| , 5=|J_AB(lo)| 
!! Speichert die Resids der Sites
!! R_intra(i,j) :: i=[1,N_P3HT_Intra] pairs for intramolecular transport j=1 Resid1 ; j=2 Resid2 ; j=3 NSchwefel_Resid1 ; j=4 N_Schewfel_Resid2
ALLOCATE(R_intra(N_P3HT_Intra,4)) 

!! Speichert ResidX in P3HT subsegment und die entsprechende Resid kette im 32mer, wenn der intramolekular transport vernachlaessigbar ist.
ALLOCATE(ResidX_in_32mer(N_P3HT_segments+N_DIPBI,2))
ResidX_in_32mer=0
i_P3HT32mer=0

intra_theta_E=0
R_intra=0

IF ( N_DIPBI /= 0) THEN
	DO j=1,N_DIPBI
		ResidX_in_32mer(j,:)=j
	END DO
END IF


! Berechnung der Winkel theta
Count_theta=0
Count_segments=0
calc_theta=.false.
Count_Atoms=0
Old_Resid=residue_number(1)
N_Schwefel=0
i=1
DO j=1,MAXATM
        IF ( residue_name(j)(1:3) == 'THP' ) THEN                                
                Count_Atoms=Count_Atoms+1
                IF (TRIM(adjustl(atom(j))) == 'CA') THEN
                        b(:)=koordA(j,:)
                        Count_Atoms=1  ! Reset
                ELSE IF ( Count_Atoms == 5 ) THEN
                        c(:)=c_old(:)
                        c_old=koordA(j,:)
                ELSE IF (TRIM(adjustl(atom(j))) == 'S') THEN
						N_Schwefel= N_Schwefel+1
                        d(:)=a(:)
                        a(:)=koordA(j,:)
                        IF ( Old_Resid /= residue_number(j) ) THEN 
                                IF ( residue_name(j)(1:5) /= 'THP1A' )  THEN
                                        calc_theta=.true.
								ELSE  ! Schwefel am Kettenende
									R_intra(Count_theta,4)=N_Schwefel
									N_Schwefel=0
                                END IF
                        END IF
                        Old_Resid=residue_number(j)
                END IF
		
		!!check resid in which 32mer: Here check if new 32mer starts
		IF( ( (residue_name(j)(1:5) == 'THP1A') .AND. (residue_name(j-1)(1:5) == 'THP32') ) .OR. &
		&   ( (residue_name(j)(1:5) == 'THP1A') .AND. (j == 1) ) .OR. &
		&   ( (residue_name(j)(1:5) == 'THP1A') .AND. (residue_name(j-1)(1:5) == 'DIPBI') ) ) THEN
			i_P3HT32mer=i_P3HT32mer+1
			
			!! Resid in 32mer mapping schema
			Count_segments=Count_segments+1
			ResidX_in_32mer(Count_segments+N_DIPBI,1)=Count_segments+N_DIPBI !residue_number(j)
			ResidX_in_32mer(Count_segments+N_DIPBI,2)=i_P3HT32mer+N_DIPBI
		END IF
        END IF ! THP ?
        
        IF (calc_theta) THEN
                CALL calc_dihedral(a,b,c,d,theta)
                Count_theta=Count_theta+1
                intra_theta_E(Count_theta,1)=theta
                R_intra(Count_theta,1)=residue_number(j)-1
                R_intra(Count_theta,2)=residue_number(j)
				R_intra(Count_theta,3)=N_Schwefel
				IF( (Count_theta/=1) .AND. ( R_intra(Count_theta,1) == R_intra(Count_theta-1,2)) ) THEN
						R_intra(Count_theta-1,4)=R_intra(Count_theta,3)
				END IF
				N_Schwefel=0

				Count_segments=Count_segments+1
				!! Resid in 32mer mapping schema
				ResidX_in_32mer(Count_segments+N_DIPBI,1)=Count_segments+N_DIPBI   !residue_number(j)
				ResidX_in_32mer(Count_segments+N_DIPBI,2)=i_P3HT32mer+N_DIPBI
				calc_theta=.false. 
        END IF !calc_theta
	IF (j==MAXATM) THEN
		IF(residue_name(j)(1:3) == 'THP') THEN
			R_intra(Count_theta,4)=N_Schwefel+1
		END IF 
	END IF 
END DO ! j - Schleife ueber alle Atome

IF(DEBUG) THEN
	DO i=1,N_P3HT_Intra
		WRITE(*,*) 'Resid_1, Resid_2, N_S1, N_S2',R_intra(i,1),R_intra(i,2),R_intra(i,3),R_intra(i,4)
	END DO 
	WRITE(*,*) 'N_Schwefel:',SUM(R_intra(:,3)),SUM(R_intra(:,4))
END IF ! DEBUG

IF (i_P3HT32mer /= 416) THEN
	WRITE(*,*) 'Consistence check: Number of found 32mer is not 416 :',i_P3HT32mer
	WRITE(*,*) 'Revise input or implementation'
	CALL EXIT(1)
END IF


!!! Shift relative resid_index to compensate the index offset between.
j=ResidX_in_32mer(1,1)-residue_number(1)
DO i=1,N_P3HT_segments+N_DIPBI
	ResidX_in_32mer(i,:)=ResidX_in_32mer(i,:)-j
END DO 

IF(DEBUG) THEN
	WRITE(*,*) ' i_P3HT32mer: ',i_P3HT32mer
	WRITE(*,*) ' Count_segments: ',Count_segments
	WRITE(*,*) ' Resid 1 and Resid in P3HT-32mer:  ResidX_in_32mer(i,) '
	DO i=1,N_P3HT_segments+N_DIPBI
		WRITE(*,*) ResidX_in_32mer(i,1),ResidX_in_32mer(i,2)
	END DO
	WRITE(*,*) ' ENDE Resid 1 and Resid in P3HT-32mer:  ResidX_in_32mer(i,) '
END IF ! DEBUG




IF (read_intramolecular_data) THEN
    ! Read dE_in_lo
    ! 1= theta , 2=dE_in_el,   3=dE_in_lo, 4=|J_AB(el)| , 5=|J_AB(lo)|  6=k_intra_el 7=k_intra_lo 
    CALL read_intramolecular_file(P3HT_dE_intr_in_lo_file,intra_data,N_intra_lines)
    DO j=1,N_P3HT_Intra           
        IF ( intra_theta_E(j,1) > 0 ) THEN        
            intra_theta_E(j,3)=intra_data(NINT(10*intra_theta_E(j,1))+1,2) !Rundet den Wert des Winkel zum Index des Integers
        ELSE
            intra_theta_E(j,3)=intra_data(NINT(10*(intra_theta_E(j,1)+360))+1,2) !Rundet den Wert des Winkel zum Index des Integers
        END IF 
        !WRITE(*,*) intra_theta_E(j,1),intra_data(INT(10*intra_theta_E(j,1))+1,1),intra_data(INT(10*intra_theta_E(j,1))+1,2)
    END DO 


    ! Read dE_in_el
    ! 1= theta , 2=dE_in_el,   3=dE_in_lo, 4=|J_AB(el)| , 5=|J_AB(lo)|  6=k_intra_el 7=k_intra_lo 
    IF ( use_fit ) THEN
        !! use fit for site energy difference dE  with scaled hole data
        WRITE(*,*) 'use fit for site energy difference dE_in_el = -0.65 * dE_in_lo '
        DO j=1,N_P3HT_Intra
            intra_theta_E(j,2)=-0.65*intra_theta_E(j,3)
        END DO 
    ELSE ! Read dE_in_el
        CALL read_intramolecular_file(P3HT_dE_intr_in_el_file,intra_data,N_intra_lines)
        DO j=1,N_P3HT_Intra
            IF ( intra_theta_E(j,1) > 0 ) THEN
                intra_theta_E(j,2)=intra_data(NINT(10*intra_theta_E(j,1))+1,2)
            ELSE
                intra_theta_E(j,2)=intra_data(NINT(10*(intra_theta_E(j,1)+360))+1,2)
            END IF 
            !WRITE(*,*) intra_theta_E(j,1),intra_data(INT(10*intra_theta_E(j,1))+1,1),intra_data(INT(10*intra_theta_E(j,1))+1,2)
        END DO !j N_P3HT_Intra
    END IF ! Read dE_in_el


    ! Read |J_AB(el)|
    IF ( use_fit ) THEN
        !!! use intramolecular electron fit / preliminary version /cosfit
        WRITE(*,*) ' use cosfit for |J_AB_intra(el)| '
        DO j=1,N_P3HT_Intra
            IF ( intra_theta_E(j,1) < 0 ) then
                theta=360+intra_theta_E(j,1)
            ELSE
                theta=intra_theta_E(j,1)
            END IF ! 
            if ((theta > 90) .AND. (theta < 270)) THEN
                intra_theta_E(j,4)=  0.42*abs( cos( theta *PI/180.0))+0.28
            ELSE
                intra_theta_E(j,4)=  0.65*abs( cos( theta *PI/180.0))+0.28
            END IF
            !WRITE(*,*) intra_theta_E(j,1),intra_theta_E(j,4)
        END DO 
    ELSE     ! Read |J_AB(el)|
        CALL read_intramolecular_file(P3HT_intr_in_el_file,intra_data,N_intra_lines)
        ! 1= theta , 2=dE_in_el,   3=dE_in_lo, 4=|J_AB(el)| , 5=|J_AB(lo)|  6=k_intra_el 7=k_intra_lo 
        DO j=1,N_P3HT_Intra
            IF ( intra_theta_E(j,1) > 0 ) THEN
                intra_theta_E(j,4)=intra_data(NINT(10*intra_theta_E(j,1))+1,2) !Rundet den werrt des Winkel zum Index des Integers
            ELSE
                intra_theta_E(j,4)=intra_data(NINT(10*(intra_theta_E(j,1)+360))+1,2)
            END IF 
            !WRITE(*,*) intra_theta_E(j,1),intra_data(INT(10*intra_theta_E(j,1))+1,1),intra_data(INT(10*intra_theta_E(j,1))+1,2)
        END DO 
    END IF        ! Read |J_AB(el)|     
  
    !  Read |J_AB(lo)| from splinefit
    CALL read_intramolecular_file(P3HT_intr_in_lo_file,intra_data,N_intra_lines) 
    DO j=1,N_P3HT_Intra
        IF ( intra_theta_E(j,1) > 0 ) THEN
                intra_theta_E(j,5)=intra_data(NINT(10*intra_theta_E(j,1))+1,2)  !NINT Rundet den Wert des Winkel zum Index des Integers
        ELSE
                intra_theta_E(j,5)=intra_data(NINT(10*(intra_theta_E(j,1)+360))+1,2)
        END IF     
    END DO 

END IF  ! read_intramolecular_data

IF(DEBUG) THEN
	j=1
	WRITE(*,*) 'Intramolecular:',j,intra_theta_E(j,1),intra_theta_E(j,2),intra_theta_E(j,3),intra_theta_E(j,4),intra_theta_E(j,5)
END IF 

END SUBROUTINE   winkel_intramolekular     




SUBROUTINE read_intramolecular_file(filename,intra_data,N_intra_lines)
			use small_functions
			IMPLICIT NONE
		!! Reading intramolecular data from intput files and select the J_AB and dE_AB for intramolecular transport for a given SCCS dihedral angle $\theta$ between adjacent thiophene units.
			CHARACTER(500), INTENT(IN) :: filename
		!! Array for intramolecular data
			REAL, ALLOCATABLE, DIMENSION(:,:), INTENT(OUT) :: intra_data 
			INTEGER, INTENT(OUT)::N_intra_lines
			CHARACTER(50) ::dummy_str
			INTEGER:: ierror,i,N_skip_line,N_lines
			LOGICAL :: Datei_vorhanden
			
		INQUIRE(file=TRIM(filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
		IF( .NOT. Datei_vorhanden) THEN
					WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(filename)
					WRITE(*,*) ' ENDE'
					CALL EXIT (1)
		END IF ! Datei-file vorhanden 

		N_lines=Read_rows_file2(filename)
		OPEN(UNIT=21,FILE=TRIM(filename),STATUS='OLD',IOSTAT=ierror)
		WRITE(*,*) 'Read intramolecular data from file: '//TRIM(filename)
		ierror=0
		N_skip_line=0
		N_lines=0
		DO WHILE ( ierror == 0 )
			Read(21,*,IOSTAT=ierror) dummy_str
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(filename),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
			if ( dummy_str(1:1) == '#' ) THEN ! Check ob erster Buchstabe ein #-Zeichen ist, um kommentare zu lesen
				N_skip_line=N_skip_line+1
				N_lines=N_lines+1
			ELSE
				N_lines=N_lines+1
			END IF
		END DO
		CLOSE(21)
		WRITE(*,*) 'N_lines: ',N_lines,' N_skip_line: ',N_skip_line

		OPEN(UNIT=32,FILE=TRIM(filename),STATUS='OLD',IOSTAT=ierror)
		IF (N_skip_line > 0 ) THEN ! Auslassen der Zeilen mit '#'
			DO i =1,N_skip_line
				Read(32,*,IOSTAT=ierror) dummy_str
			END DO
		END IF
		N_intra_lines=N_lines-N_skip_line
		ALLOCATE(intra_data(N_intra_lines,2))
		intra_data=0
		DO i=1,(N_intra_lines)
			READ(32,*,IOSTAT=ierror) intra_data(i,1),intra_data(i,2)
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(filename),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
		END DO ! Read Data

END SUBROUTINE read_intramolecular_file








SUBROUTINE Histogramm_start(X,N,M_boxes,Range_arr,Bucket)
	IMPLICIT NONE
	INTEGER, INTENT(IN)                 :: N        ! # of elements in array X
    REAL, DIMENSION(N), INTENT(IN)      :: X        ! input score
    INTEGER, INTENT(IN)                 :: M_boxes    ! # of ranges
 	INTEGER::i
	INTEGER, PARAMETER         :: dp = SELECTED_REAL_KIND(12, 60)
	REAL (dp), ALLOCATABLE, DIMENSION(:), INTENT(out) :: Range_arr
	INTEGER, ALLOCATABLE , DIMENSION(:) , INTENT(out) :: Bucket     ! counting bucket
	REAL::Min_X,Max_X,Min_Range,Max_Range,step_size
 	Min_X= MINVAL(X(:),1)
 	Max_X= MAXVAL(X(:),1)

	Min_Range=Min_X-(Max_X-Min_X)*0.02
	Max_Range=Max_X+(Max_X-Min_X)*0.02
	ALLOCATE(Range_arr(M_boxes))
	ALLOCATE(Bucket(M_boxes))
	WRITE(*,*) 'Array grenzen:',Min_X,Max_X,Min_Range,Max_Range
	step_size=(Max_Range-Min_Range)/Real(M_boxes-1)
	DO i=1,M_boxes
		Range_arr(i)=(i-1)*step_size+Min_Range
	END DO
	CALL Distribute(X, N, Range_arr, M_boxes, Bucket)

END SUBROUTINE Histogramm_start

! --------------------------------------------------------------------
!! SUBROUTINE  Distribute() :
!!    This subroutine receives a score array and a range array, counts
!! the number of each scores in each range, and calls Plot() to print
!! a histogram.
! --------------------------------------------------------------------

   SUBROUTINE  Distribute(X, N, Range, M,Bucket)
      IMPLICIT NONE
      INTEGER, PARAMETER                   :: dp = SELECTED_REAL_KIND(12, 60)
      REAL, DIMENSION(1:), INTENT(IN)      :: X     ! input score
      INTEGER, INTENT(IN)                  :: N     ! # of scores
      REAL (dp), DIMENSION(1:), INTENT(IN) :: Range ! range array
      INTEGER, INTENT(IN)                  :: M     ! # of ranges
      INTEGER                              :: i, j  
      INTEGER, DIMENSION(1:M+1),INTENT(out):: Bucket! counting bucket

      DO i = 1, M+1                     ! clear buckets
         Bucket(i) = 0
      END DO

      DO i = 1, N                       ! for each input score
         DO j = 1, M                    ! determine the bucket
            IF (X(i) < Range(j)) THEN
               Bucket(j) = Bucket(j) + 1
               EXIT
            END IF               
         END DO                         ! don't forget the last bucket
         IF (X(i) >= Range(M))  Bucket(M+1) = Bucket(M+1)+1
      END DO
      !CALL  Plot(Bucket, M+1)           ! print a histogram
      !DO i=1,M
      !  WRITE(*,*) i,Range(i),Bucket(i)
      ! END DO  

   END SUBROUTINE  Distribute

!! --------------------------------------------------------------------
!! SUBROUTINE  Plot() :
!!    This subroutine receives a counting array and prints a vertical
!! bar histogram.
!! --------------------------------------------------------------------

   SUBROUTINE  Plot(Count, K)
      IMPLICIT NONE
      INTEGER, DIMENSION(1:), INTENT(IN) :: Count
      INTEGER, INTENT(IN)                :: K
      CHARACTER(LEN=4), DIMENSION(1:K)   :: Line
      CHARACTER(LEN=4), PARAMETER        :: Division  = "---+"
      CHARACTER(LEN=4), PARAMETER        :: Empty     = "    "
      CHARACTER(LEN=4), PARAMETER        :: EmptyLast = "   |"
      CHARACTER(LEN=4), PARAMETER        :: Data      = "*** "
      CHARACTER(LEN=4), PARAMETER        :: DataLast  = "***|"
      INTEGER                            :: i, j, Maximum

      Maximum = Count(1)                ! find the maximum of the count
      Line(1) = Division                ! clear the print line
      DO i = 2, K
         Line(i) = Division
         IF (Maximum < Count(i))  Maximum = Count(i)
      END DO

      WRITE(*,*) "Histogram:"
      WRITE(*,*)
      WRITE(*,*) "+", (Line(j), j=1,K)  ! print the top border
      DO i = Maximum, 1, -1             ! print from the top
         DO j = 1, K                    ! for each count value
            IF (Count(j) >= i) THEN     !   if >= current value, show ***
               IF (j == K) THEN         !     if this is the last bar
                  Line(j) = DataLast    !       use "***|"
               ELSE                     !     otherwise
                  Line(j) = Data        !       use "*** "
               END IF
            ELSE                        !   if < current value , don't show
               IF (j == K) THEN         !     if this is the last bar
                  Line(j) = EmptyLast   !       use "   |"
               ELSE                     !     otherwise
                  Line(j) = Empty       !       use "    "
               END IF
            END IF
         END DO
         WRITE(*,*) "|", (Line(j), j=1,K)    ! all done.  display this line
      END DO

      DO j = 1, K                       ! prepare and display the lower border
         Line(j) = Division
      END DO
      WRITE(*,*) "+", (Line(j), j=1,K)
   END SUBROUTINE  Plot




REAL function marcus_rate(J_AB,lambda_in, dE_in, lambda_out, dE_out,dE_U_ext,Temperature)
    !! Berechnung der marcus_rate dE_U_ext muss vorher anhand der Geometrie berechnet werden. 
    !! Vorzeichen fuer Elektronen und Loecher beachten!
    IMPLICIT NONE
    REAL, INTENT(IN)::J_AB,lambda_in,dE_in,lambda_out,dE_out,dE_U_ext    ! eV
    REAL, INTENT(IN)::Temperature				    !! K
    REAL, PARAMETER::PI=ATAN(1.0)*4.0,k_b=8.6173303E-5		!! eV/K
    REAL, PARAMETER::hbar=6.582119514E-16	!! eV*s
    
    marcus_rate=abs(J_AB)**2*sqrt(Pi/((lambda_in+lambda_out)*k_b*Temperature))/hbar*&
                &exp(-(dE_U_ext+dE_in+dE_out+(lambda_in+lambda_out))**2/(4*(lambda_in+lambda_out)*k_b*Temperature))
    !WRITE(*,*) '|J_AB|**2:',J_AB**2,' dE_U_ext:',dE_U_ext,' dE_in:',dE_in,' dE_out:',dE_out,&
	!			&' lambda_in: ',lambda_in,' lambda_out:',lambda_out,' marcus rate:',marcus_rate
END function marcus_rate




REAL FUNCTION omegaVib(i)
	!! gives the average frequency for DIPBI/P3HT for Jortnerrate with a given index [1,32] for the number of rings i=33 /DIPBI
	INTEGER, INTENT(IN)::i
	REAL::omega_vib
	!! average_energy [eV] average_frequency [cm-1]
	if (i==33 ) THEN
		omega_vib=0.125787      !!! 1014.57	!DIPBI
	else if (i==1 ) THEN  
	   omega_vib=0.172085    !!! 1388.00	
	else if (i==2 ) THEN  
	   omega_vib=0.154500    !!! 1246.17	
	else if (i==3 ) THEN  
	   omega_vib=0.148528    !!! 1198.00	
	else if (i==4 ) THEN  
	   omega_vib=0.145516    !!! 1173.71	
	else if (i==5 ) THEN  
	   omega_vib=0.143789    !!! 1159.78	
	else if (i==6 ) THEN  
	   omega_vib=0.142584    !!! 1150.06	
	else if (i==7 ) THEN  
	   omega_vib=0.141720    !!! 1143.09	
	else if (i==8 ) THEN  
	   omega_vib=0.141091    !!! 1138.02	
	else if (i==9 ) THEN  
	   omega_vib=0.140547    !!! 1133.63	
	else if (i==10 ) THEN 
	   omega_vib=0.140204    !!! 1130.86	
	else if (i==11 ) THEN 
	   omega_vib=0.139847    !!! 1127.98	
	else if (i==12 ) THEN 
	   omega_vib=0.139560    !!! 1125.67	
	else if (i==13 ) THEN 
	   omega_vib=0.139325    !!! 1123.77	
	else if (i==14 ) THEN 
	   omega_vib=0.139141    !!! 1122.29	
	else if (i==15 ) THEN 
	   omega_vib=0.139005    !!! 1121.19	
	else if (i==16 ) THEN 
	   omega_vib=0.138824    !!! 1119.73	
	else if (i==17 ) THEN 
	   omega_vib=0.138824    !!! 1119.73	
	else if (i==18 ) THEN 
	   omega_vib=0.138824    !!! 1119.73	
	else if (i==19 ) THEN 
	   omega_vib=0.138446    !!! 1116.68	
	else if (i==20 ) THEN 
	   omega_vib=0.138368    !!! 1116.05	
	else 
		Write(*,*) '... ... WARNING: No QM vibration frequency provided, using default 0.2eV. (VOTCA default)'
	   omega_vib=0.2    !!! Votca default 0.2 eV !   1116.05	0.138368 
	endif	
	omegaVib=omega_vib
END FUNCTION omegaVib

    !! +++++++++++++ //
    !! JORTNER RATES //
    !! +++++++++++++ //
    !!! J_AB,lambda_in_AB,lambda_in_BA
    !!! gemittelte vibrationsfrequenz: omegaVib    default :: omegaVib = 0.2 eV   _nMaxVib = 20
    !!CALL JORTNER_RATE(intra_theta_E(j,4),lambda_in_el_AB,lambda_in_el_BA, intra_theta_E(j,2), lambda_out_e,&
	!!								& dE_out_pairs_intra(j,3),dE_U_ext,T,average_omegaVib,k_AB_el,k_BA_el)
    
SUBROUTINE JORTNER_RATE(J_AB,reorg12,reorg21, dE_in, lambda_out, dE_out,dE_U_ext,Temperature,omegaVib,rate12,rate21)
    IMPLICIT NONE
    REAL, INTENT(IN)  ::J_AB,reorg12,reorg21,dE_in,lambda_out,dE_out,dE_U_ext    ! eV
    REAL, INTENT(IN)  ::Temperature				    !! K
    REAL, INTENT(IN)  ::omegaVib  !! [eV] form average frequency in cm**-1
    REAL, INTENT(OUT) ::rate12,rate21 !! [s**-1]

    REAL, PARAMETER::PI=ATAN(1.0)*4.0,k_b=8.6173303E-5		!! eV/K
    !!REAL, PARAMETER::hbar=6.582119514E-16	!! eV*s
    REAL, PARAMETER ::hbar_eV = 6.58211899e-16 !! eV VOTCA program
	REAL::J2,huang_rhys12,huang_rhys21
	REAL:: kT,dG
	INTEGER:: nvib,nMaxVib
	LOGICAL:: DEBUG=.false.
	
	nMaxVib=20 !size(omegaVib)
	
	kT=k_b*Temperature
	J2=J_AB**2
	rate12=0.0
	rate21=0.0
	huang_rhys12 = reorg12 / omegaVib
    huang_rhys21 = reorg21 / omegaVib
    
    dG= dE_in +  dE_out + dE_U_ext !!dG = dG_Site + dG_Field !
    IF(DEBUG)  WRITE(*,*) 'dG',dG,'=dE_in +  dE_out + dE_U_ext :',dE_in,dE_out,dE_U_ext
    IF(lambda_out < 0.0) THEN
				WRITE(*,*)   "... ... ERROR: Pair has negative outer-sphere reorganization energy. Cannot calculate Jortner rates. "
				CALL EXIT(1)
	ELSE IF (lambda_out < 0.01) THEN
				WRITE(*,*) "... ... WARNING: Pair has small outer-sphere reorganization energy (",lambda_out,"eV). "
				WRITE(*,*)  "Could lead to over-estimated Jortner rates."
				!PASS
				!CALL EXIT(1)
	END IF

		!nvib=0
		nvib=0
        !! Hopping from Seg1 -> Seg2
            rate12=rate12 + 1/hbar_eV*sqrt( PI / (lambda_out*kT) ) * J2 * exp(-huang_rhys12) * huang_rhys12**nvib /Factorial(nvib)&
                  &  * exp( - (dG + 0.0 + lambda_out)**2 /(4*kT*lambda_out))

       !! Hopping from Seg2 -> Seg1
            rate21=rate21 + 1/hbar_eV*sqrt( PI / (lambda_out*kT) ) * J2 * exp(-huang_rhys21) * huang_rhys21**nvib /Factorial(nvib)&
                  &  * exp( -(-dG + 0.0  + lambda_out)**2 /(4*kT*lambda_out) )	
		
        DO nvib=1,nMaxVib,1
        	huang_rhys12 = reorg12 / omegaVib
			huang_rhys21 = reorg21 / omegaVib
        
            !! Hopping from Seg1 -> Seg2   ! laut paper -N * hbar *omega_vib 
            rate12=rate12 + 1/hbar_eV*sqrt( PI / (lambda_out*kT) ) * J2 * exp(-huang_rhys12) * huang_rhys12**nvib /Factorial(nvib)&
                  &  * exp( - (dG + nvib*omegaVib + lambda_out)**2 /(4*kT*lambda_out))

            !! Hopping from Seg2 -> Seg1
            rate21=rate21 + 1/hbar_eV*sqrt( PI / (lambda_out*kT) ) * J2 * exp(-huang_rhys21) * huang_rhys21**nvib /Factorial(nvib)&
                  &  * exp( -(-dG + nvib*omegaVib + lambda_out)**2 /(4*kT*lambda_out) )
                           
       END DO

	    IF(DEBUG) WRITE(*,*) 'JORTNER_RATE: k_AB:', rate12,'  k_BA: ',rate21, ' |J_AB|**2:',J2,' l_out:',lambda_out,&
				&' l_in_AB:',reorg12,' l_in_BA:',reorg21
		
END SUBROUTINE JORTNER_RATE



    !! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  //
    !! WEISS DORSEY RATES														 //
    !! See Asadi et al. Nature Comm. 2708 (DOI: 10.1038/ncomms2708)              //
    !! equation (6) in the paper	using complex gamma function CGAMA    		 //
    !! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
    !!              _alpha = 4.0;
    !!      ... ... WARNING: No Kondo parameter _alpha provided. Using default 4.0 
SUBROUTINE weiss_dorsey_rate(J_AB,lambda_in_AB,lambda_in_BA,dE_in,lambda_out,dE_out,dE_U_ext,Temperature,alpha,rate12,rate21)
    IMPLICIT NONE
    REAL, INTENT(IN)  ::J_AB,lambda_in_AB,lambda_in_BA,dE_in,lambda_out,dE_out,dE_U_ext    ! eV
    REAL, INTENT(IN)  ::Temperature				    !! K
    REAL, INTENT(IN)  ::alpha  !! alpha [eV] form average frequency in cm**-1
    REAL, INTENT(OUT) ::rate12,rate21 !! [s**-1]

    REAL, PARAMETER::M_PI=ATAN(1.0)*4.0,k_b=8.6173303E-5		!! eV/K
    !!REAL, PARAMETER::hbar=6.582119514E-16	!! eV*s
    REAL, PARAMETER ::hbar_eV = 6.58211899e-16 !! eV VOTCA program
	!! local variables 
	REAL:: J2,kT,dG,characfreq12,characfreq21
	REAL:: kondo,reorg12,reorg21
	!! Auxilliar variables
	REAL*8::X,Y,GR,GI,infinity 
	REAL*8::Factor1,Factor2
	COMPLEX, PARAMETER::M_I=(0.0,1.0)
	LOGICAL::DEBUG=.false.

	kT=k_b*Temperature
	J2=J_AB**2
    dG= dE_in +  dE_out + dE_U_ext !!dG = dG_Site + dG_Field !
    dG=-1.0*dG
    IF(DEBUG) WRITE(*,*) 'dG',dG,'=dE_in +  dE_out + dE_U_ext :',dE_in,dE_out,dE_U_ext		
	          
        kondo = alpha/2+1; !! going from alpha to alpha'

        reorg12 = lambda_in_AB + lambda_out
        reorg21 = lambda_in_BA + lambda_out
        
        characfreq12 = reorg12 /(2 *kondo*hbar_eV)
        characfreq21 = reorg21 /(2 *kondo*hbar_eV)
        
        !! Calc Complex Gamma Function to real GR and imaginary GI
        !! Factor1= abs(  ccgamma(kondo+M_I*(+dG/2/M_PI/kT))  )^2
        X=REAL(kondo,8)
        Y=REAL(dG/(2*M_PI*kT),8)
		CALL CGAMA(X,Y,1,GR,GI)
		Factor1=GR**2+GI**2    
		
		!! Factor2 = ccgamma(2*kondo,0)^-1
		X=REAL(2.0*kondo,8)
		Y=REAL(0.0,8)
		CALL CGAMA(X,Y,1,GR,GI)
		Factor2=1.0d0/GR
		
       rate12 =    Real(J2/(hbar_eV**2)/characfreq12,8)   &
               & * Real((hbar_eV*characfreq12/2/M_PI/kT)**(1-2*kondo),8)   &
               & * Factor1 * Factor2 * dexp(Real(+dG/(2.0*kT),8)) *  dexp(Real(-1.0*abs(dG)/(hbar_eV*characfreq12),8))

        !! Calc Complex Gamma Function to real GR and imaginary GI
        !! Factor1=  abs(ccgamma(kondo+M_I*(-dG/2/M_PI/kT)) )^2 
        X=REAL(kondo,8)
        Y=REAL(-1.0*dG/(2*M_PI*kT),8)
		CALL CGAMA(X,Y,1,GR,GI)
		Factor1=GR**2+GI**2    

        rate21 =   Real(J2/(hbar_eV**2)/characfreq21,8)   &
              &  * Real((hbar_eV*characfreq21/2/M_PI/kT)**(1-2*kondo),8)    &
              &  * Factor1 * Factor2 * dexp(Real(-dG/(2.0*kT),8)) *  dexp(Real(-1.0*abs(dG)/(hbar_eV*characfreq21),8))                   
        
		infinity= HUGE(X)
        IF ( rate12 > infinity .OR. ISNAN(rate12) ) THEN  ! check infinity
			WRITE(*,*) 'Warning: weiss_dorsey_rate is NaN or infinity, modify Kondo factor. as exp(x) ~ infinity ?',rate12
			WRITE(*,*) 'Set rate12=0.0'
			rate12=0.0
		ELSE IF(rate21 > infinity .OR. ISNAN(rate21) ) THEN
			WRITE(*,*) 'Warning: weiss_dorsey_rate is NaN or infinity, modify Kondo factor. as exp(x) ~ infinity ?',rate21
			WRITE(*,*) 'Set rate21=0.0'
			rate21=0.0
        END IF       
        IF(DEBUG) WRITE(*,*) ' weiss_dorsey_rate : k_AB: ',rate12,' k_BA: ',rate21,&
								&'lambda_in_AB:',lambda_in_AB,'lambda_in_BA:',lambda_in_BA        
          
 END SUBROUTINE weiss_dorsey_rate



   

SUBROUTINE CGAMA(X,Y,KF,GR,GI)
!! ===========================================================    
!!       Purpose: Compute the gamma function G(z) or Ln[G(z)]   
!!                for a complex argument   
!!       Input :  x  --- Real part of z   
!!                y  --- Imaginary part of z    
!!                KF --- Function code   
!!                       KF=0 for Ln[G(z)]   
!!                       KF=1 for G(z)   
!!       Output:  GR --- Real part of Ln[G(z)] or G(z)
!!                GI --- Imaginary part of Ln[G(z)] or G(z)   
!! ===========================================================   
	IMPLICIT NONE
 !IMPLICIT DOUBLE PRECISION (A-H,O-Z)
	REAL*8,INTENT(INOUT)::X,Y
	INTEGER,INTENT(IN)::KF
    REAL*8,INTENT(OUT)::GR,GI
   
	REAL*8::G0,GI1,GR1,X0,X1,SI,SR,T,TH,TH1,TH2,Y1,Z1,Z2
	!REAL*8::G1,S1,S2,X2 !unused?
	INTEGER*8::NA,K,J
    
    REAL*8, PARAMETER ::PI=3.141592653589793D0
    
   REAL*8, DIMENSION(10)::A=(/8.333333333333333D-02,-2.777777777777778D-03,  &
         &  7.936507936507937D-04,-5.952380952380952D-04,  &
         &  8.417508417508418D-04,-1.917526917526918D-03,  &
         &  6.410256410256410D-03,-2.955065359477124D-02,  &
         &  1.796443723688307D-01,-1.39243221690590D+00/)
         
    IF (Y.EQ.0.0D0.AND.X.EQ.INT(X).AND.X.LE.0.0D0) THEN
      GR=1.0D+300
      GI=0.0D0
      RETURN
    ELSE IF (X.LT.0.0D0) THEN
      X1=X
      Y1=Y
      X=-X
      Y=-Y
    ENDIF
	X0=X
    
    IF (X.LE.7.0) THEN
      NA=INT(7-X)
      X0=X+NA
    ENDIF
    
    Z1=DSQRT(X0*X0+Y*Y)
    TH=DATAN(Y/X0)
    
    GR=(X0-.5D0)*DLOG(Z1)-TH*Y-X0+0.5D0*DLOG(2.0D0*PI) 
    GI=TH*(X0-0.5D0)+Y*DLOG(Z1)-Y
    
    DO K=1,10   
      T=Z1**(1-2*K)
      GR=GR+A(K)*T*DCOS((2.0D0*K-1.0D0)*TH)
      GI=GI-A(K)*T*DSIN((2.0D0*K-1.0D0)*TH)
    END DO
    
    IF (X.LE.7.0) THEN
      GR1=0.0D0
      GI1=0.0D0
       
      DO J=0,NA-1
        GR1=GR1+.5D0*DLOG((X+J)**2+Y*Y)
        GI1=GI1+DATAN(Y/(X+J))
      END DO
       
      GR=GR-GR1
      GI=GI-GI1
    
    ENDIF
    
    IF (X1.LT.0.0D0) THEN
       
      Z1=DSQRT(X*X+Y*Y)
      TH1=DATAN(Y/X)
      SR=-DSIN(PI*X)*DCOSH(PI*Y)
      SI=-DCOS(PI*X)*DSINH(PI*Y)
      Z2=DSQRT(SR*SR+SI*SI)
      TH2=DATAN(SI/SR)
       
      IF (SR.LT.0.0D0) TH2=PI+TH2
        
	  GR=DLOG(PI/(Z1*Z2))-GR
	  GI=-TH1-TH2-GI 
	  X=X1
	  Y=Y1
    
	ENDIF
    
    IF (KF.EQ.1) THEN
      G0=DEXP(GR)
      GR=G0*DCOS(GI)
      GI=G0*DSIN(GI)
    ENDIF
      
    RETURN
END SUBROUTINE CGAMA







INTEGER FUNCTION Factorial(i)
	!Programm berechnet iterativ die Fakultät einer gegebenen natürlichen Zahl i!
	IMPLICIT NONE
	!Variablen sind nur ganze Zahlen
	INTEGER :: i,j
	REAL*8::n
	!!User gibt Zahl kleiner 35 ein, da faculty sonst zu groß
	!!WRITE(*,*) 'Geben Sie bitte eine natürliche Zahl kleiner 13 ein'//&
	!!	&'deren Fakultät berechnet werden soll'

	n=1 ! Initialisierung
	j=1
	IF ( (i>=1) .AND. (i < 35) ) THEN
		! Berechnung der Fakultaet, durch iterative Multiplikation 
		DO WHILE (j<=i)      
		   n=n*j
		   j=j+1
		END DO
	ELSE IF (i == 0) THEN
		n=1
	ELSE     
		DO WHILE (j<=i)       
			   n=n*j
			   j=j+1
		END DO  
		WRITE(*,*) 'Das Programm liefer einen overflow Fehler!'
		WRITE(*,*) 'Die Fakultaet von ',i,' ist:',n
		CALL EXIT(1)
	END IF    
	Factorial=int(n)
END FUNCTION Factorial

REAL FUNCTION calc_dE_U_ext(U_ext,COM_1,COM_2,x_box,y_box,z_box)
    IMPLICIT NONE
    REAL, INTENT(IN)::x_box,y_box,z_box ! in Angstroem
    REAL, DIMENSION (3), INTENT(IN) :: U_ext
    REAL, DIMENSION (3), INTENT(IN) :: COM_1,COM_2
    REAL, DIMENSION (3) ::dist,box_size
    INTEGER::i
    dist(:)=COM_2(:)-COM_1(:)
    box_size(1)=x_box
    box_size(2)=y_box
    box_size(3)=z_box
    DO i=1,3
        IF( dist(i) > 0.5*box_size(i) ) THEN
                dist(i) = dist(i)-box_size(i)
        ELSE IF ( dist(i) < -0.5*box_size(i) ) THEN
                dist(i) = dist(i)+box_size(i)
        ELSE
                CYCLE
        END IF
    END DO
	!dist = np.asarray(COM_list[index1])-np.asarray(COM_list[index2])
	!for a in range(len(dist)):
	!	if dist[a] > 1.0/2.0*box[0]*10.0: dist[a] = dist[a] - box[a]*10.0
	!	elif dist[a] < -1.0/2.0*box[0]*10.0: dist[a] = dist[a] + box[a]*10.0	
	!#calculate the electric energy difference in eV	
	! dE_U_ext = np.dot(dist,np.asarray(U)) !! Electrons
    !	#inverse charge for holes
	! dE_U_ext = -dE_U_ext  
    calc_dE_U_ext= DOT_PRODUCT(dist,U_ext)    ! Energie in eV (fuer Elektronen)
END function calc_dE_U_ext



SUBROUTINE calc_dE_U_ext_min_d_COM_vector_list(U_ext,N_Resids,N_Neighbours,ResidA,ResidB,min_d_COM_arr, x_box,y_box,z_box, & 
			&  dE_U_ext, dist,WARNING_ERROR)
    IMPLICIT NONE
    INTEGER, INTENT(IN) :: N_Resids,N_Neighbours,ResidA,ResidB
    REAL, INTENT(IN)::x_box,y_box,z_box ! in Angstroem
    REAL, DIMENSION (3), INTENT(IN)     :: U_ext
    REAL, DIMENSION (:,:,:), INTENT(IN) :: min_d_COM_arr
    REAL, DIMENSION (3), INTENT(OUT)    :: dist
    REAL               , INTENT(OUT)    :: dE_U_ext
    LOGICAL :: WARNING_ERROR 
    REAL, DIMENSION (3) ::box_size
    INTEGER::i,j
    
	!! 	min_d_COM_arr(i,j,4) = ResidA  
	!!  min_d_COM_arr(i,j,5) = ResidB 
	!!  min_d_COM_arr(i,j,6) = norm_dist_vec_min 

	!---  WRITE(*,*) 'Start calculation for minimal |d_COM|=COM_B-COM_A nearest neighbours '
	!!  ALLOCATE(min_d_COM_arr(N_Resids,N_Neighbours+1,3))
    !write(*,*) 'U_ext,N_Resids,N_Neighbours,ResidA,ResidB,min_d_COM_arr,x_box,y_box,z_box'
    !write(*,*) U_ext,N_Resids,N_Neighbours,ResidA,ResidB,' min_d_COM_arr ',x_box,y_box,z_box
    dist=0
    dE_U_ext=0
    WARNING_ERROR=.false.
    loop_i: DO i=1,N_Resids
			DO j=1,N_Neighbours
				IF(    (int(min_d_COM_arr(i,j,4)) == ResidA) .AND.   (int(min_d_COM_arr(i,j,5)) == ResidB)  ) THEN
					dist=min_d_COM_arr(i,j,1:3)
					EXIT loop_i
				ELSE IF( (int(min_d_COM_arr(i,j,4)) == ResidB) .AND. (int(min_d_COM_arr(i,j,5)) == ResidA) ) THEN
					dist=-1.0*min_d_COM_arr(i,j,1:3)
					EXIT loop_i
				ENDIF
			ENDDO 
			IF( i == N_Resids) THEN
				!WRITE(*,*) ' N_Resids,N_Neighbours,ResidA,ResidB,U_ext'
				WRITE(*,*) 'WARNING: Pair ResidA  ',ResidA,'  and ResidB  ',ResidB, ' are not found  in  min_d_COM_arr '//&
				&' use d_COM instead.' 
				!WRITE(*,*) 'WARNING: In calc_dE_U_ext_min_d_COM_vector_list.'
				WARNING_ERROR=.true.
			ENDIF
    END DO loop_i
    box_size(1)=x_box
    box_size(2)=y_box
    box_size(3)=z_box
    DO i=1,3
        IF( dist(i) > 0.5*box_size(i) ) THEN
                dist(i) = dist(i)-box_size(i)
        ELSE IF ( dist(i) < -0.5*box_size(i) ) THEN
                dist(i) = dist(i)+box_size(i)
        ELSE
                CYCLE
        END IF
    END DO

    dE_U_ext= DOT_PRODUCT(dist,U_ext)    ! Energie in eV (fuer Elektronen)

END SUBROUTINE calc_dE_U_ext_min_d_COM_vector_list

SUBROUTINE search_d_COM_vector_list(ResidA,ResidB,N_Resids,N_Neighbours,min_d_COM_arr,dist,WARNING)
	!! Searches ResidA and ResidB in the  min_d_COM_arr  data for the d_RCOM distance vector.
	IMPLICIT NONE
    INTEGER, INTENT(IN) :: N_Resids,N_Neighbours,ResidA,ResidB
    REAL, DIMENSION (:,:,:), INTENT(IN) :: min_d_COM_arr
    REAL, DIMENSION (3), INTENT(OUT)    :: dist
    LOGICAL :: WARNING
    REAL, DIMENSION (3) ::box_size
    INTEGER::i,j
    
	!! 	min_d_COM_arr(i,j,4) = ResidA  
	!!  min_d_COM_arr(i,j,5) = ResidB 
	!!  min_d_COM_arr(i,j,6) = norm_dist_vec_min 
    dist=0
    WARNING=.false.
    loop_i: DO i=1,N_Resids
			DO j=1,N_Neighbours
				IF(    (int(min_d_COM_arr(i,j,4)) == ResidA) .AND.   (int(min_d_COM_arr(i,j,5)) == ResidB)  ) THEN
					dist=min_d_COM_arr(i,j,1:3)
					EXIT loop_i
				ELSE IF( (int(min_d_COM_arr(i,j,4)) == ResidB) .AND. (int(min_d_COM_arr(i,j,5)) == ResidA) ) THEN
					dist=-1.0*min_d_COM_arr(i,j,1:3)
					EXIT loop_i
				ENDIF
			ENDDO 
			IF( i == N_Resids) THEN
				!WRITE(*,*) ' N_Resids,N_Neighbours,ResidA,ResidB,U_ext'
				!WRITE(*,*) 'WARNING: Pair ResidA  ',ResidA,'  and ResidB  ',ResidB, ' are not found  in  min_d_COM_arr '//&
				!&' use d_COM instead.' 
				!WRITE(*,*) 'WARNING: In calc_dE_U_ext_min_d_COM_vector_list.'
				WARNING=.true.
			ENDIF
    END DO loop_i
END SUBROUTINE search_d_COM_vector_list


SUBROUTINE Read_J_AB_from_file(filename,N_Resids,N_Neighbours,neighbour_list_Res,J_AB_Daten,J_AB_da)
    !! Read J_AB 
    use small_functions
    IMPLICIT NONE
    CHARACTER(500), INTENT(IN) :: filename
    INTEGER, INTENT(IN)::N_Resids,N_Neighbours
    INTEGER, DIMENSION(N_Resids,N_Neighbours+1), INTENT(IN)::neighbour_list_Res
    Real, DIMENSION(N_Resids*N_Neighbours,4), INTENT(OUT)::J_AB_Daten
    LOGICAL, DIMENSION(N_Resids*N_Neighbours), INTENT(OUT)::J_AB_da
    INTEGER::i,ierror,j,k,l,index_i,index_j,ierror1,Resid_1,Resid_2,NR,N_lines,N_skip_line,N_limit,Offset_Resid
    INTEGER, DIMENSION(13) :: buff
    INTEGER :: status
    CHARACTER(10000):: Bashline
    CHARACTER(1000)::tmp_file,J_AB_foldername
    CHARACTER(50)::dummy_str,format_1
    REAL    :: S_AB_lo,S_AB_el,J_AB_lo,J_AB_el
    LOGICAL :: Read_data,read_with_grep,Resid_1_da,Resid_2_da,skip_pair=.false.
    LOGICAL :: Datei_vorhanden
    
    Offset_Resid=neighbour_list_Res(1,1)  ! Falls die Resids nicht bei 0 starten mit dem Zählen, wie fuer DIPBI 33
    read_with_grep=.false.

    !residue_offset=33 !DIPBI Residue offset um wieder auf die Residuennuemmer zu kommen
    INQUIRE(file=TRIM(filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
    IF( .NOT. Datei_vorhanden) THEN
        WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(filename)
        WRITE(*,*) ' ENDE'
        CALL EXIT (1)
    END IF ! Datei-file vorhanden 
    WRITE(*,*) 'Reading data from: ',TRIM(filename)
    
    tmp_file='tmp_grep_JAB.dat'  ! Temporary filename should not overwrite any data, so adapt the name
    INQUIRE(file=TRIM(tmp_file),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
    IF( Datei_vorhanden) THEN
        DO i=1,10
            tmp_file='tmp_grep_JAB_V'//TRIM(str(i))//'.dat'
            INQUIRE(file=TRIM(tmp_file),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
            IF( .NOT. Datei_vorhanden) THEN
                EXIT
            END IF
        END DO
        IF( Datei_vorhanden) THEN
            WRITE(*,*) ' Fehler: Versuche_eine_temporaere_Datei_zu_erzeugen'
            WRITE(*,*) ' Die_Datei_ist_jedoch_nicht_vorhanden. '//TRIM(tmp_file)
            WRITE(*,*) ' Stellen_sie_sicher_dass_diese_nicht_ueberschrieben_wird. '
            WRITE(*,*) ' ENDE'
            CALL EXIT (1)
        END IF
    END IF ! Datei-file vorhanden 

WRITE(*,*) 'Read data, please wait ...'
J_AB_Daten=0.0
J_AB_da=.false.

IF ( read_with_grep) THEN ! Dieser Teil funktioniert ist jedoch sehr langsam!
    NR=1 !Hochzaehlen der einzelnen Paare
    DO i=1,N_Resids,1
        DO j=1,N_Neighbours,1
            Read_data=.false.
            Resid_1=INT(neighbour_list_Res(i,1))    ! Resid A
            Resid_2=INT(neighbour_list_Res(i,j+1))  ! Nachbarn Uebergeben fuer indizes 2 bis 13   
    
            Bashline='grep _'//TRIM(str(Resid_1))//'_'//TRIM(str(Resid_2))//'_ '//TRIM(filename)//&
                    &' | grep -v "Fehler" | tail --l 1 > '//TRIM(tmp_file)
            CALL execute_command_line(TRIM(Bashline)) 
            !! Test of file leer ist // bzw filegroesse wird in buff(8) gespeichert
            CALL STAT(TRIM(tmp_file), buff, status)
            IF (status == 0) THEN
                !WRITE (*, FMT="('File size:',               T30, I19)") buff(8)
                IF ( buff(8) == 0 ) THEN ! grep in other direction
                            Bashline='grep _'//TRIM(str(Resid_2))//'_'//TRIM(str(Resid_1))//'_ '//TRIM(filename)//&
                                    &' | grep -v "Fehler" | tail --l 1 > '//TRIM(tmp_file)
                            !WRITE(*,*) TRIM(Bashline)
                            CALL execute_command_line(TRIM(Bashline)) 
                            CALL STAT(TRIM(tmp_file), buff, status)
                            IF (status == 0) THEN
                                IF ( buff(8) > 0 ) THEN
                                    Read_data=.true.
                                END IF
                            END IF
                ELSE IF ( buff(8) > 0 ) THEN
                    Read_data=.true.
                END IF
                !WRITE(*,*) buff(8)  !! Enthaellt als Integer die Dateigroesse
            END IF   
            !WRITE(*,*) 'Einlesen:',Read_data
            IF ( Read_data ) THEN  ! Einlesen der Daten aus dem tmp_file in array J_AB_Daten
                OPEN(UNIT=31,FILE=TRIM(tmp_file),STATUS='unknown',IOSTAT=ierror1,action='read')
                READ(31,*,IOSTAT=ierror1) J_AB_Daten(NR,1),J_AB_Daten(NR,2),J_AB_Daten(NR,3),J_AB_Daten(NR,4),J_AB_foldername !Reading S_AB_lo,J_AB_lo,S_AB_el,J_AB_el
                J_AB_da(NR)=.true.
                CLOSE(31)
                IF ( 0 == INDEX(TRIM(J_AB_foldername), '_N') ) THEN
                    WRITE(*,*) ' WARNING: Format_beim_Einlesen_von_J_AB_fehlerhaft: '
                    WRITE(*,*) ' Pruefe: '//TRIM(str(Resid_1))//' '//TRIM(str(Resid_2))//' in '//TRIM(filename)
                    WRITE(*,*) ' Read:',J_AB_Daten(NR,1),J_AB_Daten(NR,2),J_AB_Daten(NR,3),J_AB_Daten(NR,4),TRIM(J_AB_foldername)
                    ierror1=0
                    CYCLE 
                    !CALL EXIT (1)
                END IF ! Check ob _N im foldername string ist, um ggf ein falsches Einlesen zu Vermeiden
    
                !WRITE(*,*) J_AB_Daten(NR,1),J_AB_Daten(NR,2),J_AB_Daten(NR,3),J_AB_Daten(NR,4),TRIM(J_AB_foldername)
            ELSE
                IF ( (Resid_1+1 == Resid_2) .OR. (Resid_1-1 == Resid_2)  ) THEN
                    WRITE(*,*) 'Intramolecular Transport ?:'//TRIM(str(Resid_1))//' '//TRIM(str(Resid_2))//' '//TRIM(filename)
                ELSE
                    WRITE(*,*) ' Fehler: Einlesen_von_J_AB_: '//TRIM(str(Resid_1))//' '//TRIM(str(Resid_2))//' '//TRIM(filename)
                END IF
            END IF ! Read_data
                
            Bashline=' rm '//TRIM(tmp_file)
            CALL execute_command_line(TRIM(Bashline)) 
        
            NR=NR+1
        END DO ! Schleife ueber N_Neighbours
    END DO ! Schleife ueber N_Resids

ELSE ! Read_with_grep  --- Hier read fixed format!
N_lines=Read_rows_file2(filename) 
OPEN(UNIT=20,FILE=TRIM(filename),STATUS='OLD',IOSTAT=ierror)
WRITE(*,*) 'Read J_AB from file: '//TRIM(filename)
ierror=0
N_skip_line=0
N_lines=0
DO WHILE ( ierror == 0 ) 
    Read(20,*,IOSTAT=ierror) dummy_str
    IF(ierror < 0) EXIT
    IF(ierror > 0) THEN
        WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(filename),' aufgetreten.'
        WRITE(*,*) 'Beende Einlesen !'
        CALL EXIT (1)
    END IF
    if ( dummy_str(1:1) == '#' ) THEN ! Check ob erster Buchstabe ein #-Zeichen ist, um kommentare zu lesen
        N_skip_line=N_skip_line+1
        N_lines=N_lines+1
    ELSE
        N_lines=N_lines+1
    END IF
END DO       
CLOSE(20)        
WRITE(*,*) 'N_lines=',N_lines,'N_skip_line',N_skip_line        

OPEN(UNIT=31,FILE=TRIM(filename),STATUS='OLD',IOSTAT=ierror)
IF (N_skip_line > 0 ) THEN ! Auslassen der Zeilen mit '#'
    DO i =1,N_skip_line 
        Read(31,*,IOSTAT=ierror) dummy_str
    END DO
END IF
   
   
DO k=1,(N_lines-N_skip_line)
     READ(31,*,IOSTAT=ierror) S_AB_lo,J_AB_lo,S_AB_el,J_AB_el,J_AB_foldername   !Reading S_AB_lo,J_AB_lo,S_AB_el,J_AB_el,J_AB_foldername 
     !WRITE(*,*,IOSTAT=ierror) S_AB_lo,J_AB_lo,S_AB_el,J_AB_el,TRIM(J_AB_foldername) !Reading S_AB_lo,J_AB_lo,S_AB_el,J_AB_el,J_AB_foldername  
     IF ( 0 == INDEX(TRIM(J_AB_foldername), '_N') ) THEN
         WRITE(*,*) TRIM(J_AB_foldername)
         WRITE(*,*) ' Fehler: Format_beim_Einlesen_von_J_AB_fehlerhaft: '
         WRITE(*,*) ' Pruefe: '//TRIM(str(Resid_1))//' '//TRIM(str(Resid_2))//' in '//TRIM(filename)
         WRITE(*,*) ' Read:',S_AB_lo,J_AB_lo,S_AB_el,J_AB_el,TRIM(J_AB_foldername) !Reading S_AB_lo,J_AB_lo,S_AB_el,J_AB_el
         !CALL EXIT (1)
     END IF ! Check ob _N im foldername string ist, um ggf ein falsches Einlesen zu Vermeiden


    !! Abschnitt, um aus dem J_AB_foldername string die beiden Resid_1 und Resid_2 zu isolieren.
    Resid_1_da=.false.
    Resid_2_da=.false.
    !WRITE(*,*) TRIM(J_AB_foldername)
    N_limit = count( (/ (J_AB_foldername(i:i), i=1, len_trim(J_AB_foldername)) /) == "_")  ! Bestimmt die Anzahl der Abschnitte im String mit '_'
    DO l=1,N_limit
        i= index(J_AB_foldername, '_')  ! Index des ersten '_' im string
        format_1='(I'//TRIM(str((i-1)))//'.0)' ! Format zum Test der Umwandlung in Integer an stringlaenge anpassen.
        READ(J_AB_foldername, TRIM(format_1), IOSTAT=ierror) j
        IF( ierror == 0 ) THEN ! Wenn der Teilstring eine Integervariable ist dann Speichern ; Beim Umwandlungsfehler ist ierror /= 0
            IF ( .NOT. Resid_1_da) THEN
                Resid_1=j
                Resid_1_da=.true.
            ELSE IF ( .NOT. Resid_2_da ) THEN
                Resid_2=j
                Resid_2_da=.true.
            END IF ! 
        END IF
        J_AB_foldername=J_AB_foldername(i+1:) ! Abschneiden der Teilstücke
    END DO ! Ende Abschnitt, um aus dem J_AB_foldername string die beiden Resid_1 und Resid_2 zu isolieren.
 
    
    !WRITE(*,*) 'Anzahl _ in :',N_limit,TRIM(J_AB_foldername)
    !WRITE(*,*) 'Resid_1: ',Resid_1,' Resid_2: ',Resid_2
    !WRITE(*,*) 'Offset_Resid:',Offset_Resid
    skip_pair=.false.
    !! Abschnitt um aus den Resid_1 und Resid_2 die Indizes index_i und index_j zu finden, um die Daten in der Nachbarschaftsliste finden.
    index_i=(Resid_1-Offset_Resid+1)
    index_j=0
    DO j=2,N_Neighbours+1
        IF ( neighbour_list_Res(index_i,j) == Resid_2 ) Then
            index_j=j   ! Index in Neighbourlist
            EXIT
        END IF
        IF ( (j == (N_Neighbours+1)) .AND. (index_j == 0) ) THEN
            WRITE(*,*) ' Fehler: Resid_1 '//TRIM(str(Resid_1))//' und Resid_2 '&
                        &//TRIM(str(Resid_2))//' nicht in der Nachbarliste gefunden'
         WRITE(*,*) ' Pruefe: '//TRIM(str(Resid_1))//' '//TRIM(str(Resid_2))//' in '//TRIM(filename)
         WRITE(*,*) ' Read:',S_AB_lo,J_AB_lo,S_AB_el,J_AB_el,TRIM(J_AB_foldername) !Reading S_AB_lo,J_AB_lo,S_AB_el,J_AB_el
		 WRITE(*,*) ' Cycle -- Paar wird ausgelassen '
			skip_pair=.true.
            !CYCLE
        END IF
    END DO ! Schleife ueber alle Nachbarn von Resid_1
    
    
    IF( .NOT. skip_pair) THEN
		! Abschnitt zum Abspeichern der Daten in das Array
		NR=(index_i-1)*N_Neighbours+(index_j-1) ! Umrechnung der Indizes fuer die Nachbarschaftsliste in die Paar-Nummer (NR) = { 1,..., NR_max=N_Neighbours*N_Residues}
		!WRITE(*,*) 'NR=',NR,' index_i=',index_i,' index_j=',index_j
		IF ( .NOT. J_AB_da(NR) ) THEN ! Abspeichern wenn noch nicht vorhanden
			IF ( ISNAN(S_AB_lo) .OR. ISNAN(J_AB_lo) .OR. ISNAN(S_AB_el) .OR. ISNAN(J_AB_el) ) THEN
						WRITE(*,*) 'Error: Nan in input data, Set to zero: ',S_AB_lo,J_AB_lo,S_AB_el,J_AB_el,TRIM(J_AB_foldername)  
						S_AB_lo=0.0
						J_AB_lo=0.0
						S_AB_el=0.0
						J_AB_el=0.0
						! CYCLE
			END IF
			J_AB_Daten(NR,1)=S_AB_lo
			J_AB_Daten(NR,2)=J_AB_lo
			J_AB_Daten(NR,3)=S_AB_el
			J_AB_Daten(NR,4)=J_AB_el
			J_AB_da(NR)=.true.
		ELSE 
			CYCLE
		END IF
		!WRITE(*,*) 'Neighbourlist Resids:',neighbour_list_Res(index_i,1),neighbour_list_Res(index_i,index_j)
		!WRITE(*,*) neighbour_list_Res(index_i,:)
		!write(*,*) J_AB_Daten(NR,1),J_AB_Daten(NR,2),J_AB_Daten(NR,3),J_AB_Daten(NR,4),TRIM(J_AB_foldername) !Reading S_AB_lo,J_AB_lo,J_AB_el,S_AB_el

		!!! Checke indizes in umgekehrter Reihenfolge

		!! Abschnitt um aus den Resid_2 und Resid_1 die Indizes index_i und index_j zu finden, um die Daten in der Nachbarschaftsliste finden.
		index_i=(Resid_2-Offset_Resid+1)
		index_j=0
		DO j=2,N_Neighbours+1
			IF ( neighbour_list_Res(index_i,j) == Resid_1 ) Then
				index_j=j   ! Index in Neighbourlist
					! Abschnitt zum Abspeichern der Daten in das Array
				NR=(index_i-1)*N_Neighbours+(index_j-1) ! Umrechnung der Indizes fuer die Nachbarschaftsliste in die Paar-Nummer (NR) = { 1,..., NR_max=N_Neighbours*N_Residues}
				!WRITE(*,*) 'NR=',NR,' index_i=',index_i,' index_j=',index_j
				IF ( .NOT. J_AB_da(NR) ) THEN
					IF ( ISNAN(S_AB_lo) .OR. ISNAN(J_AB_lo) .OR. ISNAN(S_AB_el) .OR. ISNAN(J_AB_el) ) THEN
						WRITE(*,*) 'Error: Nan in input data, set data to zero: ',S_AB_lo,J_AB_lo,S_AB_el,J_AB_el,TRIM(J_AB_foldername)  
						S_AB_lo=0.0
						J_AB_lo=0.0
						S_AB_el=0.0
						J_AB_el=0.0
						!WRITE(*,*) 'CYCLE'
						!CYCLE
					END IF
				
					J_AB_Daten(NR,1)=S_AB_lo
					J_AB_Daten(NR,2)=J_AB_lo
					J_AB_Daten(NR,3)=S_AB_el
					J_AB_Daten(NR,4)=J_AB_el
					J_AB_da(NR)=.true.
					!WRITE(*,*) index_i,index_j
					!WRITE(*,*) neighbour_list_Res(index_i,:)
					!write(*,*) J_AB_Daten(NR,1),J_AB_Daten(NR,2),J_AB_Daten(NR,3),J_AB_Daten(NR,4),TRIM(J_AB_foldername) !Reading S_AB_lo,J_AB_lo,J_AB_el,S_AB_el
				END IF ! J_AB_da schon vorher vorhanden ?
				EXIT  ! Springen aus Do-Schleife
			END IF ! Resid_1 an stelle j in Nachbarschaftsliste ?
			IF ( (j == (N_Neighbours+1)) .AND. (index_j == 0) ) THEN
				!WRITE(*,*) ' Anmerkung: Reihenfolge Resid_2 '//TRIM(str(Resid_2))//' und Resid_1 '&
				!            &//TRIM(str(Resid_1))//' nicht in der Nachbarliste gefunden.'
				!CALL EXIT (1)
			END IF
		END DO ! Schleife ueber die Nachbarn von Resid_2
	END IF ! skip_pair=.false.
END DO ! Schleife uber alle Zeile ohne '#' im J_AB_file
CLOSE(31)
   
   
END IF ! Read_without_grep  --- Hier read fixed format!

	WRITE(*,*) 'N_J_AB_pairs_intermolecular available: ',COUNT(J_AB_da(:))

END SUBROUTINE Read_J_AB_from_file





!! reading Read_J_AB_from_sql_file |J_AB|**2  data  from *.sql file => conversion to |J_AB| and to the J_AB_Daten array
!! with the format from sql file: id,seg1,seg2,Jeff2h,Jeff2e
!! Replace "|" with "whitespace" beforehand; Take the index shift between votca and my_kmc into account!  
!! sqlite3 state.sql 'SELECT id,seg1,seg2,Jeff2h,Jeff2e FROM pairs ' >> state_J_AB_ZINDO_MOO_votca.dat
!!
!! conversion to J_AB_Daten and J_AB_da formats
SUBROUTINE get_J_AB_from_sql_file(votca_sqlfile_name,seg1_seg2_J_AB_data,pairs_seg1_seg2_J_AB_data,N_sql_JAB_lines,&
												&N_Residues,N_Neighbours,neighbour_list_Res,J_AB_Daten,J_AB_da)
	use small_functions
	IMPLICIT NONE
    !! filename to Read_J_AB_from_sql_file
    CHARACTER(500), INTENT(IN) :: votca_sqlfile_name
    !! Array for hole    seg1_seg2_J_AB_data(i,1) and    electron seg1_seg2_J_AB_data(i,2)
    REAL, ALLOCATABLE, DIMENSION(:,:)    , INTENT(OUT) :: pairs_seg1_seg2_J_AB_data 
    !! Resids of segment 1 and segment 2 in votca 
    INTEGER, ALLOCATABLE, DIMENSION(:,:) , INTENT(OUT) :: seg1_seg2_J_AB_data
    
    !! pass the data to the output format as in
    INTEGER, INTENT(IN)::N_Residues,N_Neighbours
    INTEGER, DIMENSION(N_Residues,N_Neighbours+1), INTENT(IN)  ::neighbour_list_Res
    REAL, DIMENSION(N_Residues*N_Neighbours,4),   INTENT(OUT)  ::J_AB_Daten
    LOGICAL, DIMENSION(N_Residues*N_Neighbours), INTENT(OUT)   ::J_AB_da
    
    INTEGER, INTENT(OUT)::N_sql_JAB_lines
    CHARACTER(50) ::dummy_str
    INTEGER:: ierror,i,j,N_skip_line,N_lines
    INTEGER:: id
    LOGICAL:: Datei_vorhanden,DEBUG=.false.,skip_pair=.false.
    CHARACTER(500)  ::J_AB_filename
	Character(1024) :: bashline
	
	!! data for comparison to neighbourlist
	INTEGER::index_i,index_j,NR,Offset_Resid,count_skiped_neighbours
	!REAL::S_AB_lo,S_AB_el,J_AB_lo,J_AB_el
	INTEGER :: Resid1, Resid2

		
		INQUIRE(file=TRIM(votca_sqlfile_name),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
		IF( .NOT. Datei_vorhanden) THEN
					WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(votca_sqlfile_name)
					WRITE(*,*) ' ENDE'
					CALL EXIT (1)
		END IF ! Datei-votca_sqlfile_name vorhanden 
		
		IF (check_filetermination(votca_sqlfile_name,'.sql')) THEN
			WRITE(*,*) 'Reading data from: ',TRIM(votca_sqlfile_name)	
			J_AB_filename=TRIM(votca_sqlfile_name(1:LEN(TRIM(votca_sqlfile_name))-4))//'_J_AB_ZINDO_MOO_votca.dat'

			INQUIRE(file=TRIM(J_AB_filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
			IF( .NOT. Datei_vorhanden) THEN
					!!! make new file state_J_AB_ZINDO_MOO_votca.dat
					OPEN(UNIT=50,FILE=TRIM(J_AB_filename),STATUS='REPLACE',IOSTAT=ierror)
					WRITE(50,*) "# sqlite3 "//TRIM(votca_sqlfile_name)//"  'SELECT id,seg1,seg2,Jeff2h,Jeff2e FROM pairs'  > "//&
													&TRIM(J_AB_filename)
					CLOSE(50)
					
					bashline=" sqlite3 "//TRIM(votca_sqlfile_name)//" ' SELECT id,seg1,seg2,Jeff2h,Jeff2e FROM pairs ' >> "//TRIM(J_AB_filename)
					CALL execute_command_line(TRIM(bashline))
					
					!!! replace | by whitespaces 
					bashline=" sed -i 's/|/    /g'  "//TRIM(J_AB_filename)
					CALL execute_command_line(TRIM(bashline))
					WRITE(*,*) 'Transfered data to: ',TRIM(J_AB_filename)
			END IF ! Datei-J_AB_filename vorhanden 
			WRITE(*,*) 'Reading data from: ',TRIM(J_AB_filename)
			
		END IF ! check_filetermination sql. 
	   


	OPEN(UNIT=21,FILE=TRIM(J_AB_filename),STATUS='OLD',IOSTAT=ierror)
	WRITE(*,*) 'Read J_AB data from file: '//TRIM(J_AB_filename)
	ierror=0
	N_skip_line=0
	N_lines=0
	DO WHILE ( ierror == 0 )
		Read(21,*,IOSTAT=ierror) dummy_str
		IF(ierror < 0) EXIT
		IF(ierror > 0) THEN
			WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(J_AB_filename),' aufgetreten.'
			WRITE(*,*) 'Beende Einlesen !'
			CALL EXIT (1)
		END IF
		IF ( dummy_str(1:1) == '#' ) THEN ! Check ob erster Buchstabe ein #-Zeichen ist, um kommentare zu lesen
			N_skip_line=N_skip_line+1
			N_lines=N_lines+1
		ELSE
			N_lines=N_lines+1
		END IF
	END DO
	CLOSE(21)
	WRITE(*,*) 'N_lines: ',N_lines,' N_skip_line: ',N_skip_line

	OPEN(UNIT=32,FILE=TRIM(J_AB_filename),STATUS='OLD',IOSTAT=ierror)
	IF (N_skip_line > 0 ) THEN ! Auslassen der Zeilen mit '#'
		DO i =1,N_skip_line
			Read(32,*,IOSTAT=ierror) dummy_str
			WRITE(*,*) ierror,'tmp:' ,dummy_str
		END DO
	END IF
	N_sql_JAB_lines=N_lines-N_skip_line
	ALLOCATE(seg1_seg2_J_AB_data(N_sql_JAB_lines,2))
	ALLOCATE(pairs_seg1_seg2_J_AB_data(N_sql_JAB_lines,2))

	DO i=1,N_sql_JAB_lines
		!!!! read           pair_id,       sedment1,              segment2,            
		READ(32,*,IOSTAT=ierror) id,seg1_seg2_J_AB_data(i,1),seg1_seg2_J_AB_data(i,2),&
		!!!! Jeff2h  [eV],     Jeff2e  [eV]
		&    pairs_seg1_seg2_J_AB_data(i,1),pairs_seg1_seg2_J_AB_data(i,2)    
	 
		IF(DEBUG) WRITE(*,*) id,seg1_seg2_J_AB_data(i,1),seg1_seg2_J_AB_data(i,2),&
		&    pairs_seg1_seg2_J_AB_data(i,1),pairs_seg1_seg2_J_AB_data(i,2)   
		!!! evaluate Jeffh=sqrt(Jeff2h)
		pairs_seg1_seg2_J_AB_data(i,1)=SQRT(pairs_seg1_seg2_J_AB_data(i,1))
		!!! evaluate Jeffe=sqrt(Jeff2e)
		pairs_seg1_seg2_J_AB_data(i,2)=SQRT(pairs_seg1_seg2_J_AB_data(i,2))
			
		IF(ierror < 0) EXIT
		IF(ierror > 0) THEN
			WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(J_AB_filename),' aufgetreten.'
			WRITE(*,*) 'Beende Einlesen !'
			CALL EXIT (1)
		END IF
	END DO ! Read Data

	IF (DEBUG) THEN
		WRITE(*,*) 'Jeff2 data from file: '//TRIM(J_AB_filename)
		DO i=1,N_sql_JAB_lines
			WRITE(*,*) seg1_seg2_J_AB_data(i,1),seg1_seg2_J_AB_data(i,2),pairs_seg1_seg2_J_AB_data(i,1),pairs_seg1_seg2_J_AB_data(i,2)
		END DO 
	END IF
	!!! END reading J_AB data form sql file 


	!! shift index for resids VOTCA -> to OUZO
	j=seg1_seg2_J_AB_data(1,1)-neighbour_list_Res(1,1)
	seg1_seg2_J_AB_data(:,1)=seg1_seg2_J_AB_data(:,1)-j
	seg1_seg2_J_AB_data(:,2)=seg1_seg2_J_AB_data(:,2)-j
	WRITE(*,*) 'SEG1SEG2 shifted : ',seg1_seg2_J_AB_data(1,1),seg1_seg2_J_AB_data(1,2),' for Jeff2 data with j_Shift: ',j

	Offset_Resid=neighbour_list_Res(1,1) 

	count_skiped_neighbours=0
	!!! Start transfer data to J_AB_Daten and J_AB_da format
	DO i=1,N_sql_JAB_lines
		skip_pair=.false.
		Resid1=seg1_seg2_J_AB_data(i,1)
		Resid2=seg1_seg2_J_AB_data(i,2)
		!WRITE(*,*) 'tmp: START',Resid1,Resid2
	   !! Abschnitt um aus den Resid_1 und Resid_2 die Indizes index_i und index_j zu finden, um die Daten in der Nachbarschaftsliste finden.
		index_i=(Resid1-Offset_Resid+1)
		index_j=0
		DO j=2,N_Neighbours+1
			IF ( neighbour_list_Res(index_i,j) == Resid2 ) Then
				index_j=j   ! Index in Neighbourlist
				EXIT
			END IF
			IF ( (j == (N_Neighbours+1)) .AND. (index_j == 0) ) THEN
				WRITE(*,*) ' Warning: ResidA '//TRIM(str(Resid1))//' und ResidB '&
							&//TRIM(str(Resid2))//' nicht in der Nachbarliste gefunden'
				WRITE(*,*) ' Pruefe: '//TRIM(str(Resid1))//' '//TRIM(str(Resid2))//' in '//TRIM(J_AB_filename)
				count_skiped_neighbours=count_skiped_neighbours+1
				skip_pair=.true.
				WRITE(*,*) ' Cycle -- Paar wird ausgelassen '
				CYCLE
			END IF
		END DO ! Schleife ueber alle Nachbarn von Resid_1
		
		IF( .NOT. skip_pair) THEN
			! Abschnitt zum Abspeichern der Daten in das Array
			NR=(index_i-1)*N_Neighbours+(index_j-1) ! Umrechnung der Indizes fuer die Nachbarschaftsliste in die Paar-Nummer (NR) = { 1,..., NR_max=N_Neighbours*N_Residues}
			!WRITE(*,*) 'tmp: NR=',NR,' index_i=',index_i,' index_j=',index_j
			
			IF ( .NOT. J_AB_da(NR) ) THEN ! Abspeichern wenn noch nicht vorhanden
				IF ( ISNAN(pairs_seg1_seg2_J_AB_data(i,1)) .OR. ISNAN(pairs_seg1_seg2_J_AB_data(i,2)) ) THEN
							WRITE(*,*) 'Error: Nan in input data, Set to zero: ',pairs_seg1_seg2_J_AB_data(i,1),&
																				&pairs_seg1_seg2_J_AB_data(i,2),TRIM(J_AB_filename)  
							J_AB_Daten(NR,1)=0.0
							J_AB_Daten(NR,2)=0.0
							J_AB_Daten(NR,3)=0.0
							J_AB_Daten(NR,4)=0.0
							 CYCLE
				END IF
				J_AB_Daten(NR,1)=0.0  !S_AB_lo
				J_AB_Daten(NR,2)=pairs_seg1_seg2_J_AB_data(i,1)  !J_AB_lo
				J_AB_Daten(NR,3)=0.0  !S_AB_el
				J_AB_Daten(NR,4)=pairs_seg1_seg2_J_AB_data(i,2) !J_AB_el
				J_AB_da(NR)=.true.
			ELSE 
				CYCLE
			END IF


		   !!! Checke indizes in umgekehrter Reihenfolge

			!! Abschnitt um aus den Resid_2 und Resid_1 die Indizes index_i und index_j zu finden, um die Daten in der Nachbarschaftsliste finden.
			index_i=(Resid2-Offset_Resid+1)
			index_j=0
			DO j=2,N_Neighbours+1
				IF ( neighbour_list_Res(index_i,j) == Resid1 ) Then
					index_j=j   ! Index in Neighbourlist
						! Abschnitt zum Abspeichern der Daten in das Array
					NR=(index_i-1)*N_Neighbours+(index_j-1) ! Umrechnung der Indizes fuer die Nachbarschaftsliste in die Paar-Nummer (NR) = { 1,..., NR_max=N_Neighbours*N_Residues}
					!WRITE(*,*) 'NR=',NR,' index_i=',index_i,' index_j=',index_j
					IF ( .NOT. J_AB_da(NR) ) THEN
						IF ( ISNAN(pairs_seg1_seg2_J_AB_data(i,1)) .OR. ISNAN(pairs_seg1_seg2_J_AB_data(i,2)) ) THEN
							WRITE(*,*) 'Error: Nan in input data, Set to zero: ',pairs_seg1_seg2_J_AB_data(i,1),&
																				&pairs_seg1_seg2_J_AB_data(i,2),TRIM(J_AB_filename)  
							J_AB_Daten(NR,1)=0.0
							J_AB_Daten(NR,2)=0.0
							J_AB_Daten(NR,3)=0.0
							J_AB_Daten(NR,4)=0.0
							 CYCLE
						END IF
					
						J_AB_Daten(NR,1)=0.0  !S_AB_lo
						J_AB_Daten(NR,2)=pairs_seg1_seg2_J_AB_data(i,1)  !J_AB_lo
						J_AB_Daten(NR,3)=0.0  !S_AB_el
						J_AB_Daten(NR,4)=pairs_seg1_seg2_J_AB_data(i,2)   !J_AB_el
						J_AB_da(NR)=.true.
						!WRITE(*,*) index_i,index_j
						!WRITE(*,*) neighbour_list_Res(index_i,:)
						!write(*,*) J_AB_Daten(NR,1),J_AB_Daten(NR,2),J_AB_Daten(NR,3),J_AB_Daten(NR,4),TRIM(J_AB_foldername) !Reading S_AB_lo,J_AB_lo,J_AB_el,S_AB_el
					END IF ! J_AB_da schon vorher vorhanden ?
					EXIT  ! Springen aus Do-Schleife
				END IF ! Resid_1 an stelle j in Nachbarschaftsliste ?
				IF ( (j == (N_Neighbours+1)) .AND. (index_j == 0) ) THEN
					WRITE(*,*) ' Anmerkung: Reihenfolge ResidB '//TRIM(str(Resid2))//' und ResidA '&
								&//TRIM(str(Resid1))//' nicht in der Nachbarliste gefunden.'
					!CALL EXIT (1)
				END IF
			END DO ! Schleife ueber die Nachbarn von Resid2
		END IF ! .NOT. skip_pair	
	END DO ! i=1 to N_sql_JAB_lines


	IF(count_skiped_neighbours > 0 ) WRITE(*,*) 'Warning: ',count_skiped_neighbours,' pairs in '//TRIM(J_AB_filename)//&
										&' are not found in the neighbour_list.'

	IF(DEBUG) THEN
		DO i=1,size(J_AB_da)
				IF(J_AB_da(i))THEN
					WRITE(*,*) J_AB_Daten(i,1),J_AB_Daten(i,2)**2,J_AB_Daten(i,3),J_AB_Daten(i,4)**2
				END IF
		END DO
	END IF

	!!! End order Data to J_AB_Daten and J_AB_da format
END SUBROUTINE get_J_AB_from_sql_file



!! reading read_lambda_out_file data 
!! with the format from sql file: id,seg1,seg2,lOh,lOe
!! Replace "|" with "whitespace" beforehand; Take the index shift between votca and my_kmc into account!  
!! sqlite3 statefile.sql ' SELECT id,seg1,seg2,lOh,lOe  FROM pairs ' >> l_out_filename.dat
SUBROUTINE read_lambda_out_file(l_out_filename,seg1_seg2_l_out,N_l_out_data,N_l_out_lines)
	use small_functions
	IMPLICIT NONE
    !! filename to read lambda_out data
    CHARACTER(500), INTENT(IN) :: l_out_filename
    !! Array for hole lambda_out_h N_l_out_data(i,1) and    electron lambda_out_e  N_l_out_data(i,2)
    REAL, ALLOCATABLE, DIMENSION(:,:)    , INTENT(OUT) :: N_l_out_data 
    !! Resids of segment 1 and segment 2 in votca 
    INTEGER, ALLOCATABLE, DIMENSION(:,:) , INTENT(OUT) :: seg1_seg2_l_out
    INTEGER, INTENT(OUT)::N_l_out_lines
    CHARACTER(50) ::dummy_str
    INTEGER:: ierror,i,N_skip_line,N_lines
    INTEGER:: id
    LOGICAL:: Datei_vorhanden,DEBUG=.false.
    
		INQUIRE(file=TRIM(l_out_filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
		IF( .NOT. Datei_vorhanden) THEN
					WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(l_out_filename)
					WRITE(*,*) ' ENDE'
					CALL EXIT (1)
		END IF ! Datei-file vorhanden 
		WRITE(*,*) 'Reading data from: ',TRIM(l_out_filename)


		N_lines=Read_rows_file2(l_out_filename)
		OPEN(UNIT=21,FILE=TRIM(l_out_filename),STATUS='OLD',IOSTAT=ierror)
		WRITE(*,*) 'Read lambda_out data from file: '//TRIM(l_out_filename)
		ierror=0
		N_skip_line=0
		N_lines=0
		DO WHILE ( ierror == 0 )
			Read(21,*,IOSTAT=ierror) dummy_str
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(l_out_filename),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
			IF ( dummy_str(1:1) == '#' ) THEN ! Check ob erster Buchstabe ein #-Zeichen ist, um kommentare zu lesen
				N_skip_line=N_skip_line+1
				N_lines=N_lines+1
			ELSE
				N_lines=N_lines+1
			END IF
		END DO
		CLOSE(21)
		WRITE(*,*) 'N_lines: ',N_lines,' N_skip_line: ',N_skip_line

		OPEN(UNIT=32,FILE=TRIM(l_out_filename),STATUS='OLD',IOSTAT=ierror)
		IF (N_skip_line > 0 ) THEN ! Auslassen der Zeilen mit '#'
			DO i =1,N_skip_line
				Read(32,*,IOSTAT=ierror) dummy_str
			END DO
		END IF
		N_l_out_lines=N_lines-N_skip_line
		ALLOCATE(seg1_seg2_l_out(N_l_out_lines,2))
		ALLOCATE(N_l_out_data(N_l_out_lines,2))

		DO i=1,N_l_out_lines
			!!!! read           pair_id,       sedment1,              segment2,        lOh[eV],            lOe[eV]
			READ(32,*,IOSTAT=ierror) id,seg1_seg2_l_out(i,1),seg1_seg2_l_out(i,2),N_l_out_data(i,1),N_l_out_data(i,2)
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(l_out_filename),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
		END DO ! Read Data

		IF (DEBUG) THEN
			WRITE(*,*) 'lambda in data from file: '//TRIM(l_out_filename)
			DO i=1,N_l_out_lines
				WRITE(*,*) seg1_seg2_l_out(i,1),seg1_seg2_l_out(i,2),N_l_out_data(i,1),N_l_out_data(i,2)
			END DO 
		END IF

END SUBROUTINE read_lambda_out_file    




!! reading read_E_multipole_out_file 
!! with the format from sql file: id,eCation,eNeutral,eAnion
!! Replace "|" with "whitespace" beforehand; Take the index shift between votca and my_kmc into account!  
!! sqlite3 statefile.sql " SELECT id,eCation,eNeutral,eAnion FROM segments " >> E_out_emultipoles_DIPBI_P3HT32mers.dat
SUBROUTINE read_E_multipole_out_file(E_multipole_filename,id_E_out,E_out_data,N_E_out_lines)
	use small_functions
	IMPLICIT NONE
    !! filename to read E_out data 
    CHARACTER(500), INTENT(IN) :: E_multipole_filename
    !! Array for hole E_out_h           E_out_data(i,1)   ; neutral  E_out_data(i,2)    and    electron E_out_e  E_out_data(i,3)
    REAL, ALLOCATABLE, DIMENSION(:,:)    , INTENT(OUT) :: E_out_data 
    !! Resids of molecule id in segments
    INTEGER, ALLOCATABLE, DIMENSION(:) , INTENT(OUT) :: id_E_out
    INTEGER, INTENT(OUT)::N_E_out_lines
    CHARACTER(50) ::dummy_str
    INTEGER:: ierror,i,N_skip_line,N_lines
    LOGICAL:: DEBUG=.false.,Datei_vorhanden
    
		INQUIRE(file=TRIM(E_multipole_filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
		IF( .NOT. Datei_vorhanden) THEN
					WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(E_multipole_filename)
					WRITE(*,*) ' ENDE'
					CALL EXIT (1)
		END IF ! Datei-file vorhanden 
		WRITE(*,*) 'Reading data from: ',TRIM(E_multipole_filename)


		N_lines=Read_rows_file2(E_multipole_filename)
		OPEN(UNIT=23,FILE=TRIM(E_multipole_filename),STATUS='OLD',IOSTAT=ierror)
		!WRITE(*,*) 'Read E_multipole file data from file: '//TRIM(E_multipole_filename)
		ierror=0
		N_skip_line=0
		N_lines=0
		DO WHILE ( ierror == 0 )
			Read(23,*,IOSTAT=ierror) dummy_str
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(E_multipole_filename),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
			if ( dummy_str(1:1) == '#' ) THEN ! Check ob erster Buchstabe ein #-Zeichen ist, um kommentare zu lesen
				N_skip_line=N_skip_line+1
				N_lines=N_lines+1
			ELSE
				N_lines=N_lines+1
			END IF
		END DO
		CLOSE(23)
		WRITE(*,*) 'N_lines: ',N_lines,' N_skip_line: ',N_skip_line

		OPEN(UNIT=34,FILE=TRIM(E_multipole_filename),STATUS='OLD',IOSTAT=ierror)
		IF (N_skip_line > 0 ) THEN ! Auslassen der Zeilen mit '#'
			DO i =1,N_skip_line
				Read(34,*,IOSTAT=ierror) dummy_str
			END DO
		END IF
		N_E_out_lines=N_lines-N_skip_line
		ALLOCATE(id_E_out(N_E_out_lines))
		ALLOCATE(E_out_data(N_E_out_lines,3))

		DO i=1,N_E_out_lines
			!!!! read                      id       eCation[eV],    eNeutral[eV]    ,eAnion[eV]
			READ(34,*,IOSTAT=ierror) id_E_out(i),E_out_data(i,1),E_out_data(i,2),E_out_data(i,3)
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(E_multipole_filename),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
		END DO ! Read Data
		CLOSE(34)
		IF (DEBUG) THEN
			WRITE(*,*) 'E_out from file: '//TRIM(E_multipole_filename)
			WRITE(*,*) ' id          eCation[eV],        eNeutral[eV],      eAnion[eV]'
			DO i=1,N_E_out_lines
				WRITE(*,*) id_E_out(i),E_out_data(i,1),E_out_data(i,2),E_out_data(i,3)
			END DO 
			WRITE(*,*) 'Ende E_out_file'
		END IF

END SUBROUTINE read_E_multipole_out_file   



!! Subroutine to assign the electrostatic data from outer sphere contributions. 
!! 1) The electrostatic energy E_out data can be assigned for every segment individually as read from read_E_multipole_out_file or with:
!! 2) The reference data for the P3HT segments is the P3HT32mer IF Use_reference_data_from_P3HT32mer=.TRUE.
!! If Resid1 and Resid2 are at the same P3HT32mer chain, the contributions cancel.
!! 3) Alternatively the data can be assigned as distributions with sigma around a mean.
SUBROUTINE dE_out_for_pairs(R_u_S,N_Pairs,N_P3HT_segments,N_DIPBI,E_out_data,id_E_out,N_E_out_lines,ResidX_in_32mer,&
	   &E_out_randomized_distribution,def_E_multi_h,sig_E_multi_h,def_E_multi_e,sig_E_multi_e,&
	   &Use_reference_data_from_P3HT32mer,&
	   &def_DIPBI_E_multi_h,sig_DIPBI_E_multi_h,def_DIPBI_E_multi_e,sig_DIPBI_E_multi_e,dE_out_pairs)
	!!
	!! dE_out_pairs(i,j) collects the outer sphere data for all pairs of hopping sites (N_pairs) in the morphology  dE_out_pairs(N_Pairs,4)
	!! i: 1,...,N_Pairs 
	!! j: 1=E_out_AB_h, 2=E_out_BA_h, 3=E_out_AB_e, 4=E_out_BA_e
	IMPLICIT NONE
	INTEGER, INTENT(IN)  :: N_Pairs,N_E_out_lines,N_P3HT_segments,N_DIPBI
	!! Resids_and_number of sulfor atoms for each pair
	INTEGER, DIMENSION(N_Pairs,4), INTENT(IN) :: R_u_S
	INTEGER, DIMENSION(N_P3HT_segments+N_DIPBI,2) ::ResidX_in_32mer
	!! E_out data E_out_data(i,1) == holes , E_out_data(i,2) == neutral,  E_out_data(i,3) == electrons
	REAL,   DIMENSION(N_E_out_lines,3), INTENT(IN)  :: E_out_data
	INTEGER, DIMENSION(N_E_out_lines) , INTENT(IN)  :: id_E_out
	LOGICAL, INTENT(IN) ::E_out_randomized_distribution,Use_reference_data_from_P3HT32mer	
	!! Parametrized E_multipole_out with mean and standard deviation sigma for P3HT
	REAL, INTENT(IN)::def_E_multi_h,sig_E_multi_h,def_E_multi_e,sig_E_multi_e
	!! Parametrized E_multipole_out with mean and standard deviation sigma for DIPBI
	REAL, INTENT(IN)::def_DIPBI_E_multi_h,sig_DIPBI_E_multi_h,def_DIPBI_E_multi_e,sig_DIPBI_E_multi_e
	!! dE_out_pairs collects the outer sphere data for all pairs of hopping sites (N_pairs) in the morphology  dE_out_pairs(N_Pairs,4) 
	!! 1=E_out_AB_h,   2=E_out_BA_h,   3=E_out_AB_e,   4=E_out_BA_e
	REAL, ALLOCATABLE, DIMENSION(:,:) , INTENT(OUT) :: dE_out_pairs
	REAL   :: randomnumber
	INTEGER::i,k
	INTEGER::A32mer,B32mer
	LOGICAL::found_resid1=.false.,found_resid2=.false.,found_A32mer=.false.,found_B32mer=.false.
	LOGICAL::DEBUG=.false.
	REAL::E1_out_h,E1_out_e,E2_out_h,E2_out_e

	E1_out_h=0.0
	E1_out_e=0.0
	E2_out_h=0.0
	E2_out_e=0.0

	WRITE(*,*) 'Prepare E_out data for N_pairs: ',N_pairs
	WRITE(*,*) 'E_out_randomized_distribution  dE_out_h/e:   average +/- sigma : ',E_out_randomized_distribution
	!! dE_out_pairs collects the outer sphere data for all pairs of hopping sites (N_pairs) in the morphology  dE_out_pairs(N_Pairs,4) 
	!! 1=E_out_AB_h, 2=E_out_BA_h, 3=E_out_AB_e, 4=E_out_BA_e
	ALLOCATE(dE_out_pairs(N_Pairs,4))
	dE_out_pairs=0.0
	found_resid1=.false.
	found_resid2=.false.

	DO i=1,N_Pairs	
		found_resid1=.false.
		found_resid2=.false.
		IF(Use_reference_data_from_P3HT32mer) THEN
		!!! find the corresponding 32mer 	
			found_A32mer=.false.
			found_B32mer=.false.
			IF( .NOT. E_out_randomized_distribution) THEN ! Use file data
				!WRITE(*,*) 'Resids: ',R_u_S(i,1),R_u_S(i,2)
				k_loopA: DO k=1,N_P3HT_segments+N_DIPBI
					IF (ResidX_in_32mer(k,1) == R_u_S(i,1)) THEN
						A32mer=ResidX_in_32mer(k,2)
						found_A32mer=.true.
					ELSE IF (ResidX_in_32mer(k,1) == R_u_S(i,2)) THEN
						B32mer=ResidX_in_32mer(k,2)
						found_B32mer=.true.
					END IF
					IF(found_A32mer .AND. found_B32mer) THEN
						EXIT k_loopA
					END IF
				END DO k_loopA

				!WRITE(*,*) 'A32mer, B32mer: ', A32mer,B32mer
		
				k_E_out_loopB: DO k=1,N_E_out_lines
						IF( A32mer == id_E_out(k) ) THEN 
							E1_out_h=E_out_data(k,1)-E_out_data(k,2)
							E1_out_e=E_out_data(k,3)-E_out_data(k,2)
							found_resid1=.true.
						END IF 
						IF( B32mer == id_E_out(k) ) THEN 
							E2_out_h=E_out_data(k,1)-E_out_data(k,2)
							E2_out_e=E_out_data(k,3)-E_out_data(k,2)
							found_resid2=.true.
						END IF 



						IF( found_resid1 .AND. found_resid2) THEN
							IF(DEBUG) THEN
								WRITE(*,*) 'dE_out FOUND pair: ',E1_out_h,E1_out_e,E2_out_h,E2_out_e
							END IF
							EXIT k_E_out_loopB
						END IF

				END DO k_E_out_loopB			
			END IF ! Not E_out_randomized_distribution
		ELSE !! Every resid is expected to have a valuel for E_out

				k_E_out_loopC: DO k=1,N_E_out_lines
						IF( R_u_S(i,1) == id_E_out(k) ) THEN 
							E1_out_h=E_out_data(k,1)-E_out_data(k,2)
							E1_out_e=E_out_data(k,3)-E_out_data(k,2)
							found_resid1=.true.
						END IF 
						IF( R_u_S(i,2) == id_E_out(k) ) THEN 
							E2_out_h=E_out_data(k,1)-E_out_data(k,2)
							E2_out_e=E_out_data(k,3)-E_out_data(k,2)
							found_resid2=.true.
						END IF 

						IF( found_resid1 .AND. found_resid2) THEN
							IF(DEBUG) THEN
								WRITE(*,*) 'Resids pair: ',R_u_S(i,1),R_u_S(i,2)
								WRITE(*,*) 'dE_out FOUND pair: ',E1_out_h,E1_out_e,E2_out_h,E2_out_e
							END IF
							EXIT k_E_out_loopC
						END IF

				END DO k_E_out_loopC
				!WRITE(*,*) 'Resids pair: ',R_u_S(i,1),R_u_S(i,2),found_resid1,found_resid2
				!WRITE(*,*) 'dE_out FOUND pair: ',E1_out_h,E1_out_e,E2_out_h,E2_out_e
				!STOP 'MY_EXIT_1'
		END IF !! Use_reference_data_from_P3HT32mer

			!! RANDOM E_out for Resid_1 selection with mean and random sigma (DIPBI/P3HT)
			IF( .NOT. found_resid1) THEN 
				! Molecule with Resid 1
				! DIPBI
				IF( (R_u_S(i,3) == 33) ) THEN
					CALL RANDOM_NUMBER(randomnumber)
					E1_out_h=def_DIPBI_E_multi_h+(randomnumber-0.5)*sig_DIPBI_E_multi_h
					CALL RANDOM_NUMBER(randomnumber)
					E1_out_e=def_DIPBI_E_multi_e+(randomnumber-0.5)*sig_DIPBI_E_multi_e
					!WRITE(*,*) 'RAND DIPBI lambda_out: ',randomnumber,lambda_out_h,lambda_out_e
				ELSE ! P3HT
					CALL RANDOM_NUMBER(randomnumber)
					E1_out_h=def_E_multi_h+(randomnumber-0.5)*sig_E_multi_h
					CALL RANDOM_NUMBER(randomnumber)
					E1_out_e=def_E_multi_e+(randomnumber-0.5)*sig_E_multi_e
					!WRITE(*,*) 'RAND P3HT lambda_out: ',randomnumber,lambda_out_h,lambda_out_e
				END IF ! Resid 1
			END IF ! .NOT. found_resid1

			!! RANDOM E_out for Resid_2 selection with mean and random sigma (DIPBI/P3HT)
			IF( .NOT. found_resid2) THEN	
				! Molecule with Resid 2
				! DIPBI
				IF( (R_u_S(i,4) == 33) ) THEN
					CALL RANDOM_NUMBER(randomnumber)
					E2_out_h=def_DIPBI_E_multi_h+(randomnumber-0.5)*sig_DIPBI_E_multi_h
					CALL RANDOM_NUMBER(randomnumber)
					E2_out_e=def_DIPBI_E_multi_e+(randomnumber-0.5)*sig_DIPBI_E_multi_e
					!WRITE(*,*) 'RAND DIPBI lambda_out: ',randomnumber,lambda_out_h,lambda_out_e
				ELSE ! P3HT
					CALL RANDOM_NUMBER(randomnumber)
					E2_out_h=def_E_multi_h+(randomnumber-0.5)*sig_E_multi_h
					CALL RANDOM_NUMBER(randomnumber)
					E2_out_e=def_E_multi_e+(randomnumber-0.5)*sig_E_multi_e
					!WRITE(*,*) 'RAND P3HT lambda_out: ',randomnumber,lambda_out_h,lambda_out_e
				END IF ! Resid 2
			END IF ! .NOT. found_resid2
	       			
                        !!! Assignment for outer sphere data to pair i
			dE_out_pairs(i,1)=E2_out_h-E1_out_h
			dE_out_pairs(i,2)=E1_out_h-E2_out_h
			dE_out_pairs(i,3)=E2_out_e-E1_out_e
			dE_out_pairs(i,4)=E1_out_e-E2_out_e
			
			IF(DEBUG) THEN
				WRITE(*,*) 'dE_out_pairs:',R_u_S(i,1),R_u_S(i,2),&
							   &dE_out_pairs(i,1),dE_out_pairs(i,2),dE_out_pairs(i,3),dE_out_pairs(i,4)
			END IF
	END DO ! N_pairs

END SUBROUTINE dE_out_for_pairs



SUBROUTINE Read_Matrix_from_file(filename,array)
!! Subroutine to Read the 33x33 Matrizes for the dE_in(el,lo) , lambda_in(el_lo)
!! Comments in the file at the beginning with '#' are neglected; caution more lines in the file with '#' may cause some errors while reading
		IMPLICIT NONE
		CHARACTER (500), INTENT(IN) ::filename
		INTEGER,PARAMETER ::p=33,q=33
		REAL, DIMENSION(p,q), INTENT(OUT) ::array
		CHARACTER (500)::dummy
		INTEGER::i,N_lines,N_skip_line,ierror
		LOGICAL:: Datei_vorhanden

		INQUIRE(file=TRIM(filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
		IF( .NOT. Datei_vorhanden) THEN
			  WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(filename)
			  WRITE(*,*) ' ENDE'
			  CALL EXIT (1)
		END IF ! Datei-file vorhanden  

		OPEN(UNIT=20,FILE=TRIM(filename),STATUS='OLD',IOSTAT=ierror)
		WRITE(*,*) 'Reading data from: ',TRIM(filename)
		ierror=0
		N_skip_line=0
		N_lines=0
		DO WHILE ( ierror == 0 ) 
			Read(20,*,IOSTAT=ierror) dummy
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(filename),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
			if ( dummy(1:1) == '#' ) THEN ! Check ob erster Buchstabe ein #-Zeichen ist, um kommentare zu lesen
				N_skip_line=N_skip_line+1
			ELSE
				N_lines=N_lines+1
			END IF
		END DO       
		CLOSE(20)        
		!WRITE(*,*) 'N_lines=',N_lines,'N_skip_line',N_skip_line        

		OPEN(UNIT=20,FILE=TRIM(filename),STATUS='OLD',IOSTAT=ierror)
		IF (N_skip_line > 0 ) THEN
			DO i =1,N_skip_line 
				Read(20,*,IOSTAT=ierror) dummy
			END DO
		END IF

		DO i=1,p
			Read(20,*,IOSTAT=ierror) array(i,1),array(i,2),array(i,3),array(i,4),array(i,5), & 
					&  array(i,6),array(i,7),array(i,8),array(i,9),array(i,10), &
					&  array(i,11),array(i,12),array(i,13),array(i,14),array(i,15), &
					&  array(i,16),array(i,17),array(i,18),array(i,19),array(i,20), &
					&  array(i,21),array(i,22),array(i,23),array(i,24),array(i,25), &
					&  array(i,26),array(i,27),array(i,28),array(i,29),array(i,30), &
					&  array(i,31),array(i,32),array(i,33)
			!WRITE(*,*) array(i,1),array(i,2),array(i,3),array(i,4),array(i,5)
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(filename),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
		END DO

		CLOSE(20)
END SUBROUTINE Read_Matrix_from_file


SUBROUTINE Read_neighbourlist(filename,N_Residues,N_Neighbours,COM_Daten,Res_Daten)
        IMPLICIT NONE
        CHARACTER(500), INTENT(IN) :: filename
        INTEGER, INTENT(IN)::N_Residues,N_Neighbours
        REAL, DIMENSION(N_Residues,N_Neighbours+1), INTENT(OUT)::COM_Daten
        INTEGER, DIMENSION(N_Residues,N_Neighbours+1), INTENT(OUT)::Res_Daten
        INTEGER::i,NR,dummy,ierror
        LOGICAL :: Datei_vorhanden
        !residue_offset=33 !DIPBI Residue offset um wieder auf die Residuennuemmer zu kommen
        INQUIRE(file=TRIM(filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
        IF( .NOT. Datei_vorhanden) THEN
            WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(filename)
            WRITE(*,*) ' ENDE'
            CALL EXIT (1)
        END IF ! Datei-file vorhanden  

        OPEN(UNIT=11,FILE=TRIM(filename),STATUS='OLD',IOSTAT=ierror)

        !Daten mit dem Residuumsindex Nr_Abstand 1 Abstand1 Nr_Abstand 2 Abstand 2 ...bis ... Nr_Abstand 6 Abstand 6
            ! Einlesen der Daten aus der Datei neighbours.ngh
            NR=1
            DO i=1,N_Residues

READ(11,*,IOSTAT=ierror) COM_Daten(NR,1),dummy,COM_Daten(NR,2),COM_Daten(NR,3),COM_Daten(NR,4),COM_Daten(NR,5),COM_Daten(NR,6),&
            & COM_Daten(NR,7),COM_Daten(NR,8),COM_Daten(NR,9),COM_Daten(NR,10),COM_Daten(NR,11),COM_Daten(NR,12),COM_Daten(NR,13)
!WRITE(*,*) COM_Daten(NR,1),dummy,COM_Daten(NR,2),COM_Daten(NR,3),COM_Daten(NR,4),COM_Daten(NR,5),COM_Daten(NR,6)            
!WRITE(*,*) COM_Daten(NR,7),COM_Daten(NR,8),COM_Daten(NR,9),COM_Daten(NR,10),COM_Daten(NR,11),COM_Daten(NR,12),COM_Daten(NR,13)
            
READ(11,*,IOSTAT=ierror) Res_Daten(NR,1),dummy,Res_Daten(NR,2),Res_Daten(NR,3),Res_Daten(NR,4),Res_Daten(NR,5),Res_Daten(NR,6),&
            & Res_Daten(NR,7),Res_Daten(NR,8),Res_Daten(NR,9),Res_Daten(NR,10),Res_Daten(NR,11),Res_Daten(NR,12),Res_Daten(NR,13)
!WRITE(*,*) 'Resids:',Res_Daten(NR,1),dummy,Res_Daten(NR,2),Res_Daten(NR,3),Res_Daten(NR,4),Res_Daten(NR,5),Res_Daten(NR,6),&
!            & Res_Daten(NR,7),Res_Daten(NR,8),Res_Daten(NR,9),Res_Daten(NR,10),Res_Daten(NR,11),Res_Daten(NR,12),Res_Daten(NR,13)	
                NR=NR+1
                IF(ierror < 0) EXIT
                IF(ierror > 0) THEN
			NR=NR-1
WRITE(*,*) 'COM:',COM_Daten(NR,1),dummy,COM_Daten(NR,2),COM_Daten(NR,3),COM_Daten(NR,4),COM_Daten(NR,5),COM_Daten(NR,6)            
WRITE(*,*) COM_Daten(NR,7),COM_Daten(NR,8),COM_Daten(NR,9),COM_Daten(NR,10),COM_Daten(NR,11),COM_Daten(NR,12),COM_Daten(NR,13)

WRITE(*,*) 'Resids:',Res_Daten(NR,1),dummy,Res_Daten(NR,2),Res_Daten(NR,3),Res_Daten(NR,4),Res_Daten(NR,5),Res_Daten(NR,6),&
            & Res_Daten(NR,7),Res_Daten(NR,8),Res_Daten(NR,9),Res_Daten(NR,10),Res_Daten(NR,11),Res_Daten(NR,12),Res_Daten(NR,13)			
                    WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(filename),' aufgetreten.'
		    WRITE(*,*) 'Anzahl der nachbarn nicht 12 ? '
                    WRITE(*,*) 'Beende Einlesen !'
                    CALL EXIT (1)
                END IF
            END DO
            CLOSE(11)
            !NR=1
            !WRITE(*,*) COM_Daten(NR,1),COM_Daten(NR,2),COM_Daten(NR,3),COM_Daten(NR,4),COM_Daten(NR,5),COM_Daten(NR,6)&
            !&,COM_Daten(NR,7),COM_Daten(NR,8),COM_Daten(NR,9),COM_Daten(NR,10),COM_Daten(NR,11),COM_Daten(NR,12),COM_Daten(NR,13)
            !WRITE(*,*) Res_Daten(NR,1),Res_Daten(NR,2),Res_Daten(NR,3),Res_Daten(NR,4),Res_Daten(NR,5),Res_Daten(NR,6)&
            !&,Res_Daten(NR,7),Res_Daten(NR,8),Res_Daten(NR,9),Res_Daten(NR,10),Res_Daten(NR,11),Res_Daten(NR,12),Res_Daten(NR,13)
            !
            !NR=N_Residues
            !WRITE(*,*) COM_Daten(NR,1),COM_Daten(NR,2),COM_Daten(NR,3),COM_Daten(NR,4),COM_Daten(NR,5),COM_Daten(NR,6)&
            !&,COM_Daten(NR,7),COM_Daten(NR,8),COM_Daten(NR,9),COM_Daten(NR,10),COM_Daten(NR,11),COM_Daten(NR,12),COM_Daten(NR,13)
            !WRITE(*,*) Res_Daten(NR,1),Res_Daten(NR,2),Res_Daten(NR,3),Res_Daten(NR,4),Res_Daten(NR,5),Res_Daten(NR,6)&
            !&,Res_Daten(NR,7),Res_Daten(NR,8),Res_Daten(NR,9),Res_Daten(NR,10),Res_Daten(NR,11),Res_Daten(NR,12),Res_Daten(NR,13)

END SUBROUTINE Read_neighbourlist




!! Skalierungsfunktionen Lochtransfer CDFT / HOMO A to HOMO B fuer zwei ausgewaehlte methoden y_scale_method, x_scale_method !!!!!!!!!!!!!!!!!!
REAL FUNCTION scale_dipro_function_hole(y_scale_method,x_scale_method,matrix_element_homo_homo,linear_scaling_J_AB)
	use small_functions
	IMPLICIT NONE
	CHARACTER(LEN=*) , INTENT(IN)   :: y_scale_method,x_scale_method
	REAL, INTENT(IN)  				:: matrix_element_homo_homo
	REAL              				:: scaled_matrix_element_homo_homo
	LOGICAL:: DEBUG=.false.,linear_scaling_J_AB

	
	scaled_matrix_element_homo_homo=0.0
	IF ( DEBUG )THEN
		WRITE(*,*) 'Start J_AB vor Skalierung ',matrix_element_homo_homo
	END IF
	
	IF (linear_scaling_J_AB) THEN	
		IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ( TRIM(adjustl(x_scale_method))=='PBE/6-311G**' ))THEN
			!!! CDFT PBE PW	DIPRO PBE/6-311G**	-0.032005  & 2.8865 
			scaled_matrix_element_homo_homo=2.8865*matrix_element_homo_homo !!! -0.032005 
		ELSE IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ( TRIM(adjustl(x_scale_method))=='PM3'))THEN
			!!!CDFT PBE PW	PM3	-0.055738    &  6.8864 
			scaled_matrix_element_homo_homo=6.8864*matrix_element_homo_homo !!! -0.055738 
		ELSE IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ( TRIM(adjustl(x_scale_method))=='ZINDO'))THEN			
			!!! CDFT/PBE/PW  & ZINDO             & 0.0534 & 1.474 \\
			scaled_matrix_element_homo_homo=1.474*matrix_element_homo_homo !!! + 0.0534 		
		ELSE IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ((TRIM(adjustl(x_scale_method))=='DFTB') &
			&.OR. (TRIM(adjustl(x_scale_method))=='DFTB/MIO')) )THEN
			!!!CDFT PBE PW	DFTB	0.04455        &  3.9099
			scaled_matrix_element_homo_homo=3.9099*matrix_element_homo_homo !!!0.04455  
		ELSE IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ( TRIM(adjustl(x_scale_method))=='DFTB/3OB'))THEN			
			!!! CDFT/PBE/PW & DFTB/3OB-3-1    &  0.0468   & 3.483  \\
			scaled_matrix_element_homo_homo=3.483*matrix_element_homo_homo !!!0.0468
		ELSE IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ( TRIM(adjustl(x_scale_method))=='B3LYP/6-311G**'))THEN
			!!!P3MT	CDFT/PBE PW	B3LYP/ 6-311G**	-0.0098711 & 2.5686
			scaled_matrix_element_homo_homo=2.5686*matrix_element_homo_homo !!!-0.0098711 
		ELSE IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ( TRIM(adjustl(x_scale_method))=='B3LYP/6-31G*'))THEN
			!!!P3MT	CDFT/PBE PW	B3LYP/ 6-31G*	-0.003552   & 2.389 
			scaled_matrix_element_homo_homo=2.389*matrix_element_homo_homo !  !!-0.003552
		ELSE IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ( TRIM(adjustl(x_scale_method))=='B3LYP/3-21G*'))THEN
			!!!P3MT	CDFT/PBE PW	B3LYP/ 3-21G*	-0.003552   & 2.382 
			scaled_matrix_element_homo_homo=2.382*matrix_element_homo_homo !!!-0.003552 
		ELSE IF((TRIM(adjustl(y_scale_method))=='PBE/6-311G**' ) .AND. ( TRIM(adjustl(x_scale_method))=='PM3'))THEN
			!!! P3MT PBE/6-311G**  PM3 2.379*matrix_element_homo_homo!!!+0.02282
			scaled_matrix_element_homo_homo=2.379*matrix_element_homo_homo !!!+0.02282
		ELSE IF((TRIM(adjustl(y_scale_method))=='PBE/6-311G**' ) .AND. ( TRIM(adjustl(x_scale_method))=='DFTB'))THEN
		    !!! 0.01856 & 1.3661
			scaled_matrix_element_homo_homo=1.3661*matrix_element_homo_homo !!!+0.018968
		ELSE IF((TRIM(adjustl(y_scale_method))=='B3LYP/3-21G' ) .AND. ( TRIM(adjustl(x_scale_method))=='PM3'))THEN
			scaled_matrix_element_homo_homo=0.4925*matrix_element_homo_homo !!!-0.044356		
		ELSE IF((TRIM(adjustl(y_scale_method))=='PM3' ) .AND. ( TRIM(adjustl(x_scale_method))=='DFTB'))THEN				
			scaled_matrix_element_homo_homo=0.57802 *matrix_element_homo_homo !!!-0.0011412 
		ELSE	! Wenn nicht die passenden ausgewaehlt wurden, dann gibt es keine Skalierung!
			scaled_matrix_element_homo_homo=matrix_element_homo_homo  
		END IF
			
	ELSE	! Wenn nicht die passenden ausgewaehlt wurden, dann gibt es keine Skalierung!
		scaled_matrix_element_homo_homo=matrix_element_homo_homo  
	END IF 


	IF(DEBUG)THEN
		WRITE(*,*) 'Skaliertes J_AB am Ende ',scaled_matrix_element_homo_homo
	END IF
	scale_dipro_function_hole=scaled_matrix_element_homo_homo

END FUNCTION scale_dipro_function_hole
!!! Ende Skalierungsfunktionen fuer zwei ausgewaehlte methoden y_scale_method, x_scale_method !!!!!!#

!! Skalierungsfunktionen Eletronentransfer CDFT / DIPRO LUMO A to LUMO B fuer zwei ausgewaehlte methoden y_scale_method, x_scale_method !!!!!!!!!!!!!!!!!!
REAL FUNCTION scale_dipro_function_electron(y_scale_method,x_scale_method,matrix_element_lumo_lumo,linear_scaling_J_AB)
	IMPLICIT NONE
	CHARACTER(LEN=*) , INTENT(IN)   :: y_scale_method,x_scale_method
	REAL, INTENT(IN)  				:: matrix_element_lumo_lumo
	REAL              				:: scaled_matrix_element_lumo_lumo
	LOGICAL:: DEBUG=.false.,linear_scaling_J_AB

	
	scaled_matrix_element_lumo_lumo=0.0
	IF ( DEBUG )THEN
		WRITE(*,*) 'Start J_AB_e vor Skalierung: ',matrix_element_lumo_lumo
	END IF
	
	IF (linear_scaling_J_AB) THEN	
		IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ( TRIM(adjustl(x_scale_method))=='PBE/6-311G**' ))THEN
			!!! CDFT PBE PW	DIPRO PBE/6-311G**	0.032421    & 2.2507           
			scaled_matrix_element_lumo_lumo=2.2507*matrix_element_lumo_lumo !!! +0.032421
		ELSE IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ( TRIM(adjustl(x_scale_method))=='PM3'))THEN
			!!!CDFT PBE PW	PM3	0.1271    	  &  5.43874  
			scaled_matrix_element_lumo_lumo=5.43874*matrix_element_lumo_lumo !!! +0.1271 
		ELSE IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ( TRIM(adjustl(x_scale_method))=='ZINDO'))THEN			
			!!!!CDFT/PBE/PW & ZINDO 				& 0.0968          & 1.589                     &  0.961 \\
			scaled_matrix_element_lumo_lumo=1.589*matrix_element_lumo_lumo   !!!  + 0.0968
		ELSE IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ( (TRIM(adjustl(x_scale_method))=='DFTB/MIO') & 
			&.OR. (TRIM(adjustl(x_scale_method))=='DFTB') ) )THEN
			!!!CDFT PBE PW	DFTB	 0.0813      	  & 3.104	
			scaled_matrix_element_lumo_lumo=3.104*matrix_element_lumo_lumo !!!+ 0.0813 
		ELSE IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ( TRIM(adjustl(x_scale_method))=='DFTB/3OB'))THEN			
			!!! CDFT/PBE/PW & DFTB/3OB-3-1   & 0.0796         &  3.502                      &  0.986 \\
			scaled_matrix_element_lumo_lumo=3.502*matrix_element_lumo_lumo  !!! + 0.0796
		ELSE IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ( TRIM(adjustl(x_scale_method))=='B3LYP/6-311G**'))THEN
			!!!P3MT	CDFT/PBE PW	B3LYP/ 6-311G**	0.05067       & 		1.839	
			scaled_matrix_element_lumo_lumo=1.8393*matrix_element_lumo_lumo !!! +0.05067 
		ELSE IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ( TRIM(adjustl(x_scale_method))=='B3LYP/6-31G*'))THEN
			!!!P3MT	CDFT/PBE PW	B3LYP/ 6-31G*	 0.07676       &         1.717
			scaled_matrix_element_lumo_lumo=1.717*matrix_element_lumo_lumo !  !! +0.07676 
		ELSE IF((TRIM(adjustl(y_scale_method))=='CDFT' ) .AND. ( TRIM(adjustl(x_scale_method))=='B3LYP/3-21G*'))THEN
			!!!P3MT	CDFT/PBE PW	B3LYP/ 3-21G*	 0.0807         & 1.785   
			scaled_matrix_element_lumo_lumo=1.785*matrix_element_lumo_lumo !!! 0.0807 
		ELSE IF((TRIM(adjustl(y_scale_method))=='PBE/6-311G**' ) .AND. ( TRIM(adjustl(x_scale_method))=='PM3'))THEN
			!!! P3MT PBE/6-311G**  PM3 0.04024 		& 2.429    *matrix_element_lumo_lumo!!!
			scaled_matrix_element_lumo_lumo=2.4293*matrix_element_lumo_lumo !!!+ 0.04024 	
		ELSE IF((TRIM(adjustl(y_scale_method))=='PBE/6-311G**' ) .AND. ( TRIM(adjustl(x_scale_method))=='DFTB'))THEN
		    !!!  0.02461       	& 1.354 	
			scaled_matrix_element_lumo_lumo=1.354*matrix_element_lumo_lumo !!!+0.02461 
		ELSE IF((TRIM(adjustl(y_scale_method))=='B3LYP/3-21G' ) .AND. ( TRIM(adjustl(x_scale_method))=='PM3'))THEN
			scaled_matrix_element_lumo_lumo=2.975*matrix_element_lumo_lumo !!! +0.02887        !!!& 2.975   	
		ELSE IF((TRIM(adjustl(y_scale_method))=='PM3' ) .AND. ( TRIM(adjustl(x_scale_method))=='DFTB'))THEN				
			scaled_matrix_element_lumo_lumo=0.5394 *matrix_element_lumo_lumo !!!-0.00429		!!!& 0.05394  
		ELSE	! Wenn nicht die passenden ausgewaehlt wurden, dann gibt es keine Skalierung!
			scaled_matrix_element_lumo_lumo=matrix_element_lumo_lumo  
		END IF
			
	ELSE	! Wenn nicht die passenden ausgewaehlt wurden, dann gibt es keine Skalierung!
		scaled_matrix_element_lumo_lumo=matrix_element_lumo_lumo  
	END IF 


	IF(DEBUG)THEN
		WRITE(*,*) 'Skaliertes J_AB_e am Ende ',scaled_matrix_element_lumo_lumo
	END IF
	scale_dipro_function_electron=scaled_matrix_element_lumo_lumo

END FUNCTION scale_dipro_function_electron
!!! Ende Skalierungsfunktionen fuer zwei ausgewaehlte methoden y_scale_method, x_scale_method !!!!!!#






!!########################################################################################################################################!
!!### Start dipro_electron_matrix_fit ####################################################################################################!
!!### Transition matrix element |J_AB| LUMO A to LUMO B calculated via geometry coordinates and fit functions (COM_H,MA,MMA,Lin_Comb) ####!
!!### Uses fit parameters from relative Dimer  configuration (like COM, COM_H, MA, MMA, theta)  to determine J_AB
REAL FUNCTION dipro_electron_matrix_fit(mol_type_1,mol_type_2,COM, COM_H, MA, MMA, theta,J_AB_fit_method_geometry)
	IMPLICIT NONE
	REAL::  matrix_element_lumo_lumo
	REAL:: COM, COM_H, MA, MMA, theta
	CHARACTER(LEN=*)::	mol_type_1,mol_type_2,J_AB_fit_method_geometry
	LOGICAL::grep_error,DEBUG=.false.
	!!COM, COM_H, MA, MMA, theta, grep_error = get_coord_data_for_pair(resid1,resid2,frame_number)	
	!!WRITE(*,*) COM, COM_H, MA, MMA, theta, '### Geometriedaten')
	

	IF(DEBUG) WRITE(*,*) TRIM(mol_type_1),TRIM(mol_type_2),COM, COM_H, MA, MMA, theta,TRIM(J_AB_fit_method_geometry)
	
	
	grep_error=.false.	
	!!!! Adapt names, as fits are not available for most molecules
	!mol_type_1='DIPBI'  !!mol_type_1 = groList[(resid1)][0][1]
	!mol_type_2='DIPBI'  !!mol_type_2 = groList[(resid2)][0][1]

	IF( (INDEX(mol_type_1,'P3') /= 0) .OR. (INDEX(mol_type_1,'THP') /= 0) .OR. (INDEX(mol_type_1,'S') /= 0 )  )THEN 
		mol_type_1='THP'
	END IF
	
	IF( (INDEX(mol_type_2,'P3')/= 0) .OR. (INDEX(mol_type_2,'THP') /= 0) .OR. (INDEX(mol_type_2,'S') /= 0 )  ) THEN 
		mol_type_2='THP'
	END IF
	

	IF (grep_error) THEN
		matrix_element_lumo_lumo = 0.00000000000000001
	ELSE
		!!!# Fits fuer P3MT / P3MT
		IF ((TRIM(adjustl(mol_type_1)) == 'THP') .AND. (TRIM(adjustl(mol_type_2)) == 'THP'))THEN 
		!!!# Fits fuer LUMO_A to LUMO_B 85grad fur P3HT-Ketten PM3
			IF(('MA' == TRIM(adjustl(J_AB_fit_method_geometry))) .OR. ('Lin_Combi' == TRIM(adjustl(J_AB_fit_method_geometry))))THEN
				!!! x=MA  ;   y= -2.236-0.66354*x  | y= log10(|abs(J_AB)) [eV], R=0.63
				matrix_element_lumo_lumo=10**(-2.236-0.66354*MA)
				WRITE(*,*)' MA    PM3 fit:',matrix_element_lumo_lumo
			ELSE IF('MMA' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN 
				!!! x=MMA ;   y= -2.9808-0.11197*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_lumo_lumo=10**(-2.9808-0.11197*MMA)
				WRITE(*,*)' MMA   PM3 fit:',matrix_element_lumo_lumo
			ELSE IF('COM_H' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN
				!!! x=COM_H ; y= -2.3523-0.14167*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_lumo_lumo=10**(-2.3523-0.14167*COM_H)
				WRITE(*,*)' COM_H PM3 fit:',matrix_element_lumo_lumo
			ELSE
				WRITE(*,*) 'Fehler: Method for '//TRIM(adjustl(J_AB_fit_method_geometry))//' is not available'
				matrix_element_lumo_lumo = 0.00000000000000001
			END IF
		!!!# Fits fuer P3MT / DIPBI
		ELSE IF( ((TRIM(adjustl(mol_type_1)) == 'THP') .AND. (TRIM(adjustl(mol_type_2)) == 'DIPBI')) .OR. &
			 & ((TRIM(adjustl(mol_type_1)) == 'DIPBI') .AND. (TRIM(adjustl(mol_type_2)) == 'THP')))THEN 
		!!!# Fits fuer LUMO_A to LUMO_B  P3MT/DIPBI PM3
			IF(('MA' == TRIM(adjustl(J_AB_fit_method_geometry))) .OR. ('Lin_Combi' == TRIM(adjustl(J_AB_fit_method_geometry)) ))THEN
				!!! x=MA  ;   y= -2.7577-0.82274*x  | y= log10(|abs(J_AB)) [eV], R=0.55
				matrix_element_lumo_lumo=10**(-2.7577-0.82274*MA)	
				WRITE(*,*)' MA    PM3 fit:',matrix_element_lumo_lumo
			ELSE IF('MMA' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN		
				!!! x=MMA ;   y= -2.1555-0.38188*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_lumo_lumo=10**(-2.1555-0.38188*MMA)
				WRITE(*,*)' MMA   PM3 fit:',matrix_element_lumo_lumo
			ELSE IF('COM_H' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN
				!!! x=COM_H ; y= -3.9572-0.057061*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_lumo_lumo=10**(-3.9572-0.057061*COM_H)
				WRITE(*,*)' COM_H PM3 fit:',matrix_element_lumo_lumo
			ELSE
				WRITE(*,*) 'Fehler: Method for '//TRIM(adjustl(J_AB_fit_method_geometry))//' is not available, Return 0'
				matrix_element_lumo_lumo=0.00000000000000001
			END IF
		ELSE IF((TRIM(adjustl(mol_type_1)) == 'DIPBI') .AND. (TRIM(adjustl(mol_type_2)) == 'DIPBI')) THEN 
		!!!# Fits fuer LUMO_A to LUMO_B fur 3752 Paare DIPBI/DIPBI PM3
			IF(('MA' == TRIM(adjustl(J_AB_fit_method_geometry))) .OR. ('Lin_Combi' == TRIM(adjustl(J_AB_fit_method_geometry))))THEN
				!!! x=MA  ;   y= -0.57837-1.0094*x  | y= log10(|abs(J_AB)) [eV], R=0.964 (relativ guter Fit)
				matrix_element_lumo_lumo=10**(-0.57837-1.0094*MA)
				WRITE(*,*)' MA    PM3 fit:',matrix_element_lumo_lumo
			ELSE IF('MMA' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN 
				!!! x=MMA ;   y= +0.67757-0.71548*x  | y= log10(|abs(J_AB)) [eV], R=0,836
				matrix_element_lumo_lumo=10**(0.67757-0.71548*MMA)
				WRITE(*,*)' MMA   PM3 fit:',matrix_element_lumo_lumo
			ELSE IF('COM_H' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN
				!!! x=COM_H ; y= 0.074096-0.47174*x  | y= log10(|abs(J_AB)) [eV], R=0,695
				matrix_element_lumo_lumo=10**(0.074096-0.47174*COM_H)
				WRITE(*,*)' COM_H PM3 fit:',matrix_element_lumo_lumo
			ELSE
				WRITE(*,*) 'Fehler: Method for '//TRIM(adjustl(J_AB_fit_method_geometry))//' is not available, Return 0'
				matrix_element_lumo_lumo=0.00000000000000001
			END IF 
		ELSE
			WRITE(*,*) 'Fehler: Selected Molecules not available, Return 0'
			matrix_element_lumo_lumo = 0.00000000000000001
		END IF
	END IF
	
	IF (debug) THEN
		WRITE(*,*) ' |J_AB| LUMO A to LUMO B Fit '//TRIM(adjustl(J_AB_fit_method_geometry))//': ', matrix_element_lumo_lumo,&
					& 'for geometry data:',COM, COM_H, MA, MMA, theta 
	END IF
	dipro_electron_matrix_fit = matrix_element_lumo_lumo
END FUNCTION dipro_electron_matrix_fit
!!### Ende function dipro_electron_matrix_fit #########




!!!#### Start function dipro_hole_matrix_fit ############
!!## Transition matrix element |J_AB| HOMO A to HOMO B calculated via geometry coordinates and fit functions (COM_H,MA,MMA,Lin_Comb) ####
!! Uses fit parameters from relative Dimer  configuration (like COM, COM_H, MA, MMA, theta)  to determine J_AB
REAL FUNCTION dipro_hole_matrix_fit(mol_type_1,mol_type_2,COM, COM_H, MA, MMA, theta,J_AB_fit_method_geometry)
	IMPLICIT NONE
	REAL			::  matrix_element_homo_homo
	REAL   			::  COM, COM_H, MA, MMA, theta
	LOGICAL			::  DEBUG,grep_error
	CHARACTER(LEN=*)::	mol_type_1,mol_type_2,J_AB_fit_method_geometry
	!!COM, COM_H, MA, MMA, theta, grep_error = get_coord_data_for_pair(resid1,resid2,frame_number)	
	!WRITE(*,*) COM, COM_H, MA, MMA, theta, '!!!# Geometriedaten'


	!mol_type_1=mol_type_1_local
	!mol_type_2=mol_type_2_local
	DEBUG=.false.
	IF(DEBUG) WRITE(*,*) TRIM(mol_type_1),TRIM(mol_type_2),COM, COM_H, MA, MMA, theta,TRIM(J_AB_fit_method_geometry)

	grep_error=.false.
	!!!# Adapt names, as fits are not available for most molecules
	!mol_type_1='DIPBI'  !!!mol_type_1 = groList[(resid1)][0][1]
	!mol_type_2='DIPBI'  !!!mol_type_2 = groList[(resid2)][0][1]

	IF( (INDEX(mol_type_1,'P3') /= 0) .OR. (INDEX(mol_type_1,'THP') /= 0) .OR. (INDEX(mol_type_1,'S') /= 0 )  )THEN 
		mol_type_1='THP'
	END IF
	
	IF( (INDEX(mol_type_2,'P3')/= 0) .OR. (INDEX(mol_type_2,'THP') /= 0) .OR. (INDEX(mol_type_2,'S') /= 0 )  ) THEN 
		mol_type_2='THP'
	END IF

	
	IF (grep_error) THEN
		matrix_element_homo_homo = 0.00000000000000001
	ELSE
		!!!# Fits fuer P3MT / P3MT
		IF ((TRIM(adjustl(mol_type_1)) == 'THP') .AND. (TRIM(adjustl(mol_type_2)) == 'THP'))THEN 
		!!!# Fits fuer HOMO_A to HOMO_B 80grad fur 4535 Paare P3MT PM3
			IF('MA' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN
				!!! x=MA  ;   y= -2.613-0.649*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_homo_homo=10**(-2.613-0.649*MA)
				WRITE(*,*)' MA    PM3 fit:',matrix_element_homo_homo
			ELSE IF('MMA' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN 
				!!! x=MMA ;   y= -3.313-0.112*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_homo_homo=10**(-3.313-0.112*MMA)
				WRITE(*,*)' MMA   PM3 fit:',matrix_element_homo_homo
			ELSE IF('COM_H' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN
				!!! x=COM_H ; y= -2.649-0.145*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_homo_homo=10**(-2.649-0.145*COM_H)
				WRITE(*,*)' COM_H PM3 fit:',matrix_element_homo_homo
			ELSE IF('Lin_Combi' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN
				!!! mixed funciton y= log10(|abs(J_AB)) [eV] = A*MA +B*MMA+ C*COM_H +D 
				!!! A=-0.1083 ; B=-0.57546 ; C=7.64E-4 ; D=-1.50303
				matrix_element_homo_homo= 10**( -0.1083*MA-0.57546*MMA+7.6358E-4*COM_H-1.50303)
				WRITE(*,*)' Mixed PM3 fit:',matrix_element_homo_homo
	
			ELSE
				WRITE(*,*) 'Fehler: Method for J_AB_fit_method_geometry is not available, Return 0'
				matrix_element_homo_homo= 0.00000000000000001
			END IF
		!!!# Fits fuer P3MT / DIPBI
		ELSE IF( ((TRIM(adjustl(mol_type_1)) == 'THP') .AND. (TRIM(adjustl(mol_type_2)) == 'DIPBI')) .OR. &
			 & ((TRIM(adjustl(mol_type_1)) == 'DIPBI') .AND. (TRIM(adjustl(mol_type_2)) == 'THP'))) THEN 
		!!!# Fits fuer HOMO_A to HOMO_B  80grad fur 1693 Paare P3MT/DIPBI PM3
			IF('MA' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN
				!!! x=MA  ;   y= -2.941-0.847*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_homo_homo=10**(-2.9408-0.84717*MA)	
				WRITE(*,*)' MA    PM3 fit:',matrix_element_homo_homo
			ELSE IF('MMA' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN		
				!!! x=MMA ;   y= 2.3766-0.38643*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_homo_homo=10**(-2.3766-0.38643*MMA)
				WRITE(*,*)' MMA   PM3 fit:',matrix_element_homo_homo
			ELSE IF('COM_H' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN
				!!! x=COM_H ; y= -4.298-0.053974*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_homo_homo=10**(-4.298-0.053974*COM_H)
				WRITE(*,*)' COM_H PM3 fit:',matrix_element_homo_homo
			ELSE IF('Lin_Combi' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN
				!!! mixed funciton y= log10(|abs(J_AB)) [eV] = A*MA +B*MMA+ C*COM_H +D 
				!!! A=-0.43222 ; B=-0.16758 ; C=-0.0387 ; D=-2.2229
				matrix_element_homo_homo= 10**( -0.43222*MA-0.16758*MMA-0.0387*COM_H-2.2229)
				WRITE(*,*)' Mixed PM3 fit:',matrix_element_homo_homo
			ELSE
				WRITE(*,*) 'Fehler: Method for J_AB_fit_method_geometry is not available, Return 0'
				matrix_element_homo_homo= 0.00000000000000001
			END IF
		ELSE IF((TRIM(adjustl(mol_type_1)) == 'DIPBI') .AND. (TRIM(adjustl(mol_type_2)) == 'DIPBI'))THEN 
		!!!# Fits fuer HOMO_A to HOMO_B fur 3752 Paare DIPBI/DIPBI PM3
			IF(('MA' == TRIM(adjustl(J_AB_fit_method_geometry))) .OR. ('Lin_Combi' == TRIM(adjustl(J_AB_fit_method_geometry))))THEN
				!!! x=MA  ;   y= -0.43546-1.0429*x  | y= log10(|abs(J_AB)) [eV], R=0.968 (relativ guter Fit)
				matrix_element_homo_homo=10**(-0.43546-1.0429*MA)
				WRITE(*,*)' MA    PM3 fit:',matrix_element_homo_homo
			ELSE IF('MMA' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN
				!!! x=MMA ;   y= +0.748-0.7548*x  | y= log10(|abs(J_AB)) [eV], R=0,824
				matrix_element_homo_homo=10**(0.748-0.7548*MMA)
				WRITE(*,*)' MMA   PM3 fit:',matrix_element_homo_homo
			ELSE IF('COM_H' == TRIM(adjustl(J_AB_fit_method_geometry)))THEN
				!!! x=COM_H ; y= 0.086734-0.7392*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_homo_homo=10**(0.086734-0.7392*COM_H)
				WRITE(*,*)' COM_H PM3 fit:',matrix_element_homo_homo
			ELSE
				WRITE(*,*) 'Fehler: Method for J_AB_fit_method_geometry is not available, Return 0'
				matrix_element_homo_homo= 0.00000000000000001
			END IF
		ELSE	
			WRITE(*,*) 'Fehler: Selected Molecules not available, Return 0'
			matrix_element_homo_homo= 0.00000000000000001
		END IF
	END IF	
		
	IF (debug) THEN
		WRITE(*,*) ' |J_AB| HOMO A to HOMO B Fit '//TRIM(adjustl(J_AB_fit_method_geometry))//': ',&
				& matrix_element_homo_homo,' for geometry data: ',COM, COM_H, MA, MMA, theta 	
	END IF
	
	dipro_hole_matrix_fit=matrix_element_homo_homo
END FUNCTION dipro_hole_matrix_fit
!!!##### Ende function dipro_electron_matrix_fit ###############################################################################
!!!#############################################################################################################################



!!!#############################################################################################################################
!! Get J_AB for a pair of Resids1 and Resid2 as a fit, checks if the pair is in seg1_seg2_Geo_Data_pairs
!! and calculates J_AB via  SUBROUTINE dipro_hole_matrix_fit  and SUBROUTINE dipro_electron_matrix_fit
!! mol_type_1 and mol_type_2 need to be specified
!! Reads data form J_AB_filename and returns matrix_element_homo_homo,matrix_element_lumo_lumo
!! The geometric data for can be read from the J_AB file: N_Geo_Data_lines,seg1_seg2_Geo_Data_pairs,Geo_Data_pairs,Geo_Data_da
SUBROUTINE get_JAB_from_Geo_Data_for_pair(Resid1,mol_type_1,Resid2,mol_type_2,J_AB_fit_method_geometry,J_AB_filename,&
							&matrix_element_homo_homo, matrix_element_lumo_lumo,&
							&N_Geo_Data_lines,seg1_seg2_Geo_Data_pairs,Geo_Data_pairs,Geo_Data_da) !! DATA from Read_COM_COM_H_MA_MMA_theta_from_J_AB_from_file
	IMPLICIT NONE
	INTEGER, INTENT(IN) :: Resid1,Resid2
	REAL, INTENT(OUT)               ::  matrix_element_homo_homo, matrix_element_lumo_lumo
	CHARACTER(LEN=*)                                 ::	mol_type_1,mol_type_2,J_AB_fit_method_geometry
	CHARACTER(LEN=500), INTENT(IN)                   :: J_AB_filename
	REAL,    ALLOCATABLE, DIMENSION(:,:)     	     :: Geo_Data_pairs
	INTEGER, ALLOCATABLE, DIMENSION(:,:)		     :: seg1_seg2_Geo_Data_pairs
	LOGICAL, ALLOCATABLE, DIMENSION(:)		         :: Geo_Data_da
	INTEGER :: N_Geo_Data_lines
	INTEGER::i
	LOGICAL:: DEBUG=.false.
	
	
	matrix_element_homo_homo=0.0E0
	matrix_element_lumo_lumo=0.0E0
	
	IF(DEBUG) WRITE(*,*) 'get_JAB_from_Geo_Data'
	
	IF( .NOT. allocated(Geo_Data_pairs) ) THEN
		WRITE(*,*) 'Using: Read_COM_COM_H_MA_MMA_theta_from_J_AB_file:'
		CALL Read_COM_COM_H_MA_MMA_theta_from_J_AB_file&
			&(N_Geo_Data_lines,seg1_seg2_Geo_Data_pairs,Geo_Data_pairs,Geo_Data_da,J_AB_filename)
	END IF
	
	DO i=1,N_Geo_Data_lines
		IF(Geo_Data_da(i)) THEN
			IF( ((Resid1 == seg1_seg2_Geo_Data_pairs(i,1)) .AND. (Resid2 == seg1_seg2_Geo_Data_pairs(i,2)) ) .OR. &
			&	((Resid2 == seg1_seg2_Geo_Data_pairs(i,1)) .AND. (Resid1 == seg1_seg2_Geo_Data_pairs(i,2))	)) THEN
				IF(DEBUG) THEN
					WRITE(*,*) 'Pair found:',TRIM(mol_type_1),TRIM(mol_type_2),Geo_Data_pairs(i,1),&
					& Geo_Data_pairs(i,2),Geo_Data_pairs(i,3),Geo_Data_pairs(i,4),Geo_Data_pairs(i,5),TRIM(J_AB_fit_method_geometry)
				END IF
				!!!                      dipro_hole_matrix_fit(mol_type_1,mol_type_2,COM, COM_H, MA, MMA, theta,J_AB_fit_method_geometry)
				matrix_element_homo_homo=dipro_hole_matrix_fit(mol_type_1,mol_type_2,Geo_Data_pairs(i,1),&
				& Geo_Data_pairs(i,2),Geo_Data_pairs(i,3),Geo_Data_pairs(i,4),Geo_Data_pairs(i,5),J_AB_fit_method_geometry)	
				IF(DEBUG) WRITE(*,*) 'matrix_element_homo_homo:',matrix_element_homo_homo
				!!!                      dipro_hole_matrix_electron(mol_type_1,mol_type_2,COM, COM_H, MA, MMA, theta,J_AB_fit_method_geometry)			
				matrix_element_lumo_lumo=dipro_electron_matrix_fit(mol_type_1,mol_type_2,Geo_Data_pairs(i,1),&
				& Geo_Data_pairs(i,2),Geo_Data_pairs(i,3),Geo_Data_pairs(i,4),Geo_Data_pairs(i,5),J_AB_fit_method_geometry)
				IF(DEBUG)  WRITE(*,*) 'matrix_element_lumo_lumo:',matrix_element_lumo_lumo
				RETURN 
			END IF ! Resids available?
		END IF ! Geo_Data_da
	END DO 
	
END SUBROUTINE get_JAB_from_Geo_Data_for_pair



!! Get J_AB for a pair of Resids1 and Resid2 in neighbour_list_Res as a fit, checks if the pair is in seg1_seg2_Geo_Data_pairs
!! and calculates J_AB via  SUBROUTINE dipro_hole_matrix_fit  and SUBROUTINE dipro_electron_matrix_fit
!! mol_type_1 and mol_type_2 need to be specified in residue_names_pair
!! Reads data form J_AB_filename and returns matrix_element_homo_homo,matrix_element_lumo_lumo
!! The geometric data for can be read from the J_AB file: N_Geo_Data_lines,seg1_seg2_Geo_Data_pairs,Geo_Data_pairs,Geo_Data_da
SUBROUTINE get_JAB_from_Geo_Data_for_neighbourlist(J_AB_filename,N_Resids,N_Neighbours,neighbour_list_Res,J_AB_Daten,J_AB_da,&
							&residue_names_pair,dist_COM_inter,& 
							&J_AB_fit_method_geometry,N_Geo_Data_lines,seg1_seg2_Geo_Data_pairs,Geo_Data_pairs,Geo_Data_da) !! DATA from Read_COM_COM_H_MA_MMA_theta_from_J_AB_from_file
	IMPLICIT NONE
	INTEGER :: N_Resids,N_Neighbours
	INTEGER, DIMENSION(N_Resids,N_Neighbours+1), INTENT(IN) :: neighbour_list_Res
    REAL, DIMENSION(N_Resids*N_Neighbours,4),  INTENT(OUT)  :: J_AB_Daten
    REAL, DIMENSION(N_Resids*N_Neighbours)                  :: dist_COM_inter
    LOGICAL, DIMENSION(N_Resids*N_Neighbours), INTENT(OUT)  :: J_AB_da
	CHARACTER(LEN=500), INTENT(IN)                          :: J_AB_filename
	CHARACTER(LEN=5), DIMENSION(N_Resids*N_Neighbours,2) 	:: residue_names_pair
	!!!
	CHARACTER(LEN=50)    , INTENT(IN)                        ::	J_AB_fit_method_geometry
	!! Data form Read_COM_COM_H_MA_MMA_theta_from_J_AB_from_file
	REAL,    ALLOCATABLE, DIMENSION(:,:)     	     :: Geo_Data_pairs
	INTEGER, ALLOCATABLE, DIMENSION(:,:)		     :: seg1_seg2_Geo_Data_pairs
	LOGICAL, ALLOCATABLE, DIMENSION(:)		         :: Geo_Data_da
	INTEGER :: N_Geo_Data_lines
	!! Local variables
	CHARACTER(LEN=5)   :: mol_type_1,mol_type_2
	INTEGER            :: Resid1,Resid2	
	REAL               :: matrix_element_homo_homo, matrix_element_lumo_lumo	
	INTEGER:: i,j,k,NR
	LOGICAL:: DEBUG=.false.
	
	
	IF(DEBUG) WRITE(*,*) 'get_JAB_from_Geo_Data'
	
	IF( .NOT. allocated(Geo_Data_pairs) ) THEN
		WRITE(*,*) 'Using: Read_COM_COM_H_MA_MMA_theta_from_J_AB_file:'
		CALL Read_COM_COM_H_MA_MMA_theta_from_J_AB_file&
			&(N_Geo_Data_lines,seg1_seg2_Geo_Data_pairs,Geo_Data_pairs,Geo_Data_da,J_AB_filename)
	END IF

	J_AB_Daten=0.0
	J_AB_da=.false.

    DO k=1,N_Resids,1
        DO j=1,N_Neighbours,1
            Resid1=INT(neighbour_list_Res(k,1))    ! Resid A
            Resid2=INT(neighbour_list_Res(k,j+1))  ! Nachbarn Uebergeben fuer indizes 2 bis 13  
             
			matrix_element_homo_homo=0.0E0
			matrix_element_lumo_lumo=0.0E0
			
			!!! residue_name from pair list  index_pair = (k-1)*N_Neighbours+j  ! Umrechnung der Indizes fuer die Nachbarschaftsliste in die Paar-Nummer (NR) = { 1,..., NR_max=N_Neighbours*N_Residues}
			NR=(k-1)*N_Neighbours+j   ! Umrechnung der Indizes fuer die Nachbarschaftsliste in die Paar-Nummer (NR) = { 1,..., NR_max=N_Neighbours*N_Residues}
			mol_type_1=residue_names_pair(NR,1)
			mol_type_2=residue_names_pair(NR,2)
			
			DO i=1,N_Geo_Data_lines
				IF(Geo_Data_da(i)) THEN
					IF( ((Resid1 == seg1_seg2_Geo_Data_pairs(i,1)) .AND. (Resid2 == seg1_seg2_Geo_Data_pairs(i,2)) ) .OR. &
					&	((Resid2 == seg1_seg2_Geo_Data_pairs(i,1)) .AND. (Resid1 == seg1_seg2_Geo_Data_pairs(i,2))	)) THEN
					
						IF(DEBUG) THEN
							WRITE(*,*) 'Pair found:',TRIM(mol_type_1),TRIM(mol_type_2),Geo_Data_pairs(i,1),Geo_Data_pairs(i,2),&
							& Geo_Data_pairs(i,3),Geo_Data_pairs(i,4),Geo_Data_pairs(i,5),TRIM(J_AB_fit_method_geometry)
						END IF
						
						!!!                      dipro_hole_matrix_fit(mol_type_1,mol_type_2,COM, COM_H, MA, MMA, theta,J_AB_fit_method_geometry)
						matrix_element_homo_homo=dipro_hole_matrix_fit(mol_type_1,mol_type_2,Geo_Data_pairs(i,1),&
						& Geo_Data_pairs(i,2),Geo_Data_pairs(i,3),Geo_Data_pairs(i,4),Geo_Data_pairs(i,5),J_AB_fit_method_geometry)	
						IF(DEBUG) WRITE(*,*) 'matrix_element_homo_homo:',matrix_element_homo_homo
						
						!!!                      dipro_hole_matrix_electron(mol_type_1,mol_type_2,COM, COM_H, MA, MMA, theta,J_AB_fit_method_geometry)			
						matrix_element_lumo_lumo=dipro_electron_matrix_fit(mol_type_1,mol_type_2,Geo_Data_pairs(i,1),&
						& Geo_Data_pairs(i,2),Geo_Data_pairs(i,3),Geo_Data_pairs(i,4),Geo_Data_pairs(i,5),J_AB_fit_method_geometry)
					
						IF(DEBUG)  WRITE(*,*) 'matrix_element_lumo_lumo:',matrix_element_lumo_lumo
						
						!!!  Hochzaehlen der Paare ueber den index						
						J_AB_Daten(NR,1)=0.0      ! S_AB_lo
						J_AB_Daten(NR,2)=matrix_element_homo_homo
						J_AB_Daten(NR,3)=0.0      ! S_AB_el
						J_AB_Daten(NR,4)=matrix_element_lumo_lumo
						dist_COM_inter(NR)=Geo_Data_pairs(i,2)  ! distance_COM_H
						J_AB_da(NR)=.true.
					END IF ! Resids available?
				END IF ! Geo_Data_da
			END DO ! i=1,N_Geo_Data_lines
	
		END DO ! j=1,N_Neighbours,1
	END DO ! k=1, N_Resids
	
END SUBROUTINE get_JAB_from_Geo_Data_for_neighbourlist


        !!  READIND DATA: REAL:: COM, COM_H, MA, MMA, theta, COM_S_MA from J_AB_filename
		!!  seg1_seg2_Geo_Data_pairs seg1_seg2_Geo_Data_pairs(i,j) i=[1...N_lines]  j= 1=Resid1, 2=Resid2 
		!!  Geo_Data_pairs Geometric data for a pair of hopping sites in J_AB file.
		!!  i= 1..N_lines 
		!!  j= 1=COM, 2=COM_H, 3=MA, 4=MMA, 5=theta, 6=COM_S_MA,
		!! 	Geo_Data_da =.true. => Data is available		
SUBROUTINE Read_COM_COM_H_MA_MMA_theta_from_J_AB_file(N_lines,seg1_seg2_Geo_Data_pairs,Geo_Data_pairs,Geo_Data_da,J_AB_filename)
	IMPLICIT NONE
	CHARACTER(LEN=500), INTENT(IN)                               :: J_AB_filename
	REAL,    ALLOCATABLE, DIMENSION(:,:) , INTENT(OUT)		     :: Geo_Data_pairs
	!! Pair available in J_AB_filename =.true.?
	LOGICAL, ALLOCATABLE, DIMENSION(:)	 , INTENT(OUT)	         :: Geo_Data_da
	!! Index for pairs: segment1,segment2
	INTEGER, ALLOCATABLE, DIMENSION(:,:), INTENT(OUT)			 :: seg1_seg2_Geo_Data_pairs
	!! keywordlist with all readable data from file. The value is always read between two subsequent keywords.
	CHARACTER(LEN=500) ,DIMENSION(9) 			 :: keywordlist
	CHARACTER(LEN=500)                           :: line,dummy,keyword
	LOGICAL::Datei_vorhanden,DEBUG
	REAL			                 :: COM, COM_H, MA, MMA, theta, COM_S_MA
	INTEGER::i,j,ind1,ind2,ind3,ierror,N_skip_line,N_lines
	
	DEBUG=.false.
	COM=0.0
	COM_H=0.0
	MA=0.0
	MMA=0.0
	theta=0.0
	COM_S_MA=0.0
		
	keywordlist(1)='Resid1:'
	keywordlist(2)='Resid2:'
	keywordlist(3)='COM:'
	keywordlist(4)='COM_H:'
	keywordlist(5)='MA:'
	keywordlist(6)='MMA:'
	keywordlist(7)='theta:'
	keywordlist(8)='COM_S_MA:'
	keywordlist(9)='DIPRO/'
	
	
		INQUIRE(file=TRIM(J_AB_filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
		IF( .NOT. Datei_vorhanden) THEN
		      WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(J_AB_filename)
		      WRITE(*,*) ' ENDE'
		      CALL EXIT (1)
		END IF ! Datei J_AB_filename-file vorhanden  

		OPEN(UNIT=20,FILE=TRIM(J_AB_filename),STATUS='OLD',IOSTAT=ierror)
		WRITE(*,*) 'Reading data from: ',TRIM(J_AB_filename)
		ierror=0
		N_skip_line=0
		N_lines=0
		DO WHILE ( ierror == 0 ) 
		    Read(20,*,IOSTAT=ierror) dummy
		    IF(ierror < 0) EXIT
		    IF(ierror > 0) THEN
			WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(J_AB_filename),' aufgetreten.'
			WRITE(*,*) 'Beende Einlesen !'
			CALL EXIT (1)
		    END IF
		    IF ( dummy(1:1) == '#' ) THEN ! Check ob erster Buchstabe ein #-Zeichen ist, um kommentare zu lesen
			N_skip_line=N_skip_line+1
		    ELSE
			N_lines=N_lines+1
		    END IF
		END DO       
		CLOSE(20)        
		!WRITE(*,*) 'N_lines=',N_lines,'N_skip_line',N_skip_line        

		OPEN(UNIT=20,FILE=TRIM(J_AB_filename),STATUS='OLD',IOSTAT=ierror)
		IF (N_skip_line > 0 ) THEN
		    DO i =1,N_skip_line 
			Read(20,*,IOSTAT=ierror) dummy
		    END DO
		END IF
		
		!! seg1_seg2_Geo_Data_pairs seg1_seg2_Geo_Data_pairs(i,j) i=[1...N_lines]  j= 1=Resid1, 2=Resid2 
		ALLOCATE(seg1_seg2_Geo_Data_pairs(N_lines,2))
		!!  Geo_Data_pairs Geometric data for a pair of hopping sites in J_AB file.
		!!  i= 1..N_lines 
		!!  j= 1=COM, 2=COM_H, 3=MA, 4=MMA, 5=theta, 6=COM_S_MA,
		ALLOCATE(Geo_Data_pairs(N_lines,6))	
		!! 	Geo_Data_da =.true. => Data is available
		ALLOCATE(Geo_Data_da(N_lines))		
			
		seg1_seg2_Geo_Data_pairs=-1
		Geo_Data_pairs=0.0
		Geo_Data_da=.false.	

		
		DO i=1,N_lines	
			READ (20, '(A)') line ! reading the entire line from input file
			!write(*, '(500A)') TRIM(line)        ! write line to the screen		
				
			!!! Split inputline
			DO j=1,8
				keyword=keywordlist(j)
				! Split the string, looking for indizes with the start of keywords
				ind1 = index(TRIM(line),TRIM(adjustl(keyword))) 
				ind3 = index(TRIM(line),TRIM(adjustl(keywordlist(j+1)))) 
				IF( (ind1 .ne. 0) .AND. (ind3 .ne. 0) )THEN  ! keywords exist in string
				
					! reduce line to values and store in the dummy string 
					ind2=ind1+len(TRIM(adjustl(keyword)))
					IF(DEBUG) WRITE(*,*) ':-) ',TRIM(line(ind2:))  
					dummy=TRIM(line(ind2:ind3-1))
					IF(DEBUG) WRITE(*,*) j,'Split:',TRIM(dummy)
					
					IF(j==1) THEN
						! Convert the string to integer
						READ(dummy,'(I6)') ind1
						seg1_seg2_Geo_Data_pairs(i,1)=ind1
						IF(DEBUG) WRITE(*,*) 'Reading Resid1:', ind1
					ELSE IF(j==2) THEN
						! Convert the string to integer
						READ(dummy,'(I6)') ind1
						seg1_seg2_Geo_Data_pairs(i,2)=ind1
						IF(DEBUG) WRITE(*,*) 'Reading Resid2:', ind1
					ELSE IF(j > 2) THEN	
						IF(j==3) THEN
							Geo_Data_da(i)=.true.
						END IF 
						! Convert the string to floats
						READ(dummy,'(f16.4)') Geo_Data_pairs(i,j-2)
						IF(DEBUG) WRITE(*,*) TRIM(adjustl(keyword)),Geo_Data_pairs(i,j-2)
					END IF				
					
				END IF  ! ind1 and ind3 for keywords exist in the string!
				
			END DO ! Split inputlien
			
			IF(DEBUG) WRITE(*,*) 'Read data:',Geo_Data_da(i),seg1_seg2_Geo_Data_pairs(i,:),Geo_Data_pairs(i,:)
		    IF(ierror < 0) EXIT
		    IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von '//TRIM(J_AB_filename)//' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
		    END IF
		END DO
		CLOSE(20)
	
END SUBROUTINE Read_COM_COM_H_MA_MMA_theta_from_J_AB_file 







SUBROUTINE Massenschwerpunkt(atomsorte,koord,MAXATM,schwerpunkt) ! 
! subroutine berechnet den Massenschwerpunkt mit Ausgabe in schwerpunkt        
        IMPLICIT NONE
        Integer, INTENT(IN) :: MAXATM
        Real, Dimension(MAXATM,3), INTENT(IN) :: koord
        Character(5), Dimension(MAXATM), INTENT(IN) :: atomsorte
        Real, Dimension(3)::schwerpunkt
        integer::i
        REAL  :: m_i,m_ges,z_ges,z_i
        !write(*,*) 'Start der Berechnung des Schwerpunktes'        
        schwerpunkt(:)=0
        m_ges=0
        m_i=0
        do i=1,MAXATM
           m_i=0
           ! GRO Ausgaben
           if (TRIM(adjustl(atomsorte(i)))=='HC')  m_i=1.0079  ! fuer H
           if (TRIM(adjustl(atomsorte(i)))=='CH1') m_i=13.0186 !  fuer 1H und 1C 
           if (TRIM(adjustl(atomsorte(i)))=='CH2') m_i=14.0265 ! fuer 2H und 1C  
           if (TRIM(adjustl(atomsorte(i)))=='CH3') m_i=15.0344 ! fuer 3H und 1C  
           if (TRIM(adjustl(atomsorte(i)))=='CA')  m_i=12.0107 ! fuer CA = C 
           !richtige Elemente
           if (TRIM(adjustl(atomsorte(i)))=='H')  m_i=1.0079   !Wasserstoff     H       1
           if (TRIM(adjustl(atomsorte(i)))=='He')  m_i=4.0026  !Helium          He      2
           if (TRIM(adjustl(atomsorte(i)))=='Li')  m_i=6.941   !Lithium         Li      3
           if (TRIM(adjustl(atomsorte(i)))=='Be')  m_i=9.0122  !Beryllium       Be      4
           if (TRIM(adjustl(atomsorte(i)))=='B')  m_i=10.811   !Bor     B       5
           if (TRIM(adjustl(atomsorte(i)))=='C')  m_i=12.0107  !Kohlenstoff     C       6
           if (TRIM(adjustl(atomsorte(i)))=='N')  m_i=14.0067  !        Stickstoff      N       7
           if (TRIM(adjustl(atomsorte(i)))=='O')  m_i=15.9994  !        Sauerstoff      O       8
           if (TRIM(adjustl(atomsorte(i)))=='F')  m_i=18.9984  !        Fluor   F       9
           if (TRIM(adjustl(atomsorte(i)))=='Ne')  m_i=20.1797 !        Neon    Ne      10
           if (TRIM(adjustl(atomsorte(i)))=='Na')  m_i=22.9897 !        Natrium         Na      11
           if (TRIM(adjustl(atomsorte(i)))=='Mg')  m_i=24.305  !Magnesium       Mg      12
           if (TRIM(adjustl(atomsorte(i)))=='Al')  m_i=26.9815 !        Aluminum        Al      13
           if (TRIM(adjustl(atomsorte(i)))=='Si')  m_i=28.0855 !        Silizium        Si      14
           if (TRIM(adjustl(atomsorte(i)))=='P')  m_i=30.9738  !        Phosphor        P       15
           if (TRIM(adjustl(atomsorte(i)))=='S')  m_i=32.065   !Schwefel        S       16
           if (TRIM(adjustl(atomsorte(i)))=='Cl')  m_i=35.453  !Chlor   Cl      17
           if (TRIM(adjustl(atomsorte(i)))=='K')  m_i=39.0983  !        Kalium  K       19
           if (TRIM(adjustl(atomsorte(i)))=='Ar')  m_i=39.948  !Argon   Ar      18
           if (TRIM(adjustl(atomsorte(i)))=='Ca')  m_i=40.078  !Kalzium         Ca      20
           if (TRIM(adjustl(atomsorte(i)))=='Sc')  m_i=44.9559 !        Scandium        Sc      21
           if (TRIM(adjustl(atomsorte(i)))=='Ti')  m_i=47.867  !Titan   Ti      22
           if (TRIM(adjustl(atomsorte(i)))=='V')  m_i=50.9415  !        Vanadium        V       23
           if (TRIM(adjustl(atomsorte(i)))=='Cr')  m_i=51.9961 !        Chrom   Cr      24
           if (TRIM(adjustl(atomsorte(i)))=='Mn')  m_i=54.938  !Mangan  Mn      25
           if (TRIM(adjustl(atomsorte(i)))=='Fe')  m_i=55.845  !Eisen   Fe      26
           if (TRIM(adjustl(atomsorte(i)))=='Ni')  m_i=58.6934 !        Nickel  Ni      28
           if (TRIM(adjustl(atomsorte(i)))=='Co')  m_i=58.9332  !        Kobalt  Co      27
           if (TRIM(adjustl(atomsorte(i)))=='Cu')  m_i=63.546   !Kupfer  Cu      29
           if (TRIM(adjustl(atomsorte(i)))=='Zn')  m_i=65.39    !Zink    Zn      30
           if (TRIM(adjustl(atomsorte(i)))=='Ga')  m_i=69.723   !Gallium         Ga      31
           if (TRIM(adjustl(atomsorte(i)))=='Ge')  m_i=72.64    !Germanium       Ge      32
           if (TRIM(adjustl(atomsorte(i)))=='As')  m_i=74.9216  !        Arsen   As      33
           if (TRIM(adjustl(atomsorte(i)))=='Se')  m_i=78.96    !Selen   Se      34
           if (TRIM(adjustl(atomsorte(i)))=='Br')  m_i=79.904   !Brom    Br      35
           if (TRIM(adjustl(atomsorte(i)))=='Kr')  m_i=83.8     !Krypton         Kr      36
           if (TRIM(adjustl(atomsorte(i)))=='Rb')  m_i=85.4678  !        Rubidium        Rb      37
           if (TRIM(adjustl(atomsorte(i)))=='Sr')  m_i=87.62    !Strontium       Sr      38
           if (TRIM(adjustl(atomsorte(i)))=='Y')  m_i=88.9059   !        Yttrium         Y       39
           if (TRIM(adjustl(atomsorte(i)))=='Zr')  m_i=91.224   !Zirkonium       Zr      40
           if (TRIM(adjustl(atomsorte(i)))=='Nb')  m_i=92.9064  !        Nobium  Nb      41
           if (TRIM(adjustl(atomsorte(i)))=='Mo')  m_i=95.94   !Molybdän        Mo      42
           if (TRIM(adjustl(atomsorte(i)))=='Tc')  m_i=98      !Technetium      Tc      43
           if (TRIM(adjustl(atomsorte(i)))=='Ru')  m_i=101.07  !Ruthenium       Ru      44
           if (TRIM(adjustl(atomsorte(i)))=='Rh')  m_i=102.9055!        Rhodium         Rh      45
           if (TRIM(adjustl(atomsorte(i)))=='Pd')  m_i=106.42  !Palladium       Pd      46
           if (TRIM(adjustl(atomsorte(i)))=='Ag')  m_i=107.8682!        Silber  Ag      47
           if (TRIM(adjustl(atomsorte(i)))=='Cd')  m_i=112.411 !        Kadmium         Cd      48
           if (TRIM(adjustl(atomsorte(i)))=='In')  m_i=114.818 !        Indium  In      49
           if (TRIM(adjustl(atomsorte(i)))=='Sn')  m_i=118.71  !Zinn    Sn      50
           if (TRIM(adjustl(atomsorte(i)))=='Sb')  m_i=121.76  !Antimon         Sb      51
           if (TRIM(adjustl(atomsorte(i)))=='I')  m_i=126.9045!        Jod     I       53
           if (TRIM(adjustl(atomsorte(i)))=='Te')  m_i=127.6   !Tellur  Te      52
           if (TRIM(adjustl(atomsorte(i)))=='Xe')  m_i=131.293 !        Xenon   Xe      54
           if (TRIM(adjustl(atomsorte(i)))=='Re')  m_i=186.207 !        Rhenium         Re      75
           if (TRIM(adjustl(atomsorte(i)))=='Os')  m_i=190.23  !Osmium  Os      76
           if (TRIM(adjustl(atomsorte(i)))=='Ir')  m_i=192.217 !        Iridium         Ir      77
           if (TRIM(adjustl(atomsorte(i)))=='Pt')  m_i=195.078 !        Platin  Pt      78
           if (TRIM(adjustl(atomsorte(i)))=='Au')  m_i=196.9665!        Gold    Au      79
           if (TRIM(adjustl(atomsorte(i)))=='Hg')  m_i=200.59  !Quecksilber     Hg      80
           if (TRIM(adjustl(atomsorte(i)))=='Tl')  m_i=204.3833!        Thallium        Tl      81
           if (TRIM(adjustl(atomsorte(i)))=='Pb')  m_i=207.2   !Blei    Pb      82
           if (TRIM(adjustl(atomsorte(i)))=='Bi')  m_i=208.9804!        Wismut  Bi      83
           if (TRIM(adjustl(atomsorte(i)))=='Po')  m_i=209     !Polonium        Po      84
           if (TRIM(adjustl(atomsorte(i)))=='At')  m_i=210 !Astat   At      85
           if (TRIM(adjustl(atomsorte(i)))=='Rn')  m_i=222 !    Radon
           
           schwerpunkt(:)=schwerpunkt(:)+m_i*koord(i,:)     
           m_ges=m_ges+m_i     
           !write(*,*) m_i,schwerpunkt
        end do 
        schwerpunkt=schwerpunkt/real(m_ges)
        ! Berechnung der Anzahl der Elektronen im neutralen Molekül z_ges 
        z_ges=0
        do i=1,MAXATM
           z_i=0
           ! .gro Gruppen
           if (TRIM(adjustl(atomsorte(i)))=='HC')  z_i=1    ! fuer H
           if (TRIM(adjustl(atomsorte(i)))=='CH1') z_i=12   ! fuer 1H und 1C 
           if (TRIM(adjustl(atomsorte(i)))=='CH2') z_i=14   ! fuer 2H und 1C  
           if (TRIM(adjustl(atomsorte(i)))=='CH3') z_i=15   ! fuer 3H und 1C  
           if (TRIM(adjustl(atomsorte(i)))=='CA')  z_i=12   ! fuer CA = C  
           ! Normale Atome
           if (TRIM(adjustl(atomsorte(i)))=='H')  z_i=1!Wasserstoff     H       1
           if (TRIM(adjustl(atomsorte(i)))=='He') z_i=2!Helium          He      2
           if (TRIM(adjustl(atomsorte(i)))=='Li') z_i=3!Lithium         Li      3
           if (TRIM(adjustl(atomsorte(i)))=='Be') z_i=4!Beryllium       Be      4
           if (TRIM(adjustl(atomsorte(i)))=='B')  z_i=5!Bor     B       5
           if (TRIM(adjustl(atomsorte(i)))=='C')  z_i=6!Kohlenstoff     C       6
           if (TRIM(adjustl(atomsorte(i)))=='N')  z_i=7!        Stickstoff      N       7
           if (TRIM(adjustl(atomsorte(i)))=='O')  z_i=8!        Sauerstoff      O       8
           if (TRIM(adjustl(atomsorte(i)))=='F')  z_i=9!        Fluor   F       9
           if (TRIM(adjustl(atomsorte(i)))=='Ne') z_i=10!        Neon    Ne      10
           if (TRIM(adjustl(atomsorte(i)))=='Na') z_i=11!        Natrium         Na      11
           if (TRIM(adjustl(atomsorte(i)))=='Mg') z_i=12!Magnesium       Mg      12
           if (TRIM(adjustl(atomsorte(i)))=='Al') z_i=13!        Aluminum        Al      13
           if (TRIM(adjustl(atomsorte(i)))=='Si') z_i=14!        Silizium        Si      14
           if (TRIM(adjustl(atomsorte(i)))=='P')  z_i=15!        Phosphor        P       15
           if (TRIM(adjustl(atomsorte(i)))=='S')  z_i=16!Schwefel        S       16
           if (TRIM(adjustl(atomsorte(i)))=='Cl') z_i=17!Chlor   Cl      17
           if (TRIM(adjustl(atomsorte(i)))=='K')  z_i=19!        Kalium  K       19
           if (TRIM(adjustl(atomsorte(i)))=='Ar') z_i=17!Argon   Ar      18
           if (TRIM(adjustl(atomsorte(i)))=='Ca') z_i=20!Kalzium         Ca      20
           if (TRIM(adjustl(atomsorte(i)))=='Sc') z_i=21!        Scandium        Sc      21
           if (TRIM(adjustl(atomsorte(i)))=='Ti') z_i=22!Titan   Ti      22
           if (TRIM(adjustl(atomsorte(i)))=='V')  z_i=23 !        Vanadium        V       23
           if (TRIM(adjustl(atomsorte(i)))=='Cr') z_i=24!        Chrom   Cr      24
           if (TRIM(adjustl(atomsorte(i)))=='Mn') z_i=25!Mangan  Mn      25
           if (TRIM(adjustl(atomsorte(i)))=='Fe') z_i=26!Eisen   Fe      26
           if (TRIM(adjustl(atomsorte(i)))=='Ni') z_i=28!        Nickel  Ni      28
           if (TRIM(adjustl(atomsorte(i)))=='Co') z_i=27!        Kobalt  Co      27
           if (TRIM(adjustl(atomsorte(i)))=='Cu') z_i=29!Kupfer  Cu      29
           if (TRIM(adjustl(atomsorte(i)))=='Zn') z_i=30!Zink    Zn      30
           if (TRIM(adjustl(atomsorte(i)))=='Ga') z_i=31!Gallium         Ga      31
           if (TRIM(adjustl(atomsorte(i)))=='Ge') z_i=32!Germanium       Ge      32
           if (TRIM(adjustl(atomsorte(i)))=='As') z_i=33!        Arsen   As      33
           if (TRIM(adjustl(atomsorte(i)))=='Se') z_i=34!Selen   Se      34
           if (TRIM(adjustl(atomsorte(i)))=='Br') z_i=35!Brom    Br      35
           if (TRIM(adjustl(atomsorte(i)))=='Kr') z_i=36!Krypton         Kr      36
           if (TRIM(adjustl(atomsorte(i)))=='Rb') z_i=37!        Rubidium        Rb      37
           if (TRIM(adjustl(atomsorte(i)))=='Sr') z_i=38!Strontium       Sr      38
           if (TRIM(adjustl(atomsorte(i)))=='Y')  z_i=39!        Yttrium         Y       39
           if (TRIM(adjustl(atomsorte(i)))=='Zr') z_i=40!Zirkonium       Zr      40
           if (TRIM(adjustl(atomsorte(i)))=='Nb') z_i=41!        Nobium  Nb      41
           if (TRIM(adjustl(atomsorte(i)))=='Mo') z_i=42!Molybdän        Mo      42
           if (TRIM(adjustl(atomsorte(i)))=='Tc') z_i=43!Technetium      Tc      43
           if (TRIM(adjustl(atomsorte(i)))=='Ru') z_i=44!Ruthenium       Ru      44
           if (TRIM(adjustl(atomsorte(i)))=='Rh') z_i=45!        Rhodium         Rh      45
           if (TRIM(adjustl(atomsorte(i)))=='Pd') z_i=46!Palladium       Pd      46
           if (TRIM(adjustl(atomsorte(i)))=='Ag') z_i=47!        Silber  Ag      47
           if (TRIM(adjustl(atomsorte(i)))=='Cd') z_i=48!        Kadmium         Cd      48
           if (TRIM(adjustl(atomsorte(i)))=='In') z_i=49!        Indium  In      49
           if (TRIM(adjustl(atomsorte(i)))=='Sn') z_i=50!Zinn    Sn      50
           if (TRIM(adjustl(atomsorte(i)))=='Sb') z_i=51!Antimon         Sb      51
           if (TRIM(adjustl(atomsorte(i)))=='I')  z_i=53!        Jod     I       53
           if (TRIM(adjustl(atomsorte(i)))=='Te') z_i=52!Tellur  Te      52
           if (TRIM(adjustl(atomsorte(i)))=='Xe') z_i=54!        Xenon   Xe      54
           if (TRIM(adjustl(atomsorte(i)))=='Re') z_i=75!        Rhenium         Re      75
           if (TRIM(adjustl(atomsorte(i)))=='Os') z_i=76!Osmium  Os      76
           if (TRIM(adjustl(atomsorte(i)))=='Ir') z_i=77!        Iridium         Ir      77
           if (TRIM(adjustl(atomsorte(i)))=='Pt') z_i=78!        Platin  Pt      78
           if (TRIM(adjustl(atomsorte(i)))=='Au') z_i=79!        Gold    Au      79
           if (TRIM(adjustl(atomsorte(i)))=='Hg') z_i=80!Quecksilber     Hg      80
           if (TRIM(adjustl(atomsorte(i)))=='Tl') z_i=81!        Thallium        Tl      81
           if (TRIM(adjustl(atomsorte(i)))=='Pb') z_i=82!Blei    Pb      82
           if (TRIM(adjustl(atomsorte(i)))=='Bi') z_i=83!        Wismut  Bi      83
           if (TRIM(adjustl(atomsorte(i)))=='Po') z_i=84    !Polonium        Po      84
           if (TRIM(adjustl(atomsorte(i)))=='At') z_i=85     !Astat   At      85
           if (TRIM(adjustl(atomsorte(i)))=='Rn') z_i=86      !    Radon
           
           !if (z_i==0) THEN
            !write(*,*) 'Es ist ein Fehler bei der Berechnung der Elektronenanzahl z_ges aufgetreten!'
           !END IF
        z_ges=z_ges+z_i
        END DO
        
        !WRITE(*,*) 'Die Anzahl der Elekronen im neutralen Molekuel ist',z_ges
        !write(*,*) 'Der Schwerpunkt liegt bei ', schwerpunkt
END SUBROUTINE Massenschwerpunkt




!!!!!!!!!!!!! SUBROUTINES FOR PPDI / PBDT-TS1 START !!!!!!!!!!
SUBROUTINE Read_Matrix_17x17_from_file(filename,array)
!!  PPDI / PBDT-TS1 
!! Subroutine to Read the 17x17 Matrizes for the dE_in(el,lo) , lambda_in(el_lo)
!! Comments in the file at the beginning with '#' are neglected; caution more lines in the file with '#' may cause some errors while reading
	IMPLICIT NONE
	CHARACTER (500), INTENT(IN) ::filename
	INTEGER,PARAMETER ::p=17,q=17
	REAL, DIMENSION(p,q), INTENT(OUT) ::array
	CHARACTER (500)::dummy
	LOGICAL:: Datei_vorhanden
	INTEGER::i,N_lines,N_skip_line,ierror

		INQUIRE(file=TRIM(filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
		IF( .NOT. Datei_vorhanden) THEN
			  WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(filename)
			  WRITE(*,*) ' ENDE'
			  CALL EXIT (1)
		END IF ! Datei-file vorhanden  

		OPEN(UNIT=25,FILE=TRIM(filename),STATUS='OLD',IOSTAT=ierror)
		WRITE(*,*) 'Reading data from: ',TRIM(filename)
		ierror=0
		N_skip_line=0
		N_lines=0
		DO WHILE ( ierror == 0 ) 
			Read(25,*,IOSTAT=ierror) dummy
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(filename),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
			if ( dummy(1:1) == '#' ) THEN ! Check ob erster Buchstabe ein #-Zeichen ist, um kommentare zu lesen
				N_skip_line=N_skip_line+1
			ELSE
				N_lines=N_lines+1
			END IF
		END DO       
		CLOSE(25)        
		!WRITE(*,*) 'N_lines=',N_lines,'N_skip_line',N_skip_line        

		OPEN(UNIT=25,FILE=TRIM(filename),STATUS='OLD',IOSTAT=ierror)
		IF (N_skip_line > 0 ) THEN
			DO i =1,N_skip_line 
				Read(25,*,IOSTAT=ierror) dummy
			END DO
		END IF

		DO i=1,p
			Read(25,*,IOSTAT=ierror) array(i,1),array(i,2),array(i,3),array(i,4),array(i,5), & 
					&  array(i,6),array(i,7),array(i,8),array(i,9),array(i,10), &
					&  array(i,11),array(i,12),array(i,13),array(i,14),array(i,15), &
					&  array(i,16),array(i,17)
			!WRITE(*,*) array(i,1),array(i,2),array(i,3),array(i,4),array(i,5)
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(filename),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
		END DO

		CLOSE(25)
END SUBROUTINE Read_Matrix_17x17_from_file






SUBROUTINE  winkel_intra_PBDT_TS1(residue_number,residue_name,atom,atom_number,koordA,MAXATM,N_Resids,ResidX_in_long_chain,&
                       &intra_theta_E,N_PBDT_TS1_Intra,N_PPDI,N_PBDT_TS1_segments,R_intra,read_intramolecular_data,use_fit,& 
  & PBDT_TS1_AB_dE_intr_in_el_file,PBDT_TS1_BA_dE_intr_in_el_file,PBDT_TS1_AB_dE_intr_in_lo_file,PBDT_TS1_BA_dE_intr_in_lo_file,&
  & PBDT_TS1_AB_J_intra_in_el_file,PBDT_TS1_BA_J_intra_in_el_file,PBDT_TS1_AB_J_intra_in_lo_file,PBDT_TS1_BA_J_intra_in_lo_file)
!! Zurodnung der Intramolekularen Daten; Indezierung in Array intra_theta_E(i,j) , i=M_PBDT_TS1_intra == Anzahl der Winkel die
!! Intramolekularen Transport erlauben;  j=1-5 intex mit Daten: 
!!  1= theta , 2=dE_in_el,   3=dE_in_lo, 4=|J_AB(el)| , 5=|J_AB(lo)| 
!! use_fit= .true. verwendet den cosfit fuer 4=|J_AB(el)| und den dE_in_el=-65*abs(dE_in_lo)
use small_functions
IMPLICIT NONE
Real, ALLOCATABLE, Dimension(:,:), INTENT(IN)       :: koordA
INTEGER, ALLOCATABLE, DIMENSION(:), INTENT(IN)      :: residue_number,atom_number
Character(5), ALLOCATABLE, DIMENSION(:),INTENT(IN)  :: residue_name
Character(3), ALLOCATABLE, DIMENSION(:),INTENT(IN)  :: atom
INTEGER, INTENT(IN) ::N_Resids,MAXATM
LOGICAL, INTENT(IN) ::read_intramolecular_data,use_fit
Real, ALLOCATABLE, Dimension(:,:), INTENT(OUT) ::intra_theta_E 
!! R_intra(i,j) carries resid i and the index j to access the 17x17 matrices
INTEGER, ALLOCATABLE, Dimension(:,:), INTENT(OUT) ::R_intra,ResidX_in_long_chain
INTEGER,INTENT (out)::N_PBDT_TS1_Intra
Character(LEN=500),  INTENT(IN)    :: PBDT_TS1_AB_dE_intr_in_el_file,PBDT_TS1_BA_dE_intr_in_el_file
Character(LEN=500),  INTENT(IN)    :: PBDT_TS1_AB_dE_intr_in_lo_file,PBDT_TS1_BA_dE_intr_in_lo_file
Character(LEN=500),  INTENT(IN)    :: PBDT_TS1_AB_J_intra_in_el_file,PBDT_TS1_BA_J_intra_in_el_file
Character(LEN=500),  INTENT(IN)    :: PBDT_TS1_AB_J_intra_in_lo_file,PBDT_TS1_BA_J_intra_in_lo_file

INTEGER::i,j,count_theta,Old_Resid,N_intra_lines_AB,N_intra_lines_BA
REAL, ALLOCATABLE, DIMENSION(:,:) :: intra_data_AB,intra_data_BA
REAL, PARAMETER:: PI=4.0*ATAN(1.0)
REAL ::theta
LOGICAL::calc_theta,DEBUG=.false.
REAL, DIMENSION(3)::a,b,c,d,c_old
INTEGER::i_PBDT_TS1long_chain,N_PPDI,N_PBDT_TS1_segments,Count_segments
CHARACTER(LEN=1) :: segtype
CHARACTER(LEN=50):: sequence 
CHARACTER(LEN=50), ALLOCATABLE, DIMENSION(:,:):: polymer_sequences
!!! contains the angle dependant parametrization for the intramolecular PBDT_TS1 rates
LOGICAL :: mol_start_da,mol_ende_da
INTEGER :: N_CarboxyS2, N_PBDT, N_Schwefel


if(debug) then
	write(*,*) 'Start winkel_intramolekular for N_Resids: ',N_Resids, ' and N_atoms:',size(atom_number)
endif

N_PBDT_TS1_Intra=0
N_PPDI=0
N_PBDT_TS1_segments=0
! Schleife zur Bestimmung der Anzahl der intramolekularen Resid-Paare
DO j=1,MAXATM
    IF( residue_name(j) == '8poly' .and. (j /= 1))THEN 
		IF( (TRIM(adjustl(atom(j-1)))=='CH3') .and. (TRIM(adjustl(atom(j+3)))=='F') .and. (TRIM(adjustl(atom(j+7)))=='OE')  )THEN  ! Start CarboxyS2 unit
			mol_start_da=.true.
		ELSE IF( (TRIM(adjustl(atom(j)))=='CH3') .and. (TRIM(adjustl(atom(j-1)))=='HC') )THEN ! End chain 
			mol_ende_da=.true.
		END IF
    END IF ! 


     IF ( j /= 1 .AND. (residue_number(j) /= residue_number(j-1)) )THEN
		IF (residue_name(j-1)(1:5) == 'PPDI_') THEN
			N_PPDI=N_PPDI+1
                END IF
		IF (residue_name(j-1)(1:5) == '8poly') THEN
			N_PBDT_TS1_segments=N_PBDT_TS1_segments+1
		END IF 
		IF (residue_name(j)(1:5) == '8poly' .AND. (residue_name(j-1)(1:5) == '8poly'  ) ) THEN
		        IF ( (atom(j)(1:3) == 'CH3') .AND. (atom(j-1) == 'CH3')) THEN  ! Start einer neuen Kette. Ist die Abfrage eindeutig?
		                CYCLE
		        ELSE
		                N_PBDT_TS1_Intra=N_PBDT_TS1_Intra+1
		        END IF
		END IF
    END IF ! New site       
	IF(j==MAXATM) THEN
					IF (residue_name(j)(1:5) == 'PPDI') THEN
						N_PPDI=N_PPDI+1
                	END IF
					IF (residue_name(j)(1:5) == '8poly') THEN
						N_PBDT_TS1_segments=N_PBDT_TS1_segments+1
					END IF 
	END IF        
END DO

a=0
b=0
c=0
c_old=0
d=0
WRITE(*,*) 'N_PBDT_TS1_Intra: ', N_PBDT_TS1_Intra,' N_PPDI: ',N_PPDI,' N_PBDT_TS1_segments: ',N_PBDT_TS1_segments
ALLOCATE(intra_theta_E(N_PBDT_TS1_Intra,9)) ! 1= theta , 2=dE_in_el,   3=dE_in_lo, 4=|J_AB(el)| , 5=|J_AB(lo)| 
!! Speichert die Resids der Sites
!! R_intra(i,j) :: i=[1,N_PBDT_TS1_Intra] pairs for intramolecular transport j=1 Resid1 ; j=2 Resid2 ; j=3 NSchwefel_Resid1 ; j=4 N_Schewfel_Resid2 ; j=5 angle type = AB =1 , BA =2
ALLOCATE(R_intra(N_PBDT_TS1_Intra,5)) 

!! Speichert die Reihenfolge der ABFOLGE A, B, AB etc. A= CarboxyS2 ; B=PBDT
ALLOCATE(polymer_sequences(N_PBDT_TS1_Intra,2))
polymer_sequences=''

!! Speichert ResidX in PBDT_TS1 subsegment und die entsprechende Resid kette im long_chain, wenn der intramolekular transport vernachlaessigbar ist.
ALLOCATE(ResidX_in_long_chain(N_PBDT_TS1_segments+N_PPDI,2))
ResidX_in_long_chain=0
i_PBDT_TS1long_chain=0

intra_theta_E=0
R_intra=0

IF ( N_PPDI /= 0) THEN
	DO j=1,N_PPDI
		ResidX_in_long_chain(j,:)=j
	END DO
END IF


! Berechnung der Winkel theta
Count_theta=0
Count_segments=0
calc_theta=.false.

Old_Resid=residue_number(1)
N_CarboxyS2=0
N_PBDT=0
N_Schwefel=0
i=1
segtype=''
sequence=''
DO j=1,MAXATM
        IF ( residue_name(j) == '8poly' ) THEN                                
        	IF (TRIM(adjustl(atom(j)))=='F')  N_CarboxyS2=N_CarboxyS2+1
        	IF (TRIM(adjustl(atom(j)))=='HC') N_PBDT=N_PBDT+1
			IF (TRIM(adjustl(atom(j)))=='S')  N_Schwefel=N_Schwefel+1
			
			!! j=startindex erstes CarboxyS2 in der Kette
			IF( TRIM(adjustl(atom(j+3)))=='F'.and. TRIM(adjustl(atom(j-1)))=='CH3' .and. TRIM(adjustl(atom(j+7)))=='OE' ) THEN
				segtype='A'
				sequence=TRIM(sequence)//TRIM(segtype)
				CYCLE		
			!! j=startindex neues CarboxyS2  (ausser der Kettenstart 
			ELSE IF( TRIM(adjustl(atom(j+3)))=='F' .and. TRIM(adjustl(atom(j-1)))=='HC') THEN				
				IF  (   (TRIM(adjustl(atom(j+14))) =='S') .and. (TRIM(adjustl(atom(j))) =='C')  &
				& .and. (TRIM(adjustl(atom(j-3 ))) =='C') .and. (TRIM(adjustl(atom(j-4))) == 'S')) THEN 
					segtype='A'
					sequence=TRIM(sequence)//TRIM(segtype)
					a=koordA(j-4,:)
					b=koordA(j-3,:)
					c=koordA(j,:)
					d=koordA(j+14,:)
				ELSE 
					WRITE(*,*) 'Error reading CarboxyS2 in chain at atom: ',j,atom(j),koordA(j,:)
					CALL EXIT (1)
				END IF
			!! neues PBDT j=startindex 
			ELSE IF (       (TRIM(adjustl(atom(j+1)))=='S') .and. (TRIM(adjustl(atom(j+10)))=='HC') ) THEN
				IF  (   (TRIM(adjustl(atom(j+1))) =='S') .and. (TRIM(adjustl(atom(j))) =='C')  &
				& .and. (TRIM(adjustl(atom(j-2 ))) =='C') .and. (TRIM(adjustl(atom(j-1))) == 'S')) THEN 
					segtype='B'
					sequence=TRIM(sequence)//TRIM(segtype)
					a=koordA(j-1,:)
					b=koordA(j-2,:)
					c=koordA(j,:)
					d=koordA(j+1,:)
				ELSE 
					WRITE(*,*) 'Error reading PBDT in chain at atom: ',j,atom(j),koordA(j,:)
					CALL EXIT (1)
				END IF
			END IF
			
			!!! New Resid 
            IF ( Old_Resid /= residue_number(j) ) THEN 										
                                IF ( (atom(j)(1:3) /= 'CH3') .AND. (atom(j-1)(1:3)/='CH3') .AND. (residue_name(j-1)=='8poly') )THEN  ! neuer ketten start 
                                        calc_theta=.true.
								ELSE  ! Schwefel am Kettenende
									! Index fur 17x17 matrix
									IF (residue_name(j-1) /='PPDI_') THEN 
									
										!! complete chain
										IF( TRIM(ADJUSTL(sequence)) == 'ABABABABABABABAB' ) THEN											
											IF(DEBUG) WRITE(*,*) 'No intramolecular transfer in ',residue_number(j-1),TRIM(sequence)
										ELSE								
											!WRITE(*,*) residue_number(j),koordA(j,:),'End sequence:'//TRIM(sequence)
											R_intra(Count_theta,3)=PBDT_TS1_sequence_to_index(sequence)
											polymer_sequences(Count_theta,1)=TRIM(sequence)
										END IF
										
										N_CarboxyS2=0
										N_PBDT=0
										N_Schwefel=0
										sequence=''
										!WRITE(*,*) 'End of chain: ',j,residue_number(j-1),residue_name(j-1),residue_number(j),residue_name(j)
									END IF ! NO PPDI_
                                END IF
                                            
								Old_Resid=residue_number(j)
             END IF
                 

		
		!!check resid in which long_chain: Here check if new long_chain starts
		IF( ( (residue_name(j)(1:5) == '8poly') .AND. &
		& ( (atom(j)(1:3) == 'CH3') .AND. (atom(j-1)(1:3) == 'CH3') .AND. (TRIM(adjustl(atom(j+4))) == 'F') ) ) .OR. &
		&   ( (residue_name(j)(1:5) == '8poly') .AND. (j == 1) ) .OR. &
		&   ( (residue_name(j)(1:5) == '8poly') .AND. (residue_name(j-1)(1:5) == 'PPDI_') ) ) THEN
			i_PBDT_TS1long_chain=i_PBDT_TS1long_chain+1
			
			!! Resid in long_chain mapping schema
			Count_segments=Count_segments+1
			ResidX_in_long_chain(Count_segments+N_PPDI,1)=Count_segments+N_PPDI !residue_number(j)
			ResidX_in_long_chain(Count_segments+N_PPDI,2)=i_PBDT_TS1long_chain+N_PPDI
		END IF
        END IF ! THP ?
        
        IF (calc_theta) THEN
                CALL calc_dihedral(a,b,c,d,theta)
                sequence=TRIM(sequence(:LEN_TRIM(sequence)-1))   
                IF(DEBUG) WRITE(*,*) residue_number(j),'theta:',theta,' segtype:',segtype,' sequence(j-1):'//TRIM(sequence)
                Count_theta=Count_theta+1
                intra_theta_E(Count_theta,1)=theta
                R_intra(Count_theta,1)=residue_number(j)
                R_intra(Count_theta,2)=residue_number(j)-1
				R_intra(Count_theta,4)=PBDT_TS1_sequence_to_index(sequence)
				polymer_sequences(Count_theta,2)=TRIM(sequence)
				
				IF(segtype=='B') THEN		!N_CarboxyS2 == N_PBDT/6 +1) THEN
					!angle_type(Count_theta)=1 !'AB'
					R_intra(Count_theta,5)=1
					if(debug) WRITE(*,*) 'AB'
				ELSE IF (segtype=='A') THEN             !N_CarboxyS2 == N_PBDT/6) THEN
					!angle_type(Count_theta)=!  'BA'
					R_intra(Count_theta,5)=2
					if(debug) WRITE(*,*) 'BA'
				ELSE
					WRITE(*,*) 'calc_theta: ',calc_theta,' theta:',theta,' Elemente A:',N_CarboxyS2,' Elemente B:',N_PBDT/6
					WRITE(*,*) 	'R_intra: ',R_intra(Count_theta,:)
					WRITE(*,*) 'Error in determination of AB or BA order in PBDT-TS1 segmentation.'
					WRITE(*,*) 'Check if the input *.gro is ordered !'
					CALL EXIT (1)
				END IF ! AB or BA segment order
				

				IF( (Count_theta/=1) .AND. ( R_intra(Count_theta,2) == R_intra(Count_theta-1,1)) ) THEN
					R_intra(Count_theta-1,3)=R_intra(Count_theta,4)
					polymer_sequences(Count_theta-1,1)=polymer_sequences(Count_theta,2)
				END IF
				sequence=TRIM(segtype) 
				!IF( (Count_theta/=1) .AND. DEBUG ) THEN
				!	WRITE(*,*) 'Check -1: ',R_intra(Count_theta-1,1),R_intra(Count_theta-1,2),R_intra(Count_theta-1,3),&
				!											   &R_intra(Count_theta-1,4),R_intra(Count_theta-1,5)
				!END IF		
								
				N_CarboxyS2=0
				N_PBDT=0
				N_Schwefel=0
				Count_segments=Count_segments+1
				!! Resid in long_chain mapping schema
				ResidX_in_long_chain(Count_segments+N_PPDI,1)=Count_segments+N_PPDI   		!residue_number(j)
				ResidX_in_long_chain(Count_segments+N_PPDI,2)=i_PBDT_TS1long_chain+N_PPDI
				
				calc_theta=.false. 
        END IF ! calc_theta
		

		IF (j==MAXATM) THEN
			IF(residue_name(j)(1:5) == '8poly') THEN
				WRITE(*,*) 'ENDE:',N_CarboxyS2,N_PBDT/6,sequence
				R_intra(Count_theta,3)=PBDT_TS1_sequence_to_index(sequence)
				polymer_sequences(Count_theta,1)=TRIM(sequence)
				sequence=''
			END IF 
		END IF 
END DO ! j - Schleife ueber alle Atome


!! Change order form B->A to A->B
DO i=1,N_PBDT_TS1_Intra
	j=R_intra(i,1)
	R_intra(i,1)=R_intra(i,2)
	R_intra(i,2)=j
	
	j=R_intra(i,3)
	R_intra(i,3)=R_intra(i,4)
	R_intra(i,4)=j	
	
	sequence=TRIM(polymer_sequences(i,1))
	polymer_sequences(i,1)=TRIM(polymer_sequences(i,2))
	polymer_sequences(i,2)=TRIM(sequence)
END DO 




IF (i_PBDT_TS1long_chain /= 464) THEN
	WRITE(*,*) 'Consistence check: Number of found long_chain is not 464 :',i_PBDT_TS1long_chain
	WRITE(*,*) 'Revise input or implementation'
	CALL EXIT(1)
END IF

IF (N_PBDT_TS1_Intra /= Count_theta) THEN
	WRITE(*,*) 'Count_theta: ', Count_theta,' N_PBDT_TS1_Intra:', N_PBDT_TS1_Intra
	WRITE(*,*) 'Error: Mismatch in the number of determined intramolecular charge transfer segments, check input and implementation.'
	CALL EXIT(1)
END IF


IF(DEBUG) THEN
	WRITE(*,*) 'List with resid pairs and indizes '
	DO i=1,N_PBDT_TS1_Intra
		WRITE(*,*) 'Resid_1, Resid_2, N_S1, N_S2   theta',R_intra(i,1),R_intra(i,2),R_intra(i,3),R_intra(i,4),intra_theta_E(i,1),&
					&R_intra(i,5),TRIM(polymer_sequences(i,1)),'   ',TRIM(polymer_sequences(i,2))
	END DO 
END IF ! DEBUG

!!! Shift relative resid_index to compensate the index offset between.
j=ResidX_in_long_chain(1,1)-residue_number(1)
DO i=1,N_PBDT_TS1_segments+N_PPDI
	ResidX_in_long_chain(i,:)=ResidX_in_long_chain(i,:)-j
END DO 

IF(DEBUG) THEN
	WRITE(*,*) ' i_PBDT_TS1long_chain: ',i_PBDT_TS1long_chain
	WRITE(*,*) ' Count_segments: ',Count_segments
	WRITE(*,*) ' Resid 1 and Resid in PBDT_TS1-long_chain:  ResidX_in_long_chain(i,) '
	DO i=1,N_PBDT_TS1_segments+N_PPDI
		WRITE(*,*) ResidX_in_long_chain(i,1),ResidX_in_long_chain(i,2)
	END DO
	WRITE(*,*) ' ENDE Resid 1 and Resid in PBDT_TS1-long_chain:  ResidX_in_long_chain(i,) '
END IF ! DEBUG





IF (read_intramolecular_data) THEN
    !! Read dE_in_lo
    !! 1= theta , 2=dE_in_el,   3=dE_in_lo, 4=|J_AB(el)| , 5=|J_AB(lo)|  6=k_intra_el 7=k_intra_lo 
    CALL read_intramolecular_file(PBDT_TS1_AB_dE_intr_in_lo_file,intra_data_AB,N_intra_lines_AB)
    CALL read_intramolecular_file(PBDT_TS1_BA_dE_intr_in_lo_file,intra_data_BA,N_intra_lines_BA)
    DO j=1,N_PBDT_TS1_Intra          
        !!! Segmentation AB
	IF( INT(R_intra(j,5))==1) THEN 
        	IF ( intra_theta_E(j,1) > 0 ) THEN        
            		intra_theta_E(j,3)=intra_data_AB(NINT(10*intra_theta_E(j,1))+1,2) !Rundet den werrt des Winkel zum Index des Integers
        	ELSE
            		intra_theta_E(j,3)=intra_data_AB(NINT(10*(intra_theta_E(j,1)+360))+1,2) !Rundet den werrt des Winkel zum Index des Integers
        	END IF 
        	!WRITE(*,*) intra_theta_E(j,1),intra_data_AB(INT(10*intra_theta_E(j,1))+1,1),&
			!	&intra_data_AB(INT(10*intra_theta_E(j,1))+1,2)
	ELSE IF (INT(R_intra(j,5))==2) THEN 
	!!! Segmentation BA
        	IF ( intra_theta_E(j,1) > 0 ) THEN        
            		intra_theta_E(j,3)=intra_data_BA(NINT(10*intra_theta_E(j,1))+1,2) !Rundet den werrt des Winkel zum Index des Integers
        	ELSE
            		intra_theta_E(j,3)=intra_data_BA(NINT(10*(intra_theta_E(j,1)+360))+1,2) !Rundet den werrt des Winkel zum Index des Integers
        	END IF 
        	!WRITE(*,*) intra_theta_E(j,1),intra_data_BA(INT(10*intra_theta_E(j,1))+1,1),&
			!	&intra_data_BA(INT(10*intra_theta_E(j,1))+1,2)
	END IF
    END DO 


    !! Read dE_in_el
    !! 1= theta , 2=dE_in_el,   3=dE_in_lo, 4=|J_AB(el)| , 5=|J_AB(lo)|  6=k_intra_el 7=k_intra_lo 
    CALL read_intramolecular_file(PBDT_TS1_AB_dE_intr_in_el_file,intra_data_AB,N_intra_lines_AB)
    CALL read_intramolecular_file(PBDT_TS1_BA_dE_intr_in_el_file,intra_data_BA,N_intra_lines_BA)
    DO j=1,N_PBDT_TS1_Intra          
        !!! Segmentation AB
	IF( INT(R_intra(j,5))==1) THEN 
        	IF ( intra_theta_E(j,1) > 0 ) THEN        
            		intra_theta_E(j,2)=intra_data_AB(NINT(10*intra_theta_E(j,1))+1,2) !Rundet den werrt des Winkel zum Index des Integers
        	ELSE
            		intra_theta_E(j,2)=intra_data_AB(NINT(10*(intra_theta_E(j,1)+360))+1,2) !Rundet den werrt des Winkel zum Index des Integers
        	END IF 
        	!WRITE(*,*) intra_theta_E(j,1),intra_theta_E(j,2),intra_data_AB(INT(10*intra_theta_E(j,1))+1,1),&
			!	&intra_data_AB(INT(10*intra_theta_E(j,1))+1,2)
	ELSE IF (INT(R_intra(j,5))==2) THEN 
	!!! Segmentation BA
        	IF ( intra_theta_E(j,1) > 0 ) THEN        
            		intra_theta_E(j,2)=intra_data_BA(NINT(10*intra_theta_E(j,1))+1,2) !Rundet den werrt des Winkel zum Index des Integers
        	ELSE
            		intra_theta_E(j,2)=intra_data_BA(NINT(10*(intra_theta_E(j,1)+360))+1,2) !Rundet den werrt des Winkel zum Index des Integers
        	END IF 
        	!WRITE(*,*) intra_theta_E(j,2),intra_data_BA(INT(10*intra_theta_E(j,1))+1,1),&
			!	&intra_data_BA(INT(10*intra_theta_E(j,1))+1,2)
	END IF
    END DO 


    !! Read |J_AB(el)|
    IF ( use_fit ) THEN
        !!! use intramolecular electron fit / preliminary version /cosfit
        WRITE(*,*) ' use cosfit for |J_AB_intra(el)| '
        DO j=1,N_PBDT_TS1_Intra
            IF ( intra_theta_E(j,1) < 0 ) then
                theta=360+intra_theta_E(j,1)
            ELSE
                theta=intra_theta_E(j,1)
            END IF ! 
            IF ((theta > 90) .AND. (theta < 270)) THEN
                intra_theta_E(j,4)=  0.42*abs( cos( theta *PI/180.0))+0.28
            ELSE
                intra_theta_E(j,4)=  0.65*abs( cos( theta *PI/180.0))+0.28
            END IF
            WRITE(*,*) intra_theta_E(j,1),intra_theta_E(j,4)
        END DO 
    ELSE     


	!! Read |J_AB(el)| in for AB and BA combinations AB == CarboxyS2 to PBDT   and   BA = PBDT to CarboxyS2
    CALL read_intramolecular_file(PBDT_TS1_AB_J_intra_in_el_file,intra_data_AB,N_intra_lines_AB)
    CALL read_intramolecular_file(PBDT_TS1_BA_J_intra_in_el_file,intra_data_BA,N_intra_lines_BA)
    !! 1= theta , 2=dE_in_el,   3=dE_in_lo, 4=|J_AB(el)| , 5=|J_AB(lo)|  6=k_intra_el 7=k_intra_lo 

	DO j=1,N_PBDT_TS1_Intra
        !!! Segmentation AB
		IF( INT(R_intra(j,5))==1) THEN 
		    IF ( intra_theta_E(j,1) > 0 ) THEN
		        intra_theta_E(j,4)=intra_data_AB(NINT(10*intra_theta_E(j,1))+1,2) !Rundet den werrt des Winkel zum Index des Integers
		    ELSE
		        intra_theta_E(j,4)=intra_data_AB(NINT(10*(intra_theta_E(j,1)+360))+1,2)
		    END IF 
		    !WRITE(*,*) intra_theta_E(j,4),intra_data_AB(INT(10*intra_theta_E(j,1))+1,1),intra_data_AB(INT(10*intra_theta_E(j,1))+1,2)
		 ELSE IF (INT(R_intra(j,5))==2) THEN 
		    IF ( intra_theta_E(j,1) > 0 ) THEN
		        intra_theta_E(j,4)=intra_data_BA(NINT(10*intra_theta_E(j,1))+1,2) !Rundet den werrt des Winkel zum Index des Integers
		    ELSE
		        intra_theta_E(j,4)=intra_data_BA(NINT(10*(intra_theta_E(j,1)+360))+1,2)
		    END IF 	    	
		END IF !BA
		!WRITE(*,*) intra_theta_E(j,1),intra_theta_E(j,4)!,intra_data_BA(INT(10*intra_theta_E(j,1))+1,1),intra_data_BA(INT(10*intra_theta_E(j,1))+1,2)	
	END DO 


    END IF        ! Read |J_AB(el)|     
  


    !  Read |J_AB(lo)| from splinefit
    CALL read_intramolecular_file(PBDT_TS1_AB_J_intra_in_lo_file,intra_data_AB,N_intra_lines_AB) 
    CALL read_intramolecular_file(PBDT_TS1_BA_J_intra_in_lo_file,intra_data_BA,N_intra_lines_BA) 
    DO j=1,N_PBDT_TS1_Intra
        !!! Segmentation AB
		IF( INT(R_intra(j,5))==1) THEN 
				IF ( intra_theta_E(j,1) > 0 ) THEN
						intra_theta_E(j,5)=intra_data_AB(NINT(10*intra_theta_E(j,1))+1,2)  !NINT Rundet den wert des Winkel zum Index des Integers
				ELSE
						intra_theta_E(j,5)=intra_data_AB(NINT(10*(intra_theta_E(j,1)+360))+1,2)
				END IF   
		ELSE IF (INT(R_intra(j,5))==2) THEN
				IF (intra_theta_E(j,1) > 0 ) THEN
						intra_theta_E(j,5)=intra_data_BA(NINT(10*intra_theta_E(j,1))+1,2)  !NINT Rundet den wert des Winkel zum Index des Integers
				ELSE
						intra_theta_E(j,5)=intra_data_BA(NINT(10*(intra_theta_E(j,1)+360))+1,2)
				END IF  
		END IF 
    END DO 

END IF  ! read_intramolecular_data

IF(DEBUG) THEN
    j=1
    WRITE(*,*) 'Intramolecular:',j,intra_theta_E(j,1),intra_theta_E(j,2),intra_theta_E(j,3),intra_theta_E(j,4),intra_theta_E(j,5)
END IF 
    DO j=1,N_PBDT_TS1_Intra
		DO i=1,5
			IF ( ISNAN(intra_theta_E(j,i)) ) THEN
				WRITE(*,*) j,i,'Caution NaN in intra_theta_E array:', intra_theta_E(j,:)
			END IF
		END DO
    END DO


END SUBROUTINE   winkel_intra_PBDT_TS1   




INTEGER FUNCTION PBDT_TS1_sequence_to_index(sequence)
	use small_functions
	IMPLICIT NONE
	CHARACTER(LEN=50), INTENT(IN)::sequence
	LOGICAL::DEBUG=.false.
	INTEGER::i
	
	IF( TRIM(adjustl(sequence)) == 'A') THEN
		i=2
	ELSE IF ( TRIM(adjustl(sequence)) == 'B')THEN
		i=3
	ELSE IF ( (TRIM(adjustl(sequence)) == 'AB') .OR. (TRIM(adjustl(sequence)) == 'BA') )THEN
		i=4
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABA')THEN
		i=5
	ELSE IF ( TRIM(adjustl(sequence)) == 'BAB')THEN
		i=6		
	ELSE IF ( (TRIM(adjustl(sequence)) == 'ABAB') .OR. (TRIM(adjustl(sequence)) == 'BABA') )THEN
		i=7	
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABABA')THEN
		i=8		
	ELSE IF ( TRIM(adjustl(sequence)) == 'BABAB')THEN
		i=9		
	ELSE IF ( (TRIM(adjustl(sequence)) == 'ABABAB') .OR. (TRIM(adjustl(sequence)) == 'BABABA') )THEN
		i=10	
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABABABA')THEN
		i=11		
	ELSE IF ( TRIM(adjustl(sequence)) == 'BABABAB')THEN
		i=12			
	ELSE IF ( (TRIM(adjustl(sequence)) == 'ABABABAB') .OR. (TRIM(adjustl(sequence)) == 'BABABABA') )THEN
		i=13		
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABABABABA')THEN
		i=14		
	ELSE IF ( TRIM(adjustl(sequence)) == 'BABABABAB')THEN
		i=14
	ELSE IF ( (TRIM(adjustl(sequence)) == 'ABABABABAB') .OR. (TRIM(adjustl(sequence)) == 'BABABABABA') )THEN
		i=15
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABABABABABA')THEN
		i=15		
	ELSE IF ( TRIM(adjustl(sequence)) == 'BABABABABAB')THEN
		i=15
	ELSE IF ( (TRIM(adjustl(sequence)) == 'ABABABABABAB') .OR. (TRIM(adjustl(sequence)) == 'BABABABABABA') )THEN ! 6mer
		i=16
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABABABABABABA')THEN ! 6mer
		i=16		
	ELSE IF ( TRIM(adjustl(sequence)) == 'BABABABABABAB')THEN ! 7mer
		i=17	
	ELSE IF ( (TRIM(adjustl(sequence)) == 'ABABABABABABAB') .OR. (TRIM(adjustl(sequence)) == 'BABABABABABABA') )THEN ! 7mer
		i=17
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABABABABABABABA')THEN ! 7mer
		i=17		
	ELSE IF ( TRIM(adjustl(sequence)) == 'BABABABABABABAB')THEN ! 8mer
		i=17
	ELSE IF ( (TRIM(adjustl(sequence)) == 'ABABABABABABABAB') .OR. (TRIM(adjustl(sequence)) == 'BABABABABABABABA') )THEN ! 8mer
		i=17
	ELSE IF ( TRIM(adjustl(sequence)) == 'ABABABABABABABABA')THEN								  
		i=17		
	ELSE IF ( TRIM(adjustl(sequence)) == 'BABABABABABABABAB')THEN
		i=17					
	ELSE IF ( TRIM(adjustl(sequence)) == 'PPDI' .OR. TRIM(adjustl(sequence)) == 'PPDI_') THEN
		i=1
	ELSE
		WRITE(*,*) 'Error: string input to PBDT_TS1_sequence_to_index was not determined: '//TRIM(sequence)
		CALL EXIT (1)
	END IF
	IF (DEBUG) WRITE(*,*) 'PBDT_TS1_sequence_to_index sequence:   ',TRIM(sequence),' index:',i	
	PBDT_TS1_sequence_to_index=i
	
END FUNCTION PBDT_TS1_sequence_to_index

!!!!!!!!!!!!! END SUBROUTINES FOR PPDI / PBDT-TS1!!!!!!!!!!



INTEGER FUNCTION get_Geo_Step_from_filename(inputfilename)
		IMPLICIT NONE
		CHARACTER(LEN=*)::inputfilename
		CHARACTER(LEN=500)::dummyname
		INTEGER::Geo_Step
		Geo_Step=0
		
		IF( INDEX(inputfilename,'_G') /= 0) THEN !! Get geometry step _G${Geo_Step} from name in gro_inputfile.gro
			!! rest string 
			dummyname=TRIM(inputfilename(INDEX(inputfilename,'_G')+2:))
			!WRITE(*,*) TRIM(dummyname)
			IF ( INDEX(dummyname,'_')  /= 0) THEN !! cut at next delimiter "_"
				!WRITE(*,*) dummyname(:INDEX(dummyname,'_')-1)
				READ(dummyname(:INDEX(dummyname,'_')-1),'(I6)') Geo_Step
				 
			ELSE IF ( INDEX(dummyname,'.')  /= 0) THEN
				!WRITE(*,*) dummyname(:INDEX(dummyname,'.')-1)
				READ(dummyname(:INDEX(dummyname,'.')-1),'(I6)') Geo_Step
				!WRITE(*,*) Geo_Step
				
			ELSE
				WRITE(*,*) 'Error: _G${Geo_Step} could not be determined from filename: '//TRIM(inputfilename)
				WRITE(*,*) ' Separate with "_" or "."  e.g. indexed_G1.gro as indexed_G1_T300.gro '
				CALL EXIT(1)
			END IF

		ELSE
				WRITE(*,*) 'Error: _G${Geo_Step} could not be determined from filename: '//TRIM(inputfilename)
				WRITE(*,*) ' Separate with "_" or "."  e.g. indexed_G1.gro as indexed_G1_T300.gro '
				CALL EXIT(1)
		END IF
		get_Geo_Step_from_filename=Geo_Step
END FUNCTION get_Geo_Step_from_filename



end module rates_to_votca_sqlfile
!!!!-------------------------------------------------------------------------------------------------------------------!!!
!!!! END module  my_rates_to_votca_sql.out                                                                             !!!
!!!!-------------------------------------------------------------------------------------------------------------------!!!






!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!!    calc_current_I_from_kmc_data:
!!!    module to evaluate the local currents and hopping sites with high occupation numbers from the kmc simulations
!!! ------------------------------------------------------------------------------------------------------------------- !!!
module calc_current_I_from_kmc_data
	!! ADD global variables here


CONTAINS
	!! Calculate the current in the kmc simulations from data in votca.sql files
	!! Programm to read the occupation file with the averaged occupation, no_box_COM_file
SUBROUTINE current_I_form_votca_sql_data
	use small_functions
	use KMC_class
	implicit none
	type(KMC_setup_t) :: setup
	REAL, ALLOCATABLE, DIMENSION(:,:)   :: no_box_koord,dr_pair,marcus_rate_data,J_site_ges,J_pairs,J_site_ges_0_1
	REAL, ALLOCATABLE, DIMENSION(:)     :: tot_occ_data,J_norm_all,Array1
	INTEGER,ALLOCATABLE, DIMENSION(:,:) :: seg1_seg2_marcus_rate
	INTEGER,ALLOCATABLE, DIMENSION(:)   :: id_tot_occ,id_marcus_rate
	CHARACTER(LEN=5), ALLOCATABLE, DIMENSION(:):: elements
	Character(500)                      :: method,tot_occ_filename,marcus_rate_filename,no_box_COM_file
	Character(500)                      :: current_I_out_filename,votca_sql_filename,CUBE_filename,CUBE_filename1
	Character(500)                      :: filename,current_pdb_filename,dummyname,occupation_pdb_filename
	Character(500)                      :: carriertype
	INTEGER :: N_Resids,N_tot_occ_lines,N_pairs
	LOGICAL :: 	use_logscale_p_occ=.false.
	LOGICAL :: Datei_vorhanden,use_logscale_I,scale_to_interval_0_1,read_reference_grofile
	!!! total current vector J_ges
	REAL, DIMENSION(3) ::dr,J_ges,J_ges_norm_vec
	REAL::occ_i,J_s,J_norm,J_max,J_min,J_average,J_sigma,J_norm_cutoff,J_max_percent_cutoff
	INTEGER::i,k,ierror
	LOGICAL:: make_current_to_cubefile,current_only_use_sites_with_highest_contributions=.false.
    !!! CUBEFILE GENERATION
    integer  :: xlen,ylen,zlen,ix,iy,iz
	real     :: xbox,ybox,zbox,scalebox
	!!! cubedata(1:xlen,1:ylen,1:zlen) ! 3D Daten INPUT
    real*8 , ALLOCATABLE, DIMENSION (:,:,:) :: cubedata,cubedata_Ix,cubedata_Iy,cubedata_Iz,cubedata_0_to_1
	INTEGER, ALLOCATABLE, DIMENSION (:)     :: atomicnumber
	REAL, PARAMETER :: anstroem_to_bohr=1.889725989
	REAL, PARAMETER :: elementary_charge=1.60217662E-19 ! coulombs
	
	!! Maximum and minimal coordinate in the no_box_koord array
	REAL, DIMENSION(3)::bmin,bmax	
	LOGICAL, ALLOCATABLE, DIMENSION(:):: J_for_Resid_ok
	REAL :: norm_J_ges,scale_J_vmd_factor
    !!! boxsize data in angstroem
    REAL:: x_box,y_box,z_box
    REAL:: av_J,sigma_J
    REAL:: nm2Ang=10.0 !,Ang2nm=0.1
    REAL, PARAMETER:: Ang2m=1.0E-10, m2Ang=1.0E10
    LOGICAL::wrap_all_molecules_into_the_box,calc_high_current_pathway
    LOGICAL :: set_filenames=.false.
    LOGICAL :: read_options_from_xml=.false.
	Character(500)                      :: input_options_filename_xml="options.xml"
	!!! grofile data as a reference. It is not mendatory for the current evaluation
		CHARACTER(LEN=500)                             :: gro_inputfile
		Character(5), ALLOCATABLE, Dimension(:)        :: atomsorteA,residue_names
		REAL, ALLOCATABLE, DIMENSION(:,:)              :: koordA,vel
		INTEGER, ALLOCATABLE, DIMENSION(:)             :: residue_numbers,atom_numbers
		INTEGER, ALLOCATABLE, DIMENSION(:,:)           :: R_u_I
		INTEGER::Gesamtanzahl
	!! occupation data
	REAL::occ_min,occ_max,occ_average
	LOGICAL, ALLOCATABLE, Dimension(:)   :: p_occ_for_Resid_ok
	REAL::p_occ_max_percent_cutoff
	LOGICAL::occupations_only_use_sites_with_highest_contributions=.true.
	REAL::p_occ_cutoff
	INTEGER::N_unoccupied_sites
	
	!! occupation data scale line make pdb file
	CHARACTER(LEN=500) ::occ_scale_pdb_filename
	LOGICAL:: make_scale_p_occ_pdb
	INTEGER :: N_occ_scale_points
	REAL, ALLOCATABLE, DIMENSION(:) :: scale_p_occ_data
	REAL, ALLOCATABLE, DIMENSION(:,:)  :: scale_p_occ_koord
	Character(5), ALLOCATABLE, Dimension(:)        :: scale_p_occ_atomsorte
	LOGICAL, ALLOCATABLE, Dimension(:)   ::scale_p_occ_ok
	
   !! current data scale line make pdb file
	CHARACTER(LEN=500) ::I_scale_pdb_filename
	LOGICAL:: make_scale_I_pdb
	INTEGER :: N_I_scale_points
	REAL, ALLOCATABLE, DIMENSION(:)         :: scale_I_data
	REAL, ALLOCATABLE, DIMENSION(:,:)       :: scale_I_koord
	Character(5), ALLOCATABLE, Dimension(:) :: scale_I_atomsorte
	LOGICAL, ALLOCATABLE, Dimension(:)       ::scale_I_ok
	LOGICAL :: calc_local_current_dr
	
	write(*,*) '======================================='
	write(*,*) '|   calculate electronic current I    |'
	write(*,*) '======================================='
	
	
	
	
	!!   Use local current as in VOTCA manual (Eq.2.43) calc_local_current_dr =.true. 
	!!
	!!	$\mathbf{I}_i = \frac{1}{2} e \sum_{j} ( p^{\text{occ}}_i k_{ij} - p^{\text{occ}}_j k_{ji}) \mathbf{d}_{ij}$
	!!  or
	!!  Caution: Is an increasing current with an increasing hopping distance usefull?
	!!  Alternative: calc_local_current_dr =.false.
	!!  $\mathbf{I}_i = \frac{1}{2} e \sum_{j} ( p^{\text{occ}}_i k_{ij} - p^{\text{occ}}_j k_{ji}) \mathbf{e}_{ij}$
	!!
	!!  Use the unite vector  $\mathbf{e}_{ij} = \mathbf{d}_{ij} / |d_{ij}|$ for the i -> j distance 
	calc_local_current_dr =.true.
	
	
	!! carriertype h / e ; hole or electron
	carriertype='h'
	scale_to_interval_0_1=.true.
	make_current_to_cubefile=.false.
	use_logscale_I=.true.
	!! calculate log10 from p_occ for the displayed occupation numbers default: use_logscale_p_occ=.true. 
	use_logscale_p_occ=.true.
	!! creates a *.pdb file with points in a row, which can form a coloured bar.
	make_scale_p_occ_pdb=.true.
	!! Number of points in the scale file
	N_occ_scale_points=100
	
	!! creates a *.pdb file with points in a row, which can form a coloured bar.
	make_scale_I_pdb=.true.
	N_I_scale_points=N_occ_scale_points
	
	
	current_only_use_sites_with_highest_contributions=.true.
	occupations_only_use_sites_with_highest_contributions=.true.
	calc_high_current_pathway=.false. 
	 
	 
	!!! grofile data for pdb with current in the occupation column
	gro_inputfile="my_grofile.gro" 	 
	read_reference_grofile=.true. 
	wrap_all_molecules_into_the_box=.true. 
	 
	 
	!! default boxzize in Angstroem
	!!x_box=139.0228  
	!!y_box=269.6753  
	!!z_box=145.8116
	
	x_box=321.4275
	y_box=101.3676  
	z_box=103.3919 
	
	
	!!! for the visualization in vmd. default: scale_J_vmd_factor=1.0
	scale_J_vmd_factor=10.0

	J_max_percent_cutoff=0.95       !!!0.0001 !!!0.9  !! [0.0,1.0]  e.g. J_max_percent_cutoff=0.9 only the highest  currents 10% are printed. J_max_percent_cutoff=1.0 => All are printed
	p_occ_max_percent_cutoff=0.95   !!!! highest 95 => highest 5 % of occupation numbers is printed

	!! scalefactor for partitioning of boxes. scalefactor = [0,1]
	!! good value: scalebox=0.03 DIPBI/P3HTcd !! only change small scale eg: 0.025 P3HT
	!!!
	scalebox=0.025


	!! default: do not change this
	read_options_from_xml=.false.
	input_options_filename_xml="options.xml"
	tot_occ_filename="tot_occ_filename.dat"
	marcus_rate_filename="marcus_rate_id_drX_drY_drZ_marcus_rate12_rate21.dat"
	no_box_COM_file="no_box_COM_file.xyz"
	votca_sql_filename="state.sql"
	current_I_out_filename="my_current_I_out_arrow_vmd.dat"
	
	set_filenames=.false.
	!! Suche options.xml filename
	CALL get_command_argument(1,method)
	DO i=2,command_argument_count()
				CALL get_command_argument(i,dummyname)
				IF (check_filetermination_and_continue(dummyname,'.xml')) THEN
					input_options_filename_xml=dummyname
					inquire(file=TRIM(input_options_filename_xml),exist=Datei_vorhanden) 
					IF( .not. Datei_vorhanden) THEN 
						WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(input_options_filename_xml)
						CALL EXIT (1)
					ELSE 
						WRITE(*,*) 'Use options: ',TRIM(input_options_filename_xml)
						read_options_from_xml=.true.
					END IF ! input_options_filename_xml   vorhanden. 
				END IF !!! suche *.xml file
	ENDDO

	IF( TRIM(method) == 'calc_current_I_xml' .and. read_options_from_xml ) THEN
		WRITE(*,*) 'use input_options_filename_xml: ',TRIM(input_options_filename_xml)
	ELSE IF(command_argument_count() >= 5) THEN         !Einlesen der Flags
		CALL get_command_argument(1,method)
		CALL get_command_argument(2,tot_occ_filename)  
		CALL get_command_argument(3,marcus_rate_filename) 
		CALL get_command_argument(4,no_box_COM_file)
		CALL get_command_argument(5,current_I_out_filename)
		
		IF(command_argument_count() >= 8) THEN 
			CALL get_command_argument(6,dummyname)  
			READ(dummyname,'(F10.3)') x_box 
			WRITE(*,*) 'x_box: ',x_box
			CALL get_command_argument(7,dummyname)  
			READ(dummyname,'(F10.3)') y_box
			WRITE(*,*) 'y_box: ',y_box
			CALL get_command_argument(8,dummyname)  
			READ(dummyname,'(F10.3)') z_box
			WRITE(*,*) 'z_box: ',z_box
			IF(command_argument_count() >= 9) THEN 
					CALL get_command_argument(9,gro_inputfile)  
					read_reference_grofile=.true.
			END IF
			IF(command_argument_count() >= 10) THEN 
					CALL get_command_argument(10,input_options_filename_xml)  
					read_options_from_xml=.true.
			END IF
		END IF
	ELSE
		WRITE(*,*) ' Calculates the current I in kmc simulations '
		WRITE(*,*) '    .. A) from the data files given as arguments in the command line.  [calc_current_I]'
		WRITE(*,*) '    .. B) from the data in state.sql files.  [calc_current_I_from_sql]'
		WRITE(*,*) '    .. C) from the data files in options.xml file. [calc_current_I_xml]'
		WRITE(*,*) ' '
		WRITE(*,*) ' Select an option:  [calc_current_I, calc_current_I_from_sql, calc_current_I_xml]  '
		WRITE(*,*) ' '
		WRITE(*,*) ' A) Use:   method             tot_occ_filename.dat  id_drX_drY_drZ_marcus_rate12_rate21.dat  '&
				&//' no_box_COM_file.xyz   current_I_out_filename.vmd  [optional: x_box,y_box,z_box, gro_inputfile, options.xml] '    
		WRITE(*,*) ' Use:   calc_current_I     tot_occ_filename.dat  id_drX_drY_drZ_marcus_rate12_rate21.dat  '&
				&//' no_box_COM_file.xyz   current_I_out_filename.vmd   139.0  269.7  145.8    morphology.gro    options.xml  '    
					
		WRITE(*,*) ' '
		WRITE(*,*) ' B) Use:   calc_current_I_from_sql     tot_occ_filename.dat  id_drX_drY_drZ_marcus_rate12_rate21.dat  '&
				&//' no_box_COM_file.xyz   current_I_out_filename.vmd   votca_sql_filename.sql  [optional:  options.xml] ' 
		WRITE(*,*) ' '
		WRITE(*,*) ' C) Use:      calc_current_I_xml         options.xml '

                CALL EXIT (1)
	END IF



	!! read the input parameters from an options.xml file
	IF( read_options_from_xml .and. file_exists_and_continue(input_options_filename_xml) .and. &
		& check_filetermination_and_continue(input_options_filename_xml,'.xml')) THEN
		write(*,*) 'Start reading options from  input_options_filename_xml. '//TRIM(input_options_filename_xml)
		call set_defaults_KMC_setup(setup)
		call read_votca_optionsfile(input_options_filename_xml,setup," calc_current_I  system")
		!!! Use data from setup in options.xml file.
			carriertype = setup%carriertype
			scale_to_interval_0_1= setup%scale_to_interval_0_1 
			make_current_to_cubefile= setup%make_current_to_cubefile
			use_logscale_I= setup%use_logscale_I 
			use_logscale_p_occ= setup%use_logscale_p_occ 
			make_scale_p_occ_pdb= setup%make_scale_p_occ_pdb 
			N_occ_scale_points= setup%N_occ_scale_points
			make_scale_I_pdb= setup%make_scale_I_pdb 
			N_I_scale_points= setup%N_I_scale_points
			current_only_use_sites_with_highest_contributions= setup%current_only_use_sites_with_highest_contributions 
			occupations_only_use_sites_with_highest_contributions= setup%occupations_only_use_sites_with_highest_contributions 
			calc_high_current_pathway= setup%calc_high_current_pathway 
			read_reference_grofile= setup%read_reference_grofile  
			wrap_all_molecules_into_the_box= setup%wrap_all_molecules_into_the_box  			
			scale_J_vmd_factor= setup%scale_J_vmd_factor
			J_max_percent_cutoff= setup%J_max_percent_cutoff   
			p_occ_max_percent_cutoff= setup%p_occ_max_percent_cutoff		
			scalebox= setup%scalebox			
			calc_local_current_dr = setup%calc_local_current_dr
			set_filenames= setup%set_filenames
			gro_inputfile= setup%gro_inputfile	
			if(   file_exists_and_continue(gro_inputfile) .and. &
				& (check_filetermination_and_continue(input_options_filename_xml,'.gro')) ) then
				read_reference_grofile=.true.
			endif
			if(set_filenames) then
				current_I_out_filename= setup%current_I_out_filename
				tot_occ_filename= setup%tot_occ_filename         
				marcus_rate_filename= setup%marcus_rate_filename  
				no_box_COM_file= setup%no_box_COM_file  
				votca_sql_filename = setup%votca_sql_name
			else
				write(*,*) 'set_filenames: ',set_filenames
			endif
			
			write(*,*)  'carriertype: ',trim(carriertype)
			write(*,*)  'scale_to_interval_0_1: ',scale_to_interval_0_1                                                                                                
			write(*,*)  'make_current_to_cubefile: ',make_current_to_cubefile                                                                                               
			write(*,*)  'use_logscale_I: ', use_logscale_I                                                                                                                 
			write(*,*)  'use_logscale_p_occ:  ',use_logscale_p_occ                                                                                                         
			write(*,*)  'make_scale_p_occ_pdb:  ',make_scale_p_occ_pdb                                                                                                   
			write(*,*)  'N_occ_scale_points:  ',N_occ_scale_points                                                                                                          
			write(*,*)  'make_scale_I_pdb:  ', make_scale_I_pdb                                                                                                           
			write(*,*)  'N_I_scale_points: ', N_I_scale_points                                                                                                             
			write(*,*)  'current_only_use_sites_with_highest_contributions:  ', current_only_use_sites_with_highest_contributions                                                          
			write(*,*)  'occupations_only_use_sites_with_highest_contributions:', occupations_only_use_sites_with_highest_contributions                                                    
			write(*,*)  'calc_high_current_pathway: ', calc_high_current_pathway                                                                                            
			write(*,*)  'read_reference_grofile:  ', read_reference_grofile                                                                                                    
			write(*,*)  'wrap_all_molecules_into_the_box:  ', wrap_all_molecules_into_the_box                                                                                    
			write(*,*)  'scale_J_vmd_factor:   ', scale_J_vmd_factor                                                                                                         
			write(*,*)  'J_max_percent_cutoff: ', J_max_percent_cutoff                                                                                                     
			write(*,*)  'p_occ_max_percent_cutoff: ', p_occ_max_percent_cutoff                                                                                              
			write(*,*)  'scalebox: ',scalebox                                                                                                                  
			write(*,*)  'set_filenames: ', set_filenames                                                                                                                 
			write(*,*)  'gro_inputfile: ',trim(gro_inputfile)                                                                                                          
			write(*,*)  'current_I_out_filename: ',trim(current_I_out_filename)                                                                                            
			write(*,*)  'tot_occ_filename:  ', trim(tot_occ_filename)                                                                                                    
			write(*,*)  'marcus_rate_filename: ', trim(marcus_rate_filename)                                                                                             
			write(*,*)  'no_box_COM_file: ',trim(no_box_COM_file)                                                                                                     
			write(*,*)  'votca_sql_filename: ', trim(votca_sql_filename)     
			
	END IF ! read_options_from_xml
	
	
	IF ( TRIM(method) == 'calc_current_I' ) THEN
		WRITE(*,*) 'START calc_current_I with : '//TRIM(tot_occ_filename)//'  '//TRIM(no_box_COM_file)//'  '//TRIM(current_I_out_filename)
	ELSE IF ( TRIM(method) == 'calc_current_I_from_sql' ) THEN
		CALL get_command_argument(6,votca_sql_filename)
		CALL Read_boxsize_from_sql(votca_sql_filename,x_box,y_box,z_box)
		CALL get_command_argument(7,gro_inputfile)  
		read_reference_grofile=.true.
		WRITE(*,*) 'tmp: ',TRIM(votca_sql_filename),'  gro:',TRIM(gro_inputfile)
	ELSE IF  ( TRIM(method) == 'calc_current_I_xml' ) THEN
		if(   check_filetermination_and_continue(tot_occ_filename,'.dat') .and. &
			& file_exists_and_continue(tot_occ_filename) .and. &
			& check_filetermination_and_continue(marcus_rate_filename,'.dat') .and. & 
			& file_exists_and_continue(marcus_rate_filename) ) then
			write(*,*) 'use: calc_current_I_xml'
		else
			write(*,*) 'Use data from statefile: ',trim(votca_sql_filename)
			if( file_exists(votca_sql_filename) .and. &
				& check_filetermination_and_continue(votca_sql_filename,'.sql')) then
				CALL Read_boxsize_from_sql(votca_sql_filename,x_box,y_box,z_box)
				CALL dump_sql_data_for_current_I(votca_sql_filename,tot_occ_filename,marcus_rate_filename,carriertype)
			endif
		endif 
	ELSE
					WRITE(*,*) 'Error: use method:  calc_current_I   or  calc_current_I_from_sql  or  calc_current_I_xml'
					WRITE(*,*) ' STOP'
                    CALL EXIT (1)
	END IF 
	
	
	
	
	IF ( TRIM(method) == 'calc_current_I' ) THEN
		!!! Check if data files are available
		inquire(file=TRIM(tot_occ_filename),exist=Datei_vorhanden) ! Abfrage ob tot_occ_filename-Datei vorhanden ist.
		        IF( .NOT. Datei_vorhanden) THEN
		            WRITE(*,*) ' Fehler: Die_tot_occ_filename_Datei_ist_nicht_vorhanden. '//TRIM(tot_occ_filename)
		            WRITE(*,*) ' ENDE'
		            CALL EXIT (1)
		END IF ! tot_occ_filename-file vorhanden 

		inquire(file=TRIM(marcus_rate_filename),exist=Datei_vorhanden) ! Abfrage ob marcus_rate_filename-Datei vorhanden ist.
		        IF( .NOT. Datei_vorhanden) THEN
		            WRITE(*,*) ' Fehler: Die_marcus_rate_filename_Datei_ist_nicht_vorhanden. '//TRIM(marcus_rate_filename)
		            WRITE(*,*) ' ENDE'
		            CALL EXIT (1)
		END IF ! marcus_rate_filename-file vorhanden 
	ELSE IF ( TRIM(method) == 'calc_current_I_from_sql' ) THEN
		!! Dump data from *.sql files and make them readable by fortran program
		CALL dump_sql_data_for_current_I(votca_sql_filename,tot_occ_filename,marcus_rate_filename,carriertype)
	END IF

        inquire(file=TRIM(no_box_COM_file),exist=Datei_vorhanden) ! Abfrage ob no_box_COM_file-Datei vorhanden ist.
                IF( .NOT. Datei_vorhanden) THEN
                    WRITE(*,*) ' Fehler: Die_no_box_COM_file_Datei_ist_nicht_vorhanden. '//TRIM(no_box_COM_file)
                    WRITE(*,*) ' ENDE'
                    CALL EXIT (1)
        END IF ! no_box_COM_file-file vorhanden 

        inquire(file=TRIM(current_I_out_filename),exist=Datei_vorhanden) ! Abfrage ob current_I_out_filename-Datei vorhanden ist.
        IF( Datei_vorhanden) THEN
                WRITE(*,*) ' Fehler: Die_current_I_out_filename_file_Datei_ist_bereits_vorhanden. '//TRIM(current_I_out_filename)
		WRITE(*,*) ' Stellen Sie sicher, dass diese nicht ueberschrieben wird.'
                WRITE(*,*) ' ENDE'
                CALL EXIT (1)
        END IF ! current_I_out_filename-file vorhanden 

	IF(read_reference_grofile) THEN
			IF (check_filetermination(gro_inputfile,'.gro')) THEN
					inquire(file=TRIM(gro_inputfile),exist=Datei_vorhanden) ! Abfrage ob gro_inputfile-Datei vorhanden ist.
					IF( .NOT. Datei_vorhanden) THEN 
							WRITE(*,*) ' Fehler: Die_gro_Datei_ist_nicht_vorhanden. '//TRIM(gro_inputfile)
							WRITE(*,*) ' ENDE'
							CALL EXIT (1)
					END IF ! gro-file vorhanden  
					
			ELSE
				WRITE(*,*) 'Fehler: Datei_hat_keine_gro_Endung'//TRIM(gro_inputfile)
				CALL EXIT (1)
			END IF ! check if *.gro
	END IF ! read_reference_grofile


	!!! ---------------------------------------------------------------------------
	 write(*,*) " ------------ variables for calc_current_I_from_kmc_data  ------------"
	 write(*,*) " carriertype: ",trim(carriertype)
	 write(*,*) " scale_to_interval_0_1: ",scale_to_interval_0_1
	 write(*,*) " make_current_to_cubefile: ",make_current_to_cubefile
	 write(*,*) " use_logscale_I: ",use_logscale_I
	 write(*,*) " use_logscale_p_occ: ",use_logscale_p_occ
	 write(*,*) " make_scale_p_occ_pdb: ",make_scale_p_occ_pdb
	 write(*,*) " N_occ_scale_points: ",N_occ_scale_points
	 write(*,*) " make_scale_I_pdb: ",make_scale_I_pdb
	 write(*,*) " N_I_scale_points: ",N_occ_scale_points
	 write(*,*) " current_only_use_sites_with_highest_contributions: ",current_only_use_sites_with_highest_contributions
	 write(*,*) " occupations_only_use_sites_with_highest_contributions: ",occupations_only_use_sites_with_highest_contributions
	 write(*,*) " calc_high_current_pathway: ",calc_high_current_pathway
	 write(*,*) " read_reference_grofile: ", read_reference_grofile
	 write(*,*) " wrap_all_molecules_into_the_box: ", wrap_all_molecules_into_the_box
	 write(*,*) " scale_J_vmd_factor: ",scale_J_vmd_factor  	!!! for the visualization in vmd. default: scale_J_vmd_factor=1.0"
	 write(*,*) " J_max_percent_cutoff ",J_max_percent_cutoff,  &
			&" e.g. J_max_percent_cutoff=0.9 only the highest currents 10% are printed. J_max_percent_cutoff=1.0 => All are printed."
	 write(*,*) " p_occ_max_percent_cutoff: ",p_occ_max_percent_cutoff ," highest 95 => highest 5 % of occupation numbers is printed."

	 write(*,*) " scalebox: ",scalebox ," ! scalefactor for partitioning of boxes. scalefactor = [0,1]"	!!!! good value: scalebox=0.03 DIPBI/P3HTcd !! only change small scale eg: 0.025 P3HT
	 write(*,*) " set_filenames: ", set_filenames
	 write(*,*) " gro_inputfile: ",trim(gro_inputfile)
	 write(*,*) " current_I_out_filename: ",trim(current_I_out_filename) 
	 write(*,*) " tot_occ_filename: ",trim(tot_occ_filename)
	 write(*,*) " marcus_rate_filename: ",trim(marcus_rate_filename)
	 write(*,*) " no_box_COM_file: ",trim(no_box_COM_file)
	 write(*,*) " votca_sql_name: ",trim(votca_sql_filename)
	 write(*,*) " calc_local_current_dr: ",calc_local_current_dr
	 write(*,*) "------ variables for calc_current_I_from_kmc_data ---------"
		!!! ---------------------------------------------------------------------------


	WRITE(*,*) 'Use boxsize [Ang]: ',x_box,y_box,z_box
	
	
	
	
	
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	!!! START:     Read data from files
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	
	CALL read_no_box_COM_file(no_box_COM_file,elements,no_box_koord,N_Resids)

	CALL read_total_occupation_file2(tot_occ_filename,id_tot_occ,tot_occ_data,N_tot_occ_lines)

	IF (N_tot_occ_lines /= N_Resids) THEN
			WRITE(*,*) ' Error: The number of sites in the no_box_COM_file ',N_Resids,' in '//TRIM(no_box_COM_file)//&
			   &'   does not match the number of occupied sites ',N_tot_occ_lines,' in '//TRIM(tot_occ_filename)
			WRITE(*,*) ' Check the input STOP'
			CALL EXIT (1)
	END IF 

	CALL read_marcus_rate_data_file(marcus_rate_filename,id_marcus_rate,&
					&seg1_seg2_marcus_rate,dr_pair,marcus_rate_data,N_pairs)




	IF(read_reference_grofile) THEN
		CALL  read_my_grofile_data(gro_inputfile,Gesamtanzahl,&
			& atomsorteA,residue_names,koordA,vel,residue_numbers,atom_numbers,R_u_I,x_box,y_box,z_box)
			koordA=koordA*nm2Ang	
		IF(wrap_all_molecules_into_the_box) THEN
			DO i=1,Gesamtanzahl
					dr=koordA(i,:)
					CALL position_PBC_correction(dr,x_box,y_box,z_box)
					DO k=1,3
						koordA(i,k)=1.0*dr(k)
					END DO 
			END DO
		END IF		
	END IF 
	
	
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!
	!!! END:     Read data from files
	!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!


	!!! START Calculate a current J_site_ges(1:N_Resids):  $J_i = 0.5* e* \sum_{j} ( occ_j * k_ji - occ_i k_ij ) \vec{r_ij} $
    !!! 						  J_pairs(1:N_Pairs)= J_ij
	ALLOCATE(J_site_ges(N_Resids,3))
	J_site_ges=0
	ALLOCATE(J_pairs(N_pairs,3))
	J_pairs=0
	ALLOCATE(J_for_Resid_ok(N_Resids))
	J_for_Resid_ok=.true.
	ALLOCATE(p_occ_for_Resid_ok(N_Resids))
	p_occ_for_Resid_ok=.true.
	
	
	WRITE(*,*) ' Start J_pairs'

	DO i=1,N_Resids
			J_ges=0
			occ_i=tot_occ_data(i)
			DO k=1,N_pairs
						IF( seg1_seg2_marcus_rate(k,1) == id_tot_occ(i) ) THEN
						
							dr=(no_box_koord(seg1_seg2_marcus_rate(k,2),:)-no_box_koord(seg1_seg2_marcus_rate(k,1),:))
							CALL distance_PBC_correction(dr,x_box,y_box,z_box)
							if(calc_local_current_dr) then
								J_pairs(k,:)=(marcus_rate_data(k,2)*tot_occ_data(seg1_seg2_marcus_rate(k,2))& 
								&  - occ_i* marcus_rate_data(k,1) )* dr
							else
								J_pairs(k,:)=(marcus_rate_data(k,2)*tot_occ_data(seg1_seg2_marcus_rate(k,2))& 
								&  - occ_i* marcus_rate_data(k,1) )* dr/norm(dr)
							endif
							
							!J_ges(:)=J_ges(:)+(marcus_rate_data(k,2)*tot_occ_data(seg1_seg2_marcus_rate(k,2))& 
							!&  - occ_i* marcus_rate_data(k,1) )* dr_pair(k,:)
							
							J_ges(:)=J_ges(:)+J_pairs(k,:)
						ELSE IF( seg1_seg2_marcus_rate(k,2) == id_tot_occ(i) ) THEN
							dr=(no_box_koord(seg1_seg2_marcus_rate(k,1),:)-no_box_koord(seg1_seg2_marcus_rate(k,2),:))
						    CALL distance_PBC_correction(dr,x_box,y_box,z_box)
						    if(calc_local_current_dr) then
								J_pairs(k,:)=(marcus_rate_data(k,1)*tot_occ_data(seg1_seg2_marcus_rate(k,1))& 
								&  - occ_i* marcus_rate_data(k,2) )* dr 
							else
								J_pairs(k,:)=(marcus_rate_data(k,1)*tot_occ_data(seg1_seg2_marcus_rate(k,1))& 
								&  - occ_i* marcus_rate_data(k,2) )* dr / norm(dr)
							endif
							!J_ges(:)=J_ges(:)+(marcus_rate_data(k,1)*tot_occ_data(seg1_seg2_marcus_rate(k,1))& 
							!&  - occ_i* marcus_rate_data(k,2) )* (1.0*dr_pair(k,:))
							
							J_ges(:)=J_ges(:)+J_pairs(k,:)
						END IF						
			END DO ! N_pairs
			J_site_ges(i,1:3)=J_ges(1:3)
			!WRITE(*,*) i,"  ",J_site_ges(i,1:3)
	END DO !N_Resids

	WRITE(*,*) ' End J_pairs'





	!! Mittelwert $ J_{ges} = \frac{1}{N_Resids}   \sum_i^{N_Resids} J_i $
	J_ges=0
	DO i=1,N_Resids
			DO k=1,3
						IF( (abs(J_site_ges(i,k)) < 1.0E-20) .OR. IsNaN(J_site_ges(i,k)) ) THEN
								J_site_ges(i,k)=0
								WRITE(*,*) 'ERROR: Site: ',i,'  k',k,'   ',J_site_ges(i,k)
								J_for_Resid_ok(i)=.false.	
						END IF !
						IF (J_for_Resid_ok(i)) THEN		
								J_ges(k) = J_ges(k) + J_site_ges(i,k)
						END IF !J_for_Resid_ok(i) ? 
			END DO
	END DO
		
	WRITE(*,*) 'J_ges: ',J_ges,'  J_ges_norm:',J_ges/COUNT(J_for_Resid_ok)
	J_ges=J_ges/COUNT(J_for_Resid_ok)
	norm_J_ges=norm(J_ges(:))
	J_ges_norm_vec=J_ges/norm_J_ges
	
	IF ((norm_J_ges < 1.0E-20) .OR. IsNaN(norm_J_ges)) THEN
		WRITE(*,*) 'Error: Wrong norm_J_ges found: ',norm_J_ges
		CALL EXIT(1)
	END IF



	
	WRITE(*,*) 'Calculate order parameter J_s!'
	!! Ordnungsparameter J_s
	J_s=0
	DO i=1,N_Resids
		DO k=1,3
				IF( J_for_Resid_ok(i) .AND. ( (abs(J_site_ges(i,k)) < 1.0E-20) .OR.  IsNaN(J_site_ges(i,k))) ) THEN
							J_site_ges(i,k)=0
							WRITE(*,*) 'ERROR: Site: ',i,'  k',k,'   ',J_site_ges(i,k)
							J_for_Resid_ok(i)=.false.	
				END IF !
		END DO
		IF (J_for_Resid_ok(i)) THEN		
			J_s = J_s + ( DOT_PRODUCT(J_site_ges(i,1:3)/norm(J_site_ges(i,1:3)),J_ges_norm_vec)**2 - 1/3.)
		END IF ! J_for_Resid_ok

	END DO
	J_s=3/2. * J_s/N_Resids	
	WRITE(*,*) 'SUM ok: ',COUNT(J_for_Resid_ok(:))
	if( calc_local_current_dr) then
		WRITE(*,*) ' The total average current vector is J_ges  [e*Ang/s * Ang]:  ',J_ges(1),J_ges(2),J_ges(3)
	else
		WRITE(*,*) ' The total average current vector is J_ges  [e*Ang/s]:    ',J_ges(1),J_ges(2),J_ges(3)
	endif
	WRITE(*,*) ' The orientation dependent parameter for the current J_s is :',J_s	
	

!!! Convert to output data 
!!! Tcl function for vmd
 	ALLOCATE(J_norm_all(N_Resids))
 	ALLOCATE(J_site_ges_0_1(N_Resids,3))
	DO i=1,N_Resids
			IF(J_for_Resid_ok(i)) THEN
						J_norm_all(i)=norm(J_site_ges(i,1:3))
						DO k=1,3
							J_site_ges_0_1(i,k)=J_site_ges(i,k)
						END DO
			END IF !J_for_Resid_ok
	END DO 

WRITE(*,*) 'MINIMUM J_i: ',MINVAL(J_norm_all,J_for_Resid_ok(:))
WRITE(*,*) 'MAXIMUM J_i: ',MAXVAL(J_norm_all,J_for_Resid_ok(:))


IF(current_only_use_sites_with_highest_contributions) THEN
		! sets J_for_Resid_ok(i) =.false. if the not in the highest J_max_percent_cutoff=10% e.g. 10%  values
		ALLOCATE(Array1(N_Resids))		
		Array1=J_norm_all
		call SortArray(Array1,N_Resids)
		!! cutoff value  
		J_norm_cutoff=Array1(INT(N_Resids*J_max_percent_cutoff))
		WRITE(*,*) 'J_norm_max:',Array1(1),'J_norm_min:',Array1(N_Resids),'J_norm_cutoff: ',J_norm_cutoff,&
				&'  selects the highest ',1.0-J_max_percent_cutoff,' %'
		
		DO i=1,N_Resids	
				IF(J_for_Resid_ok(i)) THEN
						IF( J_norm_all(i) < J_norm_cutoff ) THEN
							J_for_Resid_ok(i)=.false.
						END IF
				END IF !  J_for_Resid_ok
		END DO
		!DEALLOCATE(Array1)
END IF  ! only_use_sites_with_highest_contributions




IF (use_logscale_I) THEN
	!! log10
	DO i=1,N_Resids
		IF(J_for_Resid_ok(i)) THEN
			IF( abs(J_norm_all(i)) < 1.0E-20) THEN
				J_norm_all(i)=0
			ELSE
				J_norm_all(i)=Log10(J_norm_all(i))
			END IF 
		
			DO k=1,3 ! J_x,J_y,J_z
				IF(  (abs(J_site_ges_0_1(i,k)) < 1.0E-20) .OR.  IsNaN(J_site_ges_0_1(i,k))  ) THEN
					J_site_ges_0_1(i,k)=0
					WRITE(*,*) 'Warning: Site: ',i,'  k',k,'   ',J_site_ges_0_1(i,k)
					J_for_Resid_ok(i)=.false.
				ELSE
					J_site_ges_0_1(i,k)=Log10(abs(J_site_ges_0_1(i,k)))
				END IF 
			END DO !k
		END IF !J_for_Resid_ok(i)?
	END DO ! i=1,N_Resids

	WRITE(*,*) 'Using: log10 J_i_ges'
END IF




IF(scale_to_interval_0_1) THEN
	WRITE(*,*) 'Scale DATA to interval [0,1]'
	DO k=1,3  ! J_x,J_y,J_z
		J_min=MINVAL(J_site_ges_0_1(:,k),J_for_Resid_ok(:))
		J_max=MAXVAL(J_site_ges_0_1(:,k),J_for_Resid_ok(:))
		WRITE(*,*) J_site_ges_0_1(1,k)
		!! Scale data ; transform to intervall [0,1]
		J_average=0
		DO i=1,N_Resids
			IF(J_for_Resid_ok(i)) THEN
				J_site_ges_0_1(i,k)=(J_site_ges_0_1(i,k)-J_min)/(J_max-J_min)
				J_average=J_average+J_site_ges_0_1(i,k)	
				IF( IsNaN(J_site_ges_0_1(i,k))  ) THEN
					WRITE(*,*) 'Warning: Site: ',i,'  k',k,'   ',J_site_ges_0_1(i,k)
					WRITE(*,*) J_average,J_average+J_site_ges_0_1(i,k)	
					J_for_Resid_ok(i)=.false.
					STOP
				END IF
			END IF !J_ok?
		END DO
		J_average=J_average/COUNT(J_for_Resid_ok)
		
		
		J_sigma=0		
		DO i=1,N_Resids
				J_sigma=J_sigma+(J_site_ges_0_1(i,k)-J_average)**2	
		END DO !N_Resids
		
		J_sigma=SQRT(J_sigma/(COUNT(J_for_Resid_ok)-1))
		
		
		IF (use_logscale_I) THEN
				WRITE(*,*) 'J_',k,' log10 |J_average +/- J_sigma| :', J_average,' +/- ', J_sigma,' J_min: ',J_min,'  J_max: ',J_max
		ELSE
				WRITE(*,*) 'J_',k,'       |J_average +/- J_sigma| :', J_average,' +/- ', J_sigma,' J_min: ',J_min,'  J_max: ',J_max
		END IF
	END DO ! k =1,3 == ! J_x,J_y,J_z

    !!! Analyse fuer den Betrag des J_ vectors
	J_min=MINVAL(J_norm_all,J_for_Resid_ok(:))
	J_max=MAXVAL(J_norm_all,J_for_Resid_ok(:))
	WRITE(*,*) ' MINIMUM  Log10 |J_i|: ',J_min
	WRITE(*,*) ' MAXIMUM  Log10 |J_i|: ',J_max
	!! Scale data ; transform to intervall [0,1]
	J_average=0

	DO i=1,N_Resids
		IF(J_for_Resid_ok(i)) THEN
			J_norm_all(i)=(J_norm_all(i)-J_min)/(J_max-J_min)
			J_average=J_average+J_norm_all(i)
		!WRITE(*,*) J_norm_all(i)		
		END IF !J_ok?
	END DO
	J_average=J_average/N_Resids

	J_sigma=0
	DO i=1,N_Resids
		IF(J_for_Resid_ok(i)) THEN
			J_sigma=J_sigma+(J_norm_all(i)-J_average)**2
			!WRITE(*,*) J_norm_all(i)	
		END IF !J_ok?
	END DO
	J_sigma=SQRT(J_sigma/(N_Resids-1))


	WRITE(*,*) 'MINIMUM scaled Log10 |J_i|: ',J_min
	WRITE(*,*) 'MAXIMUM scaled Log10 |J_i|: ',J_max
	WRITE(*,*) '  NORM      scaled Log10 |J_average +/- J_sigma| :', J_average,' +/- ', J_sigma
	
99 format(A15,3F10.3,A5,3F10.3,A6,F8.4,A3)

	OPEN(UNIT=51,FILE=TRIM(current_I_out_filename),STATUS='REPLACE ',IOSTAT=ierror)
	WRITE(51,*) ' ### VMD CURRENT visualization with arrows using:'
	WRITE(51,*) ' ###  '//TRIM(tot_occ_filename)//'  '//TRIM(marcus_rate_filename)//'  '//TRIM(no_box_COM_file)
	WRITE(51,*) ' proc vmd_draw_myarrow {mol start end norm } {                          '
	WRITE(51,*) '     # an arrow is made of a cylinder and a cone'
	WRITE(51,*) '     # Choose colour in the range of 1024 colours with the value norm=[0,1]	  '
	WRITE(51,*) '	   draw color [ expr 32 + int(1024 * $norm) ]'
	WRITE(51,*) '      set middle [vecadd $start [vecscale 0.8 [vecsub $end $start]]]  '
	WRITE(51,*) '      set scaled_cylinder_radius [ expr 0.15 * $norm ]                '
 	WRITE(51,*) '      set scaled_cone_radius [ expr 0.25 * $norm ]                    '
	WRITE(51,*) '     graphics $mol cylinder $start $middle radius $scaled_cylinder_radius '
	WRITE(51,*) '     graphics $mol cone $middle $end radius $scaled_cone_radius           '
	WRITE(51,*) ' }                                                                   '
	WRITE(51,*) '  color scale method RWB ' !! or RGB
		!! draw arrow {0 0 0} {1 1 1} 
		DO i=1,N_Resids
		  IF(J_for_Resid_ok(i)) THEN	
			J_norm=norm(J_site_ges(i,1:3))
			IF( abs(J_norm) < 1.0E-12) THEN
					
					WRITE(*,99) ' draw myarrow { ',no_box_koord(i,1),no_box_koord(i,2),no_box_koord(i,3),' } { ',&
					& no_box_koord(i,1) + scale_J_vmd_factor*J_site_ges(i,1)/J_norm,&
					& no_box_koord(i,2) + scale_J_vmd_factor*J_site_ges(i,2)/J_norm,&
					& no_box_koord(i,3) + scale_J_vmd_factor*J_site_ges(i,3)/J_norm,' } '&
					& //' { ',J_norm_all(i),' } '
					WRITE(*,*) 'Error: small J_norm found: cycle  J_norm',J_norm
					J_for_Resid_ok(i)=.false.
					CYCLE	
			ELSE ! Standard				
			
			
					WRITE(51,99) ' draw myarrow { ',no_box_koord(i,1),no_box_koord(i,2),no_box_koord(i,3),' } { ',&
					& no_box_koord(i,1) + scale_J_vmd_factor*J_site_ges(i,1)/J_norm,&
					& no_box_koord(i,2) + scale_J_vmd_factor*J_site_ges(i,2)/J_norm,&
					& no_box_koord(i,3) + scale_J_vmd_factor*J_site_ges(i,3)/J_norm,' } '&
					& //' { ',J_norm_all(i),' } '
			END IF ! Check small J_norm
		  END IF !J_for_Resid_ok
		END DO !i=1,N_Resids
	CLOSE(51)

ELSE

	OPEN(UNIT=50,FILE=TRIM(current_I_out_filename),STATUS='REPLACE ',IOSTAT=ierror)
	WRITE(50,*) ' ### VMD CURRENT visualization with arrows using:'
	WRITE(50,*) ' ###  '//TRIM(tot_occ_filename)//'  '//TRIM(marcus_rate_filename)//'  '//TRIM(no_box_COM_file)
	WRITE(50,*) ' proc vmd_draw_arrow {mol start end norm } {                               '
	WRITE(50,*) '	  draw color [ expr 32 + int(1024 * $norm) ]'
	WRITE(50,*) '     # an arrow is made of a cylinder and a cone                     '
	WRITE(50,*) '     set middle [vecadd $start [vecscale 0.9 [vecsub $end $start]]]  '
	WRITE(50,*) '     graphics $mol cylinder $start $middle radius 0.15               '
	WRITE(50,*) '     graphics $mol cone $middle $end radius 0.25                     '
	WRITE(50,*) ' }                                                                   '
	WRITE(50,*) '  color scale method RWB '
		!! draw arrow {0 0 0} {1 1 1} 
		DO i=1,N_Resids
		  IF(J_for_Resid_ok(i)) THEN	
			J_norm=norm(J_site_ges(i,1:3))
			WRITE(50,99) ' draw arrow { ',no_box_koord(i,1),no_box_koord(i,2),no_box_koord(i,3),' } { ',&
			& no_box_koord(i,1) + scale_J_vmd_factor*J_site_ges(i,1)/J_norm,&
			& no_box_koord(i,2) + scale_J_vmd_factor*J_site_ges(i,2)/J_norm,&
			& no_box_koord(i,3) + scale_J_vmd_factor*J_site_ges(i,3)/J_norm,' } '&
			&//' { ',J_norm_all(i),' } '
		   END IF !J_for_Resid_ok
		END DO !i=1,N_Resids
	CLOSE(50)
END IF

!!! END CREATE VMD ARROW VISUALIZATION FOR CURRENT DATA



!!! OUTPUT DATA START TO pdb
current_pdb_filename='my_current_I_for_hopping_sites.pdb'
CALL current_to_pdb(current_pdb_filename,N_Resids,no_box_koord(1:N_Resids,1:3),J_site_ges_0_1,J_for_Resid_ok,&
					&x_box,y_box,z_box)

IF(read_reference_grofile) THEN
	current_pdb_filename='my_current_I_for_molecules.pdb'
	CALL current_to_pdb_from_gro(current_pdb_filename,N_Resids,Gesamtanzahl,R_u_I,&
					&residue_names,atomsorteA,koordA,J_site_ges_0_1,J_for_Resid_ok,&
					&x_box,y_box,z_box)
					
					
	IF(make_scale_I_pdb) THEN !!! make a scale line
		I_scale_pdb_filename='my_I_scale_pdb_'//TRIM(current_pdb_filename)
		ALLOCATE(scale_I_data(N_I_scale_points))
		ALLOCATE(scale_I_koord(N_I_scale_points,3))
		ALLOCATE(scale_I_atomsorte(N_I_scale_points))
		ALLOCATE(scale_I_ok(N_I_scale_points))
		
		scale_I_data=0.0
		scale_I_koord=0
		scale_I_atomsorte="B"
		scale_I_ok=.true.
		!! scale is aligned parallel to x-axis
		DO i=1,N_I_scale_points
			scale_I_koord(i,1) = (i-1) * x_box/ ( N_I_scale_points -1)
			scale_I_koord(i,2) = -5.0 
			scale_I_data(i)=J_min  +  (i-1) * (J_max-J_min) / ( N_I_scale_points -1)
		END DO
		CALL current_to_pdb(I_scale_pdb_filename,N_I_scale_points,&
				&scale_I_koord,scale_I_data,scale_I_ok,x_box,y_box,z_box)

	END IF ! make_scale_I_pdb
END IF !read_reference_grofile

filename='output_current_all_I.dat'
OPEN(unit=10,FILE=filename, status='replace', action = 'write')
if(calc_local_current_dr) then
	WRITE(10,*)  '### Resid,    Jx  , Jy,   Jz,   |J_ges|  [e*Ang/s]'
else
	WRITE(10,*)  '### Resid,    Jx  , Jy,   Jz,   |J_ges|  [e / s]  '
endif

do i=1,N_Resids
	IF(J_for_Resid_ok(i)) THEN
		WRITE(10,'(I8,4E18.6)')  id_tot_occ(i),J_site_ges(i,1),J_site_ges(i,2),J_site_ges(i,3),norm(J_site_ges(i,:))
	ELSE
		WRITE(10,'(I8,4E18.6)')  id_tot_occ(i),0.0,0.0,0.0,0.0
	END IF
end do

av_J=0.0
DO i=1,N_Resids
	IF(J_for_Resid_ok(i)) THEN
		av_J=av_J+norm(J_site_ges(i,:))
	END IF
END DO
av_J=av_J/N_Resids  !!COUNT(J_for_Resid_ok(:))

sigma_J=0.0
DO i=1,N_Resids
	IF(J_for_Resid_ok(i)) THEN
		sigma_J=sigma_J+ (norm(J_site_ges(i,:)) - av_J)**2
	END IF
END DO
sigma_J=SQRT(sigma_J/(N_Resids-1))   !(COUNT(J_for_Resid_ok(:))-1))
!!! OUTPUT DATA ENDE 


if(calc_local_current_dr) then
		WRITE(*,*) ' |J_ges| [e*Ang/s] : ', av_J,"+/-", sigma_J
		WRITE(*,*) ' normalized per box volume [A / Ang**2 = C * Ang / (s Ang**3) ]  current |J_ges|: '&
		&,av_J*elementary_charge/(x_box*y_box*z_box), "+/-", sigma_J*elementary_charge/(x_box*y_box*z_box)
		av_J    = av_J*elementary_charge/(x_box*y_box*z_box *Ang2m**2)
		sigma_J = sigma_J*elementary_charge/(x_box*y_box*z_box*Ang2m**2)
		WRITE(*,*) ' normalized per box volume [A / m**2 ]  current |J_ges|: ',av_J , "+/-", sigma_J
else 
		!! without dr 
		WRITE(*,*) ' Averaged with respect to all hopping sites: '
		WRITE(*,*) ' average |I_ges| [e/s] : ', av_J," +/- ", sigma_J
		WRITE(*,*) ' average |I_ges| [Coulomb/s = Ampere] : ', av_J*elementary_charge," +/- ", sigma_J*elementary_charge
		WRITE(*,*) ' normalized per box volume [A / Ang**3 = C / (s Ang**3) ]  current |J_ges|: '&
		&,av_J*elementary_charge/(x_box*y_box*z_box), "+/-", sigma_J*elementary_charge/(x_box*y_box*z_box)
		av_J    =    av_J*elementary_charge/(x_box*y_box*z_box * Ang2m**3)
		sigma_J = sigma_J*elementary_charge/(x_box*y_box*z_box * Ang2m**3)
		WRITE(*,*) ' normalized per box volume [A / m**3 ]  current |J_ges|: ',av_J ," +/- ", sigma_J
		WRITE(*,*) ' current per box plane '
		WRITE(*,*) ' I_ges_x / (ybox * zbox)  [A / m**2] ', J_ges(1)*elementary_charge/(y_box*z_box*Ang2m**2)
		WRITE(*,*) ' I_ges_y / (zbox * xbox)  [A / m**2] ', J_ges(2)*elementary_charge/(z_box*x_box*Ang2m**2)
		WRITE(*,*) ' I_ges_z / (xbox * ybox)  [A / m**2] ', J_ges(3)*elementary_charge/(x_box*y_box*Ang2m**2)
endif 


!!!! Create DATA FOR CUBEFILES WITH CURRENT ISODENSITY SURFACE PLOTS
!! scalefactor for partitioning of boxes. scalefactor = [0,1]
!! good value: scalebox=0.03
!!!scalebox=0.05
IF(make_current_to_cubefile) THEN

	!! convert from Angstroem to BOHR
	no_box_koord=no_box_koord*anstroem_to_bohr

	bmax(1)=MAXVAL(no_box_koord(1:N_Resids,1))
	bmax(2)=MAXVAL(no_box_koord(1:N_Resids,2))
	bmax(3)=MAXVAL(no_box_koord(1:N_Resids,3))

	bmin(1)=MINVAL(no_box_koord(1:N_Resids,1))
	bmin(2)=MINVAL(no_box_koord(1:N_Resids,2))
	bmin(3)=MINVAL(no_box_koord(1:N_Resids,3))
	
	xbox=abs(bmax(1)-bmin(1))
	ybox=abs(bmax(2)-bmin(2))
	zbox=abs(bmax(3)-bmin(3))
	WRITE(*,*) 'Approximated boxlength: ',xbox,ybox,zbox
	xlen=int(xbox*scalebox)
	ylen=int(ybox*scalebox)
	zlen=int(zbox*scalebox)
	
	WRITE(*,*) ' CUBE segmentation / number of bins: ',xlen,ylen,zlen
	ALLOCATE(cubedata(xlen,ylen,zlen))
	ALLOCATE(cubedata_0_to_1(xlen,ylen,zlen))
	ALLOCATE(cubedata_Ix(xlen,ylen,zlen))
	ALLOCATE(cubedata_Iy(xlen,ylen,zlen))
	ALLOCATE(cubedata_Iz(xlen,ylen,zlen))
   
	cubedata=0.0d0
	cubedata_0_to_1=0.0d0
	cubedata_Ix=0.0d0
	cubedata_Iy=0.0d0
	cubedata_Iz=0.0d0
	
	! Create Array with atomic numbers for Cubefile
	ALLOCATE(atomicnumber(N_Resids))
	atomicnumber=0
	DO i=1,N_Resids
		atomicnumber(i)=Calc_N_electrons_in(elements(i),1,.false.)
	END DO 

	
	!! Fill Data array
	DO i=1,N_Resids
		IF(J_for_Resid_ok(i)) THEN
			ix=int(xlen*abs(no_box_koord(i,1)-bmin(1))/xbox)+1    
			iy=int(ylen*abs(no_box_koord(i,2)-bmin(2))/ybox)+1 
			iz=int(zlen*abs(no_box_koord(i,3)-bmin(3))/zbox)+1 
			IF( (ix == 0)  .OR. ( ix > xlen)) THEN
				WRITE(*,*) 'Warning ix, xlen',ix,xlen
				ix=xlen
			END IF
			IF( (iy == 0)  .OR. ( iy > ylen)) THEN
				WRITE(*,*) 'Warning iy, ylen',iy,ylen
				iy=ylen
			END IF
			IF(( iz == 0) .OR. ( iz > zlen)) THEN
				WRITE(*,*) 'Warning iz, zlen',iz,zlen
				iz=zlen
			END IF			
			
			cubedata(ix,iy,iz)          = cubedata(ix,iy,iz)        + REAL(norm(J_site_ges(i,:)),8)
			cubedata_Ix(ix,iy,iz)       = cubedata_Ix(ix,iy,iz)     + REAL(J_site_ges_0_1(i,1),8)
			cubedata_Iy(ix,iy,iz)       = cubedata_Iy(ix,iy,iz)     + REAL(J_site_ges_0_1(i,2),8)
			cubedata_Iz(ix,iy,iz)       = cubedata_Iz(ix,iy,iz)     + REAL(J_site_ges_0_1(i,3),8)
			cubedata_0_to_1(ix,iy,iz)   = cubedata_0_to_1(ix,iy,iz) + REAL(J_norm_all(i),8)
		END IF !J_ok?
	END DO
	
	
	CUBE_filename='CUBE_current_I.cube'


	!!! WRITE DATA TO CUBEFILE 
	CALL writecube(cubedata,xlen,ylen,zlen,xbox,ybox,zbox,N_Resids,&
		&no_box_koord(1:N_Resids,1),no_box_koord(1:N_Resids,2),no_box_koord(1:N_Resids,3),atomicnumber(1:N_Resids),CUBE_filename)

	!!! WRITE DATA TO CUBEFILE 
	CUBE_filename1='Ix_'//TRIM(CUBE_filename)
	CALL writecube(cubedata_Ix,xlen,ylen,zlen,xbox,ybox,zbox,N_Resids,&
		&no_box_koord(1:N_Resids,1),no_box_koord(1:N_Resids,2),no_box_koord(1:N_Resids,3),atomicnumber(1:N_Resids),CUBE_filename1)

	!!! WRITE DATA TO CUBEFILE 
	CUBE_filename1='Iy_'//TRIM(CUBE_filename)
	CALL writecube(cubedata_Iy,xlen,ylen,zlen,xbox,ybox,zbox,N_Resids,&
		&no_box_koord(1:N_Resids,1),no_box_koord(1:N_Resids,2),no_box_koord(1:N_Resids,3),atomicnumber(1:N_Resids),CUBE_filename1)

	!!! WRITE DATA TO CUBEFILE 
	CUBE_filename1='Iz_'//TRIM(CUBE_filename)
	CALL writecube(cubedata_Iz,xlen,ylen,zlen,xbox,ybox,zbox,N_Resids,&
		&no_box_koord(1:N_Resids,1),no_box_koord(1:N_Resids,2),no_box_koord(1:N_Resids,3),atomicnumber(1:N_Resids),CUBE_filename1)

	!!! WRITE DATA TO CUBEFILE 
	CUBE_filename1='I_norm_O_to_1_'//TRIM(CUBE_filename)
	CALL writecube(cubedata_0_to_1,xlen,ylen,zlen,xbox,ybox,zbox,N_Resids,&
		&no_box_koord(1:N_Resids,1),no_box_koord(1:N_Resids,2),no_box_koord(1:N_Resids,3),atomicnumber(1:N_Resids),CUBE_filename1)

END IF ! make_current_to_cubefile






!!! occupation reference data for the selected sites with a high current!
IF(read_reference_grofile) THEN
	!!! use logarithm
	N_unoccupied_sites=0
	occ_min=MINVAL(tot_occ_data,p_occ_for_Resid_ok(:))
	IF(use_logscale_p_occ) THEN
		DO i=1,N_Resids
				IF(p_occ_for_Resid_ok(i)) THEN
						IF( (abs(tot_occ_data(i)) < 1.0E-20) .OR. ISNAN(tot_occ_data(i)) ) THEN
							tot_occ_data(i)=log10(1.0E-20)
							WRITE(*,*) 'Warning: small occupation encountered: ',tot_occ_data(i),'  at id ',i
							p_occ_for_Resid_ok(i)=.false.
							N_unoccupied_sites= N_unoccupied_sites +1
						ELSE
							!write(*,*)' tmp: ',tot_occ_data(i),LOG10(tot_occ_data(i))
							tot_occ_data(i)=LOG10(tot_occ_data(i))

						END IF
				END IF
		END DO 
	END IF 




	IF(occupations_only_use_sites_with_highest_contributions) THEN
			! sets p_occ_for_Resid_ok(i) =.false. if the not in the highest p_occ_percent_cutoff=10% e.g. 10%  values
			!ALLOCATE(Array1(N_Resids))		
			Array1=tot_occ_data(:)
			call SortArray(Array1,N_Resids)
			!! cutoff value  
			p_occ_cutoff=Array1(INT(N_Resids*(p_occ_max_percent_cutoff)))
			WRITE(*,*) 'p_occ_max:',Array1(1),'p_occ_min:',Array1(N_Resids),'p_occ_cutoff: ',p_occ_max_percent_cutoff,&
					&'  selects the highest ',1.0-p_occ_max_percent_cutoff,' %  p_cutoff:',p_occ_cutoff
			WRITE(*,*) Array1(1:30)
			WRITE(*,*) Array1(N_Resids-30:N_Resids)
			DO i=1,N_Resids	
					!WRITE(*,*) 'ARR1:',Array1(i)
					IF(p_occ_for_Resid_ok(i)) THEN
							IF( tot_occ_data(i) < p_occ_cutoff ) THEN
								p_occ_for_Resid_ok(i)=.false.
								!WRITE(*,*) 'OUT:', tot_occ_data(i),' cutoff:',p_occ_cutoff
							!ELSE
								!IF(i < N_Resids*(p_occ_max_percent_cutoff))THEN
									!WRITE(*,*) 'IN:', Array1(i),tot_occ_data(i),' > cutoff:',p_occ_cutoff
								!END IF
							END IF
					END IF !  J_for_Resid_ok
			END DO
			!DEALLOCATE(Array1)
	END IF  ! only_use_sites_with_highest_contributions


	!!! scale occupations to interval [0,1]

    !!! Analyse fuer den Betrag des J_ vectors
	occ_min=MINVAL(tot_occ_data,p_occ_for_Resid_ok(:))
	occ_max=MAXVAL(tot_occ_data,p_occ_for_Resid_ok(:))
	
	!! Scale data ; transform to intervall [0,1]
	occ_average=0

	DO i=1,N_Resids
		IF(p_occ_for_Resid_ok(i)) THEN
			! tot_occ_data(i)=(tot_occ_data(i)-occ_min)/(occ_max-occ_min)
			occ_average=occ_average+tot_occ_data(i)
			!WRITE(*,*) occ_norm_all(i)		
		END IF !occ_ok?
	END DO
	occ_average=occ_average/COUNT(p_occ_for_Resid_ok)
	WRITE(*,*) ' MINIMUM  |p_occ_i|:   ',occ_min
	WRITE(*,*) ' MAXIMUM  |p_occ_i|:   ',occ_max
	WRITE(*,*) ' AVERAGE  |p_occ  |:   ',occ_average
	WRITE(*,*) ' N_unoccupied_sites: ', N_unoccupied_sites

	occupation_pdb_filename='my_occupation_for_molecules.pdb'
	WRITE(*,*) ' N_molecules_in per cent: ',COUNT(p_occ_for_Resid_ok)
	CALL current_to_pdb_from_gro(occupation_pdb_filename,N_Resids,Gesamtanzahl,R_u_I,&
					&residue_names,atomsorteA,koordA,tot_occ_data,p_occ_for_Resid_ok,&
					&x_box,y_box,z_box)
					
	
	
	IF(make_scale_p_occ_pdb) THEN !!! make a scale line
		occ_scale_pdb_filename='my_occ_scale_pdb_'//TRIM(occupation_pdb_filename)
		ALLOCATE(scale_p_occ_data(N_occ_scale_points))
		ALLOCATE(scale_p_occ_koord(N_occ_scale_points,3))
		ALLOCATE(scale_p_occ_atomsorte(N_occ_scale_points))
		ALLOCATE(scale_p_occ_ok(N_occ_scale_points))
		
		scale_p_occ_data=0.0
		scale_p_occ_koord=0
		scale_p_occ_atomsorte="B"
		scale_p_occ_ok=.true.
		!! scale is aligned parallel to x-axis
		DO i=1,N_occ_scale_points
			scale_p_occ_koord(i,1) = (i-1) * x_box/ ( N_occ_scale_points -1)
			scale_p_occ_koord(i,2) = -5.0 
			scale_p_occ_data(i)=occ_min  +  (i-1) * (occ_max-occ_min) / ( N_occ_scale_points -1)
		END DO
		CALL current_to_pdb(occ_scale_pdb_filename,N_occ_scale_points,&
				&scale_p_occ_koord,scale_p_occ_data,scale_p_occ_ok,x_box,y_box,z_box)

	END IF ! make_scale_p_occ_pdb
					
END IF ! read_reference_grofile


IF(calc_high_current_pathway) THEN
	write(*,*) "Warning: calc_high_current_pathway is maybe not the best method of choice!"
	CALL find_high_current_pathway(N_Resids,N_pairs,id_tot_occ,J_site_ges,&
			&J_pairs,seg1_seg2_marcus_rate,dr_pair,no_box_koord,x_box,y_box,z_box)
END IF


WRITE(*,*) 'Normal termination of  current_I_form_votca_sql_data'
END SUBROUTINE current_I_form_votca_sql_data




!!              Routine suchte einen Pfad mit großem Strom indem der Uebergang mit dem groeßten Strom zu einem Nachbarn ausgewaehlt wird.
!!              Dabei wird von der Hopping site mit dem groeßen Strombeitrag gestartet und alle schließt alle bereits durchlaufenen Pfade hinter sich,
!!              sodass diese nicht mehrfach durchlaufen werden können.
!!  Problem:    Der erzeugte Weg entspricht nicht einem realen Weg.
!!  PROBLEM:    Reihenfolge und RICHTUNG wird nicht berücksichtigt.
!!              Routine ist relativ so unbrauchbar.
SUBROUTINE find_high_current_pathway(N_Resids,N_pairs,id_Resid,J_site_ges,&
			&J_pairs,seg1_seg2_marcus_rate,dr_pair,no_box_koord,x_box,y_box,z_box)
	use small_functions
	implicit none
	INTEGER, INTENT(IN)::N_Resids,N_pairs
   INTEGER, DIMENSION(N_Resids)::id_Resid
   !!! summed data for all hopping sites in the box.
   REAL, DIMENSION(N_Resids,3)             :: J_site_ges,no_box_koord !(N_Resids,3)
   !!! current data for all pairs.
   REAL, DIMENSION(N_pairs,3)              :: J_pairs    !(N_pairs,3)
   INTEGER, DIMENSION (N_pairs,3)          :: seg1_seg2_marcus_rate
   REAL, DIMENSION(N_pairs,3)              :: dr_pair
   REAL , INTENT(IN)                       ::x_box,y_box,z_box
   
   !! Local data
   INTEGER, DIMENSION (500) :: index_pair_list
   INTEGER, ALLOCATABLE, DIMENSION(:,:) :: local_neighbourlist
   LOGICAL, ALLOCATABLE, DIMENSION(:,:) :: pair_in_path
   LOGICAL, ALLOCATABLE, DIMENSION(:)   :: path_used
   INTEGER::i,j,k,l,i_J_max,NN_max,Resid_charged,active_neighbours
   CHARACTER(LEN=500):: current_path_filename
   REAL::J_max,norm_J
   LOGICAL::  Neighbour_found,call_exit_loop
   REAL, DIMENSION(3):: R_path,R_start,R_max,R_min
   
   WRITE(*,*) 'Start: Finde pathway with highest current.'
	
	
	
	current_path_filename='my_current_pathway_file.xyz'
	OPEN(unit=10,FILE=TRIM(current_path_filename), status='replace', action = 'write')
	current_path_filename='my_current_pathway_file_all_points.xyz'
	OPEN(unit=11,FILE=TRIM(current_path_filename), status='replace', action = 'write')
	WRITE(11,*) "2000"
	WRITE(11,*) "Meine Pfad "
	
	!!! Maximum number of nearest neighbours
	NN_max=12
	ALLOCATE(path_used(N_pairs))
	! local_neighbourlist(i=1...N_resids,j==         j=1 == Resid,  j=2 == number of nearest neighbours, j==3 ... NN_max+2 = Resid neighbours
	ALLOCATE(local_neighbourlist(N_Resids,NN_max+2))
	ALLOCATE(pair_in_path(N_Resids,NN_max))
	local_neighbourlist=0
	pair_in_path=.false.
	path_used=.false.

	J_max=0.0
	i_J_max=1
	DO i=1,N_Resids
		norm_J=norm(J_site_ges(i,:))
		IF ( abs(norm_J) > J_max) THEN
				J_max=norm_J
				i_J_max=i
		END IF
	END DO

	WRITE(*,*) ' Inititial |J_max|: ',J_max,'   at	 ',i_J_max,id_Resid(i_J_max)	
	
	
	!DO j=1,N_pairs
	!		DO i=1,N_Resids
	!			IF ( id_Resid(i) == seg1_seg2_marcus_rate(j,1) ) THEN
	!						WRITE(*,*) id_Resid(i),seg1_seg2_marcus_rate(j,1),seg1_seg2_marcus_rate(j,2),local_neighbourlist(i,2)
	!						DO k=3,3+local_neighbourlist(i,2)
	!							IF ( local_neighbourlist(i,k) == seg1_seg2_marcus_rate(j,2)) THEN
	!								WRITE(*,*) "CONTINUE"
	!								CONTINUE ! Exit loop pair was found
	!							END IF 
	!							pair_in_path(i,k-2)=.false.
	!						END DO
	!						!! add new neighbour 
	!						local_neighbourlist(i,1)=seg1_seg2_marcus_rate(j,1)
	!						local_neighbourlist(i,2)=local_neighbourlist(i,2)+1
	!						local_neighbourlist(i,2+local_neighbourlist(i,2))=seg1_seg2_marcus_rate(j,2)
	!						
	!						WRITE(*,*) 'DATA: ',local_neighbourlist(i,:)
	!						!! Add neighbour for resid 1
	!						!seg1_seg2_marcus_rate(j,1)
	!						!seg1_seg2_marcus_rate(j,2)
	!						!J_pairs(j,3)
	!						!path_used(j)=.false.
	!						!dr_pair(j)
	!						
	!			END IF
	!		END DO
	!END DO !N_pairs
	index_pair_list=0
	Resid_charged=id_Resid(i_J_max)
	
	R_start=no_box_koord(id_Resid(i_J_max),:)
	R_path=0.0
	R_max(1)=x_box  !R_start(1)+x_box
	R_max(2)=y_box !R_start(2)+y_box
	R_max(3)=z_box  !R_start(3)+z_box

	R_min(1)=-1.0*x_box !R_start(1)-x_box
	R_min(2)=-1.0*y_box !R_start(2)-y_box
	R_min(3)=-1.0*z_box !R_start(3)-z_box
	

	WRITE(*,*) "Start  Location:",R_start
	WRITE(*,*) "R_max  Location:",R_max
	WRITE(*,*) "R_min  Location:",R_min
	Neighbour_found=.true.
	call_exit_loop=.false.
	DO WHILE ( Neighbour_found .eqv. .true. )
		Neighbour_found=.false.
		active_neighbours=0
		DO j=1,N_pairs
			IF( .not. path_used(j) ) THEN
							!!! Criterion find a neighbour for the Resid_charged site
							IF( (seg1_seg2_marcus_rate(j,1) == Resid_charged)) THEN
							       !!! PROBLEM: Reihenfolge und RICHTUNG wird nicht berücksichtigt. 
									!IF( marcus_rate_data(j,1) > marcus_rate_data(j,2) ) THEN  ! 1 ->2 
											!!! add pair_index to the    index_pair_list
											active_neighbours=active_neighbours+1
											
											index_pair_list(active_neighbours)=j
											Neighbour_found=.true.	
									!END IF !! compare direction 	
									
									
							ELSE IF (seg1_seg2_marcus_rate(j,2) == Resid_charged) THEN									
								    !!! PROBLEM: Reihenfolge und RICHTUNG wird nicht berücksichtigt. 
									!IF( marcus_rate_data(j,2) > marcus_rate_data(j,1) ) THEN  ! 2 ->1 
											!!! add pair_index to the    index_pair_list
											active_neighbours=active_neighbours+1
											
											index_pair_list(active_neighbours)=j
											Neighbour_found=.true.	
									!END IF !! compare direction 																

							END IF ! 
			END IF
		END DO ! N_pairs
		
		IF(.not. Neighbour_found .OR. (active_neighbours==0)) THEN
			WRITE(*,*) 'No free (unused) next neighbour on the pathway., Exit loop '
			WRITE(*,*) 'Latest charge location at Resid: ',Resid_charged
			WRITE(*,*) 'Traveled distance: ',R_path,'   |d|',norm(R_path)
			call_exit_loop=.true.
			EXIT
		END IF	
		
		!WRITE(*,*) 'Resid:', Resid_charged, 'Neighbourindexlist: ', index_pair_list(1:active_neighbours)
		!! find the a pathway in possible neighbours
		!! Richtungsinformation ist im Stromvektor enthalten. 
		J_max=norm(J_pairs(index_pair_list(1),:))
		i_J_max=index_pair_list(1)
		DO i=1,active_neighbours
			!!! look for maximum current
			norm_J=norm(J_pairs(index_pair_list(i),:))
			IF ( abs(norm_J) > J_max) THEN
					J_max=norm_J
					i_J_max=index_pair_list(i)
			END IF			
		END DO 
		
		
		!!! Selected pair / jump on pathway 
		!						!seg1_seg2_marcus_rate(j,1)
		!						!seg1_seg2_marcus_rate(j,2)
		!						!J_pairs(j,3)
		!						!path_used(j)=.true.
		!						!dr_pair(j)
		path_used(i_J_max)=.true.
		WRITE(*,*)  i_J_max,seg1_seg2_marcus_rate(i_J_max,1),seg1_seg2_marcus_rate(i_J_max,2),J_pairs(i_J_max,:),dr_pair(i_J_max,:)
		
		!! move the charge to the next hopping site.
		IF( Resid_charged == seg1_seg2_marcus_rate(i_J_max,1)) THEN
			Resid_charged=seg1_seg2_marcus_rate(i_J_max,2)
			R_path=R_path+dr_pair(i_J_max,:)
		ELSE
			Resid_charged=seg1_seg2_marcus_rate(i_J_max,1)
			R_path=R_path+dr_pair(i_J_max,:)
		END IF	
		!! Add not site to pathway
		WRITE(10,*)   1
		WRITE(10,*)   'STEP:   ',k+1
		WRITE(10,*)   'O ',no_box_koord(Resid_charged,:)
		WRITE(11,*)   'O ',no_box_koord(Resid_charged,:)
		DO l=1,3
			IF( (R_path(l) > R_max(l)) .OR. (R_path(l) < R_min(l)) ) THEN
				WRITE(*,*) R_path(:)
				call_exit_loop=.true.
				WRITE(*,*) "Exit loop, traveled through one box distance"
			END IF
		END DO
		
		k=k+1
		IF (k > 1.0E5) THEN
			WRITE(*,*) 'Warning: too many loops in current pathway determination.'
			CALL EXIT (1)
		END IF
		IF(call_exit_loop) THEN
			WRITE(*,*) 'Exit the pathmay loop.'
			WRITE(*,*) 'Traveled distance: ',R_path
			EXIT
		END IF
	END DO 

	!						
	

	WRITE(*,*) 'END	: Finde pathway with highest current.'
	
END SUBROUTINE find_high_current_pathway




!! current [0,1] to pdb format conversion
!! stores data in pbd   alpha  array.
subroutine current_to_pdb_from_gro(filename,N_Resids,Gesamtanzahl,R_u_I,residue_names,atomsorteA,koordA,&
			&J_current,J_for_Resid_ok,x_box,y_box,z_box)
			use small_functions
implicit none
character(len=500), intent(in)                :: filename
INTEGER                            			  :: N_Resids,Gesamtanzahl
REAL, DIMENSION (Gesamtanzahl,3)   			  :: koordA
CHARACTER (LEN=5), DIMENSION (Gesamtanzahl)   :: residue_names,atomsorteA
REAL, DIMENSION (N_Resids)         :: J_current
LOGICAL, DIMENSION(N_Resids)       :: J_for_Resid_ok
INTEGER, DIMENSION (N_Resids+1,2)  :: R_u_I
!!INTEGER, DIMENSION (N_Resids)  :: resids
!! local variables
real, ALLOCATABLE  , DIMENSION(:)               :: x, y, z, alpha, beta
character(len=5), ALLOCATABLE  , DIMENSION(:)   :: resname
character(len=5), ALLOCATABLE  , DIMENSION(:)   :: atomname
character(len=1), ALLOCATABLE  , DIMENSION(:)   :: chain
character(len=1)::chain_num
integer, ALLOCATABLE  , DIMENSION(:)            :: ires
integer:: N_data_points,i,j,k
real::x_box,y_box,z_box		
	WRITE(*,*) 'START:  current_to_pdb: '//TRIM(filename)
	
	N_data_points=0
	DO i=1,N_Resids
			IF(J_for_Resid_ok(i))THEN				
					N_data_points=N_data_points + (R_u_I(i+1,2)-R_u_I(i,2))
			END IF
	END DO
	IF(N_data_points == 0) THEN
		WRITE(*,*) 'Error: No data points found: ',N_data_points
		CALL EXIT(1) 
	ELSE
		WRITE(*,*) 'N_data_points: ',N_data_points,'  N_hopping_sites:',count(J_for_Resid_ok)
	END IF
	
	ALLOCATE(x(N_data_points))
	ALLOCATE(y(N_data_points))
	ALLOCATE(z(N_data_points))
	
	ALLOCATE(resname(N_data_points))
	ALLOCATE(atomname(N_data_points))
	ALLOCATE(ires(N_data_points))
	ALLOCATE(chain(N_data_points))
	ALLOCATE(alpha(N_data_points))
	ALLOCATE(beta(N_data_points))
	
	atomname="S"
	resname='TMP'
	chain="1"
	ires=1
	alpha=0.0
	beta=0.0
	chain_num="0"
							
	k=0
	DO i=1,N_Resids

		IF(J_for_Resid_ok(i)) THEN
				IF(residue_names(R_u_I(i,2)) =='DPBIK') THEN
					chain_num="1"
				ELSE IF (residue_names(R_u_I(i,2))(1:2) =='PH') THEN					
					resname=residue_names(R_u_I(i,2))
					chain_num="2"
				ELSE
					chain_num="0"
				END IF
		
				DO j=R_u_I(i,2),R_u_I(i+1,2)-1
						k=k+1
						x(k)=koordA(j,1)
						y(k)=koordA(j,2)
						z(k)=koordA(j,3)
						atomname(k)=atomsorteA(j)
						resname(k)=residue_names(j)(1:3)
						chain(k)=chain_num
						alpha(k)=(J_current(i))
						!WRITE(*,*) R_u_I(i,1),R_u_I(i,2),x(k), y(k), z(k), resname(k), atomname(k), ires(k), chain(k), alpha(k), beta(k)
				END DO
		END IF
	END DO
		
	call writePDB(filename, N_data_points,  x, y, z, resname, atomname, ires, chain, alpha, beta, x_box,y_box,z_box)
	
	WRITE(*,*) 'End current to pdb: '//TRIM(filename)
end subroutine current_to_pdb_from_gro






!! current [0,1] to pdb format conversion
!! stores data in pbd   alpha  array.
subroutine current_to_pdb(filename,N_Resids,coord,J_current,J_for_Resid_ok,x_box,y_box,z_box)
		use small_functions
		implicit none
		character(len=500), intent(in) :: filename
		INTEGER                        :: N_Resids
		REAL, DIMENSION (N_Resids,3)   :: coord
		REAL, DIMENSION (N_Resids)     :: J_current
		LOGICAL, DIMENSION(N_Resids)   :: J_for_Resid_ok
		!!INTEGER, DIMENSION (N_Resids)  :: resids
		!! local variables
		real, ALLOCATABLE  , DIMENSION(:)               :: x, y, z, alpha, beta
		character(len=5), ALLOCATABLE  , DIMENSION(:)   :: resname
		character(len=5), ALLOCATABLE  , DIMENSION(:)   :: atomname
		character(len=1), ALLOCATABLE  , DIMENSION(:)   :: chain
		integer, ALLOCATABLE  , DIMENSION(:)            :: ires
		integer:: N_data_points,i,k	
		real::x_box,y_box,z_box	
			WRITE(*,*) 'START:  current_to_pdb: '//TRIM(filename)

			N_data_points=COUNT(J_for_Resid_ok)
			ALLOCATE(x(N_data_points))
			ALLOCATE(y(N_data_points))
			ALLOCATE(z(N_data_points))
			
			ALLOCATE(resname(N_data_points))
			ALLOCATE(atomname(N_data_points))
			ALLOCATE(ires(N_data_points))
			ALLOCATE(chain(N_data_points))
			ALLOCATE(alpha(N_data_points))
			ALLOCATE(beta(N_data_points))
			
			atomname="S"
			resname='TMP'
			chain="1"
			ires=1
			alpha=0.0
			beta=0.0
				
			k=0
			DO i=1,N_Resids
				IF(J_for_Resid_ok(i)) THEN
						k=k+1
						x(k)=coord(i,1)
						y(k)=coord(i,2)
						z(k)=coord(i,3)

						alpha(k)=(J_current(i))
						!WRITE(*,*) x(k), y(k), z(k), resname(k), atomname(k), ires(k), chain(k), alpha(k), beta(k)
				END IF
			END DO
				
			call writePDB(filename, N_data_points,  x, y, z, resname, atomname, ires, chain, alpha, beta, x_box,y_box,z_box)
			
			WRITE(*,*) 'End current to pdb: '//TRIM(filename)
end subroutine current_to_pdb



!! subroutine to write a PDB file from the input data
!!         writePDB(filename, n,  x, y, z, resname, atomname, ires, chain, alpha, beta)
Subroutine writePDB(filename, n,  x, y, z, resname, atomname, ires, chain, alpha, beta,x_box,y_box,z_box)
		implicit none
		character(len=500), intent(in) :: filename
		integer, intent(in) :: n
		real, intent(in) :: x(:), y(:), z(:), alpha(:), beta(:)
		character(len=5), intent(in) :: resname(:)
		character(len=5), intent(in) :: atomname(:)
		character(len=1), intent(in) :: chain(:)
		integer, intent(in) :: ires(:)
		integer :: i
		real, intent(in)::x_box,y_box,z_box
			OPEN(unit=1,FILE=filename, status='unknown', action = 'write')
			Write(1,'("REMARK Author Name")')
			Write(1,'(A6,3F9.3,A33)') "CRYST1",x_box,y_box,z_box,"90.00  90.00  90.00 P 1        1"
			do i = 1, N
					Write(1,555) "ATOM  ", i, adjustR(atomname(i)), resname(i), chain(i), ires(i), x(i), y(i), z(i), &
					alpha(i), beta(i)
			enddo
			write(1,'("END")')
			Close(1)
		555 format(a6, i5, a5, 1x, a3, 1x, a, i4, 4x, 3F8.3, 2F6.2)
			Return
End subroutine writePDB




!! reading read_marcus_rate_data_file 
!! with the format from sql file: id,seg1,seg2,drX,drY,drZ,rate12h,rate21h 
!! Replace "|" with "whitespace" beforehand; Take the index shift between votca and my_kmc into account!  
!! sqlite3 statefile.sql " SELECT id,seg1,seg2,drX,drY,drZ,rate12h,rate21h FROM pairs " >> marcus_rate_data.dat
!! sed -i 's/|/   /g' -i marcus_rate_data.dat 
SUBROUTINE read_marcus_rate_data_file(marcus_rate_filename,id_marcus_rate,&
					&seg1_seg2_marcus_rate,dr_pair,marcus_rate_data,N_rates_lines)
	use small_functions
	implicit none
    !! filename to read marcus_rate_ data 
    CHARACTER(500), INTENT(IN) :: marcus_rate_filename
    !! Array for hole marcus_rate dataes
    !! marcus rate data(i,j) i=1:N_pairs ; , j=1 rate12(h/e), j=2 rate21 (h,e)  
    REAL, ALLOCATABLE, DIMENSION(:,:)    , INTENT(OUT) :: marcus_rate_data,dr_pair
    !! Resids of molecule id in segments
    INTEGER, ALLOCATABLE, DIMENSION(:) , INTENT(OUT) :: id_marcus_rate
    !! Resids of segment 1 and segment 2 in votca 
    INTEGER, ALLOCATABLE, DIMENSION(:,:) , INTENT(OUT) :: seg1_seg2_marcus_rate
    INTEGER, INTENT(OUT)::N_rates_lines
    CHARACTER(50) ::dummy_str
    INTEGER:: ierror,i,N_skip_line,N_lines
    LOGICAL:: DEBUG=.false.
    LOGICAL :: Datei_vorhanden

		INQUIRE(file=TRIM(marcus_rate_filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
		IF( .NOT. Datei_vorhanden) THEN
					WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(marcus_rate_filename)
					WRITE(*,*) ' ENDE'
					CALL EXIT (1)
		END IF ! Datei-file vorhanden 
		WRITE(*,*) 'Reading data from: ',TRIM(marcus_rate_filename)


		N_lines=Read_rows_file2(marcus_rate_filename)
		OPEN(UNIT=29,FILE=TRIM(marcus_rate_filename),STATUS='OLD',IOSTAT=ierror)
		!WRITE(*,*) 'Read marcus_rate_ file data from file: '//TRIM(marcus_rate_filename)
		ierror=0
		N_skip_line=0
		N_lines=0
		DO WHILE ( ierror == 0 )
			Read(29,*,IOSTAT=ierror) dummy_str
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(marcus_rate_filename),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
			if ( dummy_str(1:1) == '#' ) THEN ! Check ob erster Buchstabe ein #-Zeichen ist, um kommentare zu lesen
				N_skip_line=N_skip_line+1
				N_lines=N_lines+1
			ELSE
				N_lines=N_lines+1
			END IF
		END DO
		CLOSE(29)
		WRITE(*,*) 'N_lines: ',N_lines,' N_skip_line: ',N_skip_line

		OPEN(UNIT=35,FILE=TRIM(marcus_rate_filename),STATUS='OLD',IOSTAT=ierror)
		IF (N_skip_line > 0 ) THEN ! Auslassen der Zeilen mit '#'
			DO i =1,N_skip_line
				Read(35,*,IOSTAT=ierror) dummy_str
			END DO
		END IF
		N_rates_lines=N_lines-N_skip_line
		ALLOCATE(id_marcus_rate(N_rates_lines))
		!! marcus rate data(i,j) i=1:N_pairs ; , j=1 rate12(h/e), j=2 rate21 (h,e)   
		ALLOCATE(marcus_rate_data(N_rates_lines,2))
		ALLOCATE(dr_pair(N_rates_lines,3))
		ALLOCATE(seg1_seg2_marcus_rate(N_rates_lines,2))

		id_marcus_rate=0
		marcus_rate_data=0
		dr_pair=0
		seg1_seg2_marcus_rate=0

		DO i=1,N_rates_lines
			!!!! read                   id,seg1,seg2,drX,drY,drZ,rate12h,rate21h
			READ(35,*,IOSTAT=ierror) id_marcus_rate(i),seg1_seg2_marcus_rate(i,1),seg1_seg2_marcus_rate(i,2),&
				& dr_pair(i,1),dr_pair(i,2),dr_pair(i,3),marcus_rate_data(i,1),marcus_rate_data(i,2)
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(marcus_rate_filename),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
		END DO ! Read Data
		CLOSE(35)
		IF (DEBUG) THEN
			WRITE(*,*) 'marcus_rate_ from file: '//TRIM(marcus_rate_filename)
			WRITE(*,*) '      id,       seg1,seg2,    drX,drY,drZ,       rate12, rate21 '
			DO i=1,N_rates_lines
				WRITE(*,*)  id_marcus_rate(i),seg1_seg2_marcus_rate(i,1),seg1_seg2_marcus_rate(i,2),&
				& dr_pair(i,1),dr_pair(i,2),dr_pair(i,3),marcus_rate_data(i,1),marcus_rate_data(i,2)
			END DO 
			WRITE(*,*) 'Ende marcus_rate__file'
		END IF

		WRITE(*,*)   'read_marcus_rate_data_file: done ' 

END SUBROUTINE read_marcus_rate_data_file 



SUBROUTINE read_no_box_COM_file(no_box_COM_file,elements,no_box_koord,MAX_COM)
	!! Read data from xyz file for no_box data for kmc simulation with backmapped centers of hopping sites inside the box.
	use small_functions
	IMPLICIT NONE
	Character(500) ,INTENT(IN) :: no_box_COM_file
	!! Array with coordinates
	REAL, ALLOCATABLE, DIMENSION(:,:) ,INTENT(OUT) :: no_box_koord
	INTEGER, INTENT(OUT) ::MAX_COM
	LOGICAL::Datei_vorhanden
	INTEGER::i,j,ierror
	CHARACTER(LEN=5), ALLOCATABLE, DIMENSION(:):: elements

	INQUIRE(file=TRIM(no_box_COM_file),exist=Datei_vorhanden) ! Abfrage ob no_box_COM_file-Datei vorhanden ist.
	IF( .NOT. Datei_vorhanden) THEN
		WRITE(*,*) ' Anmerkung: Die_no_box_COM_file_Datei_ist_nicht_vorhanden.'//TRIM(no_box_COM_file)
		CALL EXIT (1)                                                                               
	ELSE 
		WRITE(*,*) 'Read Data from no_box_COM_file: ',TRIM(no_box_COM_file)
		OPEN(UNIT=78,FILE=TRIM(no_box_COM_file),STATUS='OLD',IOSTAT=ierror)

		READ(78,'(I8,/)') MAX_COM                !Einlesen der Atomanzahl / Center of Masses im COM-File.xyz

		!Read(78,*) dummyname              !Einlesen des Infokopfes im File
		!WRITE(*,*) dummyname
		ALLOCATE(no_box_koord(MAX_COM,3))
		ALLOCATE(elements(MAX_COM))
		no_box_koord=0
		i=0
		DO j=1,MAX_COM
					Read(78,*,IOSTAT=ierror) elements(j),no_box_koord(j,1),no_box_koord(j,2),no_box_koord(j,3)
					!WRITE(*,*) no_box_koord(j,1),no_box_koord(j,2),no_box_koord(j,3)
		            IF(ierror < 0) EXIT
		            IF(ierror > 0) THEN
		                WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(no_box_COM_file),'aufgetreten.'
		                WRITE(*,*) 'Beende Einlesen !'
		                CALL EXIT (1)
		            END IF
		END DO
		CLOSE(78)
	END IF ! no_box_COM_file.xyz vorhanden 

END SUBROUTINE read_no_box_COM_file

!! reading read_total_occupation_file 
!! with the format from sql file: id,occPh
!! Replace "|" with "whitespace" beforehand; Take the index shift between votca and my_kmc into account!  
!! sqlite3 statefile.sql " SELECT id,occPh FROM segments " >> tot_occ_DIPBI_P3HT.dat
!! sed -i 's/|/   /g' -i tot_occ_DIPBI_P3HT.dat 
SUBROUTINE read_total_occupation_file2(tot_occ_filename,id_tot_occ,tot_occ_data,N_tot_occ_lines)
			use small_functions
			implicit none
			!! filename to read tot_occ data 
			CHARACTER(500), INTENT(IN) :: tot_occ_filename
			!! Array for hole tot_occ_h           tot_occ_data(i,1)   ; neutral  tot_occ_data(i,2)    and    electron tot_occ_e  tot_occ_data(i,3)
			REAL, ALLOCATABLE, DIMENSION(:)    , INTENT(OUT) :: tot_occ_data 
			!! Resids of molecule id in segments
			INTEGER, ALLOCATABLE, DIMENSION(:) , INTENT(OUT) :: id_tot_occ
			INTEGER, INTENT(OUT)::N_tot_occ_lines
			CHARACTER(50) ::dummy_str
			INTEGER:: ierror,i,N_skip_line,N_lines
			LOGICAL:: DEBUG=.false.
			LOGICAL:: Datei_vorhanden

		INQUIRE(file=TRIM(tot_occ_filename),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
		IF( .NOT. Datei_vorhanden) THEN
					WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(tot_occ_filename)
					WRITE(*,*) ' ENDE'
					CALL EXIT (1)
		END IF ! Datei-file vorhanden 
		WRITE(*,*) 'Reading data from: ',TRIM(tot_occ_filename)


		N_lines=Read_rows_file2(tot_occ_filename)
		OPEN(UNIT=29,FILE=TRIM(tot_occ_filename),STATUS='OLD',IOSTAT=ierror)
		!WRITE(*,*) 'Read tot_occ file data from file: '//TRIM(tot_occ_filename)
		ierror=0
		N_skip_line=0
		N_lines=0
		DO WHILE ( ierror == 0 )
			Read(29,*,IOSTAT=ierror) dummy_str
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(tot_occ_filename),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
			if ( dummy_str(1:1) == '#' ) THEN ! Check ob erster Buchstabe ein #-Zeichen ist, um kommentare zu lesen
				N_skip_line=N_skip_line+1
				N_lines=N_lines+1
			ELSE
				N_lines=N_lines+1
			END IF
		END DO
		CLOSE(29)
		WRITE(*,*) 'N_lines: ',N_lines,' N_skip_line: ',N_skip_line

		OPEN(UNIT=35,FILE=TRIM(tot_occ_filename),STATUS='OLD',IOSTAT=ierror)
		IF (N_skip_line > 0 ) THEN ! Auslassen der Zeilen mit '#'
			DO i =1,N_skip_line
				Read(35,*,IOSTAT=ierror) dummy_str
			END DO
		END IF
		N_tot_occ_lines=N_lines-N_skip_line
		ALLOCATE(id_tot_occ(N_tot_occ_lines))
		ALLOCATE(tot_occ_data(N_tot_occ_lines))

		id_tot_occ=0
		tot_occ_data=0

		DO i=1,N_tot_occ_lines
			!!!! read                    id_occ          occPh
			READ(35,*,IOSTAT=ierror) id_tot_occ(i),tot_occ_data(i)
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(tot_occ_filename),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
		END DO ! Read Data
		CLOSE(35)
		IF (DEBUG) THEN
			WRITE(*,*) 'tot_occ from file: '//TRIM(tot_occ_filename)
			WRITE(*,*) '      id_occ          occPh '
			DO i=1,N_tot_occ_lines
				WRITE(*,*) id_tot_occ(i),tot_occ_data(i)
			END DO 
			WRITE(*,*) 'Ende tot_occ_file'
		END IF

END SUBROUTINE read_total_occupation_file2   


SUBROUTINE dump_sql_data_for_current_I(votca_sql_filename,tot_occ_filename,marcus_rate_filename,carriertype)
	IMPLICIT NONE
	CHARACTER(500), INTENT(IN) ::votca_sql_filename,tot_occ_filename,marcus_rate_filename
	CHARACTER(500)  :: carriertype
	CHARACTER(5000) :: bashline
	LOGICAL::Datei_vorhanden


        inquire(file=TRIM(votca_sql_filename),exist=Datei_vorhanden) ! Abfrage ob votca_sql_filename-Datei vorhanden ist.
        IF( .NOT. Datei_vorhanden) THEN
                WRITE(*,*) ' Fehler: Die_votca_sql_filename_Datei_ist_nicht_vorhanden. '//TRIM(votca_sql_filename)
                WRITE(*,*) ' ENDE'
                CALL EXIT (1)
        END IF  

        inquire(file=TRIM(tot_occ_filename),exist=Datei_vorhanden) ! Abfrage ob tot_occ_filename-Datei vorhanden ist.
        IF( Datei_vorhanden) THEN
                WRITE(*,*) ' Fehler: Die_tot_occ_filename_Datei_ist_bereits_vorhanden. '//TRIM(tot_occ_filename)
		WRITE(*,*) ' Stellen Sie sicher, dass diese nicht ueberschrieben wird von *.sql Daten.'
                WRITE(*,*) ' ENDE'
                CALL EXIT (1)
        END IF  

        inquire(file=TRIM(marcus_rate_filename),exist=Datei_vorhanden) ! Abfrage ob marcus_rate_filename-Datei vorhanden ist.
        IF( Datei_vorhanden) THEN
                WRITE(*,*) ' Fehler: Die_marcus_rate_filename_Datei_ist_bereits_vorhanden. '//TRIM(marcus_rate_filename)
		WRITE(*,*) ' Stellen Sie sicher, dass diese nicht ueberschrieben wird von *.sql Daten.'

                WRITE(*,*) ' ENDE'
                CALL EXIT (1)
        END IF 

	!! createa a file that can be read by SUBROUTINE read_total_occupation_file 
	!! with the format from sql file: id,occPh
	!! Replace "|" with "whitespace" beforehand; Take the index shift between votca and my_kmc into account!  
	!! sqlite3 statefile.sql " SELECT id,occPh FROM segments " >> tot_occ_data.dat
	!! sed -i 's/|/   /g' -i tot_occ_data.dat 

	if( (index(carriertype,'el') .ne. 0) .or. (index(carriertype,'e') .ne. 0) ) then
		bashline=' sqlite3 '//TRIM(votca_sql_filename)//' " SELECT id,occPe FROM segments " | '//" sed 's/|/   /g' | awk '{printf"//&
		&' "%i   %.10E\n",$1,$2} '//" ' >  "//TRIM(tot_occ_filename)
	else
		bashline=' sqlite3 '//TRIM(votca_sql_filename)//' " SELECT id,occPh FROM segments " | '//" sed 's/|/   /g' | awk '{printf"//&
		&' "%i   %.10E\n",$1,$2} '//" ' >  "//TRIM(tot_occ_filename)
	endif ! carriertype
	WRITE(*,*) 'Use: ',TRIM(bashline)
        CALL execute_command_line(TRIM(bashline)) 

	!bashline="  sed -i 's/|/   /g' -i  "//TRIM(tot_occ_filename)
	!WRITE(*,*) 'Use: ',TRIM(bashline)
        !CALL execute_command_line(TRIM(bashline)) 


	!! create data file which can be read from SUBROUTINE read_marcus_rate_data_file 
	!! with the format from sql file: id,seg1,seg2,drX,drY,drZ,rate12h,rate21h 
	!! Replace "|" with "whitespace" beforehand; Take the index shift between votca and my_kmc into account!  
	!! sqlite3 statefile.sql " SELECT id,seg1,seg2,drX,drY,drZ,rate12h,rate21h FROM pairs " >> marcus_rate_data.dat
	!! sed -i 's/|/   /g' -i marcus_rate_data.dat 
	if( (index(carriertype,'el') .ne. 0) .or. (index(carriertype,'e') .ne. 0) ) then
		bashline=' sqlite3 '//TRIM(votca_sql_filename)//&
		&' " SELECT id,seg1,seg2,drX,drY,drZ,rate12e,rate21e FROM pairs " >> '//TRIM(marcus_rate_filename)
	else
		bashline=' sqlite3 '//TRIM(votca_sql_filename)//&
		&' " SELECT id,seg1,seg2,drX,drY,drZ,rate12h,rate21h FROM pairs " >> '//TRIM(marcus_rate_filename)
	endif
	WRITE(*,*) 'Use: ',TRIM(bashline)
        CALL execute_command_line(TRIM(bashline)) 

	bashline="  sed -i 's/|/   /g' -i  "//TRIM(marcus_rate_filename)
	WRITE(*,*) 'Use: ',TRIM(bashline)
        CALL execute_command_line(TRIM(bashline)) 

END SUBROUTINE dump_sql_data_for_current_I


INTEGER FUNCTION Calc_N_electrons_in(atomsorte,N_Atoms,Kette) ! 
!! Berechnet der Anzahl der Elektronen        
!! Wenn Kette=false, dann wird die Ladung fuer CH1,CH2,CH3 in gro format =0 gesetzte
        IMPLICIT NONE
        Integer, INTENT(IN) :: N_Atoms
        Character(5), Dimension(N_Atoms), INTENT(IN) :: atomsorte
        integer::i
        integer::z_ges,z_i
        LOGICAL, INTENT(IN)::Kette 

       ! Berechnung der Anzahl der Elektronen im neutralen Molekül z_ges 
        z_ges=0
        DO i=1,N_Atoms
           z_i=0
           ! .gro Gruppen
           if (TRIM(adjustl(atomsorte(i)))=='HC')  z_i=1    ! fuer H
           if (KETTE) THEN 
                if (TRIM(adjustl(atomsorte(i)))=='CH1') z_i=12   ! fuer 1H und 1C 
                if (TRIM(adjustl(atomsorte(i)))=='CH2') z_i=14   ! fuer 2H und 1C  
                if (TRIM(adjustl(atomsorte(i)))=='CH3') z_i=15   ! fuer 3H und 1C  
           else 
                if (TRIM(adjustl(atomsorte(i)))=='CH1') z_i=0   ! fuer 1H und 1C 
                if (TRIM(adjustl(atomsorte(i)))=='CH2') z_i=0   ! fuer 2H und 1C  
                if (TRIM(adjustl(atomsorte(i)))=='CH3') z_i=0   ! fuer 3H und 1C  
           end if
           if (TRIM(adjustl(atomsorte(i)))=='CA')  z_i=12   ! fuer CA = C  
           if (TRIM(adjustl(atomsorte(i)))=='NR')  z_i=7   ! fuer NR = N 
           if (TRIM(adjustl(atomsorte(i)))=='NT')  z_i=7   ! fuer NT = N 
           ! Normale Atome
           if (TRIM(adjustl(atomsorte(i)))=='H')  z_i=1!Wasserstoff     H       1
           if (TRIM(adjustl(atomsorte(i)))=='He') z_i=2!Helium          He      2
           if (TRIM(adjustl(atomsorte(i)))=='Li') z_i=3!Lithium         Li      3
           if (TRIM(adjustl(atomsorte(i)))=='Be') z_i=4!Beryllium       Be      4
           if (TRIM(adjustl(atomsorte(i)))=='B')  z_i=5!Bor     B       5
           if (TRIM(adjustl(atomsorte(i)))=='C')  z_i=6!Kohlenstoff     C       6
           if (TRIM(adjustl(atomsorte(i)))=='N')  z_i=7!        Stickstoff      N       7
           if (TRIM(adjustl(atomsorte(i)))=='O')  z_i=8!        Sauerstoff      O       8
           if (TRIM(adjustl(atomsorte(i)))=='F')  z_i=9!        Fluor   F       9
           if (TRIM(adjustl(atomsorte(i)))=='Ne') z_i=10!        Neon    Ne      10
           if (TRIM(adjustl(atomsorte(i)))=='Na') z_i=11!        Natrium         Na      11
           if (TRIM(adjustl(atomsorte(i)))=='Mg') z_i=12!Magnesium       Mg      12
           if (TRIM(adjustl(atomsorte(i)))=='Al') z_i=13!        Aluminum        Al      13
           if (TRIM(adjustl(atomsorte(i)))=='Si') z_i=14!        Silizium        Si      14
           if (TRIM(adjustl(atomsorte(i)))=='P')  z_i=15!        Phosphor        P       15
           if (TRIM(adjustl(atomsorte(i)))=='S')  z_i=16!Schwefel        S       16
           if (TRIM(adjustl(atomsorte(i)))=='Cl') z_i=17!Chlor   Cl      17
           if (TRIM(adjustl(atomsorte(i)))=='K')  z_i=19!        Kalium  K       19
           if (TRIM(adjustl(atomsorte(i)))=='Ar') z_i=17!Argon   Ar      18
           if (TRIM(adjustl(atomsorte(i)))=='Ca') z_i=20!Kalzium         Ca      20
           if (TRIM(adjustl(atomsorte(i)))=='Sc') z_i=21!        Scandium        Sc      21
           if (TRIM(adjustl(atomsorte(i)))=='Ti') z_i=22!Titan   Ti      22
           if (TRIM(adjustl(atomsorte(i)))=='V')  z_i=23 !        Vanadium        V       23
           if (TRIM(adjustl(atomsorte(i)))=='Cr') z_i=24!        Chrom   Cr      24
           if (TRIM(adjustl(atomsorte(i)))=='Mn') z_i=25!Mangan  Mn      25
           if (TRIM(adjustl(atomsorte(i)))=='Fe') z_i=26!Eisen   Fe      26
           if (TRIM(adjustl(atomsorte(i)))=='Ni') z_i=28!        Nickel  Ni      28
           if (TRIM(adjustl(atomsorte(i)))=='Co') z_i=27!        Kobalt  Co      27
           if (TRIM(adjustl(atomsorte(i)))=='Cu') z_i=29!Kupfer  Cu      29
           if (TRIM(adjustl(atomsorte(i)))=='Zn') z_i=30!Zink    Zn      30
           if (TRIM(adjustl(atomsorte(i)))=='Ga') z_i=31!Gallium         Ga      31
           if (TRIM(adjustl(atomsorte(i)))=='Ge') z_i=32!Germanium       Ge      32
           if (TRIM(adjustl(atomsorte(i)))=='As') z_i=33!        Arsen   As      33
           if (TRIM(adjustl(atomsorte(i)))=='Se') z_i=34!Selen   Se      34
           if (TRIM(adjustl(atomsorte(i)))=='Br') z_i=35!Brom    Br      35
           if (TRIM(adjustl(atomsorte(i)))=='Kr') z_i=36!Krypton         Kr      36
           if (TRIM(adjustl(atomsorte(i)))=='Rb') z_i=37!        Rubidium        Rb      37
           if (TRIM(adjustl(atomsorte(i)))=='Sr') z_i=38!Strontium       Sr      38
           if (TRIM(adjustl(atomsorte(i)))=='Y')  z_i=39!        Yttrium         Y       39
           if (TRIM(adjustl(atomsorte(i)))=='Zr') z_i=40!Zirkonium       Zr      40
           if (TRIM(adjustl(atomsorte(i)))=='Nb') z_i=41!        Nobium  Nb      41
           if (TRIM(adjustl(atomsorte(i)))=='Mo') z_i=42!Molybdän        Mo      42
           if (TRIM(adjustl(atomsorte(i)))=='Tc') z_i=43!Technetium      Tc      43
           if (TRIM(adjustl(atomsorte(i)))=='Ru') z_i=44!Ruthenium       Ru      44
           if (TRIM(adjustl(atomsorte(i)))=='Rh') z_i=45!        Rhodium         Rh      45
           if (TRIM(adjustl(atomsorte(i)))=='Pd') z_i=46!Palladium       Pd      46
           if (TRIM(adjustl(atomsorte(i)))=='Ag') z_i=47!        Silber  Ag      47
           if (TRIM(adjustl(atomsorte(i)))=='Cd') z_i=48!        Kadmium         Cd      48
           if (TRIM(adjustl(atomsorte(i)))=='In') z_i=49!        Indium  In      49
           if (TRIM(adjustl(atomsorte(i)))=='Sn') z_i=50!Zinn    Sn      50
           if (TRIM(adjustl(atomsorte(i)))=='Sb') z_i=51!Antimon         Sb      51
           if (TRIM(adjustl(atomsorte(i)))=='I')  z_i=53!        Jod     I       53
           if (TRIM(adjustl(atomsorte(i)))=='Te') z_i=52!Tellur  Te      52
           if (TRIM(adjustl(atomsorte(i)))=='Xe') z_i=54!        Xenon   Xe      54
           if (TRIM(adjustl(atomsorte(i)))=='Re') z_i=75!        Rhenium         Re      75
           if (TRIM(adjustl(atomsorte(i)))=='Os') z_i=76!Osmium  Os      76
           if (TRIM(adjustl(atomsorte(i)))=='Ir') z_i=77!        Iridium         Ir      77
           if (TRIM(adjustl(atomsorte(i)))=='Pt') z_i=78!        Platin  Pt      78
           if (TRIM(adjustl(atomsorte(i)))=='Au') z_i=79!        Gold    Au      79
           if (TRIM(adjustl(atomsorte(i)))=='Hg') z_i=80!Quecksilber     Hg      80
           if (TRIM(adjustl(atomsorte(i)))=='Tl') z_i=81!        Thallium        Tl      81
           if (TRIM(adjustl(atomsorte(i)))=='Pb') z_i=82!Blei    Pb      82
           if (TRIM(adjustl(atomsorte(i)))=='Bi') z_i=83!        Wismut  Bi      83
           if (TRIM(adjustl(atomsorte(i)))=='Po') z_i=84    !Polonium        Po      84
           if (TRIM(adjustl(atomsorte(i)))=='At') z_i=85     !Astat   At      85
           if (TRIM(adjustl(atomsorte(i)))=='Rn') z_i=86      !    Radon
           
            IF (z_i==0 .and. KETTE) THEN
                WRITE(*,*) 'Es ist ein Fehler bei der Berechnung der Elektronenanzahl z_ges aufgetreten!'
            END IF
            z_ges=z_ges+z_i
        END DO
	Calc_N_electrons_in=z_ges
END FUNCTION Calc_N_electrons_in




!! AUSSCHREIBEN VON DATEN IN EIN CUBEFILE
!! ALLES IN BOHR!!!
!! natom  = anzahl atome
!! xlen = anzahl der Punkte in x-Richtung
!! xinc = Abstand der Punkte in x-Richtung (in  Bohr)
!! Boxlänge: xbox -> xlen = xbox / xinc
subroutine writecube(chgden,xlen,ylen,zlen,xbox,ybox,zbox,natoms,x,y,z,atomicnumber,CUBE_filename)
	  use small_functions
      implicit none
      integer, INTENT(IN)  :: natoms,xlen,ylen,zlen
	  real   , INTENT(IN)  :: xbox,ybox,zbox
	  !! chgden(1:xlen,1:ylen,1:zlen) ! 3D Daten INPUT
      real*8 , DIMENSION (xlen,ylen,zlen) :: chgden
      !! x(1:natoms),y(1:natoms),z(1:natoms)
	  REAL,    DIMENSION (natoms) :: x,y,z
	  !! atomicnumber(1:natoms)
	  INTEGER, DIMENSION (natoms) :: atomicnumber
	  CHARACTER(LEN=*)::CUBE_filename
	  ! Local variables
	  integer :: j,ix,iy,iz,ziter,zover,ierror
      real    :: xinc,yinc,zinc,dum
	  LOGICAL :: Datei_vorhanden

	  real::x_coord_min,y_coord_min,z_coord_min,norm_min
	  real, dimension(3)::r

	INQUIRE(file=TRIM(CUBE_filename),exist=Datei_vorhanden) ! Abfrage ob no_box_COM_file-Datei vorhanden ist.
	IF(Datei_vorhanden) THEN
		WRITE(*,*) ' Anmerkung: Die_CUBE_Datei_ist_bereits_vorhanden. '//TRIM(CUBE_filename)
		CALL EXIT (1)                                                                               
	END IF

	OPEN(UNIT=14,FILE=TRIM(CUBE_filename),STATUS='REPLACE',IOSTAT=ierror)
		 x_coord_min=x(1)	
		 y_coord_min=y(1)
		 z_coord_min=z(1)
		 r(1)=x(1)
		 r(2)=y(1)
		 r(3)=z(1)
		 norm_min=norm(r)
		 DO j=1,natoms
				 r(1)=x(j)
				 r(2)=y(j)
				 r(3)=z(j)
				 if( norm(r) < norm_min ) then
						 x_coord_min=x(j)
						 y_coord_min=y(j)
						 z_coord_min=z(j)
						 norm_min=norm(r)
				 end if
		 ENDDO
		 
	     dum=0.0
         ! natom  = anzahl atome
         ! xlen = anzahl der Punkte in x-Richtung
         ! xinc = Abstand der Punkte in x-Richtung (in  Bohr)
         ! Boxlänge: xbox -> xlen = xbox / xinc
         xinc = xbox / xlen
         yinc = ybox / ylen
         zinc = zbox / zlen
         write(14,*)
         write(14,*)
         !write(14,*) natoms,dum,dum,dum
         !!! Anzahl der Atome und der Ursprung 
         write(14,*) natoms,xinc*0.5,yinc*0.5,zinc*0.5
         write(14,*) xlen,xinc,dum,dum
         write(14,*) ylen,dum,yinc,dum
         write(14,*) zlen,dum,dum,zinc

         ! Inhalt der CUbe-Datei: 3D Array chgden(1:xlen, 1:ylen, 1:zlen)

         ! Schreibe alle Atome

         do j=1,natoms
            ! Ordnungszahl, dummy, x y z Koordinaten der Atome
            ! in Bohr
            write(14,*) atomicnumber(j),dum,x(j),y(j),z(j)
         enddo

         ! Anzahl der Iterationen für das Schreiben in z-Richtung
         ziter=ceiling(real(zlen)/6.0)
         ! "Überhang" für die letzte Zeile jeder z-Iteration
         zover=modulo(zlen,6)
         if(zover.eq.0) zover=6
      
         do ix=1,xlen
            do iy=1,ylen
               do iz=1,ziter-1
                  ! Die innere Schleife ist z
                  write(14,*) (chgden(ix,iy,(iz-1)*6+j), j=1,6)
               enddo
               ! Die letzte z-Iteration kann weniger als sechs Einträge haben
               ! Daher der Überhang
               write(14,*) (chgden(ix,iy,(ziter-1)*6+j), j=1,zover)
            enddo
         enddo

end subroutine writecube



!! Subroutine to read the grofile data.
!!
SUBROUTINE read_my_grofile_data(gro_inputfile,Gesamtanzahl,&
			& atomsorteA,residue_names,koordA,vel,residue_numbers,atom_numbers,R_u_I,x_box,y_box,z_box)
		use small_functions
		implicit none
		CHARACTER(LEN=*)                               :: gro_inputfile
		Character(5), ALLOCATABLE, Dimension(:)        :: atomsorteA,residue_names
		REAL, ALLOCATABLE, DIMENSION(:,:)              :: koordA,vel
		INTEGER, ALLOCATABLE, DIMENSION(:)             :: residue_numbers,atom_numbers
		INTEGER, ALLOCATABLE, DIMENSION(:,:)           :: R_u_I
		INTEGER::Gesamtanzahl,N_Resids
		CHARACTER(LEN=500)::dummyname,line
		INTEGER::start_index,end_index

		INTEGER::N_DIPBI,N_PPDI,N_P3HT,N_P3HT_segments,N_PBDT_TS1,N_PBDT_TS1_segments,N_Species
		INTEGER::ierror
		CHARACTER(5) :: lio
		REAL::nm2Ang=10.0
		INTEGER::i,j,residue_number_old,residue_number
		CHARACTER(LEN=5000)::Bashline
		REAL::x_box,y_box,z_box
		
		
		! Einlesen
		OPEN(UNIT=17,FILE=TRIM(gro_inputfile),STATUS='OLD',IOSTAT=ierror)
		Read(17,*) dummyname                             !Einlesen des Infokopfes im File
		Read(17,*) Gesamtanzahl                          !Einlesen der Atomanzahl im File
			!!! Erstelle String lio=Durcheinander, um die Rechnungen mit Hilfe von Zufallszahlen einzigartig zu machen, sodass keine Interferenzen mit anderen Rechnungen ggf. im gleichen Ordner auftreten können. 
			lio=TRIM(make_lio())
			!! Einlesen der Anzahl der Resids=N_Mol aus gro-file
			Bashline="start_index=$(sed -n '3p' "//TRIM(gro_inputfile)//' | cut -c 1-5) ; end_index=$(tail -2 '//TRIM(gro_inputfile)//&
			&' | head -1 | cut -c 1-5) ; echo ${start_index}  ${end_index} >> s2e_'//TRIM(lio)//'.dat'  ! start 2 end 
			CALL execute_command_line(TRIM(Bashline)) 
			OPEN(UNIT=32,FILE='s2e_'//TRIM(lio)//'.dat',STATUS='unknown',IOSTAT=ierror,action='read')
			READ(32,*) start_index,end_index
			CLOSE(32)
			Bashline=' rm s2e_'//TRIM(lio)//'.dat '
			CALL execute_command_line(TRIM(Bashline)) 

			N_Resids=end_index-start_index+1
			WRITE(*,*)'  N_Resids= ',N_Resids,' in ',TRIM(gro_inputfile)
			WRITE(*,*)'  N_Atoms=  ',Gesamtanzahl,' in ',TRIM(gro_inputfile)
		ALLOCATE(atomsorteA(Gesamtanzahl))
		ALLOCATE(koordA(Gesamtanzahl,3))
		ALLOCATE(vel(Gesamtanzahl,3))           ! velocities(:,v_x,v_y,v_z)
		ALLOCATE(R_u_I(N_Resids+1,2)) ! einen Eintrag mehr, damit an der letzten Stelle, der R_u_I: Resid_und_start_index(N_Resids,Gesamtanzahl+1,2) stehen kann, um die Schleifenbegrenzungen nicht anpassen zu muessen

		ALLOCATE(residue_names(Gesamtanzahl))
		ALLOCATE(residue_numbers(Gesamtanzahl))
		ALLOCATE(atom_numbers(Gesamtanzahl))


		!!! initialize system
		!call init_system(system)

		koordA=0.0
		vel=0.0
		R_u_I=0
		R_u_I(N_Resids+1,1)=-100
		R_u_I(N_Resids+1,2)=Gesamtanzahl+1
		residue_number_old=-1
		i=0
		N_DIPBI=0
		N_PPDI=0
		N_P3HT=0
		N_P3HT_segments=0
		N_PBDT_TS1=0
		N_PBDT_TS1_segments=0
		N_Species=0
		DO j=1,Gesamtanzahl
				READ(17, "(a)",IOSTAT=ierror) line
				BACKSPACE(UNIT=17)
				IF(ierror < 0) EXIT
				IF(ierror > 0) THEN
					WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(gro_inputfile),' aufgetreten.'//TRIM(line)
					WRITE(*,*) 'Beende Einlesen !'
					CALL EXIT (1)
				END IF
			!WRITE(*,*) 'laenge',LEN(TRIM(line)),' line: ',TRIM(line)
			IF (LEN(TRIM(line)) .le. 45 ) THEN ! check if no velocities are written
				!WRITE(*,*) 'case 1'
				!READ(17,*) dummyname
				!WRITE(*,*) dummyname
				!READ(17,'(i5,2a5,i5,3f8.3)') residue_number,residue_name,dummyname,i,x,y,z
				!WRITE(*,*) residue_number,residue_name,trim(dummyname),i,x,y,z
					READ(17,'(i5,2a5,i5,3f8.3)',IOSTAT=ierror) residue_numbers(j),residue_names(j),atomsorteA(j),atom_numbers(j),&
													&koordA(j,1),koordA(j,2),koordA(j,3)
					WRITE(*,'(i5,2a5,i5,3f8.3)',IOSTAT=ierror) residue_numbers(j),residue_names(j),atomsorteA(j),atom_numbers(j),&
												   &koordA(j,1),koordA(j,2),koordA(j,3)

			ELSE ! ordinary *.gro file
					Read(17,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) residue_numbers(j),residue_names(j),atomsorteA(j),atom_numbers(j),&
														   &koordA(j,1),koordA(j,2),koordA(j,3),vel(j,1),vel(j,2),vel(j,3)
					!WRITE(*,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) residue_numbers(j),residue_names(j),atomsorteA(j),atom_numbers(j),&
					!                                      &koordA(j,1),koordA(j,2),koordA(j,3),vel(j,1),vel(j,2),vel(j,3)
			END IF
			IF(ierror < 0) EXIT
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(gro_inputfile),' aufgetreten.'
				WRITE(*,*) 'Beende Einlesen !'
				CALL EXIT (1)
			END IF
			residue_number=residue_numbers(j)
			IF (residue_number /= residue_number_old ) THEN
				i=i+1
				R_u_I(i,1)=residue_number
				R_u_I(i,2)=j
				residue_number_old=residue_number
				IF((residue_names(j) == 'DIPBI') .OR. (residue_names(j) == 'DPBIK'))THEN
					N_DIPBI=N_DIPBI+1
				ELSE IF (residue_names(j)(1:4) == 'PPDI') THEN
					N_PPDI=N_PPDI+1
				ELSE IF (residue_names(j) == '8poly') THEN
					N_PBDT_TS1_segments=N_PBDT_TS1_segments+1
					IF( TRIM(adjustl(atomsorteA(j))) == 'CH3') THEN ! new PBDT_TS1 chain-Start with segment A and a CH3 group.
						N_PBDT_TS1=N_PBDT_TS1+1			
					END IF ! new PBDT_TS1 chain-Start
				ELSE IF ((residue_names(j)(1:3) == 'THP') .OR. (residue_names(j)(1:2) == 'PH') .OR. (residue_names(j)(1:2) == 'PM'))THEN
					N_P3HT_segments=N_P3HT_segments+1
					IF( (residue_names(j)(1:5) == 'THP1A') .OR. (residue_names(j)(5:5) == 'S') )THEN ! 32mer start
						N_P3HT=N_P3HT+1
					END IF ! 32mer start
				ELSE 
					N_Species=N_Species+1
				END IF
			END IF
			IF( i == N_Resids+1) EXIT
			IF (i==0 .and. j==Gesamtanzahl ) THEN
			   write(*,*) ' Error: Es ist ein Fehler beim Einlesen ausgetreten: '//TRIM(gro_inputfile)
			   write(*,*) ' ENDE '
			   CALL EXIT (1)
		   END IF  
		END DO
		Read(17,*,IOSTAT=ierror) x_box,y_box,z_box
		IF( ierror > 0) STOP 'Error: Reading_the_boxsize'
		CLOSE(17)
		x_box=x_box*nm2Ang
		y_box=y_box*nm2Ang
		z_box=z_box*nm2Ang
END SUBROUTINE read_my_grofile_data



end module calc_current_I_from_kmc_data
!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!!  end  calc_current_I_from_kmc_data
!!! ------------------------------------------------------------------------------------------------------------------- !!!


!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!!   Start module    charge_transfer_rate_calculator
!!! ------------------------------------------------------------------------------------------------------------------- !!!
module charge_transfer_rate_calculator

	CONTAINS
	!! rate_calculator()   <= Main function
	!! marcus_rate
	!! marcus_rate_votca
	!! omegaVib
	!! JORTNER_RATE
	!! weiss_dorsey_rate
	!! CGAMA               <= complex gamma function
	!! Factorial        
	!! calc_dE_U_ext  
	!! distance_PBC_correction
	 
subroutine  rate_calculator()
		!!  '  Calculates a charge transfer rate for Marcus, Jortner or Weiss-Dorsey rates '
		!!  '  rate_calculator= [marcus, jortner, weiss-dorsey, all] '
		!!  '  Reads: Charge transfer integral:                 |J_AB|      (eV)   Value is not squared! '
		!!  '         internal reorganization energy:           lambda_in   (eV)'
		!!  '         internal site energy difference:          dE_in       (eV)'
		!!  '         outer-sphere  reorganization energy:      lambda_out  (eV)' 
		!!  '         outer-sphere  energy difference:          dE_out_AB   (eV)'  
		!!  '         external field energy -e*F^{ext} * d =    dE_U_ext    (eV) '
		!!  '         hole / electron transfer rates '
		!!  '  index_S: gives the index for the frequency in jortner rates: '
	
	IMPLICIT NONE
	REAL*8::k_AB_lo,k_AB_el,k_BA_lo,k_BA_el
	CHARACTER(LEN=50):: rate_type,charge_type,method
	REAL*8::average_omegaVib,lambda_out_h,lambda_out_e
	REAL, PARAMETER::PI=ATAN(1.0)*4.0,k_b=8.6173303E-5          !! eV/K
	!!!
	REAL*8, PARAMETER::hbar=6.582119514E-16       !! eV*s
	REAL*8, PARAMETER::q_elementar=1.0 ! da k_b in eV 1.6021766208 !! E-19 Coulomb
	REAL*8:: T,Kondo
	REAL*8:: J_AB_h,J_AB_e
	REAL*8:: lambda_in_el_AB,lambda_in_el_BA,lambda_in_lo_AB,lambda_in_lo_BA
	REAL*8:: dE_in_AB_h, dE_in_AB_e, dE_in_BA_h, dE_in_BA_e, dE_out_AB_h, dE_out_AB_e
	REAL*8:: dE_out_BA_h, dE_out_BA_e
	REAL*8:: dE_U_ext
	CHARACTER(LEN=2000)::bashoutput,inputline,rate_outputfilename
	CHARACTER(LEN=135)::dummyname
	LOGICAL::TEST_RATES=.false.,calc_rate=.true.
	INTEGER::index_S_A,index_S_B
	INTEGER::i,j,k,i_max,ierror
	LOGICAL::DEBUG=.false.
	
	rate_outputfilename='rate_evaluated.dat'
	write(*,*) '================================='
	write(*,*) '|        rate_calculator        |'
	write(*,*) '================================='

	!! defaults, hole or electrpn
	charge_type='electron'
	!!    jortner, marcus, weiss_dorsey, 
	rate_type='marcus'
	
	!! index to frequency for jortner rate [i=1,33] i=1 Thiophene, i=2 2mer, i=3 3mer, i=4 4mer, i=33 DIPBI 
	index_S_A=5
	index_S_B=5
	
	!! temperature T, default T=300
	T=300.0
	
	!! Kondo parameter alpha for weiss-dorsey rate
	!! Asadi. et A. Nature Com. 2013
	!! default: Votca Kondo=4.0 ; rr-P3HT = 3.6 ; rr-P3HT doped 6.75  
	Kondo=3.6 

	!! transition matrix element / electronic coupling in eV  CAUTION HERE |J_AB|  not |J_AB|^2
	J_AB_h=0.0
	J_AB_e=0.0
	
	!! internal reorganizaion energies [eV]
	lambda_in_el_AB=0.0
	lambda_in_el_BA=0.0
	lambda_in_lo_AB=0.0
	lambda_in_lo_BA=0.0
	
	!! outer-sphere reorganizaion energies [eV]
	lambda_out_h=0.0
	lambda_out_e=0.0
	
	!! internal site energie difference [eV]
	dE_in_AB_h=0.0
	dE_in_BA_h=0.0
	dE_in_AB_e=0.0
	dE_in_BA_e=0.0
	
	!! outer-sphere contributions to the site energie difference [eV]
	dE_out_AB_h=0.0
	dE_out_AB_e=0.0
	dE_out_BA_h=0.0
	dE_out_BA_e=0.0
	
	!! rates
	k_AB_lo=0
	k_BA_lo=0
	!! rates
	k_AB_el=0
	k_BA_el=0
	
	!! external field contribution to the site energie difference [eV]
	dE_U_ext=0.0
	
	!!! Default: TEST_RATES=.false. only evaluates rates with selected properties.
	TEST_RATES=.false.
	
	average_omegaVib=0.0
	calc_rate=.true.
	bashoutput=" "
	
	inputline=""
	DO i=1,command_argument_count() 
		CALL get_command_argument(i,dummyname)
		inputline=TRIM(inputline)//'   '//trim(adjustl(dummyname))
	END DO
	write(*,*) '--- input ---'
	WRITE(*,*) trim(inputline)
	write(*,*) '-------------'
	inputline=""
	CALL get_command_argument(1,method)
	
	IF (TRIM(ADJUSTL(method)) == 'rate_calculator' .OR.  TRIM(ADJUSTL(method)) == 'rate' ) THEN
		calc_rate=.true.
	ELSE
		calc_rate=.false.
	ENDIF
	
	IF(command_argument_count() >= 4 ) THEN 
		CALL get_command_argument(2,method)
		IF (TRIM(ADJUSTL(method)) == 'rate_calculator') THEN
			rate_type="marcus"
		ELSE IF (TRIM(method) == "jortner" .OR. TRIM(method) == "Jortner" .OR. TRIM(method) == "JORTNER") THEN
			rate_type="jortner"
		ELSE IF (TRIM(method) == "marcus" .OR. TRIM(method) == "Marcus" .OR. TRIM(method) == "MARCUS") THEN
			rate_type="marcus"
		ELSE IF (TRIM(method) == "weiss_dorsey" .OR. TRIM(method) == "weiss-dorsey" .OR. TRIM(method) == "Weiss-Dorsey" &
		  & .OR. TRIM(method) == "weiss" .OR. TRIM(method) == "Weiss" .OR. TRIM(method) == "WEISS"  ) THEN
			rate_type= "weiss-dorsey"
		ELSE IF (TRIM(method) == "all") THEN
			rate_type= "all"
		ELSE 
			calc_rate=.false.
		END IF
		
		IF(calc_rate) THEN 
					CALL get_command_argument(2,dummyname)
					inputline=TRIM(dummyname)
					!!! Read J_AB
					CALL get_command_argument(3,dummyname)
					inputline=TRIM(inputline)//' '//TRIM(dummyname)
					READ(dummyname,'(f16.4)') J_AB_e
					J_AB_h=J_AB_e
					
					!!! Read   lambda_in
					CALL get_command_argument(4,dummyname)
					inputline=TRIM(inputline)//' '//TRIM(dummyname)
					READ(dummyname,'(f16.4)') lambda_in_el_AB
					lambda_in_lo_AB=lambda_in_el_AB
					lambda_in_lo_BA=lambda_in_el_AB
					lambda_in_el_BA=lambda_in_el_AB
					
					!!! Read   dE_in
					CALL get_command_argument(5,dummyname)
					inputline=TRIM(inputline)//' '//TRIM(dummyname)
					READ(dummyname,'(f16.4)') dE_in_AB_e
					dE_in_AB_h=dE_in_AB_e
					
					!!! Read   lambda_out
					CALL get_command_argument(6,dummyname)
					inputline=TRIM(inputline)//' '//TRIM(dummyname)
					READ(dummyname,'(f16.4)') lambda_out_e
					lambda_out_h=lambda_out_e
					
					!!! Read   dE_out_AB
					CALL get_command_argument(7,dummyname)
					inputline=TRIM(inputline)//' '//TRIM(dummyname)
					READ(dummyname,'(f16.4)') dE_out_AB_e
					dE_out_AB_h=dE_out_AB_e
					dE_out_BA_h=-dE_out_AB_e
					dE_out_BA_e=-dE_out_AB_e


					!!! Read   dE_U_ext
					CALL get_command_argument(8,dummyname)
					inputline=TRIM(inputline)//' '//TRIM(dummyname)
					READ(dummyname,'(f16.4)') dE_U_ext
					
					IF(command_argument_count() >= 9 ) THEN !! Start read charge type 
						CALL get_command_argument(9,dummyname)
						inputline=TRIM(inputline)//' '//TRIM(dummyname)
						IF( TRIM(adjustl(dummyname)) == 'electron') THEN
							charge_type='electron'
						ELSE IF(TRIM(adjustl(dummyname)) == 'hole') THEN
							charge_type= 'hole'
						ELSE
						   !!! Read hole =1 or electron=-1
							READ(dummyname,'(I3)') i
							IF (i ==-1) THEN
								charge_type='electron'
							ELSE IF (i==1) THEN
								charge_type='hole'
							ELSE
								WRITE(*,*) 'ERROR: Select charge_type= [hole=1,electron=-1]  '
								WRITE(*,*) 'Reading: '//TRIM(dummyname)
								CALL EXIT(1)
							END IF 
						END IF
		
					END IF !! End read charge type 
					!! Imdex to refere to the vibrational frequency
					!! Read   index schwefel Jortner rate i=1,32 PH$[i}A i-mer P3HT ; i=33 DIPBI ; 
					!! Pt complexe i=101 K1K,  Pt complexe i=102 K2K,  Pt complexe i=103 K3K,  Pt complexe i=104 K4K, Pt complexe i=107 K7,  Pt complexe i=108 K8,Pt complexe i=109 K9,  Pt complexe i=110 K10,
					!! mCP = 111
					!! NBP = 112
					!! TPBI = 113
					IF(command_argument_count() >= 10 ) THEN 
						CALL get_command_argument(10,dummyname)
						inputline=TRIM(inputline)//' '//TRIM(dummyname)
						READ(dummyname,'(I3)') index_S_A
						CALL get_command_argument(11,dummyname)
						inputline=TRIM(inputline)//' '//TRIM(dummyname)
						READ(dummyname,'(I3)') index_S_B
						WRITE(*,*) 'Read: index_S_A: ',index_S_A,' index_S_B: ',index_S_B
					END IF !!! Read index_S_A, index_S_B for jortner rates


		END IF !rate_calculator
	ELSE
		calc_rate=.false.
	END IF !
	
	
	
	IF(.NOT. calc_rate) THEN
		!!! Expected input data
		WRITE(*,*) '  Calculates a charge transfer rate for Marcus, Jortner or Weiss-Dorsey rates '
		WRITE(*,*) '  rate_calculator= [marcus, jortner, weiss-dorsey, all] '
		WRITE(*,*) '  Reads: Charge transfer integral:                 |J_AB|      (eV)   Value is not squared! '
		WRITE(*,*) '         internal reorganization energy:           lambda_in   (eV)'
		WRITE(*,*) '         internal site energy difference:          dE_in       (eV)'
		WRITE(*,*) '         outer-sphere  reorganization energy:      lambda_out  (eV)' 
		WRITE(*,*) '         outer-sphere  energy difference:          dE_out_AB   (eV)'  
		WRITE(*,*) '         external field energy -e*F^{ext} * d =    dE_U_ext    (eV) '
		WRITE(*,*) '         hole / electron transfer rates '
		WRITE(*,*) '  index_S: gives the index for the frequency in jortner rates: '
		WRITE(*,*) '  index to frequency for jortner rate [i=1,32] i=1 Thiophene, i=2 2mer, i=3 3mer, i=4 4mer, i=33 DIPBI '
		WRITE(*,*) '  Pt complexe i=101 K1K,  Pt complexe i=102 K2K,  Pt complexe i=103 K3K,  Pt complexe i=104 K4K, i=107 K7 ' 
		WRITE(*,*) '  Pt complexe  i=108 K8,   Pt complexe i=109 K9,    Pt complexe i=110 K10,  '
		WRITE(*,*) '  mCP = 111 '
		WRITE(*,*) '  NBP = 112 '
		WRITE(*,*) '  TPBI = 113 '
		WRITE(*,*) '  '
		WRITE(*,*) '  DATA IN    (eV)   rate_type  |J_AB|    lambda_in   dE_in   lambda_out  dE_out_AB  dE_U_ext electron/hole '    
		WRITE(*,*) '  rate_calculator  marcus      |J_AB|    lambda_in   dE_in   lambda_out  dE_out_AB  dE_U_ext '//&
		& '   [-1/+1   index_S_A index_S_B ]'    
		WRITE(*,*) '  rate_calculator  marcus         0.004       0.01       0.0        0.02             0.0            0.02 '//&
		& '       hole   4                 33      ' 
		CALL EXIT(1)
	ELSE
		WRITE(*,*) 'Use:   |J_AB|,   lambda_in       dE_in      lambda_out      dE_out_AB     dE_U_ext '
		WRITE(*,'(6E14.4)') J_AB_e,lambda_in_el_AB,dE_in_AB_e,  lambda_out_e,   dE_out_AB_e,  dE_U_ext
	END IF
	
	
	IF(TRIM(rate_type) =='all') THEN
		i_max=3
	ELSE
		i_max=1
	ENDIF
	
	DO i=1,i_max  ! loop_all_rate_types
	
		IF(i_max==3) THEN
			IF(i==1) THEN
				rate_type= "marcus"
			ELSE IF(i==2) THEN
				rate_type= "jortner"
			ELSE IF(i==3) THEN
				rate_type= "weiss-dorsey"
			END IF 
		END IF
		
	
		IF( (TRIM(rate_type) == "jortner") .OR. (TRIM(rate_type) == "JORTNER") .OR. (TRIM(rate_type) == "Jortner") )THEN
		
			average_omegaVib=(omegaVib(index_S_A) +  &
						 &    omegaVib(index_S_B) )/2.0
						 
						 
			WRITE(*,*) 'Use average_omegaVib: ',average_omegaVib,' [eV] for '//TRIM(rate_type)
			IF(TRIM(adjustl(charge_type)) == 'electron') THEN
				! Electrons 
				if(debug) WRITE(*,*) " jortner: electrons"
				CALL JORTNER_RATE(J_AB_e, lambda_in_el_AB, lambda_in_el_BA, dE_in_AB_e, lambda_out_e,&
													& dE_out_AB_e, dE_U_ext,T,average_omegaVib,k_AB_el,k_BA_el)
												
			ELSE IF(TRIM(adjustl(charge_type)) == 'hole') THEN
				! holes
				if(debug) WRITE(*,*) " jortner: holes"
				CALL JORTNER_RATE(J_AB_h, lambda_in_lo_AB, lambda_in_lo_BA, dE_in_AB_h, lambda_out_h,&
										&  dE_out_AB_h, (-1.0*dE_U_ext),T,average_omegaVib,k_AB_lo,k_BA_lo)
			 END IF ! charge_type
			 
        ELSE IF ( (TRIM(rate_type) == "marcus") .OR. (TRIM(rate_type)== "MARCUS") .OR. (TRIM(rate_type)== "Marcus")  )THEN
        
			IF(TRIM(adjustl(charge_type)) == 'electron') THEN
				!!! marcus: electrons
				if(debug) WRITE(*,*) "!!! marcus: holes"
				k_AB_el=marcus_rate(J_AB_e,lambda_in_el_AB, dE_in_AB_e,lambda_out_e,&
																&dE_out_BA_e,dE_U_ext,T) 
				k_BA_el=marcus_rate(J_AB_e,lambda_in_el_BA,-1.0*dE_in_AB_e, lambda_out_e,&
												& dE_out_BA_e,(-1.0*dE_U_ext),T)    												
			ELSE IF(TRIM(adjustl(charge_type)) == 'hole') THEN
			!WRITE(*,*) intra_theta_E(j,4),lambda_in_el_AB, intra_theta_E(j,2), lambda_out_e, dE_out_pairs_intra(j,3),dE_U_ext,intra_theta_E(j,6)
					!!! marcus: holes
					if(debug) WRITE(*,*) "!!! marcus: holes"
					k_AB_lo=marcus_rate(J_AB_h,lambda_in_lo_AB,dE_in_AB_h,lambda_out_h,&
															& dE_out_AB_h,(-1.0*dE_U_ext),T)
															
					k_BA_lo=marcus_rate(J_AB_h,lambda_in_lo_BA,-1.0*dE_in_AB_h, lambda_out_h,&
													& dE_out_BA_h,(dE_U_ext),T) 
													

			END IF ! charge_type 
			
		ELSE IF (TRIM(rate_type) == "weiss-dorsey" )THEN
			
			IF(TRIM(adjustl(charge_type)) == 'electron') THEN
					!! CALL weiss_dorsey_rate(J_AB,lambda_in_AB,lambda_in_BA,dE_in,lambda_out,dE_out,dE_U_ext,Temperature,alpha,rate12,rate21)	
					!! weiss_dorsey: Electrons 
					if(debug) write(*,*) "!! weiss-dorsey: Electrons "
					CALL weiss_dorsey_rate(J_AB_e, lambda_in_el_AB, lambda_in_el_BA, dE_in_AB_e, lambda_out_e,&
														& dE_out_AB_e, dE_U_ext,T,Kondo,k_AB_el,k_BA_el)
														
			ELSE IF(TRIM(adjustl(charge_type)) == 'hole') THEN
					!! weiss_dorsey: holes
					if(debug) WRITE(*,*) "!! weiss-dorsey: holes"
					CALL weiss_dorsey_rate(J_AB_h, lambda_in_lo_AB, lambda_in_lo_BA, dE_in_AB_h, lambda_out_h, &
														& dE_out_AB_h, (-1.0*dE_U_ext),T,Kondo,k_AB_lo,k_BA_lo)
			END IF !! charge_type
			
        END IF ! jortner or Marcus rate
        
        
       
				IF(TRIM(adjustl(charge_type)) == 'electron') THEN
					IF(DEBUG) THEN
						WRITE(*,*) TRIM(rate_type),' k_AB_el: ',k_AB_el,'  log10 ',log10(k_AB_el)
						WRITE(*,*) TRIM(rate_type),' k_BA_el: ',k_BA_el,'  log10 ',log10(k_BA_el)
					END IF 
					!WRITE(dummyname,'(A16,A10,ES12.4,F28.1)') TRIM(adjustl(rate_type)),' k_AB_el: ',k_AB_el,k_AB_el
					WRITE(dummyname,'(A16,A10,ES12.4)') TRIM(adjustl(rate_type)),' k_AB_el: ',k_AB_el
					bashoutput=TRIM(bashoutput)//'  '//TRIM(dummyname)
					!WRITE(dummyname,'(A16,A10,ES12.4,F28.1)') TRIM(adjustl(rate_type)),' k_BA_el: ',k_BA_el,k_BA_el
					WRITE(dummyname,'(A16,A10,ES12.4)') TRIM(adjustl(rate_type)),' k_BA_el: ',k_BA_el
					bashoutput=TRIM(bashoutput)//'  '//TRIM(dummyname)
				ELSE IF(TRIM(adjustl(charge_type)) == 'hole') THEN      
					IF(DEBUG) THEN
						WRITE(*,*) TRIM(rate_type),' k_AB_lo: ',k_AB_lo,'  log10 ',log10(k_AB_lo)
						WRITE(*,*) TRIM(rate_type),' k_BA_lo: ',k_BA_lo,'  log10 ',log10(k_BA_lo)
					END IF 
					!WRITE(dummyname,'(A16,A10,ES12.4,F28.1)') TRIM(adjustl(rate_type)),' k_AB_lo: ',k_AB_lo,k_AB_lo
					WRITE(dummyname,'(A16,A10,ES12.4)') TRIM(adjustl(rate_type)),' k_AB_lo: ',k_AB_lo
					bashoutput=TRIM(bashoutput)//'  '//TRIM(dummyname)
					!WRITE(dummyname,'(A16,A10,ES12.4,F28.1)') TRIM(adjustl(rate_type)),' k_BA_lo: ',k_BA_lo,k_BA_lo
					WRITE(dummyname,'(A16,A10,ES12.4)') TRIM(adjustl(rate_type)),' k_BA_lo: ',k_BA_lo
					bashoutput=TRIM(bashoutput)//'  '//TRIM(dummyname)
				END IF ! charge_type
			
		
	
		IF(DEBUG) THEN
			IF(TRIM(adjustl(charge_type)) == 'electron') THEN
								CALL marcus_rate_votca(k_AB_el, k_BA_el, J_AB_e, lambda_in_el_AB, lambda_in_el_BA, dE_in_AB_e, dE_out_AB_e, &
							&lambda_out_e, 1.0*dE_U_ext ,T)
			ELSE IF(TRIM(adjustl(charge_type)) == 'hole') THEN
							CALL marcus_rate_votca(k_AB_lo, k_BA_lo, J_AB_h, lambda_in_lo_AB, lambda_in_lo_BA, dE_in_AB_h, dE_out_AB_h, &
							&lambda_out_h, -1.0*dE_U_ext ,T)  !!  -1.0*dE_U_ext
			END IF
		END IF ! DEBUG
		
		
		
		END DO !!  i=1,i_max  ! loop_all_rate_types
		
		
		
		OPEN(UNIT=17,FILE=TRIM(rate_outputfilename),STATUS='unknown',IOSTAT=ierror,access='append')
		WRITE(*,*)  TRIM(bashoutput) 
		WRITE(17,*) TRIM(bashoutput)//'   '//TRIM(inputline) 
 END SUBROUTINE rate_calculator
	
	
	
	
REAL*8 function marcus_rate(J_AB,lambda_in, dE_in, lambda_out, dE_out,dE_U_ext,Temperature)
    !! Berechnung der marcus_rate dE_U_ext muss vorher anhand der Geometrie berechnet werden. 
    !! Vorzeichen fuer Elektronen und Loecher beachten!
    IMPLICIT NONE
    REAL*8, INTENT(IN)::J_AB,lambda_in,dE_in,lambda_out,dE_out,dE_U_ext    ! eV
    REAL*8, INTENT(IN)::Temperature				    !! K
    REAL*8, PARAMETER::PI=ATAN(1.0)*4.0,k_B=8.6173303E-5		!! eV/K
    REAL*8, PARAMETER::hbar=6.582119514E-16	!! eV*s
    LOGICAL ::DEBUG=.true.
    
    IF(DEBUG) write(*,*) 'dG ',dE_U_ext+dE_in+dE_out
    
    marcus_rate=abs(J_AB)**2*sqrt(PI/((lambda_in+lambda_out)*k_B*Temperature))/hbar*&
                & exp(-(dE_U_ext+dE_in+dE_out+(lambda_in+lambda_out))**2/(4*(lambda_in+lambda_out)*k_B*Temperature))
    !WRITE(*,*) '|J_AB|**2:',J_AB**2,' dE_U_ext:',dE_U_ext,' dE_in:',dE_in,' dE_out:',dE_out,&
	!			&' lambda_in: ',lambda_in,' lambda_out:',lambda_out,' marcus rate:',marcus_rate
END function marcus_rate

SUBROUTINE marcus_rate_votca(rate12, rate21, J_AB, reorg12, reorg21, dE_in, dE_out, lOut, dE_U_ext ,Temperature)
	IMPLICIT NONE
	REAL*8,PARAMETER:: NM2M    = 1.E-9
	REAL*8,PARAMETER::hbar_eV  = 6.58211899e-16
	REAL*8, PARAMETER::M_PI=DATAN(1.0D0)*4.0D0,k_b=8.6173303E-5		!! eV/K
	REAL*8 ::Temperature
	REAL*8 ::rate12                                    !!! 1->2
	REAL*8 ::rate21                                      !!! 2->1
	REAL*8 ::J_AB,reorg12,reorg21,dE_in,dE_out,dE_U_ext
	REAL*8 ::lOut
	REAL*8 ::dG_Site=0,dG=0
    REAL*8 ::dG_Field=0
	REAL*8 ::kT,J2
	
	kT = k_b * Temperature
	J2=J_AB**2
	
	dG_Site= dE_in + dE_out
      ! dG_Site  = seg2->getU_cC_nN(state)                 !!! 1->2 == - 2->1
      !                   + seg2->getEMpoles(state)
      !                   - seg1->getU_cC_nN(state)
      !                   - seg1->getEMpoles(state);
	  !
	

		dG_Field =dE_U_ext  !!!- state * _F * qmpair->R() * NM2M;

		reorg12 = reorg12 + lOut
		reorg21 = reorg21 + lOut

		dG = dG_Field + dG_Site
		WRITE(*,*) 'dG:',dG,' reorg12_all:',reorg12
		rate12 = J2 / hbar_eV * sqrt( M_PI / (reorg12*kT) ) * exp( - (+dG + reorg12)*(+dG + reorg12) / (4*kT*reorg12) )
		
		rate21 = J2 / hbar_eV * sqrt( M_PI / (reorg21*kT) ) * exp( - (-dG + reorg21)*(-dG + reorg21) / (4*kT*reorg21) )
		
		WRITE(*,'(A16,A10,ES12.4,A10,ES12.4)') 'marcus_rate:', ' k_AB: ',rate12,' k_BA: ',rate21  

END SUBROUTINE marcus_rate_votca

REAL FUNCTION omegaVib(i)
	!! gives the average frequency for DIPBI/P3HT for Jortnerrate with a given index [1,32] for the number of rings i=33 /DIPBI
	IMPLICIT NONE
	INTEGER, INTENT(IN)::i
	REAL*8::omega_vib
	!! average_energy [eV] average_frequency [cm-1]
	if (i==33 ) THEN
		omega_vib=0.125787      !!! 1014.57	!DIPBI
	else if (i==1 ) THEN  
	   omega_vib=0.172085    !!! 1388.00	
	else if (i==2 ) THEN  
	   omega_vib=0.154500    !!! 1246.17	
	else if (i==3 ) THEN  
	   omega_vib=0.148528    !!! 1198.00	
	else if (i==4 ) THEN  
	   omega_vib=0.145516    !!! 1173.71	
	else if (i==5 ) THEN  
	   omega_vib=0.143789    !!! 1159.78	
	else if (i==6 ) THEN  
	   omega_vib=0.142584    !!! 1150.06	
	else if (i==7 ) THEN  
	   omega_vib=0.141720    !!! 1143.09	
	else if (i==8 ) THEN  
	   omega_vib=0.141091    !!! 1138.02	
	else if (i==9 ) THEN  
	   omega_vib=0.140547    !!! 1133.63	
	else if (i==10 ) THEN 
	   omega_vib=0.140204    !!! 1130.86	
	else if (i==11 ) THEN 
	   omega_vib=0.139847    !!! 1127.98	
	else if (i==12 ) THEN 
	   omega_vib=0.139560    !!! 1125.67	
	else if (i==13 ) THEN 
	   omega_vib=0.139325    !!! 1123.77	
	else if (i==14 ) THEN 
	   omega_vib=0.139141    !!! 1122.29	
	else if (i==15 ) THEN 
	   omega_vib=0.139005    !!! 1121.19	
	else if (i==16 ) THEN 
	   omega_vib=0.138824    !!! 1119.73	
	else if (i==17 ) THEN 
	   omega_vib=0.138824    !!! 1119.73	
	else if (i==18 ) THEN 
	   omega_vib=0.138824    !!! 1119.73	
	else if (i==19 ) THEN 
	   omega_vib=0.138446    !!! 1116.68	
	else if (i==20 ) THEN 
	   omega_vib=0.138368    !!! 1116.05	
	   
	else if (i==101 ) THEN   !!! Pt complex section
      omega_vib= 0.154904   !!!!  1249.43 [cm-1] fr-K1An-Opt-T1-PBE0-Pur-77K.log
 	else if (i==102 ) THEN                 
      omega_vib=0.146575   !!!! 1182.25 [cm-1]fr-K2-Opt-S0-PBE0-PCM-UFF-77K.log
   else if (i==103 ) THEN   
      omega_vib=0.144459   !!!! 1165.18 [cm-1]fr-K3-Opt-S0-PBE0-PCM-UFF-77K.log 
   else if (i==104 ) THEN 
      omega_vib=0.141469   !!!! 1141.06 [cm-1] fr-K4H-Opt-S0-PBE0-PCM-UFF-77K-tight.log 
   else if (i==107 ) THEN                                           
      omega_vib=0.149171   !!!! 1203.19 [cm-1]fr-K7-Methoxyphenyl-Opt-S0-PBE0-Pur-77K.log
   else if (i==108 ) THEN    
      omega_vib=0.138147   !!!! 1114.27 [cm-1]fr-K8-Methoxy2FlPhen-Opt-S0-PBE0-PCM-UFF-CH2Cl2-77K-tight.log 
   else if (i==109 ) THEN    
      omega_vib=0.142979   !!!! 1153.24 [cm-1]fr-K9-1fl-Phen-Opt-S0-PBE0-PCM-UFF-CH2Cl2-77K.log 
   else if (i==110 ) THEN 
      omega_vib=0.130453   !!!! 1052.21 [cm-1] fr-K10-3fl-Phen-Opt-S0-PBE0-PCM-UFF-CH2Cl2-77K.log 
    !! organic matrix molecules for Pt-bases OLEDs
    else if (i==111 ) THEN !!mCP
      omega_vib=0.130453  
    else if (i==112 ) THEN !!NBP
      omega_vib=0.130453      
	else if (i==112 ) THEN !!TPBI
      omega_vib=0.146796        !!1184.03 [cm-1]   average energy:  0.146796  [eV]      Freq_OptS0_n_TPBI.log
	else 
	   omega_vib=0.138368    !!! 1116.05	!! P3HT
	endif	
	omegaVib=omega_vib
END FUNCTION omegaVib

    !! +++++++++++++ //
    !! JORTNER RATES //
    !! +++++++++++++ //
    !!! J_AB,lambda_in_AB,lambda_in_BA
    !!! gemittelte vibrationsfrequenz: omegaVib    default :: omegaVib = 0.2 eV   _nMaxVib = 20
    !!! CALL JORTNER_RATE(intra_theta_E(j,4),lambda_in_el_AB,lambda_in_el_BA, intra_theta_E(j,2), lambda_out_e,&
	!!								& dE_out_pairs_intra(j,3),dE_U_ext,T,average_omegaVib,k_AB_el,k_BA_el)
    
SUBROUTINE JORTNER_RATE(J_AB,reorg12,reorg21, dE_in, lambda_out, dE_out,dE_U_ext,Temperature,omegaVib,rate12,rate21)
    IMPLICIT NONE
    REAL*8, INTENT(IN)  ::J_AB,reorg12,reorg21,dE_in,lambda_out,dE_out,dE_U_ext    ! eV
    REAL*8, INTENT(IN)  ::Temperature				    !! K
    REAL*8, INTENT(IN)  ::omegaVib      !! [eV] form average frequency in cm**-1
    REAL*8, INTENT(OUT) ::rate12,rate21 !! [s**-1]

    REAL*8, PARAMETER::PI=ATAN(1.0)*4.0,k_b=8.6173303E-5		!! eV/K
    !!REAL, PARAMETER::hbar=6.582119514E-16	!! eV*s
    REAL*8, PARAMETER ::hbar_eV = 6.58211899e-16 !! eV VOTCA program
	REAL*8   :: J2,huang_rhys12,huang_rhys21
	REAL*8   :: kT,dG
	INTEGER  :: nvib,nMaxVib
	LOGICAL  :: DEBUG=.false.
	
	nMaxVib=30 !size(omegaVib)
	
	kT=k_b*Temperature
	J2=J_AB**2
	rate12=0.0
	rate21=0.0
	huang_rhys12 = reorg12 / omegaVib
	huang_rhys21 = reorg21 / omegaVib
    
    dG= dE_in +  dE_out + dE_U_ext !!dG = dG_Site + dG_Field !
    IF(DEBUG)  WRITE(*,*) 'dG',dG,'=dE_in +  dE_out + dE_U_ext :',dE_in,dE_out,dE_U_ext
    IF(lambda_out < 0.0) THEN
				WRITE(*,*)   "... ... ERROR: Pair has negative outer-sphere reorganization energy. Cannot calculate Jortner rates. "
				CALL EXIT(1)
	ELSE IF (lambda_out < 0.01) THEN
				WRITE(*,*) "... ... WARNING: Pair has small outer-sphere reorganization energy (",lambda_out,"eV). "
				WRITE(*,*)  "Could lead to over-estimated Jortner rates."
				!PASS
				!CALL EXIT(1)
	END IF

		!nvib=0
		nvib=0
        !! Hopping from Seg1 -> Seg2
            rate12=rate12 + 1/hbar_eV*sqrt( PI / (lambda_out*kT) ) * J2 * exp(-huang_rhys12) * huang_rhys12**nvib /Factorial(nvib)&
                  &  * exp( - (dG + 0.0 + lambda_out)**2 /(4*kT*lambda_out))

       !! Hopping from Seg2 -> Seg1
            rate21=rate21 + 1/hbar_eV*sqrt( PI / (lambda_out*kT) ) * J2 * exp(-huang_rhys21) * huang_rhys21**nvib /Factorial(nvib)&
                  &  * exp( -(-dG + 0.0  + lambda_out)**2 /(4*kT*lambda_out) )	
		
        DO nvib=1,nMaxVib,1
        	huang_rhys12 = reorg12 / omegaVib
			huang_rhys21 = reorg21 / omegaVib
        
            !! Hopping from Seg1 -> Seg2   ! laut paper -N * hbar *omega_vib 
            rate12=rate12 + 1/hbar_eV*sqrt( PI / (lambda_out*kT) ) * J2 * exp(-huang_rhys12) * huang_rhys12**nvib /Factorial(nvib)&
                  &  * exp( - (dG + nvib*omegaVib + lambda_out)**2 /(4*kT*lambda_out))

            !! Hopping from Seg2 -> Seg1
            rate21=rate21 + 1/hbar_eV*sqrt( PI / (lambda_out*kT) ) * J2 * exp(-huang_rhys21) * huang_rhys21**nvib /Factorial(nvib)&
                  &  * exp( -(-dG + nvib*omegaVib + lambda_out)**2 /(4*kT*lambda_out) )
                           
       END DO
	    IF(DEBUG) WRITE(*,*) 'JORTNER_RATE: k_AB:', rate12,'  k_BA: ',rate21, ' |J_AB|**2:',J2,' l_out:',lambda_out,&
				&' l_in_AB:',reorg12,' l_in_BA:',reorg21
END SUBROUTINE JORTNER_RATE



    !! ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++  //
    !! WEISS DORSEY RATES														 //
    !! See Asadi et al. Nature Comm. 2708 (DOI: 10.1038/ncomms2708)              //
    !! equation (6) in the paper	using complex gamma function CGAMA    		 //
    !! +++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ //
    !!              _alpha = 4.0;
    !!      ... ... WARNING: No Kondo parameter _alpha provided. Using default 4.0 
SUBROUTINE weiss_dorsey_rate(J_AB,lambda_in_AB,lambda_in_BA,dE_in,lambda_out,dE_out,dE_U_ext,Temperature,alpha,rate12,rate21)
    IMPLICIT NONE
    REAL*8, INTENT(IN)  ::J_AB,lambda_in_AB,lambda_in_BA,dE_in,lambda_out,dE_out,dE_U_ext    ! eV
    REAL*8, INTENT(IN)  ::Temperature				    !! K
    REAL*8, INTENT(IN)  ::alpha  !! alpha [eV] form average frequency in cm**-1
    REAL*8, INTENT(OUT) ::rate12,rate21 !! [s**-1]

    REAL*8, PARAMETER::M_PI=ATAN(1.0)*4.0,k_b=8.6173303E-5		!! eV/K
    !!REAL, PARAMETER::hbar=6.582119514E-16	!! eV*s
    REAL*8, PARAMETER ::hbar_eV = 6.58211899e-16 !! eV VOTCA program
	!! local variables 
	REAL*8::J2,kT,dG,characfreq12,characfreq21
	REAL*8:: kondo,reorg12,reorg21
	!! Auxilliar variables
	REAL*8::X,Y,GR,GI,infinity 
	REAL*8::Factor1,Factor2
	COMPLEX*8, PARAMETER::M_I=(0.0,1.0)
	LOGICAL::DEBUG=.true.

	kT=k_b*Temperature
	J2=J_AB**2
    dG= dE_in +  dE_out + dE_U_ext !!dG = dG_Site + dG_Field !
    dG=-1.0D0*dG
    IF(DEBUG) WRITE(*,*) 'dG',dG,'=dE_in +  dE_out + dE_U_ext :',dE_in,dE_out,dE_U_ext		
	          
        kondo = alpha/2.0D0 +1.0D0; !! going from alpha to alpha'

        reorg12 = lambda_in_AB + lambda_out
        reorg21 = lambda_in_BA + lambda_out
        
        characfreq12 = reorg12 /(2.0D0 *kondo*hbar_eV)
        characfreq21 = reorg21 /(2.0D0 *kondo*hbar_eV)
        
        !! Calc Complex Gamma Function to real GR and imaginary GI
        !! Factor1= abs(  ccgamma(kondo+M_I*(+dG/2/M_PI/kT))  )^2
        X=REAL(kondo,8)
        Y=REAL(dG/(2*M_PI*kT),8)
		CALL CGAMA(X,Y,1,GR,GI)
		Factor1=GR**2+GI**2    
		
		!! Factor2 = ccgamma(2*kondo,0)^-1
		X=REAL(2.0D0*kondo,8)
		Y=REAL(0.0,8)
		CALL CGAMA(X,Y,1,GR,GI)
		Factor2=1.0d0/GR
		
       rate12 =    Real(J2/(hbar_eV**2)/characfreq12,8)   &
               & * Real((hbar_eV*characfreq12/2/M_PI/kT)**(1.0D0-2.0D0*kondo),8)   &
               & * Factor1 * Factor2 * dexp(Real(+dG/(2.0D0*kT),8)) *  dexp(Real(-1.0D0*abs(dG)/(hbar_eV*characfreq12),8))

        !! Calc Complex Gamma Function to real GR and imaginary GI
        !! Factor1=  abs(ccgamma(kondo+M_I*(-dG/2/M_PI/kT)) )^2 
        X=REAL(kondo,8)
        Y=REAL(-1.0D0*dG/(2.0D0*M_PI*kT),8)
		CALL CGAMA(X,Y,1,GR,GI)
		Factor1=GR**2+GI**2    

        rate21 =   Real(J2/(hbar_eV**2)/characfreq21,8)   &
              &  * Real((hbar_eV*characfreq21/2.0D0/M_PI/kT)**(1.0D0-2.0D0*kondo),8)    &
              &  * Factor1 * Factor2 * dexp(Real(-dG/(2.0D0*kT),8)) *  dexp(Real(-1.0D0*abs(dG)/(hbar_eV*characfreq21),8))                   
        
		infinity= HUGE(X)
        IF ( rate12 > infinity .OR. ISNAN(rate12) ) THEN  ! check infinity
			WRITE(*,*) 'Warning: weiss_dorsey_rate is NaN or infinity, modify Kondo factor. as exp(x) ~ infinity ?',rate12
			WRITE(*,*) 'Set rate12=0.0'
			rate12=0.0
		ELSE IF(rate21 > infinity .OR. ISNAN(rate21) ) THEN
			WRITE(*,*) 'Warning: weiss_dorsey_rate is NaN or infinity, modify Kondo factor. as exp(x) ~ infinity ?',rate21
			WRITE(*,*) 'Set rate21=0.0'
			rate21=0.0
        END IF       
        IF(DEBUG) WRITE(*,*) ' weiss_dorsey_rate : k_AB: ',rate12,' k_BA: ',rate21,&
								&'lambda_in_AB:',lambda_in_AB,'lambda_in_BA:',lambda_in_BA        
          
 END SUBROUTINE weiss_dorsey_rate



   

SUBROUTINE CGAMA(X,Y,KF,GR,GI)
!! ===========================================================    
!!       Purpose: Compute the gamma function G(z) or Ln[G(z)]   
!!                for a complex argument   
!!       Input :  x  --- Real part of z   
!!                y  --- Imaginary part of z    
!!                KF --- Function code   
!!                       KF=0 for Ln[G(z)]   
!!                       KF=1 for G(z)   
!!       Output:  GR --- Real part of Ln[G(z)] or G(z)
!!                GI --- Imaginary part of Ln[G(z)] or G(z)   
!! ===========================================================   
	IMPLICIT NONE
 !IMPLICIT DOUBLE PRECISION (A-H,O-Z)
	REAL*8,INTENT(INOUT)::X,Y
	INTEGER,INTENT(IN)::KF
    REAL*8,INTENT(OUT)::GR,GI
   
	REAL*8::G1,G0,GI1,GR1,X0,X1,X2,S1,S2,SI,SR,T,TH,TH1,TH2,Y1,Z1,Z2
	INTEGER*8::NA,K,J
    
    REAL*8, PARAMETER ::PI=3.141592653589793D0
    
   REAL*8, DIMENSION(10)::A=(/8.333333333333333D-02,-2.777777777777778D-03,  &
         &  7.936507936507937D-04,-5.952380952380952D-04,  &
         &  8.417508417508418D-04,-1.917526917526918D-03,  &
         &  6.410256410256410D-03,-2.955065359477124D-02,  &
         &  1.796443723688307D-01,-1.39243221690590D+00/)
         
    IF (Y.EQ.0.0D0.AND.X.EQ.INT(X).AND.X.LE.0.0D0) THEN
      GR=1.0D+300
      GI=0.0D0
      RETURN
    ELSE IF (X.LT.0.0D0) THEN
      X1=X
      Y1=Y
      X=-X
      Y=-Y
    ENDIF
	X0=X
    
    IF (X.LE.7.0) THEN
      NA=INT(7-X)
      X0=X+NA
    ENDIF
    
    Z1=DSQRT(X0*X0+Y*Y)
    TH=DATAN(Y/X0)
    
    GR=(X0-.5D0)*DLOG(Z1)-TH*Y-X0+0.5D0*DLOG(2.0D0*PI) 
    GI=TH*(X0-0.5D0)+Y*DLOG(Z1)-Y
    
    DO K=1,10   
      T=Z1**(1-2*K)
      GR=GR+A(K)*T*DCOS((2.0D0*K-1.0D0)*TH)
      GI=GI-A(K)*T*DSIN((2.0D0*K-1.0D0)*TH)
    END DO
    
    IF (X.LE.7.0) THEN
      GR1=0.0D0
      GI1=0.0D0
       
      DO J=0,NA-1
        GR1=GR1+.5D0*DLOG((X+J)**2+Y*Y)
        GI1=GI1+DATAN(Y/(X+J))
      END DO
       
      GR=GR-GR1
      GI=GI-GI1
    
    ENDIF
    
    IF (X1.LT.0.0D0) THEN
       
      Z1=DSQRT(X*X+Y*Y)
      TH1=DATAN(Y/X)
      SR=-DSIN(PI*X)*DCOSH(PI*Y)
      SI=-DCOS(PI*X)*DSINH(PI*Y)
      Z2=DSQRT(SR*SR+SI*SI)
      TH2=DATAN(SI/SR)
       
      IF (SR.LT.0.0D0) TH2=PI+TH2
        
	  GR=DLOG(PI/(Z1*Z2))-GR
	  GI=-TH1-TH2-GI 
	  X=X1
	  Y=Y1
    
	ENDIF
    
    IF (KF.EQ.1) THEN
      G0=DEXP(GR)
      GR=G0*DCOS(GI)
      GI=G0*DSIN(GI)
    ENDIF
      
    RETURN
END SUBROUTINE CGAMA







INTEGER FUNCTION Factorial(i)
	!Programm berechnet iterativ die Fakultät einer gegebenen natürlichen Zahl i!
	IMPLICIT NONE
	!Variablen sind nur ganze Zahlen
	INTEGER :: i,j
	REAL*8::n
	!!User gibt Zahl kleiner 35 ein, da faculty sonst zu groß
	!!WRITE(*,*) 'Geben Sie bitte eine natürliche Zahl kleiner 13 ein'//&
	!!	&'deren Fakultät berechnet werden soll'

	n=1 ! Initialisierung
	j=1
	IF ( (i>=1) .AND. (i < 35) ) THEN
		! Berechnung der Fakultaet, durch iterative Multiplikation 
		DO WHILE (j<=i)      
		   n=n*j
		   j=j+1
		END DO
	ELSE IF (i == 0) THEN
		n=1
	ELSE     
		DO WHILE (j<=i)       
			   n=n*j
			   j=j+1
		END DO  
		WRITE(*,*) 'Das Programm liefer einen overflow Fehler!'
		WRITE(*,*) 'Die Fakultaet von ',i,' ist:',n
		CALL EXIT(1)
	END IF    
	Factorial=int(n)
END FUNCTION Factorial

REAL FUNCTION calc_dE_U_ext(U_ext,COM_1,COM_2,x_box,y_box,z_box)
    IMPLICIT NONE
    REAL, INTENT(IN)::x_box,y_box,z_box ! in Angstroem
    REAL, DIMENSION (3), INTENT(IN) :: U_ext
    REAL, DIMENSION (3), INTENT(IN) :: COM_1,COM_2
    REAL, DIMENSION (3) ::dist,box_size
    INTEGER::i
    dist(:)=COM_2(:)-COM_1(:)
    box_size(1)=x_box
    box_size(2)=y_box
    box_size(3)=z_box
    DO i=1,3
        IF( dist(i) > 0.5*box_size(i) ) THEN
                dist(i) = dist(i)-box_size(i)
        ELSE IF ( dist(i) < -0.5*box_size(i) ) THEN
                dist(i) = dist(i)+box_size(i)
        ELSE
                CYCLE
        END IF
    END DO
	!dist = np.asarray(COM_list[index1])-np.asarray(COM_list[index2])
	!for a in range(len(dist)):
	!	if dist[a] > 1.0/2.0*box[0]*10.0: dist[a] = dist[a] - box[a]*10.0
	!	elif dist[a] < -1.0/2.0*box[0]*10.0: dist[a] = dist[a] + box[a]*10.0	
	!#calculate the electric energy difference in eV	
	! dE_U_ext = np.dot(dist,np.asarray(U)) !! Electrons
    !	#inverse charge for holes
	! dE_U_ext = -dE_U_ext  
    calc_dE_U_ext= DOT_PRODUCT(dist,U_ext)    ! Energie in eV (fuer Elektronen)
END function calc_dE_U_ext




SUBROUTINE distance_PBC_correction(dist,x_box,y_box,z_box)
	!! PBC Correction of distance vector, make sure the input vector and the box vector is in the same length units.
	IMPLICIT NONE
	REAL, INTENT(IN)::x_box,y_box,z_box
        REAL, DIMENSION (3),INTENT(INOUT)::dist
	REAL, DIMENSION (3)::box_size
	INTEGER::i
    	box_size(1)=x_box
    	box_size(2)=y_box
    	box_size(3)=z_box

    	DO i=1,3
        	IF( dist(i) > 0.5*box_size(i) ) THEN
        	        dist(i) = dist(i)-box_size(i)
        	ELSE IF ( dist(i) < -0.5*box_size(i) ) THEN
        	        dist(i) = dist(i)+box_size(i)
        	ELSE
        	        CYCLE
        	END IF
   	END DO

END SUBROUTINE distance_PBC_correction
        
        

end module charge_transfer_rate_calculator
!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!!    END module     charge_transfer_rate_calculator
!!! ------------------------------------------------------------------------------------------------------------------- !!!




!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!! ----------------------- Start Module mod_dijkstra ----------------------------------------------------------------- !!!
!!! ------------------------------------------------------------------------------------------------------------------- !!!

!! Das Programm berechnet mit Hilfe des sog. "Dijkstra-Algorithmus" den kürzesten Weg
!! zwischen zwei Punkten in einem Netz/Graphen aus Punkten, die miteinander über Kanten verbunden sind.
!! Die Wege zwischen den Punkten können dabei entweder in eine oder in beide Richtungen
!! "befahrbar" sein und haben jeweils gewisse Kosten oder in einem gewissen Abstand, nach denen dann der kürzeste Weg berechnet
!! wird
!! Zur Angabe der kürzesten Wege wird von einem bestimmten Startpunkt aus eine Tabelle aufgestellt,
!! mit deren Hilfe sich der kürzeste Weg zu jedem erreichbaren Punkt im Netz von dem angegebenen
!! Startpunkt aus zurückverfolgen lässt.
!! Für ein Netzwerk mit 4 Knoten und 5 Verbindungen unter Verwendung des Startpunkes
!! A sieht die letzte Zeile der Tabelle in etwas so aus:
!!     B		C		D
!!   3,A	   1,A     4,B
!! Nun sucht man den gewünschten Zielpunkt, z.B. D und geht zu dem in dieser Spalte angegebenen
!! Punkt B, und dort wieder zum angegebenen Punkt A. Der Weg A-B-D ist der kürzeste Weg von D nach A.
!! Dieses Beispielnetzwerk befindet sich in der Datei net1.txt
!! Die Dateien mit einem gespeicherten Netzwerk haben folgenden Aufbau:
!! 1) Anzahl der Knotenpunkte
!! 2) Anzahl der Verbindungen
!! 3) Verbindungen (jeweils Punkt1, Punkt2, Kosten  )
!!
!!
!!  ./a.out    Dijkstra_kmcNetwork    options.xml     statefile.sql 
!!
!! Es wird der Weg des kleinsten Widerstandes R = U_ext(i) / I_local(i) berechnet. i = x,y,z
!! Dazu wird die Komponente des lokalen Stromes in Richtung des Externen Feldvektors betrachtet.
!! Mit dem Hauptschaulter "Dijkstra_kmcNetwork" kann die Analyse eines KMC-Netzwerkes bestimmt werden.
!! Dazu wird erste das KMC-Programm durchlaufen und mit Hilfe der Raten, Besetzungszahlen und Sprungdistanzen ein Netzwerk mit Knoten(Hopping-Sites) und lokales Strömen berechnet.
!! Die Besetzungszahlen stammen aus der *.sql Datei oder aus einer Datei mit den Besetzungszahlen tot_occ_XXXXXXX.dat 
!! oder müssen erst erzeugt werden.
!! 
!! Knoten werden über die Resid und den Resname benannt. z.B. 10_DIPBI   34_DIPBI  345   ( Kosten von DIPBI 10 nach DIPBI 34 sind 345 ).  
!!
!! Über den Index des Knotes / Resid kann der Weg des geringsten Widerstandes zwischen zwei Knoten bestimmt werden.
!! (z.B. start_Dijkstra=10, ziel_Dijkstra=13)
!! 
!! Ein erzeugtes Netzwerk aus Widertänden kann mit <writenetworkfiledijkstra>1</writenetworkfiledijkstra>  abgespeichert werden.      <!-- write / store the Graph for the Dijkstra evaluation the Dijkstra network file in networkfile_Dijkstra -->
!! Der Dateiname für ein Netzwerk wird in <networkfile_Dijkstra>Netztest.txt</networkfile_Dijkstra> angegeben.
!!
!! Das Programm kann als Erweiterung den kürzesten Weg in der Box von einer Startzone zur Endzone finden. (calc_pathway_between_zones =1)
!! Die Anzahl der Hopping sites in der Zone wird über die Zonenbreite bestimmt (ca. 15 Ang -> Dies sollte dem maximalen Abstand zweier Paare entsprechen.) 
!! Die Startzone wird "kopiert" und als Endzone an die Box angefügt. 
!! Alle Verbindungen über PBC von der Startzone in die Endzone, die über die Hälfte der Box hinausragen werden gelöscht,
!! um das Springen über die hintere Boxwand in die Endzone zu unterbinden.
!! Verbindungen aus der zweiten Hälfte des Mittelstücks werden, die auf die Startzone zeigen werden in die Endzone umgeleitet.
!! Verbindungen innerhalb der Endzone bleiben in der Endzone.
!! Das Externe Feld legt also die Auswahl der Seiten für die Start- und Endzone fest.
!! Es kann eine Schleife ausgeführt werden (loopstartzone=true), sodass für jeden Punkt in der Startzone der minimale Weg bis in die Endzone gesucht wird.
!! Dazu wird zuerst ein zufälliges Ziel in der Endzone gewählt und der gefundenen Weg verkürzt, bis zum ersten Knoten, der in der Endzone liegt.   
!! 
!! Mögliche Optionen zum Dijkstra Algorithmus für das Strom / Widerstandsnetzwerk.
!! 
!! 	<!--################################################################################################################### -->
!! 
!! <options>
!! 		<!---- +++++++++++ Dijkstra Algorithm +++++++++++ ---->
!! 		<dijkstra>
!! 			<carriertype>hole<carriertype
!! 			<calcpathwayDijkstra>1</calcpathwayDijkstra> <!-- Calculate a high current pathway -->
!! 			<modus_Dijkstra>Dijkstra_kmcNetwork</modus_Dijkstra> <!-- Keys: 'Dijkstra_kmcNetwork',  'Dijkstra_newNetwork', 'Dijkstra_loadNetwork'  -->
!! 			<start_Dijkstra>14</start_Dijkstra> <!-- index to start the Dikstra pathway default=10-->
!! 			<ziel_Dijkstra>41</ziel_Dijkstra>   <!-- index to start the Dikstra pathway default=10-->
!! 			<writenetworkfiledijkstra>1</writenetworkfiledijkstra>        <!-- write / store the Graph for the Dijkstra evaluation the Dijkstra network file in networkfile_Dijkstra -->
!! 			<networkfile_Dijkstra>Netztest.txt</networkfile_Dijkstra>     <!-- Dijstra network file -->
!! 			<calc_pathway_between_zones>1</calc_pathway_between_zones>    <!--   !! Define a zone for inital points and and dublicate it for a second final zone for the target of a box transversing pathway in PBC  [default: alc_pathway_between_zones=.false. ]  -->
!! 			<loopstartzone>1</loopstartzone> <!-- Loop for all initial nodes in the start zone default: loopstartzone=0 -->
!! 			<zonenbreite>16</zonenbreite> <!-- Zonenbreite für Start und Endzone in Angstroem default: 5 Ang --> 
!! 			<log10abs>0</log10abs>  <!-- log10 abs(R) for the evaluation of the pathway with the shortes resistance / highest current flow-->
!! 		</dijkstra>
!! </options>
!! 	<!--################################################################################################################### -->



module mod_dijkstra

	type verbindung_d
		integer::id
		Character(50) :: punkt1
		Character(50) :: punkt2
		Real*8        :: kosten
		logical       :: aktiv
	end type verbindung_d

	type knoten_d
		integer::id
		Character(50) :: name
		integer       :: N_verbindungen
		logical       :: hat_verbindungen
		type(verbindung_d), allocatable, dimension(:) :: verbindung
	end type knoten_d


	type graph_d
		integer :: total_anzahl_knoten
		integer :: total_anzahl_verbindungen
		type(knoten_d) , allocatable, dimension(:) :: knoten
		real*8  :: shift_kosten
	end type graph_d



		!! Global Variables
		type (graph_d)  , public :: Graph
		type (knoten_d) , public :: Startknoten, Zielknoten
		logical         , public :: debug =.false.
		contains

	!!! #################################################################################################################################################  !!!
	!!! ################################################## START FUNCTIONS DIJKSRA ALOGORITHMUS #########################################################  !!!
	!!! #################################################################################################################################################  !!!



	subroutine loadNetwork()
		use small_functions
		implicit none
		type(verbindung_d)::verbindung
		Character(50) :: punkt1
		Character(50) :: punkt2
		Real*8        :: kosten
		integer       :: total_anzahl_knoten
		integer       :: total_anzahl_verbindungen
		integer       :: i_knoten,punkt1_id
		CHARACTER(LEN=10000)::filename,lio
		logical :: datei_da
		integer::i,j,ierror,N_lines
		
		filename='net2.txt'
		datei_da=.false.
		do while(.not. datei_da)
			write(*,*) ' Beispielnetzwerk:'
			write(*,*) ' 3 '
			write(*,*) ' 4 '
			write(*,*) ' A  B  5'
			write(*,*) ' A  C  2'
			write(*,*) ' B  A  2'
			write(*,*) ' C  A  9'
			write(*,*) ' Geben Sie den Dateinamen für das Einlesen eines Netzwerkes ein.'
			read(*,*)  filename
			inquire(file=TRIM(filename),exist=datei_da)
			if(.not. datei_da) write(*,*) 'Die Datei existiert nicht:',Trim(filename)
		enddo
		lio="1234"
		
		
		OPEN(UNIT=60,FILE=TRIM(filename),STATUS='OLD',ACTION='READ',IOSTAT=ierror)
		N_lines=Read_rows_file(filename,lio)
		
		
		if(file_exists(filename)) then
			read(60,*) total_anzahl_knoten
			write(*,*) 'Anzahl der Knoten:',  total_anzahl_knoten
			 Graph%total_anzahl_knoten = total_anzahl_knoten
			read(60,*) total_anzahl_verbindungen
			write(*,*) 'Anzahl der Verbindungen: ',  total_anzahl_verbindungen
			Graph%total_anzahl_verbindungen = total_anzahl_verbindungen
			Graph%shift_kosten = 0
			allocate(Graph%knoten(Graph%total_anzahl_knoten))
			do i=1, Graph%total_anzahl_knoten
				Graph%knoten(i)%id=i
				Graph%knoten(i)%name=""
				Graph%knoten(i)%N_verbindungen = 0
				Graph%knoten(i)%hat_verbindungen =.false.
			enddo 
			
			i_knoten=0
			do j=1, Graph%total_anzahl_verbindungen
				read(60,*) punkt1, punkt2, kosten
				!! punk1 neuer knoten ?
				neuer_knoten_1: do i=1,Graph%total_anzahl_knoten
					
					!! Addiere Knoten
					if( (i == Graph%total_anzahl_knoten) .or. (i > i_knoten ) ) then
						punkt1_id = i
						if(i_knoten == Graph%total_anzahl_knoten) then
							exit neuer_knoten_1 ! Kein neuer Knoten
						endif 
						i_knoten = i_knoten + 1 
						Graph%knoten(i)%name=TRIM(punkt1)
						Graph%knoten(i)%id = i_knoten
						!write(*,*) 'neuer_knoten_1',Graph%knoten(i)%id,TRIM(Graph%knoten(i)%name)
						EXIT neuer_knoten_1
					endif
				
					if( TRIM(ADJUSTL(punkt1)) == TRIM(ADJUSTL(Graph%knoten(i)%name)) ) THEN
						punkt1_id = i
						EXIT neuer_knoten_1 ! Kein neuer Knoten
					end if 

				enddo neuer_knoten_1
				
				!! punk2 neuer knoten ?
				neuer_knoten_2: do i=1,Graph%total_anzahl_knoten
					if(i_knoten == Graph%total_anzahl_knoten) then
							exit neuer_knoten_2 ! Kein neuer Knoten
					endif 
					if( (i == Graph%total_anzahl_knoten) .or. (i > i_knoten)  ) then
						i_knoten =i_knoten + 1 
						Graph%knoten(i)%name=TRIM(punkt2)
						Graph%knoten(i)%id = i_knoten
						!write(*,*) 'neuer_knoten_2 ',Graph%knoten(i)%id,i_knoten
						exit neuer_knoten_2
					endif
					if( TRIM(ADJUSTL(punkt2)) == TRIM(ADJUSTL(Graph%knoten(i)%name)) ) THEN
						EXIT neuer_knoten_2 ! Kein neuer Knoten
					end if 
				enddo neuer_knoten_2
				
				verbindung%id=0
				verbindung%punkt1=punkt1
				verbindung%punkt2=punkt2
				verbindung%kosten=kosten
				verbindung%aktiv=.true.
				call add_verbindung_to_knoten(Graph%knoten(punkt1_id),verbindung)
			enddo
			
		end if ! file_exists ?
		

		if(debug) then
			write(*,*) '---------- Eingelesenes Netzwerk -----------------------'
			write(*,*) Graph%total_anzahl_knoten
			write(*,*) Graph%total_anzahl_verbindungen
			do i=1 , Graph%total_anzahl_knoten
				do j=1, Graph%knoten(i)%N_verbindungen
					write(*,*) TRIM(Graph%knoten(i)%verbindung(j)%punkt1),"  ", &
					& TRIM(Graph%knoten(i)%verbindung(j)%punkt2),Graph%knoten(i)%verbindung(j)%kosten, &
					& Graph%knoten(i)%id, Graph%knoten(i)%verbindung(j)%id
				enddo
			enddo
			write(*,*) '--------------------------------------------------------'
		end if
		
		!! initialisierung Start / Ziel Graph, setze hier defaults.
		Startknoten = Graph%knoten(1)
		Zielknoten  = Graph%knoten(2)
		
		
		
	end subroutine loadNetwork 


	!! Lässt den Benutzer ein neues Netzwerk eingeben, das auch gespeichert werden kann
	subroutine newNetwork()
		implicit none
		character(500) :: datei
		character(50)  :: antwort
		!!
		integer       :: total_anzahl_knoten
		integer       :: total_anzahl_verbindungen
		type(verbindung_d) :: verbindung
		character(50)      :: punkt1,punkt2
		real*8             :: kosten
		integer ::i,j,k,i_knoten,punkt1_id
		
		!! Netwerk dateiname 
		datei=''
		
		!! Anzahl der Knotenpunkte des Netzwerks einlesen 
		write(*,*) 'Starte das Einlesen des Netzwerkes '
		write(*,'(A$)') "Anzahl der Knotenpunkte: "
		read(*,*) total_anzahl_knoten
		
		Graph%total_anzahl_knoten = total_anzahl_knoten
		
		write(*,'(A$)') "Anzahl der Verbindungen insgesamt: "
		read(*,*) total_anzahl_verbindungen
		Graph%total_anzahl_verbindungen = total_anzahl_verbindungen
		Graph%shift_kosten = 0
		
		allocate(Graph%knoten(total_anzahl_knoten))
		do i=1, Graph%total_anzahl_knoten
				Graph%knoten(i)%id=i
				Graph%knoten(i)%name=""
				Graph%knoten(i)%N_verbindungen = 0
				Graph%knoten(i)%hat_verbindungen =.false.
		enddo 


		i_knoten=0
		do k=1, total_anzahl_verbindungen
			write(*,*) 'Einlesen der Verbindungen. Geben Sie Punkt_1 ein. '
			read(*,*) punkt1
			
			write(*,*) 'Einlesen der Verbindungen. Geben Sie Punkt_2 ein. '
			read(*,*) punkt2
			
			do 
				write(*,*) 'Geben Sie die Kosten ein. (Die Kosten dürfen nicht negativ sein)'
				read(*,*)  kosten
				if (kosten > 0.0 ) exit
			end do
			
			write(*,*) 'Neue Verbindung: ',TRIM(punkt1),'  ',TRIM(punkt2),'  ',kosten
			
			!! punk1 neuer knoten ?
			neuer_knoten_1: do i=1,Graph%total_anzahl_knoten
					
					!! Addiere Knoten
					if( (i == Graph%total_anzahl_knoten) .or. (i > i_knoten ) ) then
						punkt1_id = i
						if(i_knoten == Graph%total_anzahl_knoten) then
							exit neuer_knoten_1 ! Kein neuer Knoten
						endif 
						i_knoten = i_knoten + 1 
						Graph%knoten(i)%name=TRIM(punkt1)
						Graph%knoten(i)%id = i_knoten
						!write(*,*) 'neuer_knoten_1',Graph%knoten(i)%id,TRIM(Graph%knoten(i)%name)
						EXIT neuer_knoten_1
					endif
				
					if( TRIM(ADJUSTL(punkt1)) == TRIM(ADJUSTL(Graph%knoten(i)%name)) ) THEN
						punkt1_id = i
						EXIT neuer_knoten_1 ! Kein neuer Knoten
					end if 

			enddo neuer_knoten_1
				
			!! punk2 neuer knoten ?
			neuer_knoten_2: do i=1,Graph%total_anzahl_knoten
					if(i_knoten == Graph%total_anzahl_knoten) then
							exit neuer_knoten_2 ! Kein neuer Knoten
					endif 
					if( (i == Graph%total_anzahl_knoten) .or. (i > i_knoten)  ) then
						i_knoten =i_knoten + 1 
						Graph%knoten(i)%name=TRIM(punkt2)
						Graph%knoten(i)%id = i_knoten
						!write(*,*) 'neuer_knoten_2 ',Graph%knoten(i)%id,i_knoten
						exit neuer_knoten_2
					endif
					if( TRIM(ADJUSTL(punkt2)) == TRIM(ADJUSTL(Graph%knoten(i)%name)) ) THEN
						EXIT neuer_knoten_2 ! Kein neuer Knoten
					end if 
			enddo neuer_knoten_2
			if(i_knoten > Graph%total_anzahl_knoten) then
				write(*,*) 'Fehler beim Einlesen des Graphen. Mehr unterschiedliche Knoten eingegeben, als zu Beginn definiert.'
				call exit(1)
			endif
			
			verbindung%id=0
			verbindung%punkt1=punkt1
			verbindung%punkt2=punkt2
			verbindung%kosten=kosten
			verbindung%aktiv=.true.
			call add_verbindung_to_knoten(Graph%knoten(punkt1_id),verbindung)
		end do
		

		!! Ausgabe der Verbindungen zur Kontrolle

			write(*,*) 'Hier noch mal die eingegebenen Verbindungen:'
			write(*,*) '---------- Gelesenes Netzwerk -----------------------'
			write(*,*) 'Knoten:       ',Graph%total_anzahl_knoten        !! Anzahl der Punkte / Knoten 
			write(*,*) 'Verbindungen: ',Graph%total_anzahl_verbindungen  !! Die einzelnen Verbindungen / Kanten
			do i=1 , Graph%total_anzahl_knoten
				do j=1, Graph%knoten(i)%N_verbindungen
					write(*,'(A50,A2,A50,F12.4,2I5)') TRIM(Graph%knoten(i)%verbindung(j)%punkt1),"  ", &
					& TRIM(Graph%knoten(i)%verbindung(j)%punkt2),Graph%knoten(i)%verbindung(j)%kosten, &
					& Graph%knoten(i)%id, Graph%knoten(i)%verbindung(j)%id
				enddo
			enddo
			write(*,*) '--------------------------------------------------------'

		!! Netzwerk speichern?
		write(*,*) "Sollen die Daten gespeichert werden? (j/n)"
		read(*,*) antwort
		if (antwort == 'j') then
			call save_network(datei)
		end if

		return
	end subroutine newNetwork




	subroutine add_verbindung_to_knoten(knoten,verbindung)
		implicit none
		type(knoten_d)     :: knoten
		type(verbindung_d) :: verbindung
			IF( .not. (allocated(knoten%verbindung))) THEN
					allocate(knoten%verbindung(1))
					verbindung%id=1
					knoten%verbindung(1)=verbindung
					knoten%N_verbindungen=1
					knoten%hat_verbindungen=.true.
			ELSE
					CALL neue_Verbindung_zu_Verbindungen(Knoten%verbindung,verbindung)
					knoten%N_verbindungen= knoten%N_verbindungen + 1
			ENDIF
		
	end subroutine



	!! Erhöhe die Anzahl der Verbindunen für Verbindungen auf einem Knoten
	subroutine neue_Verbindung_zu_Verbindungen(Verbindungen,NeueVerbindung)
						!! Aufügen von NeueVerbindung zur Liste mit den Knoten
						implicit none
						type (verbindung_d), intent(in)::NeueVerbindung
						type (verbindung_d), ALLOCATABLE, INTENT(INOUT) :: Verbindungen(:)
						type (verbindung_d), ALLOCATABLE :: NeueVerbindungenListe(:) 
						integer::n

						n=size(Verbindungen)
						
						allocate(NeueVerbindungenListe(n+1))
						NeueVerbindungenListe(1:n)=Verbindungen(1:n)
						NeueVerbindungenListe(n+1) = NeueVerbindung

						deallocate(Verbindungen)
						allocate(Verbindungen(n+1))
						!! transfer results
						Verbindungen(:) = NeueVerbindungenListe(:)
						Verbindungen(n+1)%id = n + 1
						deallocate(NeueVerbindungenListe)
	end subroutine neue_Verbindung_zu_Verbindungen



	subroutine Dijkstra_calc(vorgaenger)
		  implicit none
		  !type(graph_d)  :: Graph
		  !type(knoten_d) :: Startknoten
		  
		  !! Local
		  type(knoten_d) :: u !u bezeichnet und wird „Betrachtungsknoten“
		  type(knoten_d) :: v !v als „Prüfknoten“
		  type(knoten_d), allocatable, dimension(:) :: Q   !! knoten = Q :: Menke aller Knoten im Graphen
		  real*8,  allocatable, dimension (:)       :: abstand
		  logical,  allocatable, dimension (:)      :: abstand_inf
		  integer, allocatable, dimension (:)       :: vorgaenger
		  logical, allocatable, dimension (:)       :: benutzt
		  real*8  :: u_v_abstand
		  integer :: u_id_min
		  integer :: total_anzahl_knoten
		  integer :: i,j
		  
			  write(*,*) 'Start Dijkstra_calc'
			  total_anzahl_knoten = Graph%total_anzahl_knoten
			  write(*,*) 'total_anzahl_knoten: ',total_anzahl_knoten
			  
			  write(*,*) 'Start: ',TRIM(Startknoten%name),' ',Startknoten%id
			  write(*,*) 'Ziel:  ',TRIM(Zielknoten%name),'  ',Zielknoten%id
			  CALL initialisiere(Graph, Startknoten, abstand, abstand_inf, benutzt, vorgaenger, Q)
			  
			  write(*,*) ' Start  Dijkstra loop.'
			  ! solange Q nicht leer:   !! Der eigentliche Algorithmus
			 loop_do: do
				  
				! solange Q nicht leer:
				if(debug) write(*,*) 'COUNT(benutzt):',COUNT(benutzt)
				if( COUNT(benutzt) == total_anzahl_knoten) then
						EXIT
				end if 
				!! u:= Knoten in Q mit kleinstem Wert in abstand[]
				if( COUNT(benutzt) == 0 ) then !! Startcycle
					u=Startknoten
				else
					call suche_u_kleinster_Abstand_in_Q( benutzt, abstand, abstand_inf, u_id_min)
					if( u_id_min == 0 ) then
						write(*,*) 'Kein weiteres u mit geringerem Abstand gefunden.'
						write(*,*) ' EXIT loop'
						EXIT loop_do
					endif 
					u=Q(u_id_min)
				endif
				  
				!! entferne u aus Q                                // für u ist der kürzeste Weg nun bestimmt
				benutzt(u%id) = .true.
				if(debug) write(*,*) 'Selected u: ',u%id,TRIM(u%name)
				do i=1,total_anzahl_knoten
					 if(  .not.  benutzt(i)) then
						!für jeden Nachbarn v von u:
							!falls v in Q:  
															!! falls noch nicht berechnet
							v = Q(i)
							!!! write(*,*) 'v: ',TRIM(ADJUSTL(v%name))
							do j = 1, u%N_verbindungen
								if ( TRIM(ADJUSTL(v%name)) == TRIM(ADJUSTL(u%verbindung(j)%punkt2)) )then
									if( u%verbindung(j)%aktiv) then
										u_v_abstand = u%verbindung(j)%kosten
										if(debug) write(*,*) 'Paar: ',TRIM(u%name)," ",TRIM(v%name),u_v_abstand
										call distanz_update(u, v, abstand, abstand_inf, u_v_abstand, vorgaenger)   !! prüfe Abstand vom Startknoten zu v 
									else
										if(debug) write(*,*) 'Inaktives Paar: ',TRIM(u%name)," ",TRIM(v%name),u_v_abstand,u%verbindung(j)%aktiv
									endif ! Uebergang aktiv?
								endif
							enddo 
					  end if ! benutzt
				enddo ! total_anzahl_knoten
			  enddo loop_do
		  
		  !! return vorgaenger[]
			
	end subroutine Dijkstra_calc



	subroutine initialisiere(Graph, Startknoten, abstand, abstand_inf, benutzt, vorgaenger, Q)
			implicit none
			type(graph_d)  :: Graph
			type(knoten_d) ::Startknoten
			type(knoten_d), allocatable, dimension(:) :: Q   !! knoten = Q :: Menke aller Knoten im Graphen
			real*8,   allocatable, dimension (:)      :: abstand
			logical,  allocatable, dimension (:)      :: abstand_inf
			logical,  allocatable, dimension (:)      :: benutzt
			integer,  allocatable, dimension (:)      :: vorgaenger
			integer::total_anzahl_knoten
			integer::N_verbindungen
			integer::i,j
			
			total_anzahl_knoten = Graph%total_anzahl_knoten
			
			if( allocated(abstand))     deallocate(abstand)
			if( allocated(abstand_inf)) deallocate(abstand_inf)
			if( allocated(benutzt))     deallocate(benutzt)
			if( allocated(vorgaenger))  deallocate(vorgaenger)
			if( allocated(Q))           deallocate(Q)
			
			if(.not. allocated(abstand)) allocate(abstand(total_anzahl_knoten))
			if(.not. allocated(abstand_inf)) allocate(abstand_inf(total_anzahl_knoten))
			if(.not. allocated(benutzt)) allocate(benutzt(total_anzahl_knoten))
			if(.not. allocated(vorgaenger)) allocate(vorgaenger(total_anzahl_knoten))
			!!! für jeden Knoten v in Graph:
			do i=1, total_anzahl_knoten
				   !!! abstand(v) = unendlich
				   abstand(i) = 0
				   abstand_inf(i) = .true.
				   benutzt(i) = .false.
				   !!!  vorgaenger[v]:= null
				   vorgaenger(i)= 0
				   !write(*,*) abstand(i), abstand_inf(i), benutzt(i), vorgaenger(i)
			enddo !i
			
			!abstand[Startknoten]:= 0
			abstand(Startknoten%id)= 0
			abstand_inf(Startknoten%id) = .true.
			

			!Q:= Die Menge aller Knoten in Graph
			if( .not. allocated(Q)) allocate(Q(total_anzahl_knoten))
			!! Uebergabe des Netzwerkes an Q 
			do i=1, total_anzahl_knoten
				N_verbindungen=Graph%knoten(i)%N_verbindungen
				Q(i)%id = Graph%knoten(i)%id
				Q(i)%name = Graph%knoten(i)%name
				Q(i)%N_verbindungen = 0
				Q(i)%hat_verbindungen = .false.
				do j=1, N_verbindungen
					call add_verbindung_to_knoten(Q(i),Graph%knoten(i)%verbindung(j))
				enddo
			enddo 
			
			!! Checke ob es negative Kosten gibt => Dann ist Dijkstra Algorithmus nicht geeignet.
			do i=1, total_anzahl_knoten
				do j=1,Graph%knoten(i)%N_verbindungen
					if( Graph%knoten(i)%verbindung(j)%aktiv)then
						if(Graph%knoten(i)%verbindung(j)%kosten < 0.0) then
							write(*,*) TRIM(Graph%knoten(i)%verbindung(j)%punkt1),"  ",TRIM(Graph%knoten(i)%verbindung(j)%punkt2),&
									& Graph%knoten(i)%verbindung(j)%kosten,"  ",Graph%knoten(i)%verbindung(j)%aktiv
							write(*,*) 'Fehler: Negative Kosten gefunden. Dijkstra Algorithmus ist nicht geeignet. EXIT.'
							call exit(1)
						endif
					endif
				enddo
			enddo
			
			write(*,*) '--- Ende Initialisierung ---'
	end subroutine 

	subroutine  distanz_update(u,v,abstand, abstand_inf, u_v_abstand, vorgaenger)
			implicit none
			type(knoten_d) :: u, v
			real*8 :: u_v_abstand
			real*8,   allocatable, dimension (:) :: abstand
			logical,  allocatable, dimension (:) :: abstand_inf
			integer,  allocatable, dimension (:) :: vorgaenger
			real*8 :: alternativ
			
				alternativ = abstand(u%id) + u_v_abstand       !  abstand_zwischen(u, v)   !! Weglänge vom Startknoten nach v über u
				!falls alternativ < abstand[v]:
				if ( (abs(alternativ) < abs(abstand(v%id))) .or. ( (abstand_inf(v%id)) .and. ( abs(u_v_abstand) > 0.0) ) )then !! order Erstbestimmung
					   abstand(v%id) = alternativ
					   abstand_inf(v%id) = .false.
					   vorgaenger(v%id) = u%id
				endif
			
	end subroutine


	subroutine erstelle_kuerzester_Weg( vorgaenger, Weg, Weg_kosten, WegSchritte, Gesamtkosten)
		implicit none
		integer,  allocatable, dimension (:) :: vorgaenger
		Character(len=50), allocatable, dimension (:)   :: Weg
		real*8, allocatable, dimension (:)  :: Weg_kosten 
		integer :: WegSchritte
		integer::total_anzahl_knoten
		integer::u_id
		integer::i,j
		real*8 :: Gesamtkosten
		total_anzahl_knoten=Graph%total_anzahl_knoten
		
		if( allocated(Weg)) deallocate(Weg)
		if( allocated(Weg_kosten)) deallocate(Weg_kosten)
		
		if(.not. allocated(Weg)) allocate(Weg(total_anzahl_knoten))
		if(.not. allocated(Weg_kosten)) allocate(Weg_kosten(total_anzahl_knoten))
		Weg=" "
		Weg_kosten=0
		WegSchritte=0
		Weg(1) = Zielknoten%name
		u_id = Zielknoten%id
		if ( vorgaenger(u_id) == 0 ) then
				write(*,*) "Es gibt keinen Weg von ", TRIM(Startknoten%name)," nach ",TRIM(Zielknoten%name)
				Gesamtkosten=0
				return
				!call exit(1)
		endif
		
		i=1
		do 
			!!solange vorgaenger[u] nicht null:   // Der vorgaenger des Startknotens ist null
			if( vorgaenger(u_id) == 0) then
				write(*,*) 'Weg gefunden. Exit loop.'
				exit
			end if
			i=i+1
			u_id = vorgaenger(u_id)
			!füge u am Anfang von Weg[] ein
			
			weg(i) = Graph%knoten(u_id)%name
			loop_j: do j =1, Graph%knoten(u_id)%N_verbindungen
				if( TRIM(ADJUSTL(weg(i-1))) == TRIM(ADJUSTL(Graph%knoten(u_id)%verbindung(j)%punkt2)) ) then
					Weg_kosten(i) = Graph%knoten(u_id)%verbindung(j)%kosten
					exit loop_j
				endif
			enddo loop_j
		end do 
		
		Gesamtkosten=0
		write(*,*) ' Anzahl der besuchten Knoten i=',i,' Anzahl der Schritte ',i-1
		write(*,*) ' Weg                           Kosten                    Kosten      log10(Kosten) '
		do j=i,1, -1
			write(*,'(A30,F30.8,ES10.2,F18.3)') Weg(j), Weg_kosten(j), Weg_kosten(j), log10(Weg_kosten(j))
			Gesamtkosten = Gesamtkosten + Weg_kosten(j)
		end do
		WegSchritte = i-1
		write(*,*) 'Die Gesamtkosten sind: ',Gesamtkosten
	end subroutine 

	!!  u:= Knoten in Q mit kleinstem Wert in abstand[]
	subroutine suche_u_kleinster_Abstand_in_Q( benutzt, abstand, abstand_inf, u_id_min)
		implicit none
		!type(knoten_d), allocatable, dimension(:) :: Q   !! knoten = Q :: Menke aller Knoten im Graphen
		logical,  allocatable, dimension (:)      :: benutzt
		real*8,   allocatable, dimension (:)      :: abstand
		logical,  allocatable, dimension (:)      :: abstand_inf
		integer :: u_id_min
		!! Lokal
		real*8:: min_abstand
		integer::total_anzahl_knoten
		integer::i
		
		
		if(debug)write(*,*) 'start suche_u_kleinster_Abstand_in Q '
		total_anzahl_knoten=size(abstand)
		min_abstand=MAXVAL(abstand,total_anzahl_knoten)
		u_id_min=0
		!!! write(*,*) 'min_abstand: ',min_abstand,' u_id_min:',u_id_min
		!!u:= Knoten in Q mit kleinstem Wert in abstand[]
		do i=1,total_anzahl_knoten
			if(debug) write(*,*) 'benutzt: ',benutzt(i),' inf: ',abstand_inf(i), abstand(i) 
			if( .not. benutzt(i)) then
				if( .not. abstand_inf(i) ) then
						if ( abstand(i) <= min_abstand ) then
							u_id_min=i
							min_abstand = abstand(i)
							if(debug) write(*,*) 'u_id_min: ',u_id_min,' min_abstand: ',min_abstand
						endif
				endif
			endif 
		enddo
		

		if(debug) write(*,*) 'Ende suche_u_kleinster_Abstand_in Q '
	end subroutine suche_u_kleinster_Abstand_in_Q

 
 
	 !! Speichert die eingegebenen Netzwerk-Daten in einer Datei
	subroutine save_network(datei)
		implicit none
		character(500), intent(inout) :: datei
		integer :: ioerr
		integer :: i,j
		logical :: Datei_vorhanden
		integer :: aktive_verbindungen
		
			if( LEN_TRIM(datei) < 1) then
				Datei_vorhanden=.true.
				do while(Datei_vorhanden) 
						write(*,*) "In welcher Datei sollen die Daten gespeichert werden? "
						read(*,*) datei
						inquire(file=TRIM(datei),exist=Datei_vorhanden)
						if(Datei_vorhanden) write(*,*) 'Die Datei existiert bereits:',Trim(datei)
				enddo 
			endif
			
			open(unit=20, file=datei, status="replace", action="write", iostat=ioerr)
			if (ioerr /= 0) then
					write(*,*) "Fehler beim Schreiben in Datei!! "//Trim(datei)
					close(unit=20)
					call exit(1)
			end if
			
			!! Zähle die aktiven Verbindungen
			aktive_verbindungen= count_aktive_Verbindungen_in_Graph(Graph)
		
			write(*,*) '---------- Schreibe Netzwerk -----------------------'
			write(20,*) Graph%total_anzahl_knoten        !! Anzahl der Punkte / Knoten 
			write(20,*) aktive_verbindungen              !! Die einzelnen (aktiven) Verbindungen / Kanten
			do i=1 , Graph%total_anzahl_knoten
				do j=1, Graph%knoten(i)%N_verbindungen
					if(Graph%knoten(i)%verbindung(j)%aktiv) then
						write(20,'(A50,A2,A50,ES20.8)')  TRIM(Graph%knoten(i)%verbindung(j)%punkt1),"  ",  &
						&    TRIM(Graph%knoten(i)%verbindung(j)%punkt2),Graph%knoten(i)%verbindung(j)%kosten
					endif
				enddo
			enddo
			write(*,*) '--------------------------------------------------------'
		
		close(unit=20)

		return
	end subroutine save_network
 
	!! Zählt die Verbindungen im Graphen, die auf Aktiv gestellt sind.
	integer function count_aktive_Verbindungen_in_Graph(this)
			implicit none
			type(graph_d) :: this
			integer ::aktive_verbindungen
			integer::i,j
			!! Zähle die aktiven Verbindungen
			aktive_verbindungen=0
			do i=1 , this%total_anzahl_knoten
				do j=1, this%knoten(i)%N_verbindungen
					if(this%knoten(i)%verbindung(j)%aktiv) then
						aktive_verbindungen = aktive_verbindungen + 1
					endif
				enddo
			enddo
			count_aktive_Verbindungen_in_Graph = aktive_verbindungen
	end function count_aktive_Verbindungen_in_Graph
 
 	!! Zählt die Verbindungen im Graphen.
	integer function count_Verbindungen_in_Graph(this)
			implicit none
			type(graph_d) :: this
			integer ::N_verbindungen
			integer::i,j
			!! Zähle die aktiven Verbindungen
			N_verbindungen=0
			do i=1 , this%total_anzahl_knoten
				do j=1, this%knoten(i)%N_verbindungen
						N_verbindungen = N_verbindungen + 1
				enddo
			enddo
			count_Verbindungen_in_Graph = N_verbindungen
	end function count_Verbindungen_in_Graph
 
 
	!!! #################################################################################################################################################  !!!
	!!! ################################################## END FUNCTIONS DIJKSRA ALOGORITHMUS ###########################################################  !!!
	!!! #################################################################################################################################################  !!!



end module mod_dijkstra
!!! ------------------------------------------------------------------------------------------------------------------- !!!
!!! ----------------------- END   Module mod_dijkstra ----------------------------------------------------------------- !!!
!!! ------------------------------------------------------------------------------------------------------------------- !!!




PROGRAM main
	use small_functions
	use mod_dijkstra
	use KMC_class
	use Molecule_class
	use gro_to_votca
	use rates_to_votca_sqlfile
	use calc_current_I_from_kmc_data
	use gro_to_DIPRO
	use DIPRO_nMO
	use charge_transfer_rate_calculator
	IMPLICIT NONE
	CHARACTER (LEN=50) :: method
	CHARACTER (LEN=500) :: dummyname
	CHARACTER (LEN=50000) :: inputline
	integer ::i
	
	inputline='charge_transport_package '
	DO i=1,command_argument_count()
				CALL get_command_argument(i,dummyname)
				inputline=trim(inputline)//'  '//trim(adjustl(dummyname))
	ENDDO
	write(*,*) '================================='
	write(*,*) '|   charge transport package    |'
	write(*,*) '================================='
	write(*,*) trim(inputline)
	
	
	CALL get_command_argument(1,method)
    IF (TRIM(method) == 'reduce_kmc_xyz') THEN
			CALL reduce_xyz_kmc_trajectory()
	ELSE IF (TRIM(method) == 'calc_pathway') THEN
			CALL KMC_EvaluateFrame()
	ELSE IF (TRIM(method) == 'Dijkstra_kmcNetwork') THEN
		CALL KMC_EvaluateFrame()
	ELSE IF (TRIM(method) == 'Dijkstra_newNetwork') THEN
		CALL dijkstra_main()
	ELSE IF (TRIM(method) == 'Dijkstra_loadNetwork') THEN
		CALL dijkstra_main()
	ELSE IF (TRIM(method) == 'KMC_FOR_MULTIPLE_CHARGES' ) THEN
			CALL KMC_EvaluateFrame()
	ELSE IF (TRIM(method) == 'KMC_FOR_MULTIPLE_CHARGES_xml' ) THEN
			CALL KMC_EvaluateFrame()
	ELSE IF (TRIM(method) == 'gro_to_VOTCA') THEN
			CALL enumerated_gro_to_VOTCA__DIPBI_P3HT_prepare()
	ELSE IF ((TRIM(method) == 'rates_to_VOTCA_sqlfile') .or. (TRIM(method)=='my_rates_to_votca_sql.out') .or. &
			&	(check_filetermination_and_continue(method,'.gro')) ) THEN
			CALL my_rates_to_votca_sql_main()
	ELSE IF (TRIM(method) == 'calc_current_I') THEN 
		CALL current_I_form_votca_sql_data()
	ELSE IF (TRIM(method) == 'calc_current_I_from_sql') THEN 
		CALL current_I_form_votca_sql_data()
	ELSE IF (TRIM(method) == 'calc_current_I_xml') THEN 
		CALL current_I_form_votca_sql_data()
	ELSE IF (TRIM(method) == 'DIPRO_nMO') THEN 
		CALL DImer_PROjection() 
	ELSE IF (TRIM(method) == 'DIPRO_pair') THEN  
		CALL gro_to_DIPRO_P3HT_DIPBI_PPDI()
	ELSE IF (TRIM(method) == 'DIPRO_xyz') THEN  
		CALL gro_to_DIPRO_P3HT_DIPBI_PPDI()
	ELSE IF (TRIM(method) == 'DIPRO') THEN 
		CALL gro_to_DIPRO_P3HT_DIPBI_PPDI()
	ELSE IF (TRIM(method) == 'lambda_out_dE_out') THEN 
		CALL lambda_out_dE_out()
	ELSE IF (TRIM(method) == 'lambda_out') THEN 
		CALL gro_to_DIPRO_P3HT_DIPBI_PPDI()
	ELSE IF ((TRIM(method) == 'lambda_in') .OR.  (TRIM(method) == 'lambda_in_pair')) THEN 
		CALL gro_to_DIPRO_P3HT_DIPBI_PPDI()
	ELSE IF (TRIM(method) == 'lambda_in_oniom') THEN 
		CALL gro_to_DIPRO_P3HT_DIPBI_PPDI()
	ELSE IF (TRIM(method) == 'rate_calculator' .OR. TRIM(method) == 'rates' ) THEN 
		CALL rate_calculator()
	ELSE IF (TRIM(method) == 'data_analysis') THEN 
		CALL data_analysis()
	ELSE
		WRITE(*,*) 'Possible calculators: '
		WRITE(*,*) 'reduce_kmc_xyz'
		WRITE(*,*) 'calc_pathway'
		WRITE(*,*) 'Dijkstra_kmcNetwork'
		WRITE(*,*) 'Dijkstra_newNetwork'
		WRITE(*,*) 'Dijkstra_loadNetwork'
		WRITE(*,*) 'KMC_FOR_MULTIPLE_CHARGES'
		WRITE(*,*) 'KMC_FOR_MULTIPLE_CHARGES_xml      use votca optionsfile for kmc run options'
		WRITE(*,*) 'gro_to_VOTCA'
		WRITE(*,*) 'rates_to_VOTCA_sqlfile'
		WRITE(*,*) 'calc_current_I'
		WRITE(*,*) 'calc_current_I_from_sql'
		WRITE(*,*) 'calc_current_I_xml'
		WRITE(*,*) 'DIPRO'            
		WRITE(*,*) 'DIPRO_pair'  
		WRITE(*,*) 'DIPRO_xyz'      
		WRITE(*,*) 'lambda_out_dE_out'
		WRITE(*,*) 'lambda_out'       
		WRITE(*,*) 'lambda_in'        
		WRITE(*,*) 'lambda_in_oniom'  
		WRITE(*,*) 'rate_calculator'
		WRITE(*,*) 'data_analysis'
	END IF 
CONTAINS



!!!! START reduce_xyz_kmc_trajectory
subroutine reduce_xyz_kmc_trajectory()
	use small_functions
	implicit none
	Character(LEN=2),allocatable,  dimension(:)  ::  element
	REAL, allocatable, dimension(:)  ::  x,y,z,x2,y2,z2,x3,y3,z3
	Character(LEN=50)::dummy
	Character(LEN=500)::method,old_xyz_trajectory_file, new_xyz_trajectory_file
	INTEGER::i,j,N_lines_file,N_Atoms,ierror1,ierror2

	LOGICAL::new_coordinates_found,last_coords_skipped,Datei_vorhanden


	old_xyz_trajectory_file='my_trajectory.xyz'
	IF (command_argument_count() /= 2) THEN	   
			WRITE(*,*) "Skript reduces kmc_trajectory.xyz and delets back- and forth jumps in order to reduce the total trajectory size!"
			WRITE(*,*) " "
			WRITE(*,*) " Usage: reduce_kmc_xyz    kmc_trajectory.xyz"
			CALL EXIT(1)
	ELSE             
			CALL get_command_argument(1,method)
			IF (TRIM(method) == 'reduce_kmc_xyz') THEN
				write (*,*) 'Start reduce_kmc_xyz'
			ELSE
				write(*,*) " Error:   use reduce_kmc_xyz  kmc_trajectory.xyz"
				CALL EXIT(1)
			END IF
			
			CALL get_command_argument(2,old_xyz_trajectory_file)
			Write(*,*) "old_xyz_trajectory_file: ", old_xyz_trajectory_file
	END IF


	new_xyz_trajectory_file='short_'//TRIM(old_xyz_trajectory_file)

	INQUIRE(file=TRIM(old_xyz_trajectory_file),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
	IF( .NOT. Datei_vorhanden) THEN
				WRITE(*,*) ' Fehler: Die_Datei_ist_nicht_vorhanden. '//TRIM(old_xyz_trajectory_file)
				WRITE(*,*) ' ENDE'
				CALL EXIT (1)
	END IF ! Datei-file vorhanden 
	WRITE(*,*) 'Reading data from: ',TRIM(old_xyz_trajectory_file)


	INQUIRE(file=TRIM(new_xyz_trajectory_file),exist=Datei_vorhanden) ! Abfrage ob Datei vorhanden ist.
	IF( Datei_vorhanden) THEN
				WRITE(*,*) ' Fehler: Die_Datei_ist_vorhanden. '//TRIM(new_xyz_trajectory_file)
				WRITE(*,*) ' Stellen Sie sicher, dass diese nicht ueberschrieben wird.'
				WRITE(*,*) ' ENDE'
				CALL EXIT (1)
	END IF ! Datei-file vorhanden 
	WRITE(*,*) 'write data to: ',TRIM(new_xyz_trajectory_file)
	
	
	N_lines_file=Read_rows_file2(old_xyz_trajectory_file)

	OPEN(UNIT=15,FILE=TRIM(old_xyz_trajectory_file),STATUS='OLD',IOSTAT=ierror1)
	OPEN(UNIT=16,FILE=TRIM(new_xyz_trajectory_file),STATUS='REPLACE',IOSTAT=ierror2)

	dummy=' '
	ierror1=1
	i=0

	new_coordinates_found=.false.
	last_coords_skipped=.false.
	do while( ierror1 > 0 .OR. i < N_lines_file ) 
		
		!! read step
		Read(15,*,IOSTAT=ierror1) N_Atoms
		!write(*,*) N_Atoms
		i=i+1
		IF(ierror1 < 0) EXIT
		IF(ierror1 > 0) THEN
			WRITE(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(old_xyz_trajectory_file),' aufgetreten.'
			WRITE(*,*) 'Beende Einlesen !'
			CALL EXIT (1)
		END IF
		
		!Read(15,*,ierror1) dummy
		!i=i+1
		
		!! Initialisierung
		if(i==1) then
					allocate(element(N_Atoms))
					allocate(x(N_Atoms),x2(N_Atoms),x3(N_Atoms))
					allocate(y(N_Atoms),y2(N_Atoms),y3(N_Atoms))
					allocate(z(N_Atoms),z2(N_Atoms),z3(N_Atoms))
					element=" "
					x=0
					y=0
					z=0
					x2=-1
					y2=-1
					z2=-1
					x3=-2
					y3=-2
					z3=-2
		end if
		
		!! Einlesen koordinaten
		do j=1,N_Atoms
			read(15,*,IOSTAT=ierror1)  element(j), x(j),y(j),z(j)
			!write(*,*) element(j), x(j),y(j),z(j)
			i=i+1
				IF(ierror1 < 0) EXIT
				IF(ierror1 > 0) THEN
					write(*,*) 'Error: Es ist eine Fehler beim Einlesen von ',TRIM(old_xyz_trajectory_file),' aufgetreten.'
					write(*,*) 'Beende Einlesen !'
					call exit(1)
				END IF
		enddo
		
		
		!! Check ob der Sprung vorher schon gemacht wurde
		new_coordinates_found=.false.
		
		do j=1,N_Atoms
			if( (Abs(x3(j)-x(j)) > 1E-3 ) .AND. ( Abs(y3(j)-y(j)) > 1E-3 ) ) then
				new_coordinates_found=.true.
				EXIT 
			endif
		enddo
		

		
		!!! insert omitted step
		IF (last_coords_skipped .and. new_coordinates_found ) then
			write(16,*) N_Atoms
			write(16,*) TRIM(dummy)
			!! Anfuegen 
			do j=1,N_Atoms
				write(16,*,IOSTAT=ierror2)  element(j), x2(j),y2(j),z2(j)
				if(ierror2 > 0) then
					write(*,*) 'Fehler beim Schreiben!'
					write(*,*) element(j), x2(j),y2(j),z2(j)
					call exit(1)
				end if
			enddo
			last_coords_skipped=.false.
		ENDIF
		
		
		if(new_coordinates_found) then
			write(16,*) N_Atoms
			write(16,*) TRIM(dummy)
			!! Anfuegen 
			do j=1,N_Atoms
				write(16,*,IOSTAT=ierror2)  element(j), x(j),y(j),z(j)
				if(ierror2 > 0) then
					write(*,*) 'Fehler beim Schreiben!'
					write(*,*) element(j), x(j),y(j),z(j)
					call exit(1)
				end if
			enddo
			last_coords_skipped=.false.
		else
			last_coords_skipped=.true.
		endif !new_coordinates_found
		
		!! Uebergabe alter Koorinaten
		x3=x2
		y3=y2
		z3=z2
		
		x2=x
		y2=y
		z2=z
		
	enddo ! while reading trajectory file

end subroutine reduce_xyz_kmc_trajectory
!!!! END reduce_xyz_kmc_trajectory




!!! Startroutine to setup the kmc simualtions
subroutine KMC_EvaluateFrame()
	use small_functions
	use KMC_class
	IMPLICIT NONE
	!type (KMC_system_t) ::KMC_system
	!type (KMC_setup_t) ::KMC_setup
	type (KMC_Node_t), ALLOCATABLE, DIMENSION(:)   ::nodes
	type (KMC_result_t), ALLOCATABLE, DIMENSION(:) ::KMC_results
	
	INTEGER ::numberofcharges
	INTEGER::numberofpairs,number_of_nodes
	INTEGER::explicitcoulomb
	CHARACTER(LEN=1)::carriertype
	LOGICAL::calc_pathway
	CHARACTER(LEN=500)::rates,votca_sql_name,kMC_options_filename
	CHARACTER(LEN=500)::dummy,modus

    !vector<Node*> node;
    !CoulombMap coulomb;
    write(*,*)  "-----------------------------------"     
    write(*,*)  "      KMC FOR MULTIPLE CHARGES     "
    write(*,*)  "-----------------------------------"  
 	
    !! defaults
	votca_sql_name='statefile7_inter_intra_PM3_to_CDFT_U1.sql'
	carriertype='h'
	explicitcoulomb=0
	numberofcharges=1
	!! sql_file or calculate
	rates='sql_file'
	calc_pathway=.false.
	
	!! initialize defaults settings 
	CALL set_defaults_KMC_system(KMC_system)
	
	!! initialize default settings
	CALL set_defaults_KMC_setup(KMC_setup)
	
	
	
	CALL get_command_argument(1,modus)
	
	IF( (TRIM(modus) == 'Dijkstra_kmcNetwork') )THEN
			KMC_setup%calc_pathway_Dijkstra=.true.
			IF (command_argument_count() == 3) THEN
				WRITE(*,*) ' Start Dijkstra_kmcNetwork '
			ELSE
				WRITE(*,*) 'Use: Dijkstra_kmcNetwork with '
				WRITE(*,*) 'Dijkstra_kmcNetwork                 options.xml                                  statefile.sql '
				WRITE(*,*) 'Dijkstra_kmcNetwork   options_cpt_run_P3HT_inter_and_intra_h.xml   '//& 
							&'statefile7_inter_intra_PM3_to_CDFT_U1.sql '
				CALL EXIT(1)
			ENDIF
	ENDIF
	
	
	IF ( (TRIM(modus) == 'KMC_FOR_MULTIPLE_CHARGES_xml') .OR. (TRIM(modus) == 'calc_pathway') .or. &
		&(TRIM(modus) == 'Dijkstra_kmcNetwork') ) THEN
		IF (command_argument_count() == 3) THEN	
				CALL get_command_argument(2,kMC_options_filename)
				KMC_setup%votca_options_name=kMC_options_filename
				
				CALL get_command_argument(3,votca_sql_name)
				KMC_setup%votca_sql_name=votca_sql_name
				
				if(file_exists(KMC_setup%votca_sql_name) .and. file_exists(KMC_setup%votca_options_name)) then
					CALL read_votca_optionsfile(kMC_options_filename,KMC_setup,&
							&" dijkstra  Dijkstra kmc_multiple  kmcmultiple  system  datafiles")
					calc_pathway=KMC_setup%calc_pathway
					write(*,*) 'tmp: calc_pathway: ',calc_pathway,'  calc_Dijkstra: ', KMC_setup%calc_pathway_Dijkstra
				endif ! file exits
		ELSE
			WRITE(*,*) '  KMC_FOR_MULTIPLE_CHARGES_xml        kMC_options_filename                         votca_sql_name          '
			WRITE(*,*) '  KMC_FOR_MULTIPLE_CHARGES_xml  options_cpt_run_P3HT_inter_and_intra_h.xml  '//&
						&'  statefile7_inter_intra_PM3_to_CDFT_U1.sql '
			CALL EXIT(1)
		END IF
	
	ELSE IF (  (TRIM(modus) == 'KMC_FOR_MULTIPLE_CHARGES' ) .or. (TRIM(modus) == 'calc_pathway') &
		& .or. (TRIM(modus) == 'Dijkstra_kmcNetwork')) THEN
		
		IF (command_argument_count() == 4 ) THEN
				CALL get_command_argument(2,votca_sql_name)
				KMC_setup%votca_sql_name=votca_sql_name
				if(file_exists(KMC_setup%votca_sql_name)) continue
				
				CALL get_command_argument(3,carriertype)
				IF( (TRIM(carriertype)=='h') .OR. (TRIM(carriertype)=='e') )THEN
					KMC_setup%carriertype=TRIM(carriertype)
				ELSE
					WRITE(*,*) "Error: carriertype not supported. Only h/e  are available (hole/electron). Found: "//TRIM(carriertype)
					CALL EXIT(1)
				END IF ! carriertype
				!!! numberofcharges 
				CALL get_command_argument(4,dummy)
				READ(dummy,'(I10)') numberofcharges
				IF( numberofcharges > 0 .AND. numberofcharges < 64) THEN
					KMC_setup%numberofcharges = numberofcharges
				ELSE 
					WRITE(*,*) 'Error: while reading numberofcharges in KMC_FOR_MULTIPLE_CHARGES: Select 0 < ',numberofcharges,' < 64 !'
					CALL EXIT(1)
				END IF
				
				IF (TRIM(modus) == 'KMC_FOR_MULTIPLE_CHARGES') THEN
					calc_pathway=.false.
					write (*,*) '  KMC_FOR_MULTIPLE_CHARGES  '//TRIM(votca_sql_name)//'  '//TRIM(carriertype)//'  '//TRIM(str(numberofcharges))
				ELSE IF(TRIM(modus) == 'calc_pathway') THEN
					calc_pathway=.true.
					write (*,*) '              calc_pathway  '//TRIM(votca_sql_name)//'  '//TRIM(carriertype)//'  '//TRIM(str(numberofcharges))
				ENDIF
		ELSE
			write (*,*) '  KMC_FOR_MULTIPLE_CHARGES    votca_sql_name                             carriertype  numberofcharges   '
			write (*,*) '  KMC_FOR_MULTIPLE_CHARGES    statefile7_inter_intra_PM3_to_CDFT_U1.sql        h              1         '
			CALL EXIT(1)
				
		END IF
	ELSE  
			write(*,*) "ERROR: Wrong modus selected"
			CALL EXIT(1)

	END IF ! command_argument_count
	
	
    !! Initialise random number generator
    !if(debug) write(*,*) "Initialising random number generator" 
    !call init_random_seed()
    !call RANDOM_SEED()
    !write(*,*) 'initialize with random number:  '//TRIM(make_lio())

    !!!node = KMCMultiple::LoadGraph();
	call LoadGraph_from_sql(KMC_setup,nodes,numberofpairs,number_of_nodes)


	if(explicitcoulomb == 1)then
			write(*,*) "Explicit Coulomb Interaction: ON (Partial Charges)." , "[explicitcoulomb=1]" 
			write(*,*) "KMCMultiple::InitialRates(node)"
			write(*,*) "coulomb = KMCMultiple::LoadCoulomb(node.size())"
			write(*,*) "Not implemented!"
			call exit(1)
	else if(explicitcoulomb == 2)then
			write(*,*)  "Explicit Coulomb Interaction: ON (Raw Coulomb Interaction)." ,"[explicitcoulomb=2]"
			write(*,*) "KMCMultiple::InitialRates(node);"
			write(*,*) "KMCMultiple::InitBoxSize(node);"
			write(*,*) "Not implemented!"
			call exit(1)
	else
		write(*,*) "Explicit Coulomb Interaction: OFF."
		if(TRIM(rates) == "calculate")then
			write(*,*) "Calculating rates (i.e. rates from state file are not used)." 
			write(*,*) "KMCMultiple::InitialRates(node)"
			write(*,*) "Not implemented!"
			call exit(1)
		else
		   write(*,*) "Using rates from state file." 
		endif !rates == "calculate"
	endif ! explicitcoulomb

	if( KMC_setup%unite_notes_for_kmc) then
			CALL unite_notes_for_kmc(nodes, KMC_setup)
	endif
	
	!write(*,*)  KMC_setup%calc_pathway , KMC_setup%calc_pathway_Dijkstra
	if(KMC_setup%calc_pathway .or. KMC_setup%calc_pathway_Dijkstra) then
		write(*,*) "----------------- START calc pathway -----------------"
		KMC_system%KMC_setup=KMC_setup
		KMC_system%has_KMC_setup=.true.
		write(*,*) 'tmp: ',TRIM(KMC_system%KMC_setup%votca_sql_name)
		write(*,*) 'tmp: ',KMC_system%KMC_Nodes(1)%event(1)%rate
		call pathway() !nodes,KMC_setup)
		write(*,*) "----------------- END   calc pathway -----------------"
		call exit(1)
	endif
	
	!! routine uses distances in dr in [m] meters 
	!!                           rates in [s**-1] 
	!!                           simulation time in [s] seconds
    !!! occP = KMCMultiple::RunVSSM(node, _runtime, _numberofcharges, RandomVariable, coulomb);
	if( .not. allocated(KMC_results)) then
		allocate(KMC_results(1))
		KMC_results(1)%id=1
	endif
    CALL kmc_run_VSSM(nodes,  KMC_setup, KMC_results(1))
    !! write occupation probabilites
    !!KMCMultiple::WriteOcc(occP, node);
    

end subroutine KMC_EvaluateFrame


subroutine pathway() !nodes,KMC_setup)
	use small_functions
	use KMC_class
	implicit none
	!type (KMC_system_t),INTENT(INOUT)   ::KMC_system
	!type (KMC_setup_t) ::KMC_setup
	type(KMC_Node_t), allocatable, dimension(:)   ::nodes
	type (KMC_result_t), allocatable, dimension(:)                ::KMC_results
	type (KMC_Chargecarrier_t), allocatable, dimension(:)         ::carrier
	
	character(len=1) :: carriertype
	real*8, allocatable, dimension(:)   ::occP
	real, allocatable, dimension(:)     :: tot_occ_data
	character(LEN=500)::votca_sql_filename,tot_occ_filename,marcus_rate_filename
	integer::i,j,k,l,N_tot_occ_lines
	integer, allocatable, dimension(:) :: id_tot_occ
	REAL, PARAMETER::nm2Ang=10.0
	!! gro
	type (gro_data_t) ::gro_data
	CHARACTER(LEN=500)                             :: gro_inputfile, gro_outputfile
	INTEGER :: NAtoms
	REAL, ALLOCATABLE, DIMENSION(:,:) :: Koords
	LOGICAL::wrap_all_molecules_into_the_box
	LOGICAL::cut_side_chains_in_gro
	LOGICAL::unite_PBC_split_molecule
	LOGICAL::read_reference_grofile
	REAL, DIMENSION(3)::dr,box
	REAL*8::I_max
	INTEGER::N_Atoms,ierror,number_of_nodes
	INTEGER::N_visited_sites
	REAL*8:: sum_tot_occ
	!! Shift molecules with a negativ coordinate by a PBC length
	LOGICAL, DIMENSION(3):: shiftbox
	LOGICAL::shift_molecule_with_negative_coords_PBC=.false.
	INTEGER:: count_shifts
	
	nodes=KMC_system%KMC_Nodes
	
	KMC_setup=KMC_system%KMC_setup

	if(KMC_system%has_nodes) then
		!nodes=KMC_system%KMC_Nodes
		!KMC_setup=KMC_system%KMC_setup
		write(*,*) TRIM(KMC_setup%votca_sql_name)
	else
		write(*,*) ' Data for pathway is not available.'
		call exit(1)
	endif
	gro_inputfile=KMC_setup%gro_inputfile
	read_reference_grofile=KMC_setup%read_reference_grofile
	wrap_all_molecules_into_the_box=KMC_setup%wrap_all_molecules_into_the_box
	cut_side_chains_in_gro=KMC_setup%cut_side_chains_in_gro
	unite_PBC_split_molecule=KMC_setup%unite_PBC_split_molecule
	votca_sql_filename=KMC_setup%votca_sql_name
	carriertype=KMC_setup%carriertype
	write(*,*) 'tmp start: ',KMC_system%KMC_setup%start_Dijkstra," ",trim(carriertype)
	
	!!! Temporaty files
	tot_occ_filename=TRIM(make_tmp_readfilename('tot_occ',KMC_setup%votca_sql_name,KMC_setup%set_seed))
	marcus_rate_filename=TRIM(make_tmp_readfilename('marcus_rate',KMC_setup%votca_sql_name,KMC_setup%set_seed))
	
	CALL dump_sql_data_for_current(votca_sql_filename,tot_occ_filename,marcus_rate_filename,carriertype)
	
	CALL read_total_occupation_file(tot_occ_filename,id_tot_occ,tot_occ_data,N_tot_occ_lines)
	ALLOCATE(occP(size(tot_occ_data)))
	sum_tot_occ=0.0
	do i=1,size(tot_occ_data)
		occP(i)=REAL(tot_occ_data(i),8)
		sum_tot_occ = sum_tot_occ + occP(i)
	end do 
	
	if ( abs(sum_tot_occ - 1.0D0) > 1.0D-5) then
		write(*,*) 'Error: the sum of all occupation numbers is not equal to 1.0: ',sum_tot_occ
		write(*,*) 'Please check occP in :   '//TRIM(tot_occ_filename)//'   and   '//TRIM(votca_sql_filename)
		call exit(1)
	end if
		
	
    CALL modify_rates_for_current_path_evaluation(nodes,occP) !, KMC_setup)

	IF(read_reference_grofile) THEN
				!!! grofile data read
				gro_inputfile=KMC_setup%gro_inputfile
				read_reference_grofile=KMC_setup%read_reference_grofile
				wrap_all_molecules_into_the_box=KMC_setup%wrap_all_molecules_into_the_box
				unite_PBC_split_molecule=KMC_setup%unite_PBC_split_molecule
				
				CALL  read_grofile_data(gro_data,KMC_setup)
				!! convert koord data
				!gro_data%koord=gro_data%koord*nm2Ang	
		
				!gro_data%x_box=gro_data%x_box  *nm2Ang
				!gro_data%y_box=gro_data%y_box  *nm2Ang
				!gro_data%z_box=gro_data%z_box  *nm2Ang
				!gro_data%koord_unit= 'Ang'
				
				write(*,*) 'wrap_all_molecules_into_the_box: ',wrap_all_molecules_into_the_box
				IF(wrap_all_molecules_into_the_box) THEN
					DO i=1,gro_data%N_Atoms
							dr=gro_data%koord(i,:)
							CALL position_PBC_correction(dr,gro_data%x_box,gro_data%y_box,gro_data%z_box)
							DO k=1,3
								gro_data%koord(i,k)=1.0*dr(k)
							END DO 
					END DO
				END IF
				
				write(*,*) 'unite_PBC_split_molecule: ',unite_PBC_split_molecule
				IF(unite_PBC_split_molecule) then
					DO i=1, gro_data%N_Resids
						NAtoms=gro_data%R_u_I(i+1,2)-gro_data%R_u_I(i,2)
						if( allocated(Koords)) deallocate(Koords) 
						allocate(Koords(NAtoms,3))
						k=0
						DO j = gro_data%R_u_I(i,2), gro_data%R_u_I(i+1,2)-1
							k = k + 1
							Koords(k,1:3) = gro_data%koord(j,1:3)
						END DO
						!write(*,*) 'Resid: ', gro_data%R_u_I(i,1),' NAtoms: ',NAtoms
						CALL PBC_center_molecule(NAtoms,Koords,gro_data%x_box, gro_data%y_box, gro_data%z_box)
						k=0
						DO j = gro_data%R_u_I(i,2), gro_data%R_u_I(i+1,2)-1
							k = k + 1
							gro_data%koord(j,1:3) = Koords(k,1:3)
						ENDDO ! j=?
					ENDDO  ! i=?
				ENDIF ! unite_PBC_split_molecule
				
				!! Shift molecules with a negativ coordinate by a PBC length
				shift_molecule_with_negative_coords_PBC=.true.
				write(*,*) 'shift_molecule_with_negative_coords_PBC: ',shift_molecule_with_negative_coords_PBC
				IF(shift_molecule_with_negative_coords_PBC) then
					box(1)=gro_data%x_box
					box(2)=gro_data%y_box
					box(3)=gro_data%z_box
					write(*,*) 'box: ',box(1),box(2),box(3),'  ',trim(gro_data%koord_unit)
					count_shifts=0
					DO i=1, gro_data%N_Resids
						shiftbox(:)=.false.
						DO k=1,3
							loop_j: DO j = gro_data%R_u_I(i,2), gro_data%R_u_I(i+1,2)-1
								IF( gro_data%koord(j,k) < 0.0 ) THEN
									shiftbox(k)=.true.
									count_shifts = count_shifts +1
									EXIT loop_j
								ENDIF
							END DO loop_j !j =1, N_Atoms
							
							IF(shiftbox(k)) THEN
								DO j = gro_data%R_u_I(i,2), gro_data%R_u_I(i+1,2)-1
									gro_data%koord(j,k)  =  gro_data%koord(j,k) + box(k)
								END DO !j =1, N_Atoms
							END IF !shiftbox
						END DO !k = x,y,z
					ENDDO  ! i=1,N_Resids
					write(*,*) '  N_shift_molecule_with_negative_coords_PBC  in gro_data: ',count_shifts
					
					IF(KMC_system%has_nodes)THEN
						!! Shift Node centers with a negativ coordinate by a PBC length
						count_shifts=0
						shiftbox(:)=.false.
						!! Convert  nm2m   as  position [m}
						box=box*1.0E-9
						DO k=1,3
							DO j = 1, KMC_system%number_of_nodes
								IF( KMC_system%KMC_Nodes(j)%position(k) < 0.0 ) THEN
									KMC_system%KMC_Nodes(j)%position(k) = KMC_system%KMC_Nodes(j)%position(k) +  box(k)
									count_shifts = count_shifts + 1
								ENDIF
							END DO !j =1, N_Atoms
						END DO !k = x,y,z
						write(*,*) '  N_shift_molecule_with_negative_coords_PBC  in KMC_Nodes: ',count_shifts
					ENDIF ! KMC_system%has_nodes
				ENDIF ! shift_molecule_with_negative_coords_PBC
				
				
				
				!! CUT THE SIDE CHAINS 
				IF(cut_side_chains_in_gro .and. gro_data%has_side_chains) then
				
					call cut_side_chains(gro_data)
				END IF
				call update_KMC_system_gro_data(gro_data)
				
	END IF 
	
	number_of_nodes=size(nodes)
	IF(read_reference_grofile) THEN
		if( number_of_nodes /= gro_data%N_Resids) then
			WRITE(*,*) 'Error: Missmatch in the number of nodes ',number_of_nodes,' and number of Resids, N_Resids :',gro_data%N_Resids
			CALL EXIT (1)
		endif
	endif ! read_reference_grofile
	
	!!! delete temporary files 
	CALL delete_file_and_check(tot_occ_filename)
	CALL delete_file_and_check(marcus_rate_filename)
	
	
	
	if(KMC_setup%calc_pathway_Dijkstra) then
		if((KMC_system%has_nodes  .eqv. .true.) .and. (KMC_system%has_KMC_setup  .eqv. .true.)) then
			call dijkstra_main()
		else
			write(*,*) 'Error: Can not use pathway_Dijkstra as the KMC_system failed!'
			call exit(1)
		endif
	endif
	
	
	
	if( .not. allocated(KMC_results)) then
		allocate(KMC_results(KMC_setup%N_testpathways))
	endif
	if( .not. allocated(carrier)) then
		allocate(carrier(KMC_setup%numberofcharges))
	endif
	
	
	I_max=0
	do l=1,KMC_setup%N_testpathways   ! KMC simulations / pathways 
		write(*,*) '-----------------  START  kmc path iteration: '//TRIM(str(l))//'  --------------------------------------------' 
		KMC_setup%xyz_trajectoryfilename="my_kmc_trajectory_P"//TRIM(str(l))//".xyz"
		KMC_results(l)%id=l
		!!! ----------------------------------------------------------------------
		!!  Start KMC VSSM Simulation 
		!!! ----------------------------------------------------------------------
		CALL kmc_run_VSSM(nodes,  KMC_setup, KMC_results(l))
		carrier(:)=KMC_results(l)%carrier(:)
		!!! -------------------------------------------------------------------------------------------------------------------------------------------- 
		!!  get the corresponding GROMACS.gro file for the visited hopping sites  
		!!! -------------------------------------------------------------------------------------------------------------------------------------------- 
		IF( KMC_setup%dump_grofile_dI_travelled_max) then
		do k=1,KMC_setup%numberofcharges   !size(carrier) ! numberofcharges

				!if( abs(norm8(carrier(k)%dI_travelled) / norm8(carrier(k)%dr_travelled))  > I_max ) then 
					
					!I_max=norm8(carrier(k)%dI_travelled)
					IF( abs(norm8(carrier(k)%dI_travelled) / norm8(carrier(k)%dr_travelled)) > I_max ) THEN 
						I_max=abs(norm8(carrier(k)%dI_travelled) / norm8(carrier(k)%dr_travelled))
					END IF
					if(l==1) then
						WRITE(*,*) '###   New trajectory with maximum current found: '//&
								  &'     |dI/dr|_max    |dI_travelled|   |dr_travelled|     |dI/dr|  '//&
								  &' |dI_travelled|_y   |dr_travelled|_y   |dI/dr|_y  '
					endif
					
					WRITE(*,'(A50,7ES16.4)')  '    New trajectory with maximum current found: ',&
					& I_max,& 
					& abs(norm8(carrier(k)%dI_travelled)), &
					& abs(norm8(carrier(k)%dr_travelled)), &
					& abs(norm8(carrier(k)%dI_travelled) / norm8(carrier(k)%dr_travelled)), &
					& abs(norm8(carrier(k)%dI_travelled(2))), &
					& abs(norm8(carrier(k)%dr_travelled(2))), &
					& abs(carrier(k)%dI_travelled(2) / carrier(k)%dr_travelled(2))
					
					IF(read_reference_grofile) THEN
					!! Determine number of atoms in new grofile  // Filter only visited sites
					N_Atoms=0
					N_visited_sites=0
					do i=1,number_of_nodes
						IF ( carrier(k)%nodevisited(i) > 0) THEN! select visited sites
							N_Atoms=N_Atoms+(gro_data%R_u_I(i+1,2)-gro_data%R_u_I(i,2))
							N_visited_sites=N_visited_sites+1
						ENDIF ! visited node ?
					enddo ! number_of_nodes
					
					WRITE(*,*) 'N_Atoms: ',N_Atoms, '  N_visited_sites: ',N_visited_sites
					
					
					gro_outputfile=TRIM(make_tmp_readfilename("output_trajectory_"//"_P"//TRIM(str(l))//"_C"//TRIM(str(k)),&
								   & KMC_setup%gro_inputfile,KMC_setup%set_seed))
					gro_outputfile='gro_'//TRIM(gro_outputfile(:LEN_TRIM(gro_outputfile)-4))//'.gro'
								
					OPEN(UNIT=18,FILE=TRIM(gro_outputfile),STATUS='REPLACE',IOSTAT=ierror)
					
					WRITE(*,*) ' Visited sites to the  grofile: '//TRIM(gro_outputfile)
					
					!! Output GROMACS DATEI *.gro
					WRITE(18,*) ''//TRIM(gro_outputfile)
					WRITE(18,*) N_Atoms 
					do i=1,number_of_nodes
						IF ( carrier(k)%nodevisited(i) > 0) THEN ! select visited sites
							DO j=gro_data%R_u_I(i,2),gro_data%R_u_I(i+1,2)-1 ! loop all index for atoms in molecule
								!atom_numbers(j)=mod(j,100000)
								WRITE(18,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) gro_data%residue_numbers(j),&
											& gro_data%residue_names(j),&
											& adjustr(gro_data%atomsorte(j)),&
											& gro_data%atom_numbers(j),&
											& gro_data%koord(j,1), gro_data%koord(j,2), gro_data%koord(j,3),&
											& gro_data%vel(j,1),   gro_data%vel(j,2),   gro_data%vel(j,3)
								IF(ierror > 0) THEN
									WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(gro_outputfile),' aufgetreten.'
								END IF !ierror
							END DO ! j 
						END IF ! visited node ?
					enddo ! number_of_nodes
					WRITE(18,'(3f8.3)',IOSTAT=ierror) gro_data%x_box, gro_data%y_box, gro_data%z_box
					IF(ierror > 0) THEN
							WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(gro_outputfile),' aufgetreten.'
					END IF
					WRITE(*,*) '#New gro file created: '//TRIM(gro_outputfile)//'   for   '//TRIM(KMC_setup%xyz_trajectoryfilename)
					ENDIF !!! read_reference_grofile
					
				!endif ! norm8(dI_travelled) > I_max
		enddo ! k iteration charges 

		END IF !dump_grofile_dI_travelled_max
		
		!!! -------------------------------------------------------------------------------------------------------------------------------------------- 
		!!! END  get the corresponding GROMACS.gro file for the visited hopping sites 
		!!! -------------------------------------------------------------------------------------------------------------------------------------------- 
		 write(*,*) 'pathway done: ',l
		 write(*,*) '------'
	enddo ! l = iterations trajectories 
	
	
	
	
	
	write(*,*) 'pathways done: ',l-1
	call exit (1)
end subroutine pathway




!!-> Local current:  It is not the current, which takes back and forth directions into account!
!!  current_ij = e * p_i * k_ij * d_ij   [ A * m  == C m/s]
subroutine modify_rates_for_current_path_evaluation(node,occP) !, KMC_setup)
	use small_functions
	use KMC_class
	implicit none
	!type (KMC_setup_t) ::KMC_setup
	type(KMC_Node_t), allocatable, dimension(:),INTENT(INOUT)     ::node
	real*8, allocatable, dimension(:)  ::occP
	REAL*8, PARAMETER ::elemetary_charge=1.0D0 !!1.60217662E-19
	INTEGER::i,j,k,number_of_nodes,number_of_occP
	REAL*8::newEscapeRate
	Real*8, dimension(3) :: current,current_node_sum
	Real*8               :: current_norm_node
	REAL*8::current_norm_maximum
	integer::current_norm_maximum_node_id
	logical::debug=.false.
	logical::set_rates_to_current=.false.
	!! Find sites with highest current contribution
	CHARACTER(500)::injectionmethod
	real*8,ALLOCATABLE,DIMENSION(:)::tmp_current
	real*8::current_cutoff
	logical :: calc_local_current_dr
	
	
	set_rates_to_current=KMC_setup%set_rates_to_current 
	injectionmethod=KMC_setup%injectionmethod 
	debug=KMC_setup%debug
	calc_local_current_dr = KMC_setup%calc_local_current_dr
	
	number_of_nodes=size(node)
	number_of_occP=size(occP)
	if (number_of_nodes /=  number_of_occP) then
		write(*,*) 'Error in rank missmatch: ', number_of_nodes, number_of_occP
		call exit(1)
	endif
	
	!!! It is not the current, which takes back and forth directions into account!
	!!! current_ij = e * p_i * k_ij * d_ij   [ A * m  == C m/s]
	
	current_norm_maximum=0.0
	current_norm_maximum_node_id=0
	do i=1,number_of_nodes
			current_node_sum = 0
			current_norm_node = 0
			do j=1,node(i)%event_size
				do k=1,3   !I_x,I_y,I_z
					!write(*,*)  elemetary_charge , occP(i)  ,  node(i)%event(j)%rate , node(i)%event(j)%dr(k) , &
					!		& node(i)%id , node(i)%event(j)%destination
					if(calc_local_current_dr) then
						current(k) = elemetary_charge * occP(i)  *  node(i)%event(j)%rate * node(i)%event(j)%dr(k)
					else 
						current(k) = elemetary_charge * occP(i)  *  node(i)%event(j)%rate * node(i)%event(j)%dr(k) / norm8(node(i)%event(j)%dr)
					endif
					node(i)%event(j)%current(k) = current(k)
					!write(*,*) 'tmp current(k): ',current(k)
				enddo
				node(i)%event(j)%current_norm = norm8( current )
				current_node_sum = current_node_sum  +  current
				!write(*,*) 'current norm',current_node_sum
			enddo
			node(i)%current = current_node_sum
			node(i)%current_norm = norm8( current_node_sum)
			if ( abs(node(i)%current_norm) > current_norm_maximum ) then
					current_norm_maximum = node(i)%current_norm
					current_norm_maximum_node_id = i
			endif 
	enddo
	



	if( set_rates_to_current ) then
		write(*,*) 'modify_rates_for_current_path_evaluation start' 
		write(*,*) ' CAUTION: STARTS to replace all rates by their current. => KMC run will change !'
		!! Not recommended, but the methods may help to find high current pathways.
		do i=1,number_of_nodes
			do j=1,node(i)%event_size
				node(i)%event(j)%rate =  abs(node(i)%event(j)%current_norm)  !abs((node(i)%event(j)%rate))
			enddo
		enddo 

		do i=1,number_of_nodes
				newEscapeRate=0.0
				do j=1,node(i)%event_size
					newEscapeRate = newEscapeRate + node(i)%event(j)%rate 
				enddo 
				node(i)%escaperate = newEscapeRate
				if(debug)then
					write(*,*) "Escape rate for segment " , node(i)%id," was set to ",newEscapeRate 
				endif
		enddo 
	end if
	
	!! Find a list with ids of the highest current and set it to injection_node_list
	if( TRIM(KMC_setup%injectionmethod) == "injection_node_list") then
		if( .not. allocated(tmp_current) ) then
			allocate(tmp_current(number_of_nodes))
		endif
		do i=1,number_of_nodes
			tmp_current(i)=node(i)%current_norm
		enddo 
		CALL SortArray8(tmp_current,number_of_nodes)
		
		current_cutoff=tmp_current((number_of_nodes-KMC_setup%numberofcharges))
		write(*,*) 'current_cutoff: ',current_cutoff
		j=0
		DO i=1,number_of_nodes
				if( node(i)%current_norm > current_cutoff) then 
						j=j+1
						KMC_setup%injection_node_list(j)=node(i)%id
						write(*,*) j,'Selected startnode: ',node(i)%id,' current ',node(i)%current_norm
				endif
		END DO
		deallocate(tmp_current)
	end if
	
	
	if (current_norm_maximum_node_id == 0 )then
		write(*,*) "Error: the site with the  maximum current contribution was not determined!"
		call exit (1)
	else
		write(*,*) ' Site with maximum current contribution to injection_node: ',current_norm_maximum_node_id
		KMC_setup%injection_node = current_norm_maximum_node_id
	endif
	
	write(*,*) 'modify_rates_for_current_path_evaluation done' 
	
	!! update global system
	call update_KMC_system_nodes(node)
end subroutine modify_rates_for_current_path_evaluation




SUBROUTINE dump_sql_data_for_current(votca_sql_filename,tot_occ_filename,marcus_rate_filename,carriertype)
	use small_functions
	IMPLICIT NONE
	CHARACTER(500), INTENT(IN) ::votca_sql_filename,tot_occ_filename,marcus_rate_filename
	CHARACTER(LEN=1) :: carriertype
	CHARACTER(5000)  :: bashline
	LOGICAL::Datei_vorhanden


        inquire(file=TRIM(votca_sql_filename),exist=Datei_vorhanden) ! Abfrage ob votca_sql_filename-Datei vorhanden ist.
        IF( .NOT. Datei_vorhanden) THEN
                WRITE(*,*) ' Fehler: Die_votca_sql_filename_Datei_ist_nicht_vorhanden. '//TRIM(votca_sql_filename)
                WRITE(*,*) ' ENDE'
                CALL EXIT (1)
        END IF  

        inquire(file=TRIM(tot_occ_filename),exist=Datei_vorhanden) ! Abfrage ob tot_occ_filename-Datei vorhanden ist.
        IF( Datei_vorhanden) THEN
                WRITE(*,*) ' Fehler: Die_tot_occ_filename_Datei_ist_bereits_vorhanden. '//TRIM(tot_occ_filename)
		WRITE(*,*) ' Stellen Sie sicher, dass diese nicht ueberschrieben wird von *.sql Daten.'
                WRITE(*,*) ' ENDE'
                CALL EXIT (1)
        END IF  

        inquire(file=TRIM(marcus_rate_filename),exist=Datei_vorhanden) ! Abfrage ob marcus_rate_filename-Datei vorhanden ist.
        IF( Datei_vorhanden) THEN
                WRITE(*,*) ' Fehler: Die_marcus_rate_filename_Datei_ist_bereits_vorhanden. '//TRIM(marcus_rate_filename)
		WRITE(*,*) ' Stellen Sie sicher, dass diese nicht ueberschrieben wird von *.sql Daten.'

                WRITE(*,*) ' ENDE'
                CALL EXIT (1)
        END IF 

	!! createa a file that can be read by SUBROUTINE read_total_occupation_file 
	!! with the format from sql file: id,occPh
	!! Replace "|" with "whitespace" beforehand; Take the index shift between votca and my_kmc into account!  
	!! sqlite3 statefile.sql " SELECT id,occPh FROM segments " >> tot_occ_data.dat
	!! sed -i 's/|/   /g' -i tot_occ_data.dat 

	bashline=' sqlite3 '//TRIM(votca_sql_filename)//' " SELECT id,occP'//trim(adjustl(carriertype))//' FROM segments " | '//& 
		&" sed 's/|/   /g' | awk '{printf"//' "%i   %.10E\n",$1,$2} '//" ' >  "//TRIM(tot_occ_filename)
	WRITE(*,*) 'Use: ',TRIM(bashline)
        CALL execute_command_line(TRIM(bashline)) 

	!bashline="  sed -i 's/|/   /g' -i  "//TRIM(tot_occ_filename)
	!WRITE(*,*) 'Use: ',TRIM(bashline)
        !CALL execute_command_line(TRIM(bashline)) 


	!! create data file which can be read from SUBROUTINE read_marcus_rate_data_file 
	!! with the format from sql file: id,seg1,seg2,drX,drY,drZ,rate12h,rate21h 
	!! Replace "|" with "whitespace" beforehand; Take the index shift between votca and my_kmc into account!  
	!! sqlite3 statefile.sql " SELECT id,seg1,seg2,drX,drY,drZ,rate12h,rate21h FROM pairs " >> marcus_rate_data.dat
	!! sed -i 's/|/   /g' -i marcus_rate_data.dat 

	bashline=' sqlite3 '//TRIM(votca_sql_filename)//&
	&' " SELECT id,seg1,seg2,drX,drY,drZ,rate12'//trim(adjustl(carriertype))//',rate21'//trim(adjustl(carriertype))//&
	&' FROM pairs " >> '//TRIM(marcus_rate_filename)
	WRITE(*,*) 'Use: ',TRIM(bashline)
        CALL execute_command_line(TRIM(bashline)) 

	bashline="  sed -i 's/|/   /g' -i  "//TRIM(marcus_rate_filename)
	WRITE(*,*) 'Use: ',TRIM(bashline)
	CALL execute_command_line(TRIM(bashline)) 

END SUBROUTINE dump_sql_data_for_current














!!  ------------  START DES DIJKSRA HAUPTPROGRAMMS -------------- !!
subroutine dijkstra_main()
	use small_functions
	use KMC_class
	use mod_dijkstra
	implicit none
	integer,  allocatable, dimension (:) :: vorgaenger
	Character(len=50), allocatable, dimension (:)   :: Weg
	real*8, allocatable, dimension (:)  :: Weg_kosten 
	integer :: WegSchritte
	real*8  :: Gesamtkosten
	Character(len=50) :: modus,start,ziel
	logical:: start_found, ziel_found
	logical::exists
	character(len=500) :: loopstartzone_file
	integer::i,j,k,ierror,u_id,N_nodes_zone
	real::Harvest
	
		write(*,*) ' Start dijkstra_main '
	
		CALL get_command_argument(1,modus)
		write (*,*) "Starte Programm zur Berechnung der kuerzester Wege in einem Netzwerk"
		write (*,*) "mit dem Algorithmus von Dijkstra !! "
		write (*,*) "Use modus: ",TRIM(modus)
		
		!modus%KMC_result=modus_Dijkstra
		if (TRIM(modus) == 'Dijkstra_kmcNetwork' ) then !! Neues Netz eingeben
			!call load_dijkstra_kmc_network()
		else if (TRIM(modus) == 'Dijkstra_newNetwork' ) then !! Neues Netz eingeben
			call newNetwork()
		else if (TRIM(modus) == 'Dijkstra_loadNetwork' ) then !! Daten aus Datei laden
			call loadNetwork()
		else
			write(*,*) "Select Dijkstra modi:  'Dijkstra_kmcNetwork' 'Dijkstra_newNetwork'  'Dijkstra_loadNetwork' "
			call exit(1)
		end if
	
		if( (TRIM(adjustl(modus)) == 'Dijkstra_newNetwork') .or. (TRIM(modus) == 'Dijkstra_loadNetwork' )) then 
		!! Startpunkt einlesen
				
				do
					write(*,*) "Welcher Startpunkt soll verwendet werden?"
					read(*,*) start
					write(*,*) 'start: ',start
					start_found=.false.
					do i=1,Graph%total_anzahl_knoten
						if( TRIM(ADJUSTL(Graph%knoten(i)%name)) == TRIM(ADJUSTL(start)) ) then 
							Startknoten = Graph%knoten(i)
							start_found = .true.
						end if
					enddo
					
					if(start_found) then
						write(*,*) ' Startknoten: ',TRIM(Startknoten%name),'  id: ',Startknoten%id
						exit
					else
						write(*,*) ' Startknoten im Graph nicht gefunden :'//TRIM(start)
					end if
				end do
				
				do
					write(*,*) "Welcher Zielpunkt soll verwendet werden?"
					read(*,*) ziel
					write(*,*) 'ziel: ',ziel
					ziel_found=.false.
					do i=1,Graph%total_anzahl_knoten
						if( TRIM(ADJUSTL(Graph%knoten(i)%name)) == TRIM(ADJUSTL(ziel)) ) then 
							Zielknoten = Graph%knoten(i)
							ziel_found = .true.
						end if
					enddo
					
					if(ziel_found) then
						write(*,*) ' Zielknoten: ',TRIM(Zielknoten%name),'  id: ',Zielknoten%id
						exit
					else
						write(*,*) ' Zielknoten im Graph nicht gefunden :'//TRIM(ziel)
					end if
				end do
				
		else if (TRIM(modus) == 'Dijkstra_kmcNetwork' ) then 
			call load_dijkstra_kmc_network()
			write(*,*) 'END Dijkstra_kmcNetwork '
		endif
		
	N_nodes_zone=1
	if (TRIM(modus) == 'Dijkstra_kmcNetwork' ) then 
		if( KMC_setup%loopstartzone) then
			N_nodes_zone=size(start_zone)
			write(*,*) ' Schleife für alle ',N_nodes_zone,' Knoten in der Startzone. '
		endif
	endif
	
	!! Schleife über mehrere Startpunkte
	do k=1, N_nodes_zone
		
		if( TRIM(modus) == 'Dijkstra_kmcNetwork' ) then 
			if( KMC_setup%loopstartzone) then
				Startknoten=Graph%knoten(start_zone(k)%id)
				if(TRIM(KMC_setup%injectionmethod) == 'random' ) then
					call random_number(Harvest)
					i =  1 + int(Harvest * (N_nodes_zone-1))
					KMC_setup%ziel_Dijkstra=end_zone(i)%id
					Zielknoten = Graph%knoten(end_zone(i)%id)
					write(*,*) 'Zielknoten: ',TRIM(Zielknoten%name),'  id: ',Zielknoten%id
				endif ! random
			endif ! loopstartzone
		endif ! Dijkstra_kmcNetwork
		
		
		!! Hauptroutine Dijkstra Algorithmus
		CALL Dijkstra_calc(vorgaenger)
		
		
		if (TRIM(modus) == 'Dijkstra_kmcNetwork' ) then 
			if(KMC_system%KMC_setup%log10abs) then
				!! Rückumwandulung nach log10abs
				write(*,*)  'Rückumwandlung log10abs mit shift: ',Graph%shift_kosten
				!if( Graph%shift_kosten < 0.0 ) then
					!! Verschiebung
					do i=1, Graph%total_anzahl_knoten
						do j= 1, Graph%knoten(i)%N_verbindungen
							if( Graph%knoten(i)%verbindung(j)%aktiv) then
								Graph%knoten(i)%verbindung(j)%kosten= 10**(Graph%knoten(i)%verbindung(j)%kosten - abs(Graph%shift_kosten) )
							endif ! aktiv
						enddo ! N_verbindungen
					enddo ! knoten
				!endif !  min_kosten < 0
			endif
			
			!! Setze Ziel auf den Knoten in der Endzone mit dem minimalen Punkt in Vorgaenger
			u_id = Zielknoten%id
			do 
				!!solange vorgaenger[u] nicht null:   // Der vorgaenger des Startknotens ist null
				if( vorgaenger(u_id) == 0) then
					write(*,*) 'Weg gefunden. Exit loop.'
					exit
				end if
				u_id = vorgaenger(u_id)
				loop_find_end_zone_node : do j= 1, size(end_zone)
					if( u_id == end_zone(j)%id ) then
						Zielknoten = Graph%knoten(end_zone(j)%id)
						exit loop_find_end_zone_node
					endif
				enddo loop_find_end_zone_node
			enddo !! Finde minimalen Weg zur Endzone
			
			write(*,*) ' Erster erreichter Knoten in der Endzone wird das neue Ziel: ',Zielknoten%id,' ',TRIM(Zielknoten%name)
		endif ! Dijkstra_kmcNetwork
		
		
		!! Finde den kürstesten Weg
		CALL erstelle_kuerzester_Weg(vorgaenger, Weg, Weg_kosten, WegSchritte, Gesamtkosten)
	
		if (TRIM(modus) == 'Dijkstra_kmcNetwork' ) then 
			call dijkstra_to_gro(Weg, Weg_kosten, WegSchritte, Gesamtkosten)
		endif
		
		if(KMC_setup%loopstartzone)then
			loopstartzone_file='Pathway_start_ziel_list.dat'
			inquire(file=trim(loopstartzone_file), exist=exists)
			if (exists) then
				OPEN(UNIT=15,FILE=trim(loopstartzone_file),status='unknown', position="append", action="write",  IOSTAT=ierror)
			else
				OPEN(UNIT=15,FILE=trim(loopstartzone_file),status='unknown', action="write",  IOSTAT=ierror)
				write(15,*) '###  Startknoten   Zielknoten   Gesamtkosten  '
			endif
			if( ierror > 0 ) then
				write(*,*) 'Error: Try to open file '//trim(loopstartzone_file)
				call exit(1)
			endif
		
			write(15,*)  trim(Startknoten%name),"  ", trim(Zielknoten%name), Gesamtkosten
			CLOSE(15)
			write(*,*)   trim(Startknoten%name),"  ", trim(Zielknoten%name), Gesamtkosten
			write(*,*) 'End loop ',k
		endif
	enddo ! loop für meherer Startpunkte
	
	if (TRIM(modus) == 'Dijkstra_kmcNetwork' ) then 
		if(KMC_setup%write_Networkfile_Dijkstra) then
			call save_network(KMC_setup%networkfile_Dijkstra)
		endif
		call exit(1)
	endif
	
	write(*,*) '--- dijkstra_main Ende ---'
	call exit(1)
end subroutine dijkstra_main

!!  ------------  ENDE DES DIJKSRA HAUPTPROGRAMMS -------------- !!



!! Lädt ein Netzwerk aus kmc programm
subroutine load_dijkstra_kmc_network()
	use small_functions
	use mod_dijkstra
	use KMC_class
	implicit none
	!type(KMC_system_t)::KMC_system
	!type(KMC_setup_t)::KMC_setup
	!! KMC daten
	!! --- Berechnung von Start zur Zielzone ---
	!type(KMC_Node_t),allocatable,dimension(:)::start_zone, mitte_zone, end_zone, tmp_zone, drei_zonen
	
	type(verbindung_d) :: verbindung
	character(50)      :: punkt1, punkt2
	real*8             :: kosten
	logical            :: verbindung_aktiv
	integer            :: N_aktive_verbindungen
	integer            :: total_anzahl_knoten
	integer            :: total_anzahl_verbindungen
	

	integer  :: N_nodes_zone, N_nodes_mitte, i_field, event_id, number_of_nodes
	character(500)      :: kmcnodefilename
	real*8, dimension(3):: field,box
	real*8 :: Zonenbreite_Angstroem
	real*8 :: shift_kosten
	real*8 :: min_kosten
	real*8 :: casi_zero=1.0D-100  !! numerisch null
	integer, dimension(1024)::delete_event_list
	integer::n_events
	integer::N_umlengungen_mitte_ende
	integer::N_start_ende_delete
	integer::N_ende_start_delete
	integer::N_umlengungen_ende_ende
	logical:: umgelenkt =.false.
	logical::startpunkt_in_zone=.false.
	logical::endpunkt_in_zone=.false.
	real::Harvest
	!! Function
	!integer events_to_netzwork
	integer :: i,j,k, n,ierror

	!! KMC_Setup
	integer:: seg1,seg2

	logical :: calc_pathway_between_zones=.false.
	logical :: log10abs=.false.
	real*8  :: m2Ang=1.0D+10, nm2Ang=10.0
	write(*,*) '-- Start: load_dijkstra_kmc_network --'
	
	calc_pathway_between_zones=KMC_setup%calc_pathway_between_zones
	number_of_nodes = size(KMC_system%KMC_nodes)
	debug = KMC_system%KMC_setup%debug
	total_anzahl_knoten = KMC_system%number_of_nodes
	calc_pathway_between_zones = KMC_system%KMC_setup%calc_pathway_between_zones
	Zonenbreite_Angstroem = KMC_system%KMC_setup%zonenbreite
	log10abs              = KMC_system%KMC_setup%log10abs
	
	write(*,*) ' has_nodes: ',KMC_system%has_nodes
	write(*,*) ' has_KMC_setup: ',KMC_system%has_KMC_setup
	write(*,*) ' has_KMC_grid: ',KMC_system%has_grid
	write(*,*) ' has_gro_data: ',KMC_system%has_gro_data
	write(*,*) ' debug: ',KMC_system%KMC_setup%debug
	write(*,*) ' number of nodes: ',number_of_nodes
	write(*,*) ' Zonenbreite_Angstroem: ',Zonenbreite_Angstroem
	write(*,*) ' log10(|J(i)|) :',log10abs
	write(*,*) ' calc_pathway_between_zones :', KMC_setup%calc_pathway_between_zones
	
	if(.not. (KMC_system%has_nodes .and. KMC_system%has_KMC_setup .and. KMC_system%has_grid .and. KMC_system%has_gro_data)) then
		write(*,*) 'There is not sufficient data supplied in KMC_system.'
		write(*,*) 'Error:  Can not start  load_dijkstra_kmc_network.'
		call exit(1) 
	endif
	
		box(1)= KMC_system%gro_data%x_box
		box(2)= KMC_system%gro_data%y_box
		box(3)= KMC_system%gro_data%z_box 
		box = box * nm2Ang
		write(*,*) 'Nutze Box: ',box(:)
		
		field(1) = KMC_system%KMC_setup%fieldX
		field(2) = KMC_system%KMC_setup%fieldY
		field(3) = KMC_system%KMC_setup%fieldZ
		write(*,*) 'Nutze Feld: ',field(:)
		i_field=0
		do i=1,3
			if( abs(field(i)) > casi_zero) then
				i_field=i
			end if
		enddo
		if( (i_field == 0 )) then
			write(*,*) 'Fehler: Es wurde kein Feld für die Auswahl der Ausrichtung der Wegrichtung ausgewählt.'
			call exit(1)
		endif
	
	! Position [m] -> Position [Angstroem]
	do i=1,KMC_system%number_of_nodes
		KMC_system%KMC_nodes(i)%position(:) = KMC_system%KMC_nodes(i)%position(:) * m2Ang
	enddo !i 
	
	!!-----  Write out all kmc nodes
	kmcnodefilename='tmp_kmc_nodes_system.xyz'
	OPEN(UNIT=21,FILE=TRIM(kmcnodefilename),STATUS='REPLACE',IOSTAT=ierror)
	write(21,*) KMC_system%number_of_nodes
	write(21,*) trim(kmcnodefilename),'  for  ',trim(KMC_setup%votca_sql_name)
	do i=1,KMC_system%number_of_nodes
		write(21,*) 'Au ',KMC_system%KMC_nodes(i)%position(:)
	enddo
	Close(21)
	!!-----  Write out all kmc nodes
	
	
	if (debug) write(*,*) "Punkte insgesamt: ", total_anzahl_knoten
	
	if( .not. calc_pathway_between_zones) then
		!! Anzahl der Verbindungen entspricht der Anzahl der Events
		total_anzahl_verbindungen=0
		do i=1,KMC_system%number_of_nodes
			total_anzahl_verbindungen = KMC_system%KMC_nodes(i)%event_size + total_anzahl_verbindungen
		enddo 

		if (debug) write(*,*) "Anzahl Verbindungen: ", total_anzahl_verbindungen
			Graph%total_anzahl_knoten = total_anzahl_knoten
			Graph%total_anzahl_verbindungen = total_anzahl_verbindungen
			Graph%shift_kosten = 0
		allocate(Graph%knoten(Graph%total_anzahl_knoten))
		
		do i=1, Graph%total_anzahl_knoten
			Graph%knoten(i)%id=i
			Graph%knoten(i)%name= TRIM(str(KMC_system%KMC_nodes(i)%id))//'_'//&
					  & TRIM(KMC_system%KMC_grid%hopping_site_list( KMC_system%KMC_nodes(i)%node_type_id ))
			Graph%knoten(i)%N_verbindungen = 0
			Graph%knoten(i)%hat_verbindungen =.false.
		enddo 
		if (debug) write(*,*) 'Knoten(1): ',TRIM(Graph%knoten(1)%name),' Knoten(max): ',TRIM(Graph%knoten(total_anzahl_knoten)%name)
		
		do i=1,total_anzahl_knoten
			seg1=KMC_system%KMC_nodes(i)%id
			punkt1=TRIM(str(seg1))//'_'//&
									  & TRIM(KMC_system%KMC_grid%hopping_site_list( KMC_system%KMC_nodes(i)%node_type_id ))
									  
			do j=1, KMC_system%KMC_nodes(i)%event_size
				
				seg2=KMC_system%KMC_nodes(i)%event(j)%destination
				punkt2 = TRIM(str(seg2))//'_'//&
									  &  TRIM(KMC_system%KMC_grid%hopping_site_list( KMC_system%KMC_nodes(seg2)%node_type_id ))
				verbindung_aktiv=.false.
				kosten = 0.0
				!! R = U /I   -> Suche Weg des minimale Widerstandes ~ 1 / I
				if( i_field == 0 ) then !! Gesamtstrom
					if( abs(KMC_system%KMC_nodes(i)%event(j)%current_norm) < casi_zero ) then
						kosten = 0.0  ! == unendlich
						verbindung_aktiv=.false.
					else
						if( .not. log10abs) then
							kosten = abs(1.0/KMC_system%KMC_nodes(i)%event(j)%current_norm)
							verbindung_aktiv=.true.
						else
							kosten = log10(abs(1.0/KMC_system%KMC_nodes(i)%event(j)%current_norm))
							verbindung_aktiv=.true.
						endif 
					endif
				else
					if( abs(KMC_system%KMC_nodes(i)%event(j)%current(i_field)) < casi_zero ) then
							kosten = 0.0  ! == unendlich
							verbindung_aktiv=.false.
					else
						if( .not. log10abs) then
							kosten = abs(field(i_field) / KMC_system%KMC_nodes(i)%event(j)%current(i_field))
							verbindung_aktiv=.true.
						else
							kosten = log10(abs(field(i_field) / KMC_system%KMC_nodes(i)%event(j)%current(i_field)))
							verbindung_aktiv=.true.
						endif
					endif
				endif ! i_field =0
				
				verbindung%id=0
				verbindung%punkt1=punkt1
				verbindung%punkt2=punkt2
				verbindung%kosten=kosten
				verbindung%aktiv=verbindung_aktiv
				if (debug) write(*,*) 'Add: ',TRIM(verbindung%punkt1), TRIM(verbindung%punkt2), verbindung%kosten
				call add_verbindung_to_knoten(Graph%knoten(seg1),verbindung)
				
			enddo ! number_of_neighbours
		end do ! total_anzahl_knoten
		
		
		!! Start index select by id. default: [start_Dijkstra = 1,ziel_Dijkstra =2]
		if( (0 < KMC_setup%start_Dijkstra) .and. ( KMC_setup%start_Dijkstra < total_anzahl_knoten)) then
			Startknoten = Graph%knoten(KMC_setup%start_Dijkstra)
		else
			write(*,*) ' Startindex außerhalb des zulässigen Bereiches [ 0, ',total_anzahl_knoten,']: ',KMC_setup%start_Dijkstra
			call exit(1)
		end if
		!! Start index select by id. default: [start_Dijkstra = 1,ziel_Dijkstra =2]
		if( (0 < KMC_setup%ziel_Dijkstra) .and. ( KMC_setup%ziel_Dijkstra < total_anzahl_knoten)) then
			Zielknoten = Graph%knoten(KMC_setup%ziel_Dijkstra)
		else
			write(*,*) ' Zielindex außerhalb des zulässigen Bereiches [ 0, ',total_anzahl_knoten,']: ',KMC_setup%ziel_Dijkstra
			call exit(1)
		end if
		
	endif ! not calc_pathway_between_zones
	
	
	!! tmp_check sprünge über Box in Feldrichtung.
	k=0
	do i=1,KMC_system%number_of_nodes
		if( KMC_system%KMC_nodes(i)%position(i_field) < Zonenbreite_Angstroem )then
			do j=1,KMC_system%KMC_nodes(i)%event_size
				seg2= KMC_system%KMC_nodes(i)%event(j)%destination 
				if(  abs(KMC_system%KMC_nodes(seg2)%position(i_field)) > (box(i_field)/2.0) ) then
					
					k=k+1
				endif
			enddo
		endif
	enddo
	
	
	if( i_field == 1) then !check
		write(*,*) 'tmp  Sprünge über box x0 --> x +box  k: ',k," pos:", KMC_system%KMC_nodes(1)%position(:)
	else if ( i_field == 2) then
		write(*,*) 'tmp  Sprünge über box y0 --> y +box  k: ',k," pos:", KMC_system%KMC_nodes(1)%position(:)
	else if ( i_field == 3) then
		write(*,*) 'tmp  Sprünge über box z0 --> z +box  k: ',k," pos:", KMC_system%KMC_nodes(1)%position(:)
	endif
	
	
	!! Definiere eine initiale Startzone für die Wege und dubliziere sie in Feldrichtung als Endzone als periodisches Bilder der Box. 
	!! Sprünge, die Über den Boxrand in die Startzone zeigen werden entfernt.
	if(calc_pathway_between_zones) then 
		write(*,*) ' --- START calc_pathway between zones  ---'
		
		write(*,*) 'number_of_nodes: ',number_of_nodes
		N_nodes_zone = 0
		N_nodes_mitte = 0
		N_umlengungen_mitte_ende = 0
		N_umlengungen_ende_ende = 0
		N_start_ende_delete = 0
		N_ende_start_delete = 0
		
		allocate(start_zone(number_of_nodes))
		allocate(mitte_zone(number_of_nodes))
		allocate(end_zone(number_of_nodes))
		
		do i=1, number_of_nodes
					if(   (KMC_system%KMC_nodes(i)%position(i_field) < Zonenbreite_Angstroem) .or. & !! Node in der Zonenbreite 
						& (KMC_system%KMC_nodes(i)%position(i_field) > box(i_field) ) ) then !! oder in PCB über die Box hinaus
						!! Addiere Knoten zur Zonenliste
						N_nodes_zone = N_nodes_zone + 1
						 
						start_zone(N_nodes_zone)  = KMC_system%KMC_nodes(i)
						end_zone(N_nodes_zone)    = KMC_system%KMC_nodes(i)
						!! Hochzählen der Node id
						end_zone(N_nodes_zone)%id = number_of_nodes + N_nodes_zone 
						
						!! Verschiebung in Boxrichtung
						if( end_zone(N_nodes_zone)%position(i_field) < box(i_field)/2.0 ) then
							end_zone(N_nodes_zone)%position(i_field) = end_zone(N_nodes_zone)%position(i_field) + box(i_field)
						endif
						if(debug) write(*,*) 'New Endzone id: ', end_zone(N_nodes_zone)%id,' pos: ',end_zone(N_nodes_zone)%position(:)
						
						
						!! Finde Events, die ueber die Box reichen aus der Startzone, und lösche diese
						delete_event_list=0
						k=0
						do event_id=1,start_zone(N_nodes_zone)%event_size
							seg2= start_zone(N_nodes_zone)%event(event_id)%destination
							if( abs(KMC_system%KMC_nodes(seg2)%position(i_field)) > box(i_field) /2.0) then
								
								k=k+1
								delete_event_list(k)=event_id
								if(debug) write(*,*) 'Case found event_id: ',event_id, 'pos:',KMC_system%KMC_nodes(seg2)%position(i_field)
							end if 
						enddo
						if( k > 0 ) then
							do event_id=k, 1, -1
								if(debug) write(*,*) ' Remove event from node: ',start_zone(N_nodes_zone)%id, 'delete id:',delete_event_list(event_id)
								if(debug) write(*,*) ' node%position: ',start_zone(N_nodes_zone)%position 
								seg2=start_zone(N_nodes_zone)%event(delete_event_list(event_id))%destination
								if(debug) write(*,*) ' Delete to target site: ',seg2,' at position y:', KMC_system%KMC_nodes(seg2)%position(i_field)
								CALL Node_removeEvent(start_zone(N_nodes_zone), delete_event_list(event_id))
								N_start_ende_delete = N_start_ende_delete +1
							enddo
						endif
						
						if(debug) write(*,*) 'Start Zone node id: ',start_zone(N_nodes_zone)%id,start_zone(N_nodes_zone)%position(i_field)," ",&
									& ' event_size: ', start_zone(N_nodes_zone)%event_size, end_zone(N_nodes_zone)%event_size
					else !! Mittelteil der großteil der Punkte liegt in der box
						N_nodes_mitte = N_nodes_mitte + 1
						mitte_zone(N_nodes_mitte) = KMC_system%KMC_nodes(i)
					endif !! in Zone?
		enddo 
		
		
		allocate(tmp_zone(N_nodes_zone))
		!! Definiere die Endzone
		tmp_zone(1:N_nodes_zone) = end_zone(1:N_nodes_zone)
		deallocate(end_zone)
		allocate(end_zone(N_nodes_zone))
		end_zone=tmp_zone
		
		!! Startzone 
		tmp_zone(1:N_nodes_zone) = start_zone(1:N_nodes_zone)
		deallocate(start_zone)
		allocate(start_zone(N_nodes_zone))
		start_zone=tmp_zone
		deallocate(tmp_zone)
		
		!! Mittezone 
		allocate(tmp_zone(N_nodes_mitte))
		tmp_zone(1:N_nodes_mitte) = mitte_zone(1:N_nodes_mitte)
		deallocate(mitte_zone)
		allocate(mitte_zone(N_nodes_mitte))
		mitte_zone=tmp_zone
		deallocate(tmp_zone)
		
		!! Umlenken der Sprünge innerhalb der Endzone
		write(*,*) '--- Start Umlenkung Endzone ---'
		do i=1,N_nodes_zone
			delete_event_list=0
			k=0
			
			event_loop: do event_id=1,end_zone(i)%event_size
				umgelenkt =.false.
				!! check ob in der startzone
				loop_j: do j=1,N_nodes_zone
					if( end_zone(i)%event(event_id)%destination == start_zone(j)%id ) then !! Liegt das zielsegment in der Startzone?
						!! Umlenkung in die Endzone 
						if(debug) write(*,*) end_zone(i)%event(event_id)%destination,' Umlenkung auf: ',end_zone(j)%id
						end_zone(i)%event(event_id)%destination  = end_zone(j)%id
						N_umlengungen_ende_ende = N_umlengungen_ende_ende + 1
						umgelenkt =.true.
						exit loop_j
					endif
				end do loop_j ! j 
			
			
				if( .not. umgelenkt ) then
					seg2= end_zone(i)%event(event_id)%destination
					!! Lösche Event, wenn die Target seg2 in der ersten Boxhälfte liegt: also im Mittelstück. 
					if( KMC_system%KMC_nodes(seg2)%position(i_field) < box(i_field)/2.0) then 
						k=k+1
						delete_event_list(k) = event_id
						if(debug) write(*,*) 'Delete Case found: ',event_id,'  diff pos: ', &
						& end_zone(i)%position(i_field)-KMC_system%KMC_nodes(seg2)%position(i_field),&
						& '  seg2 pos: ',KMC_system%KMC_nodes(seg2)%position(i_field)
						cycle event_loop
					end if 
				endif ! nicht umgelenkt?
			enddo event_loop ! event_id
			
			
			!! Lösche Events aus der Event_liste
			if( k > 0 ) then
					do event_id=k, 1, -1
						if(debug) write(*,*) 'Remove event from node ',end_zone(i)%id, ' delete id:', delete_event_list(event_id)
						CALL Node_removeEvent(end_zone(i), delete_event_list(event_id))
						N_ende_start_delete = N_ende_start_delete + 1
					enddo
			endif
			
		enddo ! i 
		write(*,*) '--- End Umlenkung Endzone ---'
		
		
		!! Umlenken der Boxmitte über die Box in die Endzone, wenn diese in die Startzone zeigt.
		write(*,*) '--- Start Umlenkung Mitte => Endzone ---'
		write(*,*)  'N_nodes_mitte: ',N_nodes_mitte
		N_umlengungen_mitte_ende =0
		do i=1,N_nodes_mitte
			!! Checke ob der Node im Mittelbereich über der Hälfte der Boxlänge liegt
			if( abs(mitte_zone(i)%position(i_field)) > box(i_field) /2.0) then
				event_loop_m: do event_id=1,mitte_zone(i)%event_size
						seg2= mitte_zone(i)%event(event_id)%destination
						!! Wenn ja, dann checke ob die id in der Startzone liegt, und lenke dann um in die Endzone.
						do j=1,N_nodes_zone
							if( seg2 == start_zone(j)%id ) then
									if(debug) write(*,*) 'Target aus der Mitte: ',mitte_zone(i)%id,' von Start',start_zone(j)%id,&
									&' Umlenkung auf Endzone: ',end_zone(j)%id
									mitte_zone(i)%event(event_id)%destination  = end_zone(j)%id
									N_umlengungen_mitte_ende = N_umlengungen_mitte_ende + 1 
							endif 
						enddo !j=1,N_nodes_zone
					
					
				enddo event_loop_m ! event_id
			else
				event_loop_mitte_vorn: do event_id=1,mitte_zone(i)%event_size
						seg2= mitte_zone(i)%event(event_id)%destination
						!! Wenn das erste Stück in der ersten Hälfte des Mittelstücks liegt und über PCB i
						do j=1,N_nodes_zone
							if( seg2 == start_zone(j)%id ) then
									if( abs( mitte_zone(i)%position(i_field) - start_zone(j)%position(i_field) ) > box(i_field) /2.0) then
										
									if(debug) write(*,*) 'Target aus der 1. Teil der Mitte: ',mitte_zone(i)%id,' von Start',start_zone(j)%id,&
									&' Umlenkung auf Endzone: ',end_zone(j)%id
									mitte_zone(i)%event(event_id)%destination  = end_zone(j)%id
									N_umlengungen_mitte_ende = N_umlengungen_mitte_ende + 1 
									write(*,*) KMC_system%KMC_nodes(i)%position(i_field) ,"<", box(i_field),i_field
									
									write(*,*) 'mitte id: ',i, ' position: ',KMC_system%KMC_nodes(i)%position(:)
									WRITE(*,*) 'ERROR CASE FOUND MITTE 1. Hälfte => END ZONE '
									WRITE(*,*) 'Are all hoppingsite centers inside the box.? '
									WRITE(*,*) 'This should not occure, or the conection should be deleted.'
									CALL EXIT(1)
									endif
							endif 
						enddo !j=1,N_nodes_zone
				enddo event_loop_mitte_vorn ! event_id
			endif !! check ueber der Boxmitte
		enddo ! i=1,N_nodes_mitte
		write(*,*) '--- End   Umlenkung Mitte => Endzone ---'
		
		write(*,*) '--- START ZONE ---'
		write(*,*) ( start_zone(i)%id, i=1, N_nodes_zone ,1) 
		write(*,*) '----------------------------------------'
		!! Vergleich alle Events im system
		n_events=0
		do i=1,number_of_nodes
			n_events= n_events + KMC_system%KMC_Nodes(i)%event_size 
		enddo
		write(*,*) 'N_events in total system: ',n_events
		
		!! Count events
		n_events=0
		do i=1,N_nodes_zone
			n_events = n_events + end_zone(i)%event_size
		enddo
		write(*,*) 'N_events ende : ',n_events
		j=0
		do i=1,N_nodes_zone
			n_events = n_events + start_zone(i)%event_size
			j = j + start_zone(i)%event_size 
		enddo
		write(*,*) 'N_events start: ',j
		j=0
		do i=1,N_nodes_mitte
			n_events = n_events + mitte_zone(i)%event_size
			j = j + mitte_zone(i)%event_size
		enddo
		write(*,*) 'N_events mitte: ',j
		
		write(*,*) 'N_events: ',n_events
		write(*,*) 'N_umlengungen_mitte_ende: ',N_umlengungen_mitte_ende
		write(*,*) 'N_umlengungen_ende_ende:  ',N_umlengungen_ende_ende
		write(*,*) 'N_start_ende_delete:      ',N_start_ende_delete
		write(*,*) 'N_ende_start_delete:      ',N_ende_start_delete
		
		
		write(*,*) 'N_nodes_start :',size(start_zone)
		write(*,*) 'N_nodes_mitte :',size(mitte_zone)
		write(*,*) 'N_nodes_end   :',size(end_zone)
		write(*,*) 'N_nodes_zone  :',N_nodes_zone
		write(*,*) ' ---  Initialisierung beendet von calc_pathway between zones  ---'
		
		!do i=1,N_nodes_zone
		!	write(*,*)  start_zone(i)%id,   end_zone(i)%id
		!enddo
		!write(*,*) '--- Mitte ---'
		!do i=1,N_nodes_mitte
		!	write(*,*)   mitte_zone(i)%id
		!enddo
		!write(*,*) '--- END Mitte ---'
		
		WRITE(*,*) ' --- Umwandlung der Zonen zum Graphen ---'
		total_anzahl_knoten = N_nodes_mitte + 2 * N_nodes_zone
		total_anzahl_verbindungen = n_events
		
		allocate(Graph%knoten(total_anzahl_knoten))
		Graph%total_anzahl_knoten = total_anzahl_knoten
		Graph%total_anzahl_verbindungen = 0
		Graph%shift_kosten = 0
		do i=1, Graph%total_anzahl_knoten
			Graph%knoten(i)%id=i
			Graph%knoten(i)%name=""
			Graph%knoten(i)%N_verbindungen = 0
			Graph%knoten(i)%hat_verbindungen =.false.
		enddo 
		if (debug) write(*,*) 'Knoten(1): ',TRIM(Graph%knoten(1)%name),' Knoten(max) ',TRIM(Graph%knoten(total_anzahl_knoten)%name)
		
		if(debug) then
			write(*,*) '--- tmp start ---'
			write(*,*) ' total_anzahl_knoten: ',total_anzahl_knoten
			do i=1,N_nodes_zone
				write(*,*) start_zone(i)%id,"  ",end_zone(i)%id
			enddo
			write(*,*) '--- tmp mitte ---'
			do i=1,size(mitte_zone)
				write(*,*) mitte_zone(i)%id
			enddo
			write(*,*) '--- tmp ende ---'
		endif !debug
		!! Punkte nach typname_Resid benennen der nummer des nodes benennen
		i=1
		j=1
		k=1
		do n = 1,  Graph%total_anzahl_knoten
			if( Graph%knoten(n)%id == start_zone(i)%id ) then
				Graph%knoten(n)%name = TRIM(str(start_zone(i)%id))//'_'//&
					  & TRIM(KMC_system%KMC_grid%hopping_site_list( start_zone(i)%node_type_id ))
				i = i + 1
			else if ( Graph%knoten(n)%id == mitte_zone(j)%id ) then
				Graph%knoten(n)%name = TRIM(str(mitte_zone(j)%id))//'_'//&
					  & TRIM(KMC_system%KMC_grid%hopping_site_list( mitte_zone(j)%node_type_id ))
				j = j + 1
			else if ( Graph%knoten(n)%id == end_zone(k)%id ) then
				Graph%knoten(n)%name = TRIM(str(end_zone(k)%id))//'_'//&
					  & TRIM(KMC_system%KMC_grid%hopping_site_list( end_zone(k)%node_type_id ))
				k = k + 1
			endif
		enddo
		write(*,*) 'start done. ',i-1
		write(*,*) 'mitte done. ',j-1
		write(*,*) 'ende  done. ',k-1
		
		if (debug) write(*,*) 'p(1): ',TRIM(Graph%knoten(1)%name),'  and  p(max): ',TRIM(Graph%knoten(n)%name)
		
		allocate(drei_zonen(total_anzahl_knoten)) 
		do i=1,number_of_nodes
			drei_zonen(i) = KMC_system%KMC_Nodes(i)
		enddo
 
		do i=1,N_nodes_zone
			drei_zonen(KMC_system%number_of_nodes+i) = end_zone(i)
		enddo 
		
		write(*,*) '--- nodes_to_netzwork ---'
		n = 0
		n =  events_to_netzwork(n, field, i_field, N_nodes_zone,  start_zone,  drei_zonen ,log10abs)
		n =  events_to_netzwork(n, field, i_field, N_nodes_mitte, mitte_zone,  drei_zonen ,log10abs)
		n =  events_to_netzwork(n, field, i_field, N_nodes_zone,    end_zone,  drei_zonen ,log10abs)
		
		write(*,*) 'Knoten: ',Graph%total_anzahl_knoten
		Graph%total_anzahl_verbindungen = count_Verbindungen_in_Graph(Graph)
		write(*,*) 'Anzahl Verbindungen: ',Graph%total_anzahl_verbindungen
		if(debug) write(*,*) 'N_Verbindungen: ',count_Verbindungen_in_Graph(Graph),' aktiv: ', count_aktive_Verbindungen_in_Graph(Graph)

		
		
		
		!! Setze Punkte für start und ziel in start_zone bzw. end_zone
		startpunkt_in_zone=.false.
		endpunkt_in_zone=.false.
		
		!! Start index select by id. default: [start_Dijkstra = 1,ziel_Dijkstra =2]
		if( (0 < KMC_setup%start_Dijkstra) .and. ( KMC_setup%start_Dijkstra < total_anzahl_knoten)) then
			Startknoten = Graph%knoten(KMC_setup%start_Dijkstra)
			write(*,*) 'Startknoten: ',TRIM(Startknoten%name),' id: ',Startknoten%id
		else
			write(*,*) ' Startindex außerhalb des zulässigen Bereiches [ 0, ',total_anzahl_knoten,']: ',KMC_setup%start_Dijkstra
			call exit(1)
		end if
		!! Start index select by id. default: [start_Dijkstra = 1,ziel_Dijkstra =2]
		if( (0 < KMC_setup%ziel_Dijkstra) .and. ( KMC_setup%ziel_Dijkstra < total_anzahl_knoten)) then
			Zielknoten = Graph%knoten(KMC_setup%ziel_Dijkstra)
			write(*,*) 'Zielknoten: ',TRIM(Zielknoten%name),' id: ',Zielknoten%id
		else
			write(*,*) ' Startindex außerhalb des zulässigen Bereiches [ 0, ',total_anzahl_knoten,']: ',KMC_setup%ziel_Dijkstra
			call exit(1)
		end if
		
		
		do i = 1, N_nodes_zone
			punkt1=TRIM(str(start_zone(i)%id))//'_'//&
					  & TRIM(KMC_system%KMC_grid%hopping_site_list( start_zone(i)%node_type_id ))
			if(  TRIM(ADJUSTL(punkt1)) == TRIM(ADJUSTL(Startknoten%name)) ) THEN
				startpunkt_in_zone=.true.
			endif
			punkt1=TRIM(str(end_zone(i)%id))//'_'//&
					  & TRIM(KMC_system%KMC_grid%hopping_site_list( end_zone(i)%node_type_id ))
			if(  TRIM(ADJUSTL(punkt1)) == TRIM(ADJUSTL(Zielknoten%name)) ) THEN
				endpunkt_in_zone=.true.
			endif
		enddo

		if( .not. startpunkt_in_zone  .or. (TRIM(KMC_setup%injectionmethod) == 'random' )) then
			call random_number(Harvest)
			i =  1 + int(Harvest * (N_nodes_zone-1))
			KMC_setup%start_Dijkstra=start_zone(i)%id
			Startknoten = Graph%knoten(start_zone(i)%id)
			write(*,*) 'Startknoten: ',TRIM(Startknoten%name),'  id: ',Startknoten%id
		endif


		if( .not. endpunkt_in_zone  .or. (TRIM(KMC_setup%injectionmethod) == 'random' )) then
			call random_number(Harvest)
			i =  1 + int(Harvest * (N_nodes_zone-1))
			KMC_setup%ziel_Dijkstra=end_zone(i)%id
			Zielknoten = Graph%knoten(end_zone(i)%id)
			write(*,*) 'Zielknoten: ',TRIM(Zielknoten%name),'  id: ',Zielknoten%id
		endif
		
		write(*,*) '----- END ZONE ids ------'
		if(debug) then
			write(*,*) ( "id: ",end_zone(i)%id ,"NN: ", end_zone(i)%event_size, i= 1, N_nodes_zone )
		else
			write(*,*) ( end_zone(i)%id , i= 1, N_nodes_zone )
		endif
		write(*,*) '-------------------------'
		!! Nehme all
	endif ! calc_pathway_between_zones
	
	
	
	!! log10abs:  Für beide Modi  calc_pathway_between_zones  und  normale Suche  .not. calc_pathway_between_zones
	
	!! Verschiebe alle Elemente, das log10(abs(R)) auch negative Werte liefert. 
	!! Diese sind im Dijkstra Algorithmus nicht Erlaubt. Die Verschiebung muss später korrigiert werden.
	if(log10abs)then
			shift_kosten=Graph%knoten(1)%verbindung(1)%kosten
			!! Suche minimale Wert
			do i=1, Graph%total_anzahl_knoten
				do j= 1, Graph%knoten(i)%N_verbindungen
					if(  Graph%knoten(i)%verbindung(j)%aktiv) then
						if( Graph%knoten(i)%verbindung(j)%kosten < shift_kosten ) then
							shift_kosten = Graph%knoten(i)%verbindung(j)%kosten
						endif 
					endif ! aktiv
				enddo ! N_verbindungen
			enddo ! knoten
			
			if( shift_kosten < 0.0 ) then
				!! Verschiebung
				do i=1, Graph%total_anzahl_knoten
					do j= 1, Graph%knoten(i)%N_verbindungen
						if(  Graph%knoten(i)%verbindung(j)%aktiv) then
							
							Graph%knoten(i)%verbindung(j)%kosten = abs(shift_kosten) + Graph%knoten(i)%verbindung(j)%kosten
							 
						endif ! aktiv
					enddo ! N_verbindungen
				enddo ! knoten
				write(*,*) 'Shift_kosten bei log10abs(R): ',shift_kosten
			else
				write(*,*) 'Kein shift bei log10abs(R), da  0.0 < ',shift_kosten,' shift_kosten.'
				shift_kosten = 0
			endif !  min_kosten < 0
			
			Graph%shift_kosten = shift_kosten
	endif ! log10abs -> Shift
	
	
	if(debug) then	!! tmp check
		write(*,*) '--- start -> mitte tmp check ---'
		do i=1,N_nodes_zone
			do j=1, start_zone(i)%event_size
				seg2=start_zone(i)%event(j)%destination
				do k=1,N_nodes_mitte
					if(  seg2 == mitte_zone(k)%id )then
						write(*,*) 'Start to mitte: ',start_zone(i)%id,mitte_zone(k)%id 
					endif
				enddo
			enddo
		enddo
		write(*,*) '######## Ende   start -> mitte #########'
		!! Check Start -> Ende
		write(*,*) '--- start -> end ---'
		do i=1,N_nodes_zone
			do j=1, start_zone(i)%event_size
				seg2=start_zone(i)%event(j)%destination
				do k=1,N_nodes_zone
					if(  seg2 == end_zone(k)%id )then
						write(*,*) 'start. ',start_zone(i)%id,'  =>  ',end_zone(k)%id,' End' 
					endif
				enddo
			enddo
		enddo
		write(*,*) '######## Ende   start -> end #########'
		
		!! tmp check
		write(*,*) '----- START tmp check          end -> mitte  -----'
		do i=1,N_nodes_zone
			do j=1, end_zone(i)%event_size
				seg2=end_zone(i)%event(j)%destination
				if(  seg2 < KMC_system%number_of_nodes )then
					write(*,*) 'End to mitte: ',end_zone(i)%id,KMC_system%KMC_nodes(seg2)%id
				endif
			enddo
		enddo
		!!
		write(*,*) '########  END tmp check         end -> mitte   ######## '
		
		
		!! tmp check
		write(*,*) '--- start tmp mitte -> ende ---'
		do i=1,N_nodes_mitte
			do j=1, mitte_zone(i)%event_size
				seg2=mitte_zone(i)%event(j)%destination
				do k=1,N_nodes_zone
					if(  seg2 == end_zone(k)%id )then
						write(*,*) ' mitte: ', mitte_zone(i)%id,' ende: ',  end_zone(k)%id
					endif
				enddo
			enddo
		enddo
		!!
		write(*,*) '--- end    tmp mitte -> ende ---'
	endif ! debug
	
	
	
	
	!! Gesamtkosten 
	kosten=0
	min_kosten=Graph%knoten(1)%verbindung(1)%kosten
	do i=1, Graph%total_anzahl_knoten
		do j=1,Graph%knoten(i)%N_verbindungen
			if(Graph%knoten(i)%verbindung(j)%aktiv) then
				if( Graph%knoten(i)%verbindung(j)%kosten < 0.0 ) then
					verbindung=Graph%knoten(i)%verbindung(j)
					write(*,*) TRIM(verbindung%punkt1),'  ',TRIM(verbindung%punkt2),verbindung%kosten,verbindung%aktiv
					write(*,*) 'Fehler: Negative Kosten sind nicht im Dijkstra algorithmus erlaubt.'
					call exit(1)
				end if
				kosten = kosten + Graph%knoten(i)%verbindung(j)%kosten
				if(debug) then
					write(*,*) TRIM(Graph%knoten(i)%verbindung(j)%punkt1),'  ',TRIM(Graph%knoten(i)%verbindung(j)%punkt2),&
					&'  ',Graph%knoten(i)%verbindung(j)%kosten
				endif ! debug ! Print Connections
			endif ! aktiv
		enddo ! N_verbindungen
	enddo ! total_anzahl_knoten
	
	N_aktive_verbindungen = count_aktive_Verbindungen_in_Graph(Graph)
	write(*,*) 'Summe der Kosten: ',kosten,'  für (aktive) Verbindungen: ',N_aktive_verbindungen
	
	if( abs(kosten) < 1.0E-3) then
		write(*,*) ' Fehler: Die Summe der Kostenfunktion ist zu gering < 1.0E-3, oder alle 0. Kosten: ',kosten
		write(*,*) ' Prüfe die Eingabedaten.'
		write(*,*) ' Ende'
		call exit(1)
	else if ( N_aktive_verbindungen == 0 ) then
		write(*,*) ' Fehler: Die Anzahl der aktiven Verbindungen im Graph ist null.'
		write(*,*) ' Ende'
		call exit(1)
	else if ( (Graph%total_anzahl_verbindungen == 0) .or. (count_Verbindungen_in_Graph(Graph) == 0)) then
		write(*,*) ' Fehler: Die Anzahl der aller Verbindungen im Graph ist null.'
		write(*,*) ' Ende'
		call exit(1)
	else if ( Graph%total_anzahl_knoten == 0 ) then
		write(*,*) ' Fehler: Die Anzahl der aller Knoten im Graph ist null.'
		write(*,*) ' Ende'
		call exit(1)
	endif
	
	
	
	return
end subroutine load_dijkstra_kmc_network

integer function events_to_netzwork(n, field, i_field, N_nodes_zone, zone, drei_zonen_nodes, log10abs )
		use small_functions
		use mod_dijkstra
		use KMC_class
		implicit none
		integer, intent (inout)          :: n
		real*8, dimension(3), intent(in) :: field
		integer, intent (in)             :: i_field, N_nodes_zone
		type(KMC_Node_t), dimension(N_nodes_zone):: zone
		type(KMC_Node_t), dimension(Graph%total_anzahl_knoten)::drei_zonen_nodes
		type(verbindung_d) :: verbindung
		character(len=50)  :: punkt1, punkt2
		real*8             :: kosten 
		logical            :: verbindung_aktiv
		integer :: seg1,seg2
		logical :: log10abs
		
		real*8  :: casi_zero=1.0D-20
		integer :: i,j
		
		!debug =.true.
		do i= 1, N_nodes_zone
			seg1=zone(i)%id
			punkt1=TRIM(str(seg1))//'_'//&
									  &  TRIM(KMC_system%KMC_grid%hopping_site_list( zone(i)%node_type_id ))
			! write(*,*) i,'seg1: ',seg1,'  punkt: ',TRIM(punkt),'   event_size: ',zone(i)%event_size
									  
			do j=1, zone(i)%event_size
				n=n+1
				kosten = 0.0  ! == unendlich
				verbindung_aktiv=.false.
				
				seg2=zone(i)%event(j)%destination
				punkt2 = TRIM(str(seg2))//'_'//&
									  &  TRIM(KMC_system%KMC_grid%hopping_site_list( drei_zonen_nodes(seg2)%node_type_id ))
				!write(*,*) 'seg2: ',seg2,' node_type_id: ',KMC_system%KMC_nodes(seg2)%node_type_id
				
				!! R = U /I   -> Suche Weg des minimale Widerstandes ~ 1 / I
				if( i_field == 0 ) then !! Gesamtstrom
					if( abs(zone(i)%event(j)%current_norm) < casi_zero ) then
						kosten = 0.0  ! == unendlich
						verbindung_aktiv=.false.
					else
						if(log10abs)then
							kosten = log10(abs(1.0/zone(i)%event(j)%current_norm))
							verbindung_aktiv=.true.
						else
							kosten = abs(1.0/zone(i)%event(j)%current_norm)
							verbindung_aktiv=.true.
						endif
					endif
				else
					if( abs(zone(i)%event(j)%current(i_field)) < casi_zero ) then
						kosten = 0.0  ! == unendlich
						verbindung_aktiv=.false.
					else
						if(log10abs) then
							kosten = log10(abs(field(i_field) / zone(i)%event(j)%current(i_field)))
							verbindung_aktiv=.true.
						else
							kosten = abs(field(i_field) / zone(i)%event(j)%current(i_field))
							verbindung_aktiv=.true.
						endif
					endif
				endif ! i_field =0
				
				verbindung%id=0
				verbindung%punkt1=punkt1
				verbindung%punkt2=punkt2
				verbindung%kosten=kosten
				verbindung%aktiv=verbindung_aktiv
				if(debug) write(*,*) 'Add: ',seg1,verbindung%punkt1, verbindung%punkt2, verbindung%kosten, verbindung%aktiv
				call add_verbindung_to_knoten(Graph%knoten(seg1),verbindung)
			enddo ! number_of_neighbours
		end do ! number_of_nodes
		write(*,*) 'events_to_netzwork added: ',n
		
		events_to_netzwork = n
end function events_to_netzwork


subroutine dijkstra_to_gro(Weg, Weg_kosten, WegSchritte, Gesamtkosten)
	use small_functions
	use mod_dijkstra
	use KMC_class
	implicit none
	character(len=50), allocatable, dimension(:) :: Weg
	real*8  :: Gesamtkosten
	real*8, allocatable, dimension (:)  :: Weg_kosten 
	integer :: WegSchritte
	integer :: WegKnoten
	
	real*8, allocatable, dimension (:)   :: log10_Weg_kosten,scale_Weg_kosten 
	real  ::min_kosten,max_kosten
	integer, allocatable, dimension(:) :: nodevisited_id
	logical, allocatable, dimension(:) :: nodevisited_end_zone
	Character(len=50):: string
	integer::seg1
	
	integer :: NAtoms
	real, allocatable, dimension(:,:) :: Koords
	logical :: unite_PBC_split_molecule
	
	type(gro_data_t) :: gro_data
	logical::read_reference_grofile
	logical::wrap_all_molecules_into_the_box
	!! print_gro_end_zone: Wird nur einmal auf .true. ausgeführt und dann nicht mehr -> Unten wird der Schalter auf false gesetzt
	logical :: print_gro_end_zone=.true.
	logical :: print_gro_start_zone=.true.
	character(500) :: gro_outputfile, gro_inputfile , R_linear_pathway_gro_outputfile, R_linear_pathway_pdbfile
	character(500) :: pathway_gro_outputfile, linear_pathway_gro_outputfile,  start_zone_gro_outputfile, end_zone_gro_outputfile
	character(500) :: Box_pathway_pdbfile
	real, dimension(3):: dr, koord,  last_position
	integer::i,j,l,k,ierror,count_atoms
	real*8, dimension(3) :: box
	real*8, dimension(3) :: nbox,abox
	integer::N_Atoms
	integer::N_visited_sites
	real, parameter:: nm2Ang=10.0,Ang2nm=0.1
	real ::alpha, beta
	logical:: print_R_patway_all_atoms
	integer::pdb_count_atoms
	
	
	unite_PBC_split_molecule= KMC_setup%unite_PBC_split_molecule
	wrap_all_molecules_into_the_box=KMC_setup%wrap_all_molecules_into_the_box
	read_reference_grofile=.true.
	!print_gro_end_zone=.true.
	!print_gro_start_zone=.true.
	!! Create a list with the costs for all atoms along the minimum resistance pathway.
	print_R_patway_all_atoms=.false.
	
	gro_outputfile=TRIM(make_tmp_readfilename("_"//TRIM(Startknoten%name)//"_"//TRIM(Zielknoten%name), &
								   & KMC_setup%gro_inputfile,KMC_setup%set_seed))
	pathway_gro_outputfile='pathway_'//TRIM(gro_outputfile(:LEN_TRIM(gro_outputfile)-4))//'_'//TRIM(Real8str(Gesamtkosten))//'.gro'
	Box_pathway_pdbfile='pathway_'//TRIM(gro_outputfile(:LEN_TRIM(gro_outputfile)-4))//'_'//TRIM(Real8str(Gesamtkosten))//'.pdb'
	
	linear_pathway_gro_outputfile='linear_'//trim(pathway_gro_outputfile)
	R_linear_pathway_gro_outputfile='R_'//trim(linear_pathway_gro_outputfile(:LEN_TRIM(linear_pathway_gro_outputfile)-4))//'.dat'
	R_linear_pathway_pdbfile='R_'//trim(linear_pathway_gro_outputfile(:LEN_TRIM(linear_pathway_gro_outputfile)-4))//'.pdb'
	start_zone_gro_outputfile='Start_zone_'//TRIM(gro_outputfile(:LEN_TRIM(gro_outputfile)-4))//'.gro'
	end_zone_gro_outputfile='End_zone_'//TRIM(gro_outputfile(:LEN_TRIM(gro_outputfile)-4))//'.gro'
	
	
	write(*,*) 'Start dijkstra_to_gro'
	IF(KMC_system%has_gro_data) THEN
		gro_data = KMC_system%gro_data
	ELSE
		IF(read_reference_grofile) THEN
				!!! grofile data read
				gro_inputfile=KMC_setup%gro_inputfile
				read_reference_grofile=KMC_setup%read_reference_grofile
				CALL  read_grofile_data(gro_data,KMC_setup)
				!! convert koord data
				!gro_data%koord=gro_data%koord*nm2Ang	
		
				!gro_data%x_box=gro_data%x_box  *nm2Ang
				!gro_data%y_box=gro_data%y_box  *nm2Ang
				!gro_data%z_box=gro_data%z_box  *nm2Ang
				!gro_data%koord_unit= 'Ang'
				
		END IF ! read_reference_grofile
	ENDIF ! has_gro_data
	
	write(*,*) 'wrap_all_molecules_into_the_box: ',wrap_all_molecules_into_the_box
	IF(wrap_all_molecules_into_the_box) THEN
					DO i=1,gro_data%N_Atoms
							dr=gro_data%koord(i,:)
							CALL position_PBC_correction(dr,gro_data%x_box,gro_data%y_box,gro_data%z_box)
							DO k=1,3
								gro_data%koord(i,k)=1.0*dr(k)
							END DO 
					END DO
	END IF ! wrap_all_molecules_into_the_box
	
	write(*,*) 'unite_PBC_split_molecule: ',unite_PBC_split_molecule
	IF(unite_PBC_split_molecule) then
					DO i=1, gro_data%N_Resids
						NAtoms=gro_data%R_u_I(i+1,2)-gro_data%R_u_I(i,2)
						if( allocated(Koords)) deallocate(Koords) 
						allocate(Koords(NAtoms,3))
						k=0
						DO j = gro_data%R_u_I(i,2), gro_data%R_u_I(i+1,2)-1
							k = k + 1
							Koords(k,1:3) = gro_data%koord(j,1:3)
						END DO
						!write(*,*) 'Resid: ', gro_data%R_u_I(i,1),' NAtoms: ',NAtoms
						CALL PBC_center_molecule(NAtoms,Koords,gro_data%x_box, gro_data%y_box, gro_data%z_box)
						k=0
						DO j = gro_data%R_u_I(i,2), gro_data%R_u_I(i+1,2)-1
							k = k + 1
							gro_data%koord(j,1:3) = Koords(k,1:3)
						ENDDO ! j=?
					ENDDO  ! i=?
	ENDIF ! unite_PBC_split_molecule
	
	!!! Cut the side chains in the gro_data 
	write(*,*) 'cut_side_chains_in_gro:  ',KMC_setup%cut_side_chains_in_gro
	IF(KMC_setup%cut_side_chains_in_gro .and. gro_data%has_side_chains) then
			call cut_side_chains(gro_data)
	END IF
	
	
	call update_KMC_system_gro_data(gro_data)
	
	
	
	WegKnoten = WegSchritte +1
	write(*,*) 'WegSchritte: ',WegSchritte,' WegKnoten: ',WegKnoten
	ALLOCATE(nodevisited_id(WegKnoten))
	ALLOCATE(nodevisited_end_zone(WegKnoten))
	
	if( .not. allocated(scale_Weg_kosten)) THEN
		ALLOCATE(scale_Weg_kosten(WegKnoten))
		ALLOCATE(log10_Weg_kosten(WegKnoten))
		do k=WegKnoten,1,-1
			if( abs(Weg_kosten(k)) < 1.0E-40 ) then
				if(k==1) then
					log10_Weg_kosten(k)=log10(Weg_kosten(2))
				else
					WRITE(*,*) 'Error, small costs encountered: ',abs(Weg_kosten(k))
					log10_Weg_kosten(k)=0.0
				endif
			else
				log10_Weg_kosten(k)=log10(Weg_kosten(k))
			endif
		enddo
		min_kosten=MINVAL(log10_Weg_kosten)
		max_kosten=MAXVAL(log10_Weg_kosten)
		do k=WegKnoten,1,-1
			scale_Weg_kosten(k)=(log10_Weg_kosten(k)-min_kosten)/(max_kosten-min_kosten)
		enddo
		write(*,*) 'log10 min_kosten: ',min_kosten,' max_kosten: ',max_kosten
		write(*,*) '      min_kosten: ',MINVAL(Weg_kosten),' max_kosten: ',MAXVAL(Weg_kosten)
	endif
	
	nodevisited_id=0
	nodevisited_end_zone = .false.
	do k= WegKnoten,1, -1
			string= TRIM(Weg(k)(1:(index(Weg(k),'_')-1)))
			!write(*,*) trim(string)
			READ (string, '(I12)',IOSTAT=ierror) seg1
			!write(*,*) 'seg1: ',seg1
			if( seg1 > KMC_system%number_of_nodes) then !! Korrektur für ids in der Extrazone
				do i=1,size(end_zone)
					if( end_zone(i)%id == seg1 ) then
						write(*,*) ' Setzte endzonen segment wieder zurück in die Startzone von ',seg1, ' auf ',start_zone(i)%id
						seg1 = start_zone(i)%id
						nodevisited_end_zone(k) = .true.
					endif
				enddo
			endif
			nodevisited_id(k) = seg1
	enddo

	
	write(*,*) ' Knoten: ',( nodevisited_id(k),nodevisited_end_zone(k) ,k = 1, WegKnoten)
	
	IF( read_reference_grofile .or. print_gro_end_zone .or. print_gro_start_zone ) THEN  !!! prepare box 
					box=0
					nbox=0
					abox(1)=gro_data%x_box
					abox(2)=gro_data%y_box
					abox(3)=gro_data%z_box
					
					
					if( abs(KMC_setup%fieldX) > 0.0 ) then
						box(1)=gro_data%x_box * sign(1.0D0,KMC_setup%fieldX)
					endif
					if( abs(KMC_setup%fieldY) > 0.0 ) then
						box(2)=gro_data%y_box * sign(1.0D0,KMC_setup%fieldY)
					endif
					if( abs(KMC_setup%fieldZ) > 0.0 ) then
					
						box(3)=gro_data%z_box * sign(1.0D0,KMC_setup%fieldZ)
					endif
	endif !!! prepare box 
					
	write(*,*) 'read_reference_grofile: ',read_reference_grofile
	IF(read_reference_grofile) THEN
				!! Determine number of atoms in new grofile  // Filter only visited sites
				N_Atoms=0
				count_atoms=0
				N_visited_sites=0
				do k=WegKnoten,1, -1
					do i=1,KMC_system%number_of_nodes
						IF ( nodevisited_id(k) == gro_data%R_u_I(i,1) ) THEN! select visited sites
							N_Atoms=N_Atoms+(gro_data%R_u_I(i+1,2)-gro_data%R_u_I(i,2))
							N_visited_sites=N_visited_sites+1
						ENDIF ! visited node ?
					enddo ! number_of_nodes
				end do 
					
				WRITE(*,*) 'N_Atoms: ',N_Atoms, '  N_visited_sites: ',N_visited_sites
				WRITE(*,*) ' Visited sites to the  grofile: '//TRIM(pathway_gro_outputfile)
				
				!! pdb file for the linear pathway with costs.
				OPEN(UNIT=15,FILE=TRIM(R_linear_pathway_pdbfile),STATUS='REPLACE',IOSTAT=ierror)
				Write(15,'("REMARK Author Name charge_transport_package")')
				Write(15,'(A6,3F9.3,A33)') "CRYST1",abox(1)*nm2Ang,abox(2)*nm2Ang,abox(3)*nm2Ang,"90.00  90.00  90.00 P 1        1"
515 format(a6, i5, a5, 1x, a3, 1x, a, i4, 4x, 3F8.3, 2F6.2)
				
				IF(print_R_patway_all_atoms) OPEN(UNIT=16,FILE=TRIM(R_linear_pathway_gro_outputfile),STATUS='REPLACE',IOSTAT=ierror)
				last_position=0
				!! gromacs linear pathway file
				OPEN(UNIT=17,FILE=TRIM(linear_pathway_gro_outputfile),STATUS='REPLACE',IOSTAT=ierror)
				WRITE(17,*) ''//TRIM(linear_pathway_gro_outputfile)
				WRITE(17,*) N_Atoms 
				WegSchritte_chain_loop: do k=WegKnoten,1,-1
					loop_nodes: do i=1,KMC_system%number_of_nodes
						
							IF ( nodevisited_id(k) == gro_data%R_u_I(i,1) ) THEN ! select visited sites
								j=gro_data%R_u_I(i,2)
								IF(k==WegKnoten)THEN ! default
									last_position(:) = gro_data%koord(j,:)
								ENDIF 
								!! update last position
								DO l=1,3  !l=x,y,z
									IF(      ( gro_data%koord(j,l) + nbox(l)*abox(l) - last_position(l) ) > (0.5*abox(l)) ) THEN
										nbox(l) = nbox(l) - 1 
									ELSE IF( ( gro_data%koord(j,l) + nbox(l)*abox(l) - last_position(l) ) < (-0.5*abox(l)) ) THEN
										nbox(l) = nbox(l) + 1 
									ENDIF
										last_position(l) = gro_data%koord(j,l) + nbox(l)*abox(l)
								ENDDO
								
								
								!!!IF(.not. nodevisited_end_zone(k)) THEN  
									DO j=gro_data%R_u_I(i,2),gro_data%R_u_I(i+1,2)-1 ! loop all index for atoms in molecule
										count_atoms= count_atoms +1 
										!Write(*,515) "ATOM  ", i, adjustR(atomname(i)), resname(i), chain(i), ires(i), x(i), y(i), z(i), alpha(i), beta(i)
										alpha=scale_Weg_kosten(k)
										beta=log10_Weg_kosten(k)
										Write(15,515) "ATOM  ",count_atoms, & 
													& adjustr(gro_data%atomsorte(j)),&
													& trim(adjustr(gro_data%residue_names(j))),'0',0, &  !!! gro_data%R_u_I(i,2),&
													&  nm2Ang*(gro_data%koord(j,1) + nbox(1)*abox(1)),  & 
													&  nm2Ang*(gro_data%koord(j,2) + nbox(2)*abox(2)),  & 
													&  nm2Ang*(gro_data%koord(j,3) + nbox(3)*abox(3)),  &
													&  alpha,beta

										
										IF(print_R_patway_all_atoms) WRITE(16,*) Weg_kosten(k)
										WRITE(17,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) gro_data%residue_numbers(j),&
													& gro_data%residue_names(j),&
													& adjustr(gro_data%atomsorte(j)),&
													&  gro_data%atom_numbers(j),&
													&  gro_data%koord(j,1) + nbox(1)*abox(1),  & 
													&  gro_data%koord(j,2) + nbox(2)*abox(2),  & 
													&  gro_data%koord(j,3) + nbox(3)*abox(3),  &
													&  gro_data%vel(j,1),   gro_data%vel(j,2),   gro_data%vel(j,3)

										IF(ierror > 0) THEN
											WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(pathway_gro_outputfile),' aufgetreten.'
										END IF !ierror
										if(j == gro_data%R_u_I(i+1,2)-1 ) exit loop_nodes
									END DO ! j 
								!!!ENDIF ! nodevisited_end_zone
							END IF ! visited node ?
						enddo loop_nodes ! number_of_nodes
					enddo WegSchritte_chain_loop ! WegSchritte
					
					write(15,'("END")')
					Close(15)
					
					WRITE(17,'(3f8.3)',IOSTAT=ierror) gro_data%x_box, gro_data%y_box, gro_data%z_box
					IF(ierror > 0) THEN
							WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(linear_pathway_gro_outputfile),' aufgetreten.'
					END IF
					WRITE(*,*) ' New gro file created: '//TRIM(linear_pathway_gro_outputfile)//'   for   '//TRIM(KMC_setup%xyz_trajectoryfilename)
					CLOSE(17)
					
					
					
					!!! grofile data in the box
					OPEN(UNIT=18,FILE=TRIM(pathway_gro_outputfile),STATUS='REPLACE',IOSTAT=ierror)
					
					!! Output GROMACS DATEI *.gro
					WRITE(18,*) ''//TRIM(pathway_gro_outputfile)
					WRITE(18,*) N_Atoms 
					do i=1,KMC_system%number_of_nodes
						WegSchritte_loop: do k=1, WegKnoten
							IF ( nodevisited_id(k) == gro_data%R_u_I(i,1) ) THEN ! select visited sites
								IF(.not. nodevisited_end_zone(k)) THEN  
									DO j=gro_data%R_u_I(i,2),gro_data%R_u_I(i+1,2)-1 ! loop all index for atoms in molecule
										WRITE(18,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) gro_data%residue_numbers(j),&
													& gro_data%residue_names(j),&
													& adjustr(gro_data%atomsorte(j)),&
													& gro_data%atom_numbers(j),&
													& gro_data%koord(j,1), gro_data%koord(j,2), gro_data%koord(j,3), &
													& gro_data%vel(j,1),   gro_data%vel(j,2),   gro_data%vel(j,3)
										
										IF(ierror > 0) THEN
											WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(pathway_gro_outputfile),' aufgetreten.'
										END IF !ierror
										if(j == gro_data%R_u_I(i+1,2)-1 ) exit WegSchritte_loop
									END DO ! j 
								ENDIF ! nodevisited_end_zone
							END IF ! visited node ?
						enddo WegSchritte_loop ! WegSchritte
					enddo ! number_of_nodes
									
									
					!! Output GROMACS DATEI 
					!! END ZONE
					do i=1,KMC_system%number_of_nodes
						WegSchritte_loop_2: do k=1, WegKnoten
							IF ( nodevisited_id(k) == gro_data%R_u_I(i,1) ) THEN ! select visited sites
								DO j=gro_data%R_u_I(i,2),gro_data%R_u_I(i+1,2)-1 ! loop all index for atoms in molecule
									!atom_numbers(j)=mod(j,100000)
									IF(nodevisited_end_zone(k)) THEN  !! END ZONE
										
										do l=1,3
											if( gro_data%koord(j,l) > box(l)/2 ) then
												koord(l) =  gro_data%koord(j,l)
											else
												koord(l) =  Real(gro_data%koord(j,l),4) + Real(box(l),4) 
											endif
										enddo
										!!! Wenn das Hopping-Site in der Endzone / außerhalb der Box liegt,
										!!! dann müssen die Koordinaten in Feldrichtung um eine Boxlänge verschoben werden
												string= TRIM(Weg(k)(1:(index(Weg(k),'_')-1)))   !!! segment id
												READ (string, '(I12)',IOSTAT=ierror) seg1
												string= TRIM(Weg(k)((index(Weg(k),'_')+1):LEN_TRIM(Weg(k))))  !!! Resname 
												WRITE(18,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror) seg1, &
												& string,&
												& adjustr(gro_data%atomsorte(j)),&
												& gro_data%atom_numbers(j),&
												& koord(1),koord(2),koord(3),&  !gro_data%koord(j,1)+box(1), gro_data%koord(j,2)+box(2), gro_data%koord(j,3)+box(3),&
												& gro_data%vel(j,1),   gro_data%vel(j,2),   gro_data%vel(j,3)
									IF(ierror > 0) THEN
										WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(pathway_gro_outputfile),' aufgetreten.'
									END IF !ierror
									if(j == gro_data%R_u_I(i+1,2)-1 ) exit WegSchritte_loop_2
									END IF
								END DO ! j 
							END IF ! visited node ?
						enddo WegSchritte_loop_2 ! WegSchritte
					enddo ! number_of_nodes
					
					WRITE(18,'(3f8.3)',IOSTAT=ierror) gro_data%x_box, gro_data%y_box, gro_data%z_box
					IF(ierror > 0) THEN
							WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(pathway_gro_outputfile),' aufgetreten.'
					END IF
					WRITE(*,*) ' New gro file created: '//TRIM(pathway_gro_outputfile)//'   for   '//TRIM(KMC_setup%xyz_trajectoryfilename)
					CLOSE(18)
					
					
					
					
					

				
				
					!!_______________________________________________________________________!!!
					!!                     pdb in box  START
					!!_______________________________________________________________________!!!
					pdb_count_atoms=0
					!! pdb file for the pathway with costs inside the first box!
					OPEN(UNIT=14,FILE=TRIM(Box_pathway_pdbfile),STATUS='REPLACE',IOSTAT=ierror)
					Write(14,'("REMARK Author Name charge_transport_package")')
					Write(14,'(A6,3F9.3,A33)') "CRYST1",abox(1)*nm2Ang,abox(2)*nm2Ang,abox(3)*nm2Ang,"90.00  90.00  90.00 P 1        1"
					
					do i=1,KMC_system%number_of_nodes
						WegSchritte_loop_pdb: do k=WegKnoten,1,-1
							IF ( nodevisited_id(k) == gro_data%R_u_I(i,1) ) THEN ! select visited sites
								IF(.not. nodevisited_end_zone(k)) THEN  
									DO j=gro_data%R_u_I(i,2),gro_data%R_u_I(i+1,2)-1 ! loop all index for atoms in molecule
									
										pdb_count_atoms= pdb_count_atoms +1 
										!Write(*,515) "ATOM  ", i, adjustR(atomname(i)), resname(i), chain(i), ires(i), x(i), y(i), z(i), alpha(i), beta(i)
										alpha=scale_Weg_kosten(k)
										beta=log10_Weg_kosten(k)
										Write(14,515) "ATOM  ",pdb_count_atoms, & 
													& adjustr(gro_data%atomsorte(j)),&
													& trim(adjustr(gro_data%residue_names(j))),'0',0, &  !!! gro_data%R_u_I(i,2),&
													&  nm2Ang*gro_data%koord(j,1) ,  & 
													&  nm2Ang*gro_data%koord(j,2) ,  &
													&  nm2Ang*gro_data%koord(j,3) , alpha,beta								
										
										IF(ierror > 0) THEN
											WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(Box_pathway_pdbfile),' aufgetreten.'
										END IF !ierror
										if(j == gro_data%R_u_I(i+1,2)-1 ) exit WegSchritte_loop_pdb
									END DO ! j 
								ENDIF ! nodevisited_end_zone
							END IF ! visited node ?
						enddo WegSchritte_loop_pdb ! WegSchritte_loop_pdb
					enddo ! number_of_nodes
									
									
					!! Output GROMACS DATEI 
					!! END ZONE
					do i=1,KMC_system%number_of_nodes
						WegSchritte_loop_pdb_2: do k=1, WegKnoten
							IF ( nodevisited_id(k) == gro_data%R_u_I(i,1) ) THEN ! select visited sites
								alpha=scale_Weg_kosten(k)
								beta=log10_Weg_kosten(k)
								DO j=gro_data%R_u_I(i,2),gro_data%R_u_I(i+1,2)-1 ! loop all index for atoms in molecule
									IF(nodevisited_end_zone(k)) THEN  !! END ZONE
										do l=1,3
											if( gro_data%koord(j,l) > box(l)/2 ) then
												koord(l) =  gro_data%koord(j,l)
											else
												koord(l) =  Real(gro_data%koord(j,l),4) + Real(box(l),4) 
											endif
										enddo
										!!! Wenn das Hopping-Site in der Endzone / außerhalb der Box liegt,
										!!! dann müssen die Koordinaten in Feldrichtung um eine Boxlänge verschoben werden
										string= TRIM(Weg(k)(1:(index(Weg(k),'_')-1)))   !!! segment id
										READ (string, '(I12)',IOSTAT=ierror) seg1
										string= TRIM(Weg(k)((index(Weg(k),'_')+1):LEN_TRIM(Weg(k))))  !!! Resname 
										pdb_count_atoms= pdb_count_atoms +1 

										Write(14,515) "ATOM  ",pdb_count_atoms, & 
													& adjustr(gro_data%atomsorte(j)),&
													& trim(adjustr(string)),'0',0, &  
													&  nm2Ang*koord(1),  & 
													&  nm2Ang*koord(2),  &
													&  nm2Ang*koord(3), alpha,beta								
									IF(ierror > 0) THEN
										WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(Box_pathway_pdbfile),' aufgetreten.'
									END IF !ierror
									if(j == gro_data%R_u_I(i+1,2)-1 ) exit WegSchritte_loop_pdb_2
									END IF
								END DO ! j 
							END IF ! visited node ?
						enddo WegSchritte_loop_pdb_2 ! WegSchritte_loop_pdb_2
					enddo ! number_of_nodes
					IF(ierror > 0) THEN
							WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(Box_pathway_pdbfile),' aufgetreten.'
					END IF
					WRITE(*,*) ' New gro file created: '//TRIM(Box_pathway_pdbfile)//'   for   '//TRIM(KMC_setup%xyz_trajectoryfilename)
					CLOSE(14)
					
					!!_______________________________________________________________________!!!
					!!                     pdb in box  Ende
					!!_______________________________________________________________________!!!
	ENDIF !!! read_reference_grofile
	
	
	
	
	!! Write out only all atoms in the End Zone.
	write(*,*) 'print_gro_end_zone: ',print_gro_end_zone
	IF(print_gro_end_zone) then
					
					!! Output GROMACS DATEI 
					
					!! Determine number of atoms in the end zone
					N_Atoms=0
					N_visited_sites=0
					do k=1,size(end_zone(:))
						do i=1,KMC_system%number_of_nodes
							IF ( start_zone(k)%id == gro_data%R_u_I(i,1) ) THEN ! select visited sites
								N_Atoms=N_Atoms+(gro_data%R_u_I(i+1,2)-gro_data%R_u_I(i,2))
								N_visited_sites=N_visited_sites+1
							ENDIF ! visited node ?
						enddo ! number_of_nodes
					end do 
					
					WRITE(*,*) 'End Zone: N_Atoms: ',N_Atoms, '  N_visited_sites: ',N_visited_sites

					OPEN(UNIT=19,FILE=TRIM(end_zone_gro_outputfile),STATUS='REPLACE',IOSTAT=ierror)
					if(debug) WRITE(*,*) ' All atom in the end zone grofile: '//TRIM(end_zone_gro_outputfile)
					WRITE(19,*) ''//TRIM(end_zone_gro_outputfile)
					WRITE(19,*) N_Atoms 
					!! END ZONE
					do i=1,KMC_system%number_of_nodes
						end_zone_loop: do k=1, size(end_zone)
							IF( start_zone(k)%id == gro_data%R_u_I(i,1) )THEN ! select visited sites
								DO j=gro_data%R_u_I(i,2),gro_data%R_u_I(i+1,2)-1 ! loop all index for atoms in molecule
									!atom_numbers(j)=mod(j,100000)
									
									!!! Wenn das Hopping-Site in der Endzone / außerhalb der Box liegt,
									!!! dann müssen die Koordinaten in Feldrichtung um eine Boxlänge verschoben werden
										do l=1,3
											if( gro_data%koord(j,l) > box(l)/2 ) then
												koord(l) =  gro_data%koord(j,l)
											else
												koord(l) =  Real(gro_data%koord(j,l),4) + Real(box(l),4) 
											endif
										enddo
										
										WRITE(19,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror)  &
										& end_zone(k)%id, &
										& end_zone(k)%node_name,&
										& adjustr(gro_data%atomsorte(j)),&
										& gro_data%atom_numbers(j),&
										& koord(1),& !!gro_data%koord(j,1) + box(1),&
										& koord(2),& !!gro_data%koord(j,2) + box(2),&
										& koord(3),& !!gro_data%koord(j,3) + box(3),&
										& gro_data%vel(j,1),   gro_data%vel(j,2),   gro_data%vel(j,3)
										IF(ierror > 0) THEN
											WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(end_zone_gro_outputfile),' aufgetreten.'
										END IF !ierror
										if(j == gro_data%R_u_I(i+1,2)-1 ) exit end_zone_loop
									
								END DO ! j 
							END IF ! visited node ?
						enddo end_zone_loop 
					enddo ! number_of_nodes
		
		
		
			WRITE(19,'(3f8.3)',IOSTAT=ierror) gro_data%x_box, gro_data%y_box, gro_data%z_box
			CLOSE(19)
		IF(ierror > 0) THEN
			WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(end_zone_gro_outputfile),' aufgetreten.'
		END IF
		WRITE(*,*) ' End_zone_gro_file created: '//TRIM(end_zone_gro_outputfile)//'   for   '//TRIM(KMC_setup%xyz_trajectoryfilename)
		print_gro_end_zone=.false.
	ENDIF


	!! Write out only all atoms in the Start Zone.
	write(*,*) 'print_gro_start_zone: ',print_gro_start_zone
	IF(print_gro_start_zone) then
		!! Output GROMACS DATEI 
					!! Determine number of atoms in the end zone
					N_Atoms=0
					N_visited_sites=0
					do k=1,size(start_zone(:))
						do i=1,KMC_system%number_of_nodes
							IF ( start_zone(k)%id == gro_data%R_u_I(i,1) ) THEN ! select visited sites
								N_Atoms=N_Atoms+(gro_data%R_u_I(i+1,2)-gro_data%R_u_I(i,2))
								N_visited_sites=N_visited_sites+1
							ENDIF ! visited node ?
						enddo ! number_of_nodes
					end do 
					
					if(debug) WRITE(*,*) 'Start Zone: N_Atoms: ',N_Atoms, '  N_visited_sites: ',N_visited_sites
					OPEN(UNIT=20,FILE=TRIM(start_zone_gro_outputfile),STATUS='REPLACE',IOSTAT=ierror)
					if(debug) WRITE(*,*) ' All atom in the start zone grofile: '//TRIM(start_zone_gro_outputfile)
					WRITE(20,*) ''//TRIM(start_zone_gro_outputfile)
					WRITE(20,*) N_Atoms 
					!! END ZONE
					do i=1,KMC_system%number_of_nodes
						start_zone_loop: do k=1, size(end_zone)
							IF( start_zone(k)%id == gro_data%R_u_I(i,1) )THEN ! select visited sites
								DO j=gro_data%R_u_I(i,2),gro_data%R_u_I(i+1,2)-1 ! loop all index for atoms in molecule
									!atom_numbers(j)=mod(j,100000)
									
									!!! Wenn das Hopping-Site in der Endzone / außerhalb der Box liegt,
									!!! dann müssen die Koordinaten in Feldrichtung um eine Boxlänge verschoben werden
										do l=1,3
											if( gro_data%koord(j,l) > box(l)/2 ) then
												koord(l) =  Real(gro_data%koord(j,l),4) - Real(box(l),4)
											else
												koord(l) =  gro_data%koord(j,l)  
											endif
										enddo
										
										WRITE(20,'(i5,2a5,i5,3f8.3,3f8.4)',IOSTAT=ierror)  &
										& start_zone(k)%id, &
										& start_zone(k)%node_name,&
										& adjustr(gro_data%atomsorte(j)),&
										& gro_data%atom_numbers(j),&
										& koord(1),& !!gro_data%koord(j,1) + box(1),&
										& koord(2),& !!gro_data%koord(j,2) + box(2),&
										& koord(3),& !!gro_data%koord(j,3) + box(3),&
										& gro_data%vel(j,1),   gro_data%vel(j,2),   gro_data%vel(j,3)
										IF(ierror > 0) THEN
											WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(start_zone_gro_outputfile),' aufgetreten.'
										END IF !ierror
										if(j == gro_data%R_u_I(i+1,2)-1 ) exit start_zone_loop
									
								END DO ! j 
							END IF ! visited node ?
						enddo start_zone_loop 
					enddo ! number_of_nodes
					WRITE(20,'(3f8.3)',IOSTAT=ierror) gro_data%x_box, gro_data%y_box, gro_data%z_box
			IF(ierror > 0) THEN
				WRITE(*,*) 'Error: Es ist eine Fehler beim Schreiben von ',TRIM(start_zone_gro_outputfile),' aufgetreten.'
			END IF
			WRITE(*,*) ' Start_zone_gro_file created: '//TRIM(start_zone_gro_outputfile)//&
						 &'   for   '//TRIM(KMC_setup%xyz_trajectoryfilename)
			CLOSE(20)
		print_gro_start_zone=.false.
	ENDIF

end subroutine dijkstra_to_gro



	!! Modify the node positions to those read from xyz_inputfile
	subroutine update_KMC_system_nodes_positions_xyz(nodes,xyz_inputfile)
		!! Subroutine which replaces the hopping site positions by those read from an external xyz_inputfile
		type (KMC_Node_t), allocatable, dimension(:), intent(inout)::nodes
		character(500), intent(in) :: xyz_inputfile
		
		Real, ALLOCATABLE, Dimension(:,:)         :: koordA
		Character(5), ALLOCATABLE, DIMENSION(:)   :: atomsorteA
		REAL, PARAMETER :: Ang2m=1.0E-10, m2Ang=1.0E10
		integer  ::i,j,NN,NAtoms
		
		WRITE(*,*) 'Read new node positions from: ',trim(xyz_inputfile)
		NN=size(nodes)
		CALL Read_coord_from_xyz(atomsorteA,koordA,xyz_inputfile)
		NAtoms=size(atomsorteA)
		if( NN == NAtoms ) then
			
			koordA = koordA * Ang2m
			do i=1,KMC_system%number_of_nodes
				do j=1,3
					KMC_system%KMC_nodes(i)%position(j) = koordA(i,j)
				enddo
			enddo !i 
		else
			WRITE(*,*) 'Error: The number of nodes does not match the number of centers in the inputfile: '//trim(xyz_inputfile)
			CALL EXIT(1)
		endif
		
	end subroutine update_KMC_system_nodes_positions_xyz


END PROGRAM main

!! ---------------  ENDE DES DIJKSRA HAUPTPROGRAMMS ------------------ !!



!program main
!	use Dijkstra_types
!	use Dijkstra_functions
!	implicit none
!	call shortway
!end program main
