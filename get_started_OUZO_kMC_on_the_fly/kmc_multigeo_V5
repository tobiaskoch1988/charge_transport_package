#!/usr/bin/python
# @author Jim Bachmann, t_koch08
# modifiziert t_koch08: kmc_multigeo_V1: kmc_rechnung mit wechselnder Grundgeometrie, (Einlesen der Startdaten aus einer sim_data_12N/multigeo_kmc.dat Datei)
# _V2 adapted marcus rate (E-lambda), get lambda_in for el and hole, intramolecular charge transfer between 1mer-1mer for electron and holes parametrized. (01.02.2017)
# Skalierung und Fit(COM,MMA,MA,Lin_Combi) |J_AB|   
# _V3 random_insertion of charges, calculate mobility otf and use mobility convergence croterion
# _V4 usage for PPDI, PBDT-TS1,HDI
# _V4 internal queuing system for threads (number_of_parallel_thread=x) that execute subprocesses for DIPRO, lambda_in, lambda_out.
# _V4 calculate many trajectories in parallel, if startet with gnu parallel (flags -NGeo, -U_ext).
# _V5 calculate DIPRO list from distances.ngh and exclude recalculation of data, if pairs are available in the J_AB reference file.
##### this algorith uses the VSSM and FRM to simulate charge dynamics in a DIPBI P3HT blend
##### with on the fly marcus rate evaluation
import random, numpy as np, sys, subprocess, shlex, os, logging, Queue
import pdb # debugger
import thread
import threading
from threading import Timer
import time
from os import listdir
import signal, psutil
NGeo=1
print 'Inputline: '+str(sys.argv[:])
if 1==1:																									#check the input
	SCRIPT=sys.argv[0].split('/')
	NARGS=len(sys.argv)-1
	THELP=['-h','-help']

	if NARGS<5 or (NARGS>0 and sys.argv[1] in THELP):
		print""
		print"parameterexpected:",SCRIPT[len(SCRIPT)-1],
		print" expected: [distances.ngh] [COM.xyz] [morphology.gro] [debug = True/False] [lambda_out_neighbour_list] optional: [old matrix elem List] [old hole matrix elem List]"
		print" example: kmc_otf sorted_neighbours.ngh no_box.xyz indexed.gro False lambda_out_neighbour_list.ngh matrixList.ngh hole_matrixList.ngh"
		print""
		sys.exit(0)

	if (sys.argv[1][-4:] != ".ngh"):
		print""
		print" wrong input format"
		print" expected: [distances.ngh] [COM.xyz] [morphology.gro]"
		print""
		sys.exit(0)

	if (sys.argv[2][-4:] != ".xyz"):
		print""
		print" wrong input format"
		print" expected: [distances.ngh] [COM.xyz] [morphology.gro]"
		print""
		sys.exit(0)

	if (sys.argv[3][-4:] != ".gro"):
		print""
		print" wrong input format"
		print" expected: [distances.ngh] [COM.xyz] [morphology.gro]"
		print""
		sys.exit(0)
	# check if files exist
	for s in range(1,4): # check files 1-3
		if not os.path.isfile(sys.argv[s]):
			print" file does not exist: "+str(sys.argv[s])
			print" expected: [distances.ngh] [COM.xyz] [morphology.gro]"	
			sys.exit(0)
	read_NGeo= False
	read_U_ext=False
	if (NARGS > 5):
		for s in range(5,NARGS): # check files 5-NARGS
			#print s
			#print sys.argv[s]
			### check the geometry flag -NGeo ; NGeo numbers different trajetories with distinct initial starting positions.
			### check the external voltage flag -U_ext real_number in x direction.
			if ( (read_NGeo and read_U_ext) or str(sys.argv[s]) == '' ): 				
				pass
    			elif( str(sys.argv[s]) == '-NGeo'):
				NGeo=sys.argv[s+1]
				print 'NGeo: '+str(NGeo)
				read_NGeo= True
				### resets system arguments, as the flag was read.
				sys.argv[s]=''
				sys.argv[s+1]=''
        			pass
			elif (read_U_ext): 				
				pass
			elif (str(sys.argv[s]) == '-U_ext'):
				print 'U=',sys.argv[s],sys.argv[s+1]
				U_ext=float(sys.argv[s+1])
				print 'U_ext: '+str(U_ext)
				read_U_ext= True
				### resets system arguments, as the flag was read.
				sys.argv[s]=''
				sys.argv[s+1]=''
				pass
			elif not os.path.isfile(sys.argv[s]):
				print" file does not exist: "+str(sys.argv[s])
				print" expected: [distances.ngh] [COM.xyz] [morphology.gro] optional: [debug = True/False] [lambda_out_neighbour_list.ngh] [old matrix elem List.dat] [old hole matrix elem List.dat]"
				print" use flags: -NGeo 1 -U_ext 0.001 "
				sys.exit(0)
		if (sys.argv[5][-4:] != ".ngh") and (sys.argv[6][-4:] != ".dat") and (sys.argv[7][-4:] != ".dat"):
			print""
			print" wrong input format"
			print" expected: [distances.ngh] [COM.xyz] [morphology.gro] optional: [debug = True/False] [lambda_out_neighbour_list.ngh] [old matrix elem List.dat] [old hole matrix elem List.dat]"
			print""

# input
neighbours_in=open(sys.argv[1])
COM_in=open(sys.argv[2])
GRO_in=open(sys.argv[3])

		
########################## input parameters ####################################
### select the system molecule type 
DIPBI_P3HT = True
PPDI_PBDT_TS1 = False
HDI = False
TDI = False
PtK2K = False
PtK3K = False
mCP = False
NPB = False
Alq3 = False
## number of KMC steps: limits the maximum number of kMC-steps in the simulation default: number_of_steps = 1.0E7
number_of_steps = 1
## print xyz to disk after buffered_traj_out_steps only
buffered_traj_out_steps=10000
#### Voltage [V/Angstrom]
U=np.asarray([0,0,0.0001]) ### U_Array_zu_ersetzen
##### Read old occupied_list, charge_type_list, tau_i from file
read_multigeo_old = False  
### sets the charges to random resids in the box as initial guess 
### (neglects settings in the occupied_list charge_type_list) , [default = False]
random_charge_insertion = False
## Number of charges in the kMC simulation
N_charges=4  ###10
## set occupied spaces
## must match length of the charge type list
######occupied_list=[9000,9900,900,90,999,9001,9901,901,91,991]
occupied_list=[366,412,456,371] ###[0,1,2,3,4,5,366,412,456,371]
## set charge carries types e.g. holes/electrons
## must match length of the occupied list
charge_type_list =['hole','hole','hole','hole'] ###['hole','hole','hole','hole','hole','hole','hole','hole','hole','hole'] ####['hole','hole','hole','hole','hole','electron','electron','electron','electron','electron']
## Datenfile fuer die DIPRO-Methode, bereits berechnete Werte
DIPRO_J_AB_datafile='./subroutines/Datenauswertung_SAB_H_H0_Jab_H0_H0_SAB_L0_L0_Jab_L0_L0_G0.dat'
### use g09 or dftb+ to calculate |J_AB| with DIPRO (default = sub_g09) DIPRO_programm=['sub_g09'/'sub_dftb+']
DIPRO_programm='sub_g09' ##'sub_dftb+'
#### maximum time to wait, till a calculation is finised and start a resubmission in [s] default: time_count == 31
time_count_max=901 # 901 = 15min
### time till resubmission
time_count_resubmit=601
### select intramolecular charge transfer jumps with CDFT fit data
intramolecular_charge_transfer_on = False
## if true only intermolecular steps are printed
print_only_intermolecular = False
## if silent_mode_off = True, the printed output is increased to print more kMC-Information
silent_mode_off= True 
### intramolecular_method_el ='cosfit' :use cos-function fit to calculate intramolecular charge transfer. 
### default uses hole parametrisation with splinefit for holes and electrons.
intramolecular_method_el ='cosfit'
## set the calculation method for the gaussian subscripts
##  default: calculation_method  = 'PM3' OR  'ZINDO' 'DFTB+' 'PM3'
calculation_method='PM3'  
### g09_DIPRO_method_line select the model for the DIPRO calculation
g09_DIPRO_method_line=' PM3 SCF(XQC,MaxCycles=2024,MaxConventionalCycles=1024) '
### set calculation_method_lambda_in
calculation_method_lambda_in='UFF'
## sets the method with which lambda in is calculated. possible sets are:
## lambda_in_method settings: static, gaussian, fit, from_matrix, otf, otf_oniom
## lambda_in_method='otf_oniom'
lambda_in_method='otf' ##'gaussian'  ##'from_matrix'
oniom_method='oniom(B3LYP/6-31G*:UFF(QEq))'
## lambda_out_method='otf'
lambda_out_method='off'
## cutoff radius in Angstrom for lambda_out_method
r_cut='0.0'
## sub_one_calc_at_a_time, wait with the new calculation till the calculation with external scrits have finised; False == many calculations at the same time 
sub_one_calc_at_a_time= True
## if you dont want to run a KMC simulation but just want to calc a complete rate list
## set this value to true
calc_complete_list=True 
## this is the index from which the complete list calculation starts
start_index_for_complete_list_calculation=0
end_index_for_complete_list_calculation=8000
## number of parallel instances of the quantum property evaluation program
## dont set this to >1 unless you have an insane powerfull cpu! (bug: does not work as expected)
number_of_parallel_dipro_threads=6
### number of parallel threads 
number_of_parallel_threads=1
## submission via threading in internal queue for eg. DIPRO or lambda_in calculations.
sub_internal_queue = True
## sub_old_style = True, spams DIPRO calculations 
sub_old_style= False
## set this to True to delete all the debug data while calculating complete neighbour list
delete_debug_data = True
## print kmc data every n steps
kmc_print_intervall = 3
## finishing time for the kmc simulations in seconds ## got to next geometry
t_kmc_max =0.1  ### 1.0e-1
### starting number for counting all dipro calculations
calculation_number_All=1
## if true |J_AB| are scaled to CDFT-Data 
scale_J_AB = False
linear_scaling_J_AB= False
y_scale_method='CDFT'
x_scale_method='PM3'
## Method to parametize |J_AB| for PM3 with MA (minimaler Abstand),MMA (mittlerer Minimalabstand), COM_H (Schwerpunktsabstand der Molekuele mit H-Atomen)
## Lin_Combi (Linearkombination der 3 Geometrieparameter (falls diese nicht zur Verfuegung steht, wird die Methode mit der besten Korrelation R verwendet). 
## J_AB_fit_method_geometry={MA,MMA,COM_H,Lin_Combi}
J_AB_fit_method_geometry='Lin_Combi'
### read_boxsize_from_gro = True data set here will be replaced by data in the gro.file
read_boxsize_from_gro = True
xbox=306.4451  	## boxsize in Angstroenm
ybox=103.5850	## boxsize in Angstroenm
zbox=105.4510   ## boxsize in Angstroenm
 ### Nachbereitung und Grenze wenn Trajectory zu gross wird  
script_path='.' ##'/home/t/t_koch08/transfer/kMC_Rechnungen/multi_geo/skripte'   #'.' + Path_where you can find executables 
### maximum trajectory size of in byte (after this a new trajectory file is openend and the current and mobility are calculated if requested and scripts are available (skript_path) )
max_kmc_traj_filesize= 1.0E11 
### Counts the various _V${counter_kmc_traj_steps} for the trajectory ; default is counter_kmc_traj_steps=1 
counter_kmc_traj_steps=1  ## default=1
### maximum number of kmc_trajectories to avoid huge amount of output
max_kmc_traj_step=10
#### mobility convergence
### convergence criterion for the mobility, checks the last steps of the mobility calculation and checks, if the relative variation in the last check_N_latest_mobility_steps=5 steps is smaller than the limit. [Default: mobility_conv_criterion=np.array([0.07,0.07,0.07])
mobility_conv_criterion=np.array([0.2,0.2,0.2])
### modus to calculate the mobility, use mobilitymode=FEM as field effect mobility or mobilitymode=Einstein via RMSD 
mobilitymode='FEM'
### Buffer to write mobility data to the output mobility files [Default=1.0E5]
buffered_mobility_out_steps=1000
#### check the latest N mobilities if the relative difference of the consecutive mobilities is below the threshold in: mobility_conv_criterion
check_N_latest_mobility_steps=5
#### file to store the mobility data: default mobility_n_t__mu_el__mu_lo.dat
mobility_filename='mobility_n_t__mu_el__mu_lo.dat'
####### read mobility data from file if = True in the list of arrays (use for restart kMC-Trajectory calculation) [Default: False]
read_mobility_data_from_file = False
#### minimal Number of kMC steps for equilibration before the convergence of the mobility ist checked. [Default:1.0E7]
minimum_N_kMC_steps_to_check_mobility=1.0E7 ### momentan AUS!
#### create Backup folder and Backup data
make_backup = False
#### accuracy of the mobility 0.01 means <1% derivation of old mobility is convergence criterion
mobility_conv_crit = 0.01
########################## input parameters ####################################

#### calculate the "constant" terms
#lambd=0.0  			## 0.21	# eV Alq3
#delta_E=0.0       		## 0.03 ## eV
#marcus_const=np.sqrt(np.pi/(lambd*k_B*T))/hbar*np.exp(-(delta_E+lambd)**2/(4*lambd*k_B*T))
##### [lambda_in_lo, sigman_lo],[lambda_in_el, sigman_el],[dE_in_lo, dE_in_sigman_lo],[dE_in_el, dE_in_sigman_el]
##### lambda_in_method == 'static' or 'gaussian' to address these values [eV]
lambda_in_dE_arr=np.array([[0.212,0.026],[0.27,0.019],[0.001,0.011],[0.002,0.18]]) #eV Alq3 B3LYP/6-311G(d,p)

##### input & output files
	
if (DIPBI_P3HT):
	# contains the angle dependant parametrization for the intramolecular p3ht data.
	P3HT_intr_in_lo=open('data/spline_interp_2mere_P3HT_hole', 'r')
	P3HT_intr_in_el=open('data/spline_interp_2mere_P3HT_electron', 'r')
	P3HT_dE_intr_in_lo=open('data/energie_p3mt_daten_hole', 'r')
	P3HT_dE_intr_in_el=open('data/energie_p3mt_daten_electron', 'r')

	# contains the lambda_internal and dE_internal parametrization matrices
	lambda_in_ho_matrix_file=open('data/lambda_in_matrix/Mat_lambda_in_lo_P3MT_S1_S32_B3LYP_6-311Gss.dat', 'r') ##open('data/lambda_in_matrix/Mat_lambda_in_lo_P3MT_S1_S32_DFTB-Mio-1-1.dat', 'r')
	lambda_in_el_matrix_file=open('data/lambda_in_matrix/Mat_lambda_in_el_P3MT_S1_S32_B3LYP_6-311Gss.dat', 'r') ##open('data/lambda_in_matrix/Mat_lambda_in_el_P3MT_S1_S32_DFTB-Mio-1-1.dat', 'r')
	dE_in_ho_matrix_file=open('data/lambda_in_matrix/Mat_dE_in_lo_P3MT_S1_S32_B3LYP_6-311Gss.dat', 'r')  ##open('data/lambda_in_matrix/Mat_dE_in_lo_P3MT_S1_S32_DFTB-Mio-1-1.dat', 'r')
	dE_in_el_matrix_file=open('data/lambda_in_matrix/Mat_dE_in_el_P3MT_S1_S32_B3LYP_6-311Gss.dat', 'r')   ##open('data/lambda_in_matrix/Mat_dE_in_el_P3MT_S1_S32_DFTB-Mio-1-1.dat', 'r')
elif(PPDI_PBDT_TS1):
	# contains the angle dependant parametrization for the intramolecular data.
	pbdt_JAB_intr_in_lo_AB_file=open('data/spline_3600_JAB_intra_pbdt-TS1_CDFT_PBE_AB_Loch.dat', 'r')
	pbdt_JAB_intr_in_el_AB_file=open('data/spline_3600_JAB_intra_pbdt-TS1_CDFT_PBE_AB_electrons.dat', 'r')
	pbdt_dE_intr_in_lo_AB_file=open('data/dE_intra_lo_spline_3600_pbdt-TS1_CDFT_PBE_AB_Loch.dat', 'r')
	pbdt_dE_intr_in_el_AB_file=open('data/dE_intra_el_spline_3600_pbdt-TS1_CDFT_PBE_AB_electrons.dat', 'r')

	pbdt_JAB_intr_in_lo_BA_file=open('data/spline_3600_JAB_intra_pbdt-TS1_CDFT_PBE_BA_Loch.dat', 'r')
	pbdt_JAB_intr_in_el_BA_file=open('data/spline_3600_JAB_intra_pbdt-TS1_CDFT_PBE_BA_electrons.dat', 'r')
	pbdt_dE_intr_in_lo_BA_file=open('data/dE_intra_lo_spline_3600_pbdt-TS1_CDFT_PBE_BA_Loch.dat', 'r')
	pbdt_dE_intr_in_el_BA_file=open('data/dE_intra_el_spline_3600_pbdt-TS1_CDFT_PBE_BA_electrons.dat', 'r')

	# contains the lambda_internal and dE_internal parametrization matrices
	lambda_in_ho_matrix_file=open('data/lambda_in_matrix/Mat_lambda_in_lo_PPDI_PBDT-TS1_S1_S17_B3LYP_6-31Gs.dat', 'r') ##open('data/lambda_in_matrix/Mat_lambda_in_lo_P3MT_S1_S32_DFTB-Mio-1-1.dat', 'r')
	lambda_in_el_matrix_file=open('data/lambda_in_matrix/Mat_lambda_in_el_PPDI_PBDT-TS1_S1_S17_B3LYP_6-31Gs.dat', 'r') ##open('data/lambda_in_matrix/Mat_lambda_in_el_P3MT_S1_S32_DFTB-Mio-1-1.dat', 'r')
	dE_in_ho_matrix_file=open('data/lambda_in_matrix/Mat_dE_in_lo_PPDI_PBDT-TS1_S1_S17_B3LYP_6-31Gs.dat', 'r')  ##open('data/lambda_in_matrix/Mat_dE_in_lo_P3MT_S1_S32_DFTB-Mio-1-1.dat', 'r')
	dE_in_el_matrix_file=open('data/lambda_in_matrix/Mat_dE_in_el_PPDI_PBDT-TS1_S1_S17_B3LYP_6-31Gs.dat', 'r')   ##open('data/lambda_in_matrix/Mat_dE_in_el_P3MT_S1_S32_DFTB-Mio-1-1.dat', 'r')
elif(PtK2K or PtK3K or mCP or NPB or HDI or TDI ):
	lambda_in_ho_matrix_file=open('data/lambda_in_matrix/Mat_lambda_in_lo_PtK2K_PtK3K_mCP_NPB_HDI_TDI_B3LYP_6-31Gs.dat', 'r') ##open('data/lambda_in_matrix/Mat_lambda_in_lo_P3MT_S1_S32_DFTB-Mio-1-1.dat', 'r')
	lambda_in_el_matrix_file=open('data/lambda_in_matrix/Mat_lambda_in_el_PtK2K_PtK3K_mCP_NPB_HDI_TDI_B3LYP_6-31Gs.dat', 'r') ##open('data/lambda_in_matrix/Mat_lambda_in_el_P3MT_S1_S32_DFTB-Mio-1-1.dat', 'r')
	dE_in_ho_matrix_file=open('data/lambda_in_matrix/Mat_dE_lo_PtK2K_PtK3K_mCP_NPB_HDI_TDI_B3LYP_6-31Gs.dat', 'r')  ##open('data/lambda_in_matrix/Mat_dE_in_lo_P3MT_S1_S32_DFTB-Mio-1-1.dat', 'r')
	dE_in_el_matrix_file=open('data/lambda_in_matrix/Mat_dE_el_PtK2K_PtK3K_mCP_NPB_HDI_TDI_B3LYP_6-31Gs.dat', 'r')   ##open('data/lambda_in_matrix/Mat_dE_in_el_P3MT_S1_S32_DFTB-Mio-1-1.dat', 'r')
elif(Alq3):
	print 'use lambda:',lambda_in_dE_arr
else:
	print 'Select only DIPBI_P3HT, PPDI_PBDT_TS1 or (PtK2K, PtK3K, mCP, NPB, HDI, TDI) for kMC simulations!'
	sys.exit(0)

# for otf control
control_file=open('./control_file', 'w')



def does_file_exist_in_dir(path):
    return any(os.path.isfile(os.path.join(path, i)) for i in listdir(path))

### check if folder for the output of the data is available
NGeo_path='./'
if (read_NGeo):
		### check if folder exists ###
		NGeo_path='./kmc_calc_'+str(NGeo)+'/'
		if (os.path.isdir(NGeo_path)):
			print 'tmp: folder exists:'+str(NGeo_path)
			if does_file_exist_in_dir(NGeo_path):
				print 'tmp: listdir(NGeo_path): ',listdir(NGeo_path)
				for i in listdir(NGeo_path):
					if (('kmc_calc_'+str(NGeo)+'.err' in i) or ('kmc_calc_'+str(NGeo)+'.seq' in i) or ('kmc_calc_'+str(NGeo) in i) ):
						pass
					else:
						print 'Error: A file was found in the output directory, make sure it is not overwritten: ',i
						print 'EXIT'
						exit(0)					
			else:
				pass
		else:
			make_NGeo_path=subprocess.Popen(shlex.split('mkdir '+str(NGeo_path)))
			make_NGeo_path.wait()
			print 'mkdir '+str(NGeo_path)
			if (os.path.isdir(NGeo_path)):
				print 'tmp folder exists'
			else:
				print 'Error: no folder available.'
				exit(0)
else:
		NGeo_path='./'

starting_time = time.strftime('%c')
starting_time = starting_time.replace(" ","_").replace(":","-")
# output
kmc_traj_filename =str(NGeo_path)+'kmc_traj_'+starting_time[4:19].replace(" ","_").replace(":","-")+'_T'+str(NGeo)+'.xyz'
info_out_filename =str(NGeo_path)+'kmc_info_'+starting_time[4:19].replace(" ","_").replace(":","-")+'_T'+str(NGeo)+'.info'
elec_prob_out_filename = str(NGeo_path)+'elec_probList_'+starting_time[4:19].replace(" ","_").replace(":","-")+'_T'+str(NGeo)+'.ngh'
elec_matrix_out_filename = str(NGeo_path)+'elec_matrixElementList_'+starting_time[4:19].replace(" ","_").replace(":","-")+'_T'+str(NGeo)+'.ngh'
hole_prob_out_filename = str(NGeo_path)+'hole_probList_'+starting_time[4:19].replace(" ","_").replace(":","-")+'_T'+str(NGeo)+'.ngh'
hole_matrix_out_filename = str(NGeo_path)+'hole_matrixElementList_'+starting_time[4:19].replace(" ","_").replace(":","-")+'_T'+str(NGeo)+'.ngh'
elec_lambda_in_out_filename = str(NGeo_path)+'elec_lambdaList_'+starting_time[4:19].replace(" ","_").replace(":","-")+'_T'+str(NGeo)+'.ngh'
hole_lambda_in_out_filename = str(NGeo_path)+'elec_hole_lambdaList_'+starting_time[4:19].replace(" ","_").replace(":","-")+'_T'+str(NGeo)+'.ngh'
elec_dE_in_out_filename = str(NGeo_path)+'elec_dE_inList_'+starting_time[4:19].replace(" ","_").replace(":","-")+'_T'+str(NGeo)+'.ngh'
hole_dE_in_out_filename = str(NGeo_path)+'hole_dE_inList_'+starting_time[4:19].replace(" ","_").replace(":","-")+'_T'+str(NGeo)+'.ngh'
elec_dE_out_out_filename = str(NGeo_path)+'elec_dE_outList_'+starting_time[4:19].replace(" ","_").replace(":","-")+'_T'+str(NGeo)+'.ngh'
hole_dE_out_out_filename = str(NGeo_path)+'hole_dE_outList_'+starting_time[4:19].replace(" ","_").replace(":","-")+'_T'+str(NGeo)+'.ngh'
elec_lambda_out_out_filename = str(NGeo_path)+'elec_lambda_outList_'+starting_time[4:19].replace(" ","_").replace(":","-")+'_T'+str(NGeo)+'.ngh'
hole_lambda_out_out_filename = str(NGeo_path)+'hole_lambda_outList_'+starting_time[4:19].replace(" ","_").replace(":","-")+'_T'+str(NGeo)+'.ngh'

#info_out=open(os.path.join(str(NGeo_path), info_out_filename),'w')
info_out=open(info_out_filename,'w')

###### start the logger to append all output to a log file this means all print to stout will be appended to the log file
#class Tee(object):
#    def __init__(self, name, mode):
#        self.file = open(name, mode)
#        self.stdout = sys.stdout
    #    self.stderr = sys.stderr
#        sys.stdout = self
    #    sys.stderr = self
#    def __del__(self):
#        sys.stdout = self.stdout
    #    sys.stderr = self.stderr
#        self.file.close()
#    def write(self, data):
#        self.file.write(data)
#        self.stdout.write(data)
    #    self.stderr.write(data)

class Tee_Error(object):
    def __init__(self, name, mode):
        self.file = open(name, mode)
        self.stderr = sys.stderr
    #    self.stderr = sys.stderr
        sys.stdout = self
    #    sys.stderr = self
    def __del__(self):
        sys.stderr = self.stderr
    #    sys.stderr = self.stderr
        self.file.close()
    def write(self, data):
        self.file.write(data)
        self.stderr.write(data)
    #    self.stderr.write(data)

#logger_task = Tee('KMC_LOG_'+starting_time[4:19].replace(" ","_")+'.log', 'w')
logger_error = Tee_Error(str(NGeo_path)+'KMC_LOG_'+starting_time[4:19].replace(" ","_").replace(":","-")+'_T'+str(NGeo)+'.log', 'w')
######
#class LogFile(object):
#    """File-like object to log text using the `logging` module."""
#
 #   def __init__(self, name=None):
  #      self.logger = logging.getLogger(name)
#
#    def write(self, msg, level=logging.INFO):
#        self.logger.log(level, msg)
#
#    def flush(self):
#        for handler in self.logger.handlers:
#            handler.flush()
#
#logging.basicConfig(level=logging.DEBUG, filename='KMC_'+starting_time[4:19].replace(" ","_")+'.log')

# Redirect stdout and stderr
#sys.stdout = LogFile('stdout')
#sys.stderr = LogFile('stderr')
########
#class Logger(object):
 #   def __init__(self):
 #       self.terminal = sys.stdout
#        self.log = open("log_KMC.dat", "a")

#    def write(self, message):
#        self.terminal.write(message)
#        self.log.write(message)  

#sys.stdout = Logger()
######


##### variables
i = 0
frame_number=0




##### specifies weather the program should submit DIPRO into the queue or just run in debug mode
debug = False
try:
	debugname = sys.argv[4]
	if (debugname == 'True'):
		debug= True
	else:
		debug= False
except IndexError:
	debug = False

print 'debug: ', debug

if((make_backup or debug)):
	# backup old files
	mk_backup_folder = subprocess.Popen(shlex.split('mkdir ./Backups_'+starting_time[4:19].replace(" ","_")))
	mk_backup_folder.wait()
	cp_data = subprocess.Popen(shlex.split('cp '+str(DIPRO_J_AB_datafile)+' ./Backups_'+starting_time[4:19].replace(" ","_")+'/Datenauswertung_Backup_'+starting_time[4:19].replace(" ","_")),stdout=subprocess.PIPE)
	cp_data = subprocess.Popen(shlex.split('cp ./subroutines/lambda_in/results_lambda_in_G'+ str(frame_number) +'.dat '+ './Backups_'+starting_time[4:19].replace(" ","_")+'/lambda_in_Backup_'+starting_time[4:19].replace(" ","_")),stdout=subprocess.PIPE)
	cp_data = subprocess.Popen(shlex.split('cp ./subroutines/results_lambda_out_el_G'+ str(frame_number) +'.dat '+ './Backups_'+starting_time[4:19].replace(" ","_")+'/results_lambda_out_el_S0_Backup_'+starting_time[4:19].replace(" ","_")),stdout=subprocess.PIPE)
	cp_data = subprocess.Popen(shlex.split('cp ./subroutines/results_lambda_out_lo_G'+ str(frame_number) +'.dat ' + './Backups_'+starting_time[4:19].replace(" ","_")+'/results_lambda_out_lo_S0_Backup_'+starting_time[4:19].replace(" ","_")),stdout=subprocess.PIPE)

##### files for and from subroutines
open(str(DIPRO_J_AB_datafile), 'a')
open('subroutines/lambda_in/results_lambda_in_G'+ str(frame_number) +'.dat', 'a')

##### starts counting at 0!
##### contains in the i comp.: [index, distance, distance to 1st jump partner, distance to 2nd ... , usw.]
##### contains in the i comp.: [index, index, index of 1. jump partner, index of second jump partner, ...]
distList = []

##### list to store the sum of all probabilities to the neighbours
elec_total_sum_probList = np.array([])
hole_total_sum_probList = np.array([])

##### starts counting at 0!
##### contains in the i comp.: [index, stay probability, jump probability to index of 1st jump partner, jump prob to index ... , usw.]
##### contains in the i comp.: [index, index, index of 1. jump partner, index of second jump partner, ...]
elec_probList = []	
hole_probList = []		

##### starts counting at 0!
##### contains in the i comp.: [index, 0, lambda_in to index of 1st jump partner, lambda_in to index ... , usw.]
##### contains in the i comp.: [index, index, index of 1. jump partner, index of second jump partner, ...]
elec_lambdaList = []	
hole_lambdaList = []	
lambda_out_neighbourlist =[]	
elec_lambda_out_List=[]
hole_lambda_out_List=[]

##### starts counting at 0!
##### contains in the i comp.: [index, 0, matrix element to index of 1st jump partner, matrix element to index ... , usw.]
##### contains in the i comp.: [index, index, index of 1. jump partner, index of second jump partner, ...]
elec_matrixElementList = []	
hole_matrixElementList = []

##### starts counting at 0!
##### contains in the i comp.: [index, 0, dE_in to index of 1st jump partner, dE_in to index ... , usw.]
##### contains in the i comp.: [index, index, index of 1. jump partner, index of second jump partner, ...]
elec_dE_inList = []
hole_dE_inList = []
elec_dE_out_List = []
hole_dE_out_List = []

##### contains the index of occupied spot
#occupied_list = []

##### contains the coordinates in atomic resolution and the mol types
groList=[[]]

##### contains the COM coords
COM_list=[]

##### contains the total jump probability of a single charge at spot i
prob_per_charge = []

##### contains the index of the charge with minimum event time
min_tau = 0

##### contains the simulation time
sim_time = 0.0

##### contains event times of charge index i
tau_i = []

##### counts the steps
step_count = 0

##### stores how many percent of the calculation are done
percent=0

##### stores the mobility for the individual charges in [mu_x,mu_y,mu_z]
mobility_charges=[]
#### stores the traveled distance for each charge in the kmc calculation.
dr_travelled=[]
#### stores the velocity for each charge in the kmc calculation.
velocity_charges=[]
#### stores the boolean convergence values for 1) mob_el ,2) mob_lo, 3) mob_ges 4) all
mobility_conv=[ False, False, False, False]
#### array to store the latest mobility result 1) Steps:N 2) time t/s 3) mob_el ,4) mob_lo, 5) mob_ges
mobility_arr=np.array([0,0,0,0,0])
#### list to append the latest mobilities as np.arrays
mob_list=[]
### subjoblist: List for the batch-submission lines, used to start the subprocesses *e.g. in aufruf.out, in the internal threading + queuing system
subjoblist=[]
### FEM lists that will hold numpy arrays for field effect mobiliy
net_displacement_total=np.asarray([0.0, 0.0, 0.0])
net_displacement_el=np.asarray([0.0, 0.0, 0.0])
net_displacement_lo=np.asarray([0.0, 0.0, 0.0])
net_mobility_total=np.asarray([0.0, 0.0, 0.0])
net_mobility_lo=np.asarray([0.0, 0.0, 0.0])
net_mobility_el=np.asarray([0.0, 0.0, 0.0])
net_mobility_old=np.asarray([0.0, 0.0, 0.0])

print 'tmp net_mobility_el[:]',net_mobility_el[:],net_mobility_el[0],net_mobility_el[1],net_mobility_el[2]

#net_displacement_total=[]
#net_displacement_el=[]
#net_displacement_lo=[]
#net_mobility_total=[]
#net_mobility_lo=[]
#net_mobility_el=[]
#net_mobility_old=[]
velocity_charges.append([0.0,0.0,0.0])
### fieldfactor for FEM
fieldfactors=np.array([0.0,0.0,0.0])
if((np.linalg.norm(U) != 0) and (mobilitymode == 'FEM')):
	print U[:]
	for j in np.nonzero(U):
			print 'j=',j,' U= ',U[j]
			print 'fieldfactors[j]',fieldfactors[j]
			fieldfactors[j]=np.array(1.0E-16/U[j]) ## Angstroem**2 to cm**2
			print 'fieldfactors[:]',fieldfactors[:]




#### constants in SI units and eV
hbar=6.582119514E-16	# eV*s
k_B=8.6173303E-5 	# eV/K
T=300.0			# K

### dummy array for the gromacs boxsize in angstroem
box_ang= [0.0, 0.0, 0.0]


##### manage arguments for complete list calculation
if end_index_for_complete_list_calculation ==0:	end_index_for_complete_list_calculation=len(distList)/2

### check submission of external jobs ####
if (sub_internal_queue and sub_old_style):
	print 'Error: Only one method can be selected: sub_internal_queue or sub_old_style ',sub_internal_queue,sub_old_style
	sys.exit(0)
elif( not sub_internal_queue and not sub_old_style):
	print 'Error: One method needs to be selected: sub_internal_queue or sub_old_style ',sub_internal_queue,sub_old_style
	sys.exit(0)
else:
	if (silent_mode_off):
		print 'use sub_internal_queue: ',sub_internal_queue
		print 'use sub_old_style: ',sub_old_style 
##### checks wether the charge is moving or not
jumped = False

##### checks if the jump is occuring inter or intramolecular
intramolecular = False

##### checks if an old matrix list is specified
old_matrix_list = False
old_hole_matrix_list = False

##### counts the number of marcus rate calculations
###[0]=KMC_rates, [1]=DIPRO, [2]=J_AB_intramolecular, [3]=lambda_in, [4]=lambda_in_oniom, [5]=lambda_out, [6]=calc_complete_list
calculation_number=np.array([0,1,1,1,1,1,1])

#########
### build the info file header
info_out.write('KMC info file' + '\n')
info_out.write('Starting time: ' + starting_time+ '\n'+ '\n')
#info_out.write('Date: ' + str(localtime()[0:3]) + '\n')
#info_out.write('Starting time: ' + str(localtime()[3:5]) + '\n' + '\n')
info_out.close()
#########

if (DIPBI_P3HT):
	## contains the intramolecular matrix element angle dependant parametrization
	p3ht_angle_JAB_intra_list_lo = []
	p3ht_angle_JAB_intra_list_el = []
	## contains the intramolecular energy angle dependant parametrization
	p3ht_dE_rate_list_lo = []
	p3ht_dE_rate_list_el = []
elif(PPDI_PBDT_TS1):
	## contains the intramolecular matrix element angle dependant parametrization
	pbdt_angle_JAB_intra_list_lo_AB = []
	pbdt_angle_JAB_intra_list_el_AB = []
	## contains the intramolecular energy angle dependant parametrization
	pbdt_dE_rate_list_lo_AB = []
	pbdt_dE_rate_list_el_AB = []

	## contains the intramolecular matrix element angle dependant parametrization
	pbdt_angle_JAB_intra_list_lo_BA = []
	pbdt_angle_JAB_intra_list_el_BA = []
	## contains the intramolecular energy angle dependant parametrization
	pbdt_dE_rate_list_lo_BA = []
	pbdt_dE_rate_list_el_BA = []



### def function is_number
def is_number(s):
    try:
        float(s)
        return True
    except ValueError:
        return False
### end function is_number


##### read data
# for multigeo calculations with adapted gro-geometry from MM simulations 
if (read_multigeo_old):
	if os.path.isfile('sim_data_12N/multigeo_kmc.dat'):
    		multigeo_file=open('sim_data_12N/multigeo_kmc.dat', 'r')
		info_out=open(info_out_filename,'a')
		info_out.write('Reading Data from '+str(multigeo_file)+' ' + '\n')
		info_out.close()
	else:
		print 'Error: File does not exist, sim_data_12N/multigeo_kmc.dat '
		info_out=open(info_out_filename,'a')
		info_out.write('Error: File does not exist, sim_data_12N/multigeo_kmc.dat ' + '\n')
		info_out.close()		
		sys.exit(0)

## read old data for multigeo calculation
if read_multigeo_old:
	if (mobilitymode =='Einstein'):
		mobility_sum=0.0
		mobility_lo=0.0
		mobility_el=0.0  
	while 1:
		line1 = multigeo_file.readline()
		if not line1:
			break
		splitted = line1.split()
		if splitted[0] == 'number_charges:':
			N_charges=int(splitted[1])
		if splitted[0] == 'new_occupied_list:':
			occupied_list=map(int,line1.split()[1:])
		if splitted[0] == 'charge_type_list:':
			charge_type_list=line1.split()[1:]
		if splitted[0] == 'last_tau_i:':
			tau_i = map(float,line1.split()[1:])
		if splitted[0] == 'step_count:':
			step_count=int(splitted[1])
		if splitted[0] == 'MSD_all:':
			MSD=float(splitted[1])
		if splitted[0] == 'MSD_el:':
			MSD_el=float(splitted[1])
		if splitted[0] == 'MSD_lo:':
			MSD_lo=float(splitted[1])
		if splitted[0] == 'simulated_time_s:':
			sim_time = float(splitted[1])
			t_kmc_max = sim_time+t_kmc_max
		if splitted[0] == 'geo_step:':
			frame_number = int(splitted[1])
        	#occupied_list=[]
        	#line1 = multigeo_file.readline()
	if(mobilitymode =='FEM'):
		for i in range(N_charges):
			mobility_charges.append(np.array([0.0,0.0,0.0]))
			dr_travelled.append(np.array([0.0,0.0,0.0]))
			velocity_charges.append(np.array([0.0,0.0,0.0]))
			#net_displacement_total.append(np.array([0.0,0.0,0.0]))
			#net_displacement_el.append(np.array([0.0,0.0,0.0]))
			#net_displacement_lo.append(np.array([0.0,0.0,0.0]))
			#net_mobility_total.append(np.array([0.0,0.0,0.0]))
			#net_mobility_lo.append(np.array([0.0,0.0,0.0]))
			#net_mobility_el.append(np.array([0.0,0.0,0.0]))
			#net_mobility_old.append(np.array([0.0,0.0,0.0]))
else:
    	#build the time list
	for i in range(len(occupied_list)):
		tau_i.append(0)
	if(mobilitymode =='FEM'):
		for i in range(N_charges):
			### lists for each charge carrier of numpy arrays
			mobility_charges.append(np.array([0.0,0.0,0.0]))
			dr_travelled.append(np.array([0.0,0.0,0.0]))
			velocity_charges.append([0.0,0.0,0.0])
			#net_displacement_total.append(np.array([0.0,0.0,0.0]))
			#net_displacement_el.append(np.array([0.0,0.0,0.0]))
			#net_displacement_lo.append(np.array([0.0,0.0,0.0]))
			#net_mobility_total.append(np.array([0.0,0.0,0.0]))
			#net_mobility_lo.append(np.array([0.0,0.0,0.0]))
			#net_mobility_el.append(np.array([0.0,0.0,0.0]))
			#net_mobility_old.append(np.array([0.0,0.0,0.0]))

	elif (mobilitymode =='Einstein'):
		MSD=0.0
		MSD_el=0.0
		MSD_lo=0.0
		mobility_sum=0.0
		mobility_lo=0.0
		mobility_el=0.0     

if read_multigeo_old:
	print 'frame_number ',frame_number
	print 'number_charges ',N_charges
	print 'occupied_list ',occupied_list
	print 'charge_type ',charge_type_list
	print 'tau_i ',tau_i
	print 'step_count ',step_count
	print 'sim_time ',sim_time
	print "t_kmc_max ",t_kmc_max
	DIPRO_J_AB_datafile='./subroutines/Datenauswertung_SAB_H_H0_Jab_H0_H0_SAB_L0_L0_Jab_L0_L0_G'+ str(frame_number) +'.dat'
	if( (N_charges == len(occupied_list)) and  (N_charges == len(charge_type_list)) ):
		print 'Multigeo Data was read from '+str(multigeo_file)
	else: 
		print 'Error: The size of the occupied_list or the charge_type_list does not match the number of charges, EXIT'
		info_out=open(info_out_filename,'a')
		info_out.write('Error: The size of the occupied_list or the charge_type_list does not match the number of charges in:' +str(multigeo_file) + '\n')
		info_out.close()
		sys.exit(1)
N_el=0
N_lo=0
N_exciton=0
for charge in charge_type_list:
	if (charge == 'electron'):
		N_el=N_el+1
	elif (charge == 'hole'):
		N_lo=N_lo+1
	elif (charge == 'exciton'):
		N_exciton=N_exciton+1

if (N_charges != (N_el+N_lo+N_exciton)):
	print 'Error: The number of charges is not determined correctly, check the charge_type_list.'
	print 'N_charges: ',N_charges,'N_el: ',N_el,' N_lo:',N_lo,'N_exciton: ',N_exciton
	exit()	

### end read old data for multigeo calculation###

### initialization of lists with old resids, to check if the sites were visited before #########
### latest_occupied_lists[i][j] with i= Resids[ 0 to elements in occupuied list] ; j= last steps in trajectory [0-5] (inicialized with zeros) ###
latest_occupied_lists=[]
for i in range(len(occupied_list)):
	latest_occupied_lists.append([0,0,0,0,0,0])

### plugs in external Voltage U_ext, read with flag ###
if (read_U_ext):	
	U=np.asarray([float(U_ext),0,0])

### mobility mob_infostring to write the kMC-characteristics into the mobility file.
mob_infostring='|U_ext|= '+str(np.linalg.norm(U))+'  U_ext= '+str(U)

###### read intramolecular holes ##########################
## read intramolecular matrix parametrization for holes
if (DIPBI_P3HT):
	while 1:
		line1 = P3HT_intr_in_lo.readline()															#to avoid smaug killing
		if not line1:
			break
		line = line1.split()
		if line1[0] != '#':
			p3ht_angle_JAB_intra_list_lo.append(float(line[1]))
	######## info output
	info_out=open(info_out_filename,'a')
	info_out.write('Finished reading intramolecular matrix element parametrization file: '+P3HT_intr_in_lo.name + '\n')
	info_out.close()
	######## info output
elif(PPDI_PBDT_TS1):
	while 1:
		line1 = pbdt_JAB_intr_in_lo_AB_file.readline()															#to avoid smaug killing
		if not line1:
			break
		line = line1.split()
		if line1[0] != '#':
			pbdt_angle_JAB_intra_list_lo_AB.append(float(line[1]))
	######## info output
	info_out=open(info_out_filename,'a')
	info_out.write('Finished reading intramolecular matrix element parametrization file: '+pbdt_JAB_intr_in_lo_AB_file.name + '\n')
	info_out.close()
	######## info output
	while 1:
		line1 = pbdt_JAB_intr_in_lo_BA_file.readline()															#to avoid smaug killing
		if not line1:
			break
		line = line1.split()
		if line1[0] != '#':
			pbdt_angle_JAB_intra_list_lo_BA.append(float(line[1]))
	######## info output
	info_out=open(info_out_filename,'a')
	info_out.write('Finished reading intramolecular matrix element parametrization file: '+pbdt_JAB_intr_in_lo_BA_file.name + '\n')
	info_out.close()
	######## info output	

	
## read intramolecular dE parametrization for holes
if (DIPBI_P3HT):
	while 1:
		line1 =P3HT_dE_intr_in_lo.readline()															#to avoid smaug killing
		if not line1:
			break
		line = line1.split()
		if line1[0] != '#':
		#	print line
			p3ht_dE_rate_list_lo.append(float(line[1]))
	
	######## info output
	info_out=open(info_out_filename,'a')
	info_out.write('Finished reading intramolecular dE parametrization file: '+P3HT_dE_intr_in_lo.name + '\n')
	info_out.close()
	######## info output
elif (PPDI_PBDT_TS1):
	while 1:
		line1 =pbdt_dE_intr_in_lo_AB_file.readline()															#to avoid smaug killing
		if not line1:
			break
		line = line1.split()
		if line1[0] != '#':
		#	print line
			pbdt_dE_rate_list_lo_AB.append(float(line[1]))
	
	######## info output
	info_out=open(info_out_filename,'a')
	info_out.write('Finished reading intramolecular dE parametrization file: '+pbdt_dE_intr_in_lo_AB_file.name + '\n')
	info_out.close()
	######## info output
	while 1:
		line1 =pbdt_dE_intr_in_lo_BA_file.readline()															#to avoid smaug killing
		if not line1:
			break
		line = line1.split()
		if line1[0] != '#':
		#	print line
			pbdt_dE_rate_list_lo_BA.append(float(line[1]))
	
	######## info output
	info_out=open(info_out_filename,'a')
	info_out.write('Finished reading intramolecular dE parametrization file: '+pbdt_dE_intr_in_lo_BA_file.name + '\n')
	info_out.close()
	######## info output

######## end intramolecular holes #######


###### intramolecular electrons #############################
## read intramolecular matrix parametrization for electrons 
### start read JAB intramolecular electrons ###
if(DIPBI_P3HT):
	while 1:
	        line1 = P3HT_intr_in_el.readline()                                                                                                                      #to avoid smaug killing
	        if not line1:
	                break
	        line = line1.split()
	        if line1[0] != '#':
			#print line
	                p3ht_angle_JAB_intra_list_el.append(float(line[1]))
	
	######## info output
	info_out=open(info_out_filename,'a')
	info_out.write('Finished reading intramolecular matrix element parametrization file:'+P3HT_intr_in_el.name+ '\n')
	info_out.close()
	######## info output   
elif(PPDI_PBDT_TS1):
	while 1:
	        line1 = pbdt_JAB_intr_in_el_AB_file.readline()                                                                                                                      #to avoid smaug killing
	        if not line1:
	                break
	        line = line1.split()
	        if line1[0] != '#':
			#print line
	                pbdt_angle_JAB_intra_list_el_AB.append(float(line[1]))
	
	######## info output
	info_out=open(info_out_filename,'a')
	info_out.write('Finished reading intramolecular matrix element parametrization file:'+pbdt_JAB_intr_in_el_AB_file.name+ '\n')
	info_out.close()
	######## info output  
	while 1:
	        line1 = pbdt_JAB_intr_in_el_BA_file.readline()                                                                                                                      #to avoid smaug killing
	        if not line1:
	                break
	        line = line1.split()
	        if line1[0] != '#':
			#print line
	                pbdt_angle_JAB_intra_list_el_BA.append(float(line[1]))
	
	######## info output
	info_out=open(info_out_filename,'a')
	info_out.write('Finished reading intramolecular matrix element parametrization file:'+pbdt_JAB_intr_in_el_BA_file.name+ '\n')
	info_out.close()
	######## info output  

### end read JAB intramolecular electrons ###

### read intramolecular dE parametrization for electrons
if(DIPBI_P3HT):
	while 1:
		line1 =P3HT_dE_intr_in_el.readline()															#to avoid smaug killing
		if not line1:
			break
		line = line1.split()
		if line1[0] != '#':
			#print line
			p3ht_dE_rate_list_el.append(float(line[1]))

	######## info output
	info_out=open(info_out_filename,'a')
	info_out.write('Finished reading intramolecular dE parametrization file:'+P3HT_dE_intr_in_el.name+ '\n')
	info_out.close()
	######## info output
elif(PPDI_PBDT_TS1):
	while 1:
		line1 =pbdt_dE_intr_in_el_AB_file.readline()															#to avoid smaug killing
		if not line1:
			break
		line = line1.split()
		if line1[0] != '#':
			#print line
			pbdt_dE_rate_list_el_AB.append(float(line[1]))
			
	######## info output
	info_out=open(info_out_filename,'a')
	info_out.write('Finished reading intramolecular dE parametrization file:'+pbdt_dE_intr_in_el_AB_file.name+ '\n')
	info_out.close()
	######## info output
	while 1:
		line1 =pbdt_dE_intr_in_el_BA_file.readline()															#to avoid smaug killing
		if not line1:
			break
		line = line1.split()
		if line1[0] != '#':
			#print line
			pbdt_dE_rate_list_el_BA.append(float(line[1]))

	######## info output
	info_out=open(info_out_filename,'a')
	info_out.write('Finished reading intramolecular dE parametrization file:'+pbdt_dE_intr_in_el_BA_file.name+ '\n')
	info_out.close()
	######## info output

######## info output
info_out=open(info_out_filename,'a')
info_out.write('Finished reading all intramolecular data files'+'\n')
info_out.close()
######## info output
########### end intramolecular electrons read data #####

if ((lambda_in_method == 'from_matrix') or (lambda_in_method == 'otf') or (lambda_in_method == 'otf_oniom')):
######## read in lambda parametrization matrices
	i=0
	l=0
	lambda_in_el_matrix=[]
	while 1:
		line1 = lambda_in_el_matrix_file.readline()															#to avoid smaug killing
		if not line1:
			break
		lambda_in_el_matrix.append([])
		line = line1.split()
		#allow comments
		if line1[0] != '#':
			#print line
			for l in range(len(line)):
				lambda_in_el_matrix[i].append(float(line[l]))
			i=i+1
	i=0
	l=0
	### read in lambda parametrization matrices
	lambda_in_ho_matrix=[]
	while 1:
		line1 = lambda_in_ho_matrix_file.readline()															#to avoid smaug killing
		if not line1:
			break
		lambda_in_ho_matrix.append([])
		line = line1.split()
		#allow comments
		if line1[0] != '#':
			for l in range(len(line)):
				lambda_in_ho_matrix[i].append(float(line[l]))
			i=i+1
	i=0
	l=0
	### read in dE parametrization matrices
	dE_in_el_matrix=[]
	while 1:
		line1 = dE_in_el_matrix_file.readline()															#to avoid smaug killing
		if not line1:
			break
		dE_in_el_matrix.append([])
		line = line1.split()
		#allow comments
		if line1[0] != '#':
			for l in range(len(line)):
				dE_in_el_matrix[i].append(float(line[l]))
			i=i+1
	i=0
	l=0
	### read in dE parametrization matrices
	dE_in_ho_matrix=[]
	while 1:
		line1 = dE_in_ho_matrix_file.readline()													#to avoid smaug killing
		if not line1:
			break
		dE_in_ho_matrix.append([])		
		line = line1.split()
		#allow comments
		if line1[0] != '#':
			for l in range(len(line)):
				dE_in_ho_matrix[i].append(float(line[l]))
			i=i+1
	i=0
	l=0
	######## info output
	info_out=open(info_out_filename,'a')
	info_out.write('Finished reading lambda/dE internal parametrization matrices data/lambda_in_matrix/*' + '\n')
	info_out.close()
	######## info output
else:
	print 'use lambda_in_method:',lambda_in_method

######## end of read in lambda parametrization matrices


i=0
## read neighbours
while 1:
	line1 = neighbours_in.readline()																#to avoid smaug killing
	if not line1:
		break
	
	distList.append(line1.split()[0:])
	lambda_out_neighbourlist.append([])
	elec_probList.append([])
	hole_probList.append([])
	elec_matrixElementList.append([])
	hole_matrixElementList.append([])
	elec_lambdaList.append([])
	hole_lambdaList.append([])
	elec_dE_inList.append([])
	hole_dE_inList.append([])
	elec_dE_out_List.append([])
	hole_dE_out_List.append([])
	elec_lambda_out_List.append([])
	hole_lambda_out_List.append([])
	##### cast list to float
	distList[i] = [float(a) for a in distList[i]]
	i = i+1

######## info output
info_out=open(info_out_filename,'a')
info_out.write('Finished reading '+str(sys.argv[1])+' file'+ '\n')
info_out.close()
######## info output

####### read data from gro-file ###################################################################################
counter=0
iline=0
number_of_atoms=0
while 1:
	line1 = GRO_in.readline()
	if not line1:
		break
		
	##### get the number of atoms	
	if iline==1:	number_of_atoms = int(line1)
	##### get the center of masses
	if iline==2:	last_mol_number = int(line1[0:5])
	if iline>=2 and iline<number_of_atoms+2:
		##### split the line
		line=[int(line1[0:5]),str(line1[5:10]),str(line1[10:15]),int(line1[15:20]),float(line1[20:28]),float(line1[28:36]),float(line1[36:44])]
		mol_number = line[0]
		if mol_number!=last_mol_number:
			counter=counter+1
			groList.append([])
		groList[counter].append(line)
		last_mol_number=mol_number
	#save the box
	if iline==number_of_atoms+2:
		box = line1.split()
		for a in range(len(box)):
			box[a] = float(box[a])
			box_ang[a]=float(box[a])*10.0
		if read_boxsize_from_gro:
			xbox=10.0*float(box[0])   ## boxsize in Angstroem from nm
			ybox=10.0*float(box[1])   ## boxsize in Angstroem from nm
			zbox=10.0*float(box[2])	  ## boxsize in Angstroem from nm

	iline = iline + 1


######## info output
info_out=open(info_out_filename,'a')
info_out.write('Finished reading '+str(sys.argv[3])+' file'+ '\n')
info_out.close()
######## info output
####### end read data from gro-file ###################################################################################

#### random insertion of charges in the box 
if random_charge_insertion:
	first_mol_number=groList[0][0][0]
	last_mol_number=groList[-1][0][0]
	charge_type_list=[]
	occupied_list=[]
	## 	
	for i in range(N_charges/2):
		charge_type_list = charge_type_list + ['hole']
		#scaling random number		
		r_1=int(np.random.random()*(last_mol_number-first_mol_number)+first_mol_number)
		occupied_list=occupied_list+[r_1]
	for i in range(N_charges/2):
		charge_type_list = charge_type_list + ['electron']
		#scaling random number	
		r_2=int(np.random.random()*(last_mol_number-first_mol_number)+first_mol_number)
		occupied_list=occupied_list+[r_2]		
	print 'Start with random position of '+str(N_charges)+' charges in the box.'
	print 'Start occupied_list: ',occupied_list
	print 'Start charge_type_list: ',charge_type_list
	info_out=open(info_out_filename,'a')
	info_out.write('Start with random position of '+str(N_charges)+' charges in the box.'+ '\n')
	info_out.write('Start occupied_list: '+str(occupied_list)+' '+'\n')
	info_out.write('Start charge_type_list: '+str(charge_type_list)+' '+'\n')
	info_out.close()
	### if the random_charge_insertion is selected, the old mobilities do not have any influence!
	read_mobility_data_from_file = False

#### end random insertion of charges in the box


### start reading COM_list from *.xyz file ####
i=0
while 1:
	line1 = COM_in.readline()																#to avoid smaug killing
	if not line1:
		break
	line = line1.split()
	if i>=2:
		COM_list.append([float(line[1]),float(line[2]),float(line[3])])	
		elec_total_sum_probList=np.append(elec_total_sum_probList, -1.0)
		hole_total_sum_probList=np.append(hole_total_sum_probList, -1.0)
	i = i+1


######## info output
info_out=open(info_out_filename,'a')
info_out.write('Finished reading '+str(sys.argv[2])+' file'+ '\n')
info_out.close()
######## info output
### end reading COM_list from *.xyz file ####


#### here's a block to read in the lambda_out neighbour list
lambda_out_neighbourlist_file = open(sys.argv[5])
i=0
while 1==1:
	line = lambda_out_neighbourlist_file.readline()
	if not line:
		break
	lambda_out_neighbourlist[i] = line.split('	')
	lambda_out_neighbourlist[i][-1] = lambda_out_neighbourlist[i][-1].replace("\n", "")
	for l in range(len(lambda_out_neighbourlist[i])):
		try:
			if i%2==0:
				lambda_out_neighbourlist[i][l] = float(lambda_out_neighbourlist[i][l])
			else:
				lambda_out_neighbourlist[i][l] = int(lambda_out_neighbourlist[i][l])
		except ValueError:
			print 'Error while reading in hole matrixList at line '+str(i+1)
			print 'Value: ' + str(lambda_out_neighbourlist[i][l])
			print 'exiting'
			######## info output
			info_out=open(info_out_filename,'a')
			info_out.write('Error while reading in hole matrixList at line '+str(i+1)+ '\n')
			info_out.write('Value: ' + str(lambda_out_neighbourlist[i][l])+ '\n')
			info_out.write('exiting'+ '\n')
			info_out.close()
			######## info output
			sys.exit()
	i=i+1



#### here's a block to read in an existing matrix list
try:
	if sys.argv[6] != '':
		old_matrix_list=True
		elec_matrixListFile = open(sys.argv[5])
		i=0
		while 1==1:
			line = elec_matrixListFile.readline()
			if not line:
				break
			elec_matrixElementList[i] = line.split('	')
			elec_matrixElementList[i][-1] = elec_matrixElementList[i][-1].replace("\n", "")
			if len(elec_matrixElementList[i])>1:
				for l in range(len(elec_matrixElementList[i])):
					try:
						elec_matrixElementList[i][l] = float(elec_matrixElementList[i][l])
					except ValueError:
						print 'Error while reading in elec_matrixElementList at line '+str(i+1)
						print 'Value: ' + str(elec_matrixElementList[i][l])
						print 'exiting'
						######## info output
						info_out=open(info_out_filename,'a')
						info_out.write('Error while reading in elec_matrixElementList at line '+str(i+1)+ '\n')
						info_out.write('Value: ' + str(elec_matrixElementList[i][l])+ '\n')
						info_out.write('exiting'+ '\n')
						info_out.close()
						######## info output
						sys.exit()
			else:
				elec_matrixElementList[i]=[]
			i=i+1
except IndexError:
	i=0

#### here's a block to read in an existing hole_matrix list
try:
	if sys.argv[7] != '':
		old_hole_matrix_list=True
		hole_matrixListFile = open(sys.argv[6])
		i=0
		while 1==1:
			line = hole_matrixListFile.readline()
			if not line:
				break
			hole_matrixElementList[i] = line.split('	')
			hole_matrixElementList[i][-1] = hole_matrixElementList[i][-1].replace("\n", "")
			if len(hole_matrixElementList[i])>1:
				for l in range(len(hole_matrixElementList[i])):
					try:
						hole_matrixElementList[i][l] = float(hole_matrixElementList[i][l])
					except ValueError:
						print 'Error while reading in hole matrixList at line '+str(i+1)
						print 'Value: ' + str(hole_matrixElementList[i][l])
						print 'exiting'
						######## info output
						info_out=open(info_out_filename,'a')
						info_out.write('Error while reading in hole matrixList at line '+str(i+1)+ '\n')
						info_out.write('Value: ' + str(hole_matrixElementList[i][l])+ '\n')
						info_out.write('exiting'+ '\n')
						info_out.close()
						######## info output
						sys.exit()
			else:
				hole_matrixElementList[i]=[]
			i=i+1
except IndexError:
	i=0


#### here's a block to read in the voltage
try:
	if sys.argv[8] != '':
		U=[]
		a = sys.argv[8]
		U.append(float(a))
		U.append(0)
		U.append(0)
                print 'Use Voltage U, which is read from input line in [V/Angstrom] : '+str(U)
		######## info output 
		info_out=open(info_out_filename,'a')
		info_out.write('Use Voltage U, which is read from input line in [V/Angstrom] : '+ str(U)+'\n')
		info_out.close()
		######## info output
except IndexError:
	i=0

######## info output
if old_matrix_list:
	info_out=open(info_out_filename,'a')
	info_out.write('Old matrix list specified: '+ str(sys.argv[5])+'\n')
	info_out.write('Finished reading old matrix list'+ '\n'+ '\n')
	info_out.close()
else:
	info_out=open(info_out_filename,'a')
	info_out.write('No old matrix list specified, building a new one'+ '\n'+ '\n')
	info_out.close()
######## info output
	

######## info output
if old_hole_matrix_list:
	info_out=open(info_out_filename,'a')
	info_out.write('Old hole matrix list specified: '+ str(sys.argv[6])+'\n')
	info_out.write('Finished reading old hole matrix list'+ '\n'+ '\n')
	info_out.close()
else:
	info_out=open(info_out_filename,'a')
	info_out.write('No old hole matrix list specified, building a new one'+ '\n'+ '\n')
	info_out.close()
######## info output	

#occupied_list=[100,200,300,400,500,600,700]


######## info output
info_out=open(info_out_filename,'a')
info_out.write('Occupied starting places: '+ str(occupied_list) + '\n')
info_out.write('Occupied charge types: '+ str(charge_type_list) + '\n')
info_out.write('Voltage [V/Angstrom]: '+ str(U) + '\n')
info_out.close()
######## info output


if (len(occupied_list) != len(charge_type_list)):
	print 'error: not all the charge types specified OR charge type list too long'
	info_out=open(info_out_filename,'a')
	info_out.write('error: not all the charge types specified OR charge type list too long' + '\n')
	info_out.close()
	sys.exit()



######## info output
if (not calc_complete_list):
	info_out=open(info_out_filename,'a')
	info_out.write('kmc_traj.xyz file generated' + '\n')
	info_out.write('starting the simulation ...' + '\n'+ '\n')
	info_out.close()
######## info output



#### functions

############################################################################################################
############################################################################################################
#################### returns the total jumping probability of a charge at site index ####################### 
def total_jump_probability(index, charge_type):
	double_index=2*index
	if charge_type == 'electron':	
		if (elec_total_sum_probList[index] == -1): 
			try:
				test = elec_probList[double_index][1]
				elec_total_sum_probList[index]=sum(elec_probList[double_index][2:])
				return elec_total_sum_probList[index]
			except IndexError:
				build_elec_probList(double_index)
				elec_total_sum_probList[index]=sum(elec_probList[double_index][2:])
				return elec_total_sum_probList[index]
		else:
			return elec_total_sum_probList[index]

	#	except IndexError:
	#		print 'error ecountered at index: '+str(index)+ ' in probability file'
	#		print 'index out of range ... now exiting'
	#		print 'maybe there are indices missing?'
	#		######## info output
	#		info_out=open(info_out_filename,'a')
	#		info_out.write('error ecountered at index: '+str(index)+ ' in probability file' + '\n')
	#		info_out.write('index out of range ... now exiting' + '\n')
	#		info_out.write('maybe there are indices missing?' + '\n')
	#		info_out.close()
	#		sys.exit()
			######## info output
	elif charge_type == 'hole':
		if (hole_total_sum_probList[index] == -1):
			try:
				test = hole_probList[double_index][1]
				hole_total_sum_probList[index]=sum(hole_probList[double_index][2:])
				return hole_total_sum_probList[index]
			except IndexError:
				build_hole_probList(double_index)
				hole_total_sum_probList[index]=sum(hole_probList[double_index][2:])
				return hole_total_sum_probList[index]
		else:
			return hole_total_sum_probList[index]

	#	except IndexError:
	#		print 'error ecountered at index: '+str(index)+ ' in probability file'
	#		print 'index out of range ... now exiting'
	#		print 'maybe there are indices missing?'
	#		######## info output
	#		info_out=open(info_out_filename,'a')
	#		info_out.write('error ecountered at index: '+str(index)+ ' in probability file' + '\n')
	#		info_out.write('index out of range ... now exiting' + '\n')
	#		info_out.write('maybe there are indices missing?' + '\n')
	#		info_out.close()
	#		exit()
			######## info output
	else:
		print 'error ecountered at index: '+str(index)+ ' in probability file'
		print 'unknown charge carrier type: ' + str(charge_type)
		######## info output
		info_out=open(info_out_filename,'a')
		info_out.write('error ecountered at index: '+str(index)+ ' in probability file' + '\n')
		info_out.write('unknown charge carrier type: ' + str(charge_type) + '\n')
		info_out.write('exiting...' + '\n')
		info_out.close()
		exit()
		######## info output
############################################################################################################
############################################################################################################		




################### returns the jumping probability of charge at site index to sub_index ################### 
############################## (see structure of neighbour list file) ######################################
def jump_probability(index, sub_index, charge_type):
	if charge_type == 'electron':
		return elec_probList[2*index][sub_index+2]
	if charge_type == 'hole':
		return hole_probList[2*index][sub_index+2]
############################################################################################################
############################################################################################################	

########### check_soft_exit ######
def check_soft_exit():
        if os.path.isfile('EXIT'):
                print 'Soft exit was requested with the EXIT file'
                end_kMC_time = time.strftime('%c')
                print 'Soft EXIT time:',end_kMC_time
                ### write to info_out ###
                info_out=open(info_out_filename,'a')
                info_out.write('Soft EXIT time:'+str(end_kMC_time) + '\n')
                info_out.close()
                os.kill(os.getpid(), signal.SIGINT)
##### End function check_soft_exit #####


### old stuff
####### single thread
###### calculates rates on the fly using the marcus rate subroutine
#def build_probList(index):
#	for l in range(len(distList[index])):
#		if l==0:
#			probList[index].append(distList[index][l])#rates
#			probList[index+1].append(distList[index][l])#indices
#		elif l==1:
#			probList[index].append(0)#rates
#			probList[index+1].append(distList[index+1][l])#indices
#		else:
#			probList[index].append(elec_marcus_rate(index,l,calculation_number))#rates
#			probList[index+1].append(distList[index+1][l])#indices
	#print probList[index]	
	#print probList[index+1]

#########################################grab the results###################################################
############################################################################################################
###### grab the results for electrons
def elec_get_results_from_dat(indexA,subindexB):
	global calculation_number
	#### get the resid's and the path for the subroutines
	resid1 = groList[indexA/2][0][0]
	resid2 = groList[int(distList[indexA+1][subindexB])][0][0]
	mol_type_1= groList[indexA/2][0][1]
	mol_type_2=groList[int(distList[indexA+1][subindexB])][0][1]
	charge_type='electron'
	#### DIPRO or |J_AB| intramolecular: ###
	if (intramolecular_charge_transfer_on and  (mol_type_1[:3] == 'THP' and mol_type_2[:3] == 'THP') and (resid1 == resid2 + 1 or resid1 + 1 == resid2) and not ( (groList[(resid1)][-1][1] == 'THP32' and groList[(resid2)][0][1] == 'THP1A') or (groList[(resid2)][-1][1] == 'THP32' and groList[(resid1)][0][1] == 'THP1A')) ):
		if charge_type == 'lo' or charge_type == 'hole':
				matrix_element_homo_homo, dE_lo_intra , matrix_element_lumo_lumo, dE_el_intra = calc_intramolecular_rate_P3HT([resid1,resid2,'hole'])
		elif charge_type == 'el' or charge_type == 'electron':
				matrix_element_homo_homo, dE_lo_intra , matrix_element_lumo_lumo, dE_el_intra = calc_intramolecular_rate_P3HT([resid1,resid2,'electron'])
		### get_lambda_dE for electrons
		lambda_in_el, dE_in_el, lambda_out_el, dE_out_el = get_lambda_dE(indexA, subindexB, lambda_in_method, lambda_out_method, 'electron')
		## ggf. Skalierung der Uebergangsmatrixelemente
		if scale_J_AB:
			matrix_element_lumo_lumo = scale_dipro_function_el(y_scale_method,x_scale_method,matrix_element_lumo_lumo)
		return matrix_element_lumo_lumo, lambda_in_el, dE_el_intra, lambda_out_el, dE_out_el

		
	elif ( intramolecular_charge_transfer_on and (mol_type_1 == '8poly') and (mol_type_2 == '8poly') and ((resid1 == resid2+1) or (resid1+1 == resid2)) ): 
		#check if the charge is transferring intramolecular for PBDT-TS1 to PBDT-TS1
		### exclude intramolecular transport if resid1 is the last element in the chain and resid2 the first element in the chain or vice versa => else DIPRO
		### (resid1=ende and resid2=start) OR (resid2=start and resid1=ende)
		if not ( ( ('CH3'==groList[(resid1)][-1][2][-3:]) and ('F'==groList[(resid2)][4][2][-1]) ) or ( ('CH3'==groList[(resid2)][-1][2][-3:]) and ('F'==groList[(resid1)][4][2][-1]) ) ): 
			if ( silent_mode_off ):
				print 'using fit for intramolecular electron transport for PBDT-TS1'
			if charge_type == 'lo' or charge_type == 'hole':
					matrix_element_homo_homo, dE_lo_intra , matrix_element_lumo_lumo, dE_el_intra = calc_intramolecular_data_PBDT_TS1([resid1,resid2,'hole'])
			elif charge_type == 'el' or charge_type == 'electron':
					matrix_element_homo_homo, dE_lo_intra , matrix_element_lumo_lumo, dE_el_intra = calc_intramolecular_data_PBDT_TS1([resid1,resid2,'electron'])
			### get_lambda_dE for electrons
			lambda_in_el, dE_in_el, lambda_out_el, dE_out_el = get_lambda_dE(indexA, subindexB, lambda_in_method, lambda_out_method, 'electron')

			## ggf. Skalierung der Uebergangsmatrixelemente
			if scale_J_AB:
				matrix_element_lumo_lumo = scale_dipro_function_el(y_scale_method,x_scale_method,matrix_element_lumo_lumo)
			return matrix_element_lumo_lumo, lambda_in_el, dE_el_intra, lambda_out_el, dE_out_el


	### end get intramoleculat data 
	else:
		#	subpath = os.getcwd()+'/subroutines'
		output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +str(DIPRO_J_AB_datafile)),stdout=subprocess.PIPE)
		output_line = output_subscript.stdout.read()	
		#	check if the rate was already calculated in the opposite direction
		if output_line == '':
			output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid2)+'_'+str(resid1)+'_' + ' ' +str(DIPRO_J_AB_datafile)),stdout=subprocess.PIPE)
			output_line = output_subscript.stdout.read()
		time_count=0
		while output_line == '':
			output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +str(DIPRO_J_AB_datafile)),stdout=subprocess.PIPE)
			output_line = output_subscript.stdout.read()
			if (time_count ==  time_count_max):
				output_line = '0.00001 0.00001 0.00001 0.00001 Dim_'+str(mol_type_1)+'_'+str(mol_type_2)+'_'+str(resid1)+'_'+str(resid2)+'_DIPRO_ERROR_G'+ str(frame_number) +'_N1'
			time.sleep(0.1)
			time_count = time_count + 1
			#check if the process is in the queue
			grep_subscript = subprocess.Popen(shlex.split('qstat -f'),stdout=subprocess.PIPE)
			grep_line = grep_subscript.stdout.read()
			if '_' +str(resid1)+'_'+str(resid2)+'_' not in grep_line:
				grep_line=''
				if grep_line=='' and (time_count%time_count_resubmit)==0:
						if ( silent_mode_off ):
							print 'still waiting for matrix element for indices ' + '_' +str(resid1)+'_'+str(resid2)+'_' 
							print 'resubmitting dipro'
						select_DIPRO=[False,True,False,False,False]
						DIPRO_sub([indexA,subindexB,'el',calculation_number,select_DIPRO])
						### enable otf restart
#				print "Would you like to resubmit Resid: "+str(resid1)+" and Resid: "+str(resid2)+"?"
#				print "Please add "+str(resid1)+'_'+str(resid2)+"restart to the control_file"
#				control_file=open('./control_file')
#				while 1:
#					line1 = control_file.readline()															#to avoid smaug killing
#					if not line1:
#						break
#					if line1[0] != '#':
#						if str(line1).replace('\n','') == str(str(resid1)+'_'+str(resid2)+'restart'):
#							print 're-submitting dipro'
#							DIPRO_sub([indexA,subindexB])
				###
		if ( silent_mode_off ):		
			print output_line.split('  ')[:],'  ### DIPRO_output_grep_results '
		#### Funktion fuer Matrixelement aus Fit vom Abstand z.B.
		if output_line.split(' ')[0] == 'Fehler:':
			matrix_element_lumo_lumo = dipro_electron_matrix_fit(resid1,resid2,frame_number,J_AB_fit_method_geometry)
			######## info output
			info_out=open(info_out_filename,'a')
			info_out.write('DIPRO error at index: '+str(resid1)+' to '+str(resid2)+ '\n')
			info_out.write('using fit function '+ '\n')
			info_out.close()
			######## info output
		elif output_line.split(' ')[2] == 'Das_Paar_wurde_fuer_DIPRO_aussortiert_MA_>_15_Ang_':
			matrix_element_lumo_lumo = dipro_electron_matrix_fit(resid1,resid2,frame_number,J_AB_fit_method_geometry)
			######## info output
			info_out=open(info_out_filename,'a')
			info_out.write('distance too far at index: '+str(resid1)+' to '+str(resid2)+ '\n')
			info_out.write('using fit function '+ '\n')
			info_out.close()
			######## info output
		else:	
			#### calculate the marcus rate
			#print output_line.split(' ')[1]
			#print output_line
			try:
				### get matrix_element_lumo_lumo = float(output_line.split('  ')[4])
				use_dipro_matrix_fit,S_AB_homo_homo,matrix_element_homo_homo,S_AB_lumo_lumo,matrix_element_lumo_lumo=DIPRO_line_split(output_line,debug)
				if (use_dipro_matrix_fit):
					matrix_element_lumo_lumo = dipro_electron_matrix_fit(resid1,resid2,frame_number,J_AB_fit_method_geometry)  #Ausname, verwende Fit
			except ValueError:
				print "Error: DIPRO output_line not a float", output_line.split('  ')[4]
				print "Check: DIPRO outputfile "
				print output_line , '### output_line nach ValueError'
				print "Use dipro_electron_matrix_fit",resid1,resid2
				matrix_element_lumo_lumo = dipro_electron_matrix_fit(resid1,resid2,frame_number,J_AB_fit_method_geometry)  #Ausname, verwende Fit
		### get_lambda_dE for electrons
		lambda_in_el, dE_in_el, lambda_out_el, dE_out_el = get_lambda_dE(indexA, subindexB, lambda_in_method, lambda_out_method, 'electron')
		## ggf. Skalierung der Uebergangsmatrixelemente
		if scale_J_AB:
			matrix_element_lumo_lumo = scale_dipro_function_el(y_scale_method,x_scale_method,matrix_element_lumo_lumo)
	return matrix_element_lumo_lumo, lambda_in_el, dE_in_el, lambda_out_el, dE_out_el

####

def hole_get_results_from_dat(indexA,subindexB):
	global calculation_number
	#### get the resid's and the path for the subroutines
	resid1 = groList[indexA/2][0][0]
	resid2 = groList[int(distList[indexA+1][subindexB])][0][0]
	mol_type_1= groList[indexA/2][0][1]
	mol_type_2=groList[int(distList[indexA+1][subindexB])][0][1]
	charge_type='hole'

	#### DIPRO or |J_AB| intramolecular: ###
	if (intramolecular_charge_transfer_on and  (mol_type_1[:3] == 'THP' and mol_type_2[:3] == 'THP') and (resid1 == resid2 + 1 or resid1 + 1 == resid2) and not ( (groList[(resid1)][-1][1] == 'THP32' and groList[(resid2)][0][1] == 'THP1A') or (groList[(resid2)][-1][1] == 'THP32' and groList[(resid1)][0][1] == 'THP1A')) ):
		if charge_type == 'lo' or charge_type == 'hole':
				matrix_element_homo_homo, dE_lo_intra , matrix_element_lumo_lumo, dE_el_intra = calc_intramolecular_rate_P3HT([resid1,resid2,'hole'])
		elif charge_type == 'el' or charge_type == 'electron':
				matrix_element_homo_homo, dE_lo_intra , matrix_element_lumo_lumo, dE_el_intra = calc_intramolecular_rate_P3HT([resid1,resid2,'electron'])
		### get_lambda_dE for holes
		lambda_in_lo, dE_in_lo, lambda_out_lo, dE_out_lo = get_lambda_dE(indexA, subindexB, lambda_in_method, lambda_out_method, 'hole')
		## ggf. Skalierung der Uebergangsmatrixelemente
		if scale_J_AB:
			matrix_element_homo_homo = scale_dipro_function_lo(y_scale_method,x_scale_method,matrix_element_homo_homo)
		return matrix_element_homo_homo, lambda_in_lo, dE_lo_intra, lambda_out_lo, dE_out_lo


	elif ( intramolecular_charge_transfer_on and (mol_type_1 == '8poly') and (mol_type_2 == '8poly') and ((resid1 == resid2+1) or (resid1+1 == resid2)) ): 
		### exclude intramolecular transport if resid1 is the last element in the chain and resid2 the first element in the chain or vice versa => else DIPRO
		### (resid1=ende and resid2=start) OR (resid2=start and resid1=ende)
		if not ( ( ('CH3'==groList[(resid1)][-1][2][-3:]) and ('F'==groList[(resid2)][4][2][-1]) ) or ( ('CH3'==groList[(resid2)][-1][2][-3:]) and ('F'==groList[(resid1)][4][2][-1]) ) ): 
			#calc_intramolecular_data_PBDT_TS1([resid1,resid2,'hole'])
			if ( silent_mode_off ):
				print 'using fit for intramolecular electron transport for PBDT-TS1'	
			if charge_type == 'lo' or charge_type == 'hole':
					matrix_element_homo_homo, dE_lo_intra , matrix_element_lumo_lumo, dE_el_intra = calc_intramolecular_data_PBDT_TS1([resid1,resid2,'hole'])
			elif charge_type == 'el' or charge_type == 'electron':
					matrix_element_homo_homo, dE_lo_intra , matrix_element_lumo_lumo, dE_el_intra = calc_intramolecular_data_PBDT_TS1([resid1,resid2,'electron'])
			### get_lambda_dE for holes
			lambda_in_lo, dE_in_lo, lambda_out_lo, dE_out_lo = get_lambda_dE(indexA, subindexB, lambda_in_method, lambda_out_method, 'hole')
			## ggf. Skalierung der Uebergangsmatrixelemente
			if scale_J_AB:
				matrix_element_homo_homo = scale_dipro_function_lo(y_scale_method,x_scale_method,matrix_element_homo_homo)
			return matrix_element_homo_homo, lambda_in_lo, dE_lo_intra, lambda_out_lo, dE_out_lo

	
	else: ### grep DIPRO data from DIPRO_J_AB_datafile
		#	subpath = os.getcwd()+'/subroutines'            
		output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +str(DIPRO_J_AB_datafile)),stdout=subprocess.PIPE)
		output_line = output_subscript.stdout.read()	
		#	check if the rate was already calculated in the opposite direction
		if output_line == '':
			output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid2)+'_'+str(resid1)+'_' + ' ' +str(DIPRO_J_AB_datafile)),stdout=subprocess.PIPE)
			output_line = output_subscript.stdout.read()
		time_count=0
		while output_line == '':
			output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +str(DIPRO_J_AB_datafile)),stdout=subprocess.PIPE)
			output_line = output_subscript.stdout.read()
			if (time_count ==  time_count_max):
				output_line = '0.00001 0.00001 0.00001 0.00001 Dim_'+str(mol_type_1)+'_'+str(mol_type_2)+'_'+str(resid1)+'_'+str(resid2)+'_DIPRO_ERROR_G'+ str(frame_number) +'_N1'
			time.sleep(0.1)
			time_count = time_count+1
			#check if the process is in the queue
			grep_subscript = subprocess.Popen(shlex.split('qstat -f'),stdout=subprocess.PIPE)
			grep_line = grep_subscript.stdout.read()
			if '_' +str(resid1)+'_'+str(resid2)+'_' not in grep_line:
				grep_line=''
			if grep_line=='' and (time_count%time_count_resubmit)==0:
				if ( silent_mode_off ):
					print 'still waiting for matrix element for indices ' + '_' +str(resid1)+'_'+str(resid2)+'_'
					print 'resubmitting dipro'
				select_DIPRO=[False,True,False,False,False]
				DIPRO_sub([indexA,subindexB,'lo',calculation_number,select_DIPRO]) 
				### enable otf restart
			#	print "Would you like to resubmit Resid: "+str(resid1)+" and Resid: "+str(resid2)+"?"
			#	print "Please add '"+str(resid1)+'_'+str(resid2)+"restart' to the control_file"
			#	control_file=open('./control_file')
			#	while 1:
			#		line1 = control_file.readline()															#to avoid smaug killing
			#		if not line1:
			#			break
			#		if line1[0] != '#':
			#			if str(line1).replace('\n','') == str(str(resid1)+'_'+str(resid2)+"restart"):
			#				print 're-submitting dipro'
			#				DIPRO_sub([indexA,subindexB])
			###
			#if (time_count %time_count_resubmit)==0:
			#	print 'still waiting for lambda for indices ' + '_' +str(resid1)+'_'+str(resid2)+'_' 
		if ( silent_mode_off ):
			print output_line.split('  ')[:]
		### end grep DIPRO data	
		#### Funktion fuer Matrixelement aus Fit vom Abstand z.B.
		if output_line.split(' ')[0] == 'Fehler:':
			matrix_element_homo_homo = dipro_hole_matrix_fit(resid1,resid2,frame_number,J_AB_fit_method_geometry)
			######## info output
			info_out=open(info_out_filename,'a')
			info_out.write('DIPRO error at index: '+str(resid1)+' to '+str(resid2)+ '\n')
			info_out.write('using fit function '+ '\n')
			info_out.close()
			######## info output
		elif output_line.split(' ')[2] == 'Das_Paar_wurde_fuer_DIPRO_aussortiert_MA_>_15_Ang_':
			matrix_element_homo_homo = dipro_hole_matrix_fit(resid1,resid2,frame_number,J_AB_fit_method_geometry)
			######## info output
			info_out=open(info_out_filename,'a')
			info_out.write('distance too far at index: '+str(resid1)+' to '+str(resid2)+ '\n')
			info_out.write('using fit function '+ '\n')
			info_out.close()
			######## info output
		else:	
			#### calculate the marcus rate
			#print output_line.split(' ')[1]
			#print output_line
			try: 
				### get matrix_element_homo_homo = float(output_line.split('  ')[2])   # Convert sting to float
				use_dipro_matrix_fit,S_AB_homo_homo,matrix_element_homo_homo,S_AB_lumo_lumo,matrix_element_lumo_lumo=DIPRO_line_split(output_line,debug)
				if (use_dipro_matrix_fit):
					matrix_element_homo_homo = dipro_hole_matrix_fit(resid1,resid2,frame_number,J_AB_fit_method_geometry)  #Ausname, verwende Fit
			except ValueError:
				print "Error: DIPRO output_line not a float", output_line.split('  ')[1]
				print "Check: DIPRO outputfile "
				print output_line[:]
				print "Use dipro_hole_matrix_fit",resid1,resid2
				matrix_element_homo_homo = dipro_hole_matrix_fit(resid1,resid2,frame_number,J_AB_fit_method_geometry)  #Ausname, verwende Fit
		### get_lambda_dE for holes
		lambda_in_lo, dE_in_lo, lambda_out_lo, dE_out_lo = get_lambda_dE(indexA, subindexB, lambda_in_method, lambda_out_method, 'hole')
		## ggf. Skalierung der Uebergangsmatrixelemente
		if scale_J_AB:
			matrix_element_homo_homo = scale_dipro_function_lo(y_scale_method,x_scale_method,matrix_element_homo_homo)

	return matrix_element_homo_homo, lambda_in_lo, dE_in_lo, lambda_out_lo, dE_out_lo


################################## subroutine for checking active threads ##################################
############################################################################################################
def wait_for_active_threads(number_of_parallel_threads):
	if (threading.active_count() != number_of_parallel_threads):
		print 'still waiting for threads to finish'
		print str(threading.active_count()) + ' threads still running'
		print str(threading.enumerate())    + ' threads still running'
	while (int(threading.active_count()) > int(number_of_parallel_threads)):
		time.sleep(1)
############################################################################################################
############################################################################################################



##################################subroutine for getting the lambdas########################################
################################## and the reorganization energies  ########################################

def get_lambda_dE(indexA, subindexB,  lambda_in_method, lambda_out_method, charge_type):
	global calculation_number
	#get the resids from index and subindex
	resid1 = groList[indexA/2][0][0]
	resid2 = groList[int(distList[indexA+1][subindexB])][0][0]
	mol_type_1= groList[indexA/2][0][1]
	mol_type_2=groList[int(distList[indexA+1][subindexB])][0][1]
	lambda_in_reverse_order = False
	if lambda_in_method=='otf':
		lambda_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +'./subroutines/lambda_in/results_lambda_in_G'+ str(frame_number) +'.dat'),stdout=subprocess.PIPE)
		lambda_line = lambda_subscript.stdout.read()
		#search if the rate was already calculated in the oppisite direction
		if lambda_line == '':
			lambda_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid2)+'_'+str(resid1)+'_' + ' ' +'./subroutines/lambda_in/results_lambda_in_G'+ str(frame_number) +'.dat'),stdout=subprocess.PIPE)
			lambda_line = lambda_subscript.stdout.read()
			if not (lambda_line == ''):
				lambda_in_reverse_order = True
            
		time_count=0
		resubmitted = False
		while lambda_line == '':
			lambda_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +'./subroutines/lambda_in/results_lambda_in_G'+ str(frame_number) +'.dat'),stdout=subprocess.PIPE)
			lambda_line = lambda_subscript.stdout.read()
			if (time_count ==  time_count_max):
				lambda_line = '0.00001 0.00001 0.00001 0.00001 0.00001 0.00001   Dim_'+str(mol_type_1)+'_'+str(mol_type_2)+'_'+str(resid1)+'_'+str(resid2)+'_lambda_in_'+str(charge_type)+'_ERROR_G'+ str(frame_number)+'_lam_in' 
			time.sleep(3)
			time_count = time_count+1
			if (time_count%time_count_resubmit)==0:
				print 'still waiting for lambda_in for indices ' + '_' +str(resid1)+'_'+str(resid2)+'_' 
				### enable otf restart
				print "Would you like to resubmit Resid: "+str(resid1)+" and Resid: "+str(resid2)+"?"
				print "Please add "+str(resid1)+'_'+str(resid2)+"restart to the control_file"
				control_file=open('./control_file')
				if resubmitted == False:
					if ( silent_mode_off ):
						print 're-submitting lambda_in '
					select_lambda_in=[False,False,False,True,False]
					if charge_type == 'hole':
						DIPRO_sub([indexA,subindexB,'lo',calculation_number,select_lambda_in])
					elif charge_type == 'electron':
						DIPRO_sub([indexA,subindexB,'el',calculation_number,select_lambda_in])
					resubmitted = True
				else:	
					while 1:
						line1 = control_file.readline()															#to avoid smaug killing
						if not line1:
							break
						if line1[0] != '#':
							if str(line1).replace('\n','') == str(str(resid1)+'_'+str(resid2)+"restart"):
								if ( silent_mode_off ):
									print 're-submitting lambda_in'
								select_lambda_in=[False,False,False,True,False]
								if charge_type == 'hole':
									DIPRO_sub([indexA,subindexB,'lo',calculation_number,select_lambda_in])
								elif charge_type == 'electron':
									DIPRO_sub([indexA,subindexB,'el',calculation_number,select_lambda_in])					
				###
#			if (time_count % time_count_resubmit)==0:
#				print 'still waiting for lambda for indices ' + '_' +str(resid1)+'_'+str(resid2)+'_' 
		if ( silent_mode_off ):
			print lambda_line.split(' ')[:],'### lambda_in_line'

	if lambda_out_method=='otf':	
### Hier koennte eine Methode fuer die lambda_out bei intramolecularem Transfer definiert werden; jedoch scheint es sinnvoll lambda_out unabhaengig vom intra und intermolecular transfer zu definieren       
		if ((mol_type_1[:3] == 'THP' and mol_type_2[:3] == 'THP') and (resid1 == resid2 + 1 or resid1 + 1 == resid2) and not ( (groList[(resid1)][-1][1] == 'THP32' and groList[(resid2)][0][1] == 'THP1A') or (groList[(resid2)][-1][1] == 'THP32' and groList[(resid1)][0][1] == 'THP1A')) ):
			lambda_out_line = p3ht_internal_lambda_out(resid1, resid2, charge_type)
		else:
			if charge_type == 'hole':
				lambda_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +'./subroutines/results_lambda_out_lo_G'+ str(frame_number) +'.dat'),stdout=subprocess.PIPE)
			elif charge_type == 'electron':
				lambda_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +'./subroutines/results_lambda_out_el_G'+ str(frame_number) +'.dat'),stdout=subprocess.PIPE)
			lambda_out_line = lambda_subscript.stdout.read()	
            
			# check if lambda was already calculated in the opposite direction
			if lambda_out_line == '':
				if charge_type == 'hole':
					lambda_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid2)+'_'+str(resid1)+'_' + ' ' +'./subroutines/results_lambda_out_lo_G'+ str(frame_number) +'.dat'),stdout=subprocess.PIPE)
				elif charge_type == 'electron':
					lambda_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid2)+'_'+str(resid1)+'_' + ' ' +'./subroutines/results_lambda_out_el_G'+ str(frame_number) +'.dat'),stdout=subprocess.PIPE)
				lambda_out_line = lambda_subscript.stdout.read()
                
			time_count=0
			resubmitted = False
			while lambda_out_line == '':
				if charge_type == 'hole':
					lambda_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +'./subroutines/results_lambda_out_lo_G'+ str(frame_number) +'.dat'),stdout=subprocess.PIPE)
				elif charge_type == 'electron':
					lambda_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +'./subroutines/results_lambda_out_el_G'+ str(frame_number) +'.dat'),stdout=subprocess.PIPE)
				lambda_out_line = lambda_subscript.stdout.read()
				if (time_count ==  time_count_max):
					lambda_out_line = '   0.00001 -0.00001                           Dim_DIPBI_DIPBI_'+str(resid1)+'_'+str(resid2)+'_lambda_out_PBE0_6-31G#_'+str(charge_type)+'_ERROR_G'+ str(frame_number) +'_lambda_out'
				time.sleep(3)
				time_count = time_count+1
				if (time_count %time_count_resubmit)==0:
					print 'still waiting for lambda_out for indices ' + '_' +str(resid1)+'_'+str(resid2)+'_' 
					### enable otf restart
					print "Would you like to resubmit Resid: "+str(resid1)+" and Resid: "+str(resid2)+"?"
					print "Please add "+str(resid1)+'_'+str(resid2)+"restart to the control_file"
					control_file=open('./control_file')
					if resubmitted == False:
						if ( silent_mode_off ):
							print 're-submitting lambda_out'
						select_lambda_out=[False,False,False,False,True]
						if charge_type == 'hole':
							DIPRO_sub([indexA,subindexB,'lo',calculation_number,select_lambda_out])
						elif charge_type == 'electron':
							DIPRO_sub([indexA,subindexB,'el',calculation_number,select_lambda_out])
						resubmitted = True
					else:
						while 1:
							line1 = control_file.readline()															#to avoid smaug killing
							if not line1:
								break
							if line1[0] != '#':
								if str(line1).replace('\n','') == str(str(resid1)+'_'+str(resid2)+"restart"):
									if ( silent_mode_off ):
										print 're-submitting lambda_out'
									select_lambda_out=[False,False,False,False,True]
									if charge_type == 'hole':
										DIPRO_sub([indexA,subindexB,'lo',calculation_number,select_lambda_out])
									elif charge_type == 'electron':
										DIPRO_sub([indexA,subindexB,'el',calculation_number,select_lambda_out])	
	if lambda_out_method=='otf':    
		if ( silent_mode_off ):    
			print lambda_out_line.split('  ')[:] ,' ### lambda_out_line'

	if lambda_in_method=='static':
		if charge_type == 'hole':
			lambda_in =lambda_in_dE_arr[0][0]  #0.22
			dE_in = lambda_in_dE_arr[2][0]  #0
		elif charge_type == 'electron':
			lambda_in =lambda_in_dE_arr[1][0]  #0.22
			dE_in = lambda_in_dE_arr[3][0]  #0
	elif lambda_in_method=='gaussian':
		### gaussian DOS as in ref. andrieko
		if charge_type == 'hole':
			mu=lambda_in_dE_arr[0][0] ## 0.22, 0.03
			sigma=lambda_in_dE_arr[0][1] 
		elif charge_type == 'electron':
			mu=lambda_in_dE_arr[1][0] 
			sigma=lambda_in_dE_arr[1][1]
		lambda_in = np.random.normal(mu, sigma)
		if charge_type == 'hole':
			mu=lambda_in_dE_arr[2][0] 
			sigma=lambda_in_dE_arr[2][1] 
		elif charge_type == 'electron':
			mu=lambda_in_dE_arr[3][0]
			sigma=lambda_in_dE_arr[3][1] 
		dE_in = np.random.normal(mu, sigma) 
	elif lambda_in_method=='fit':
		if charge_type == 'hole':
			lambda_in, dE_in = lambda_in_dE_in_hole_lambda_fit(resid1,resid2)
		elif charge_type == 'electron':
			lambda_in, dE_in = lambda_in_dE_in_electron_lambda_fit(resid1,resid2)
	elif lambda_in_method=='from_matrix':
		if charge_type == 'hole':
			lambda_in, dE_in = lambda_in_dE_in_hole_matrix_fit(resid1,resid2)
		elif charge_type == 'electron':
			lambda_in, dE_in = lambda_in_dE_in_electron_matrix_fit(resid1,resid2)
	else:
		#### Funktion fuer lambda_in error handling
		if lambda_line.replace('    ',' ').replace('   ',' ').replace('  ',' ').split(' ')[0] == 'Fehler:':
			### hier matrix fit einbauen
			if charge_type == 'hole':
				lambda_in, dE_in = lambda_in_dE_in_hole_matrix_fit(resid1,resid2)
			elif charge_type == 'electron':
				lambda_in, dE_in = lambda_in_dE_in_electron_matrix_fit(resid1,resid2)

			######## info output
			info_out=open(info_out_filename,'a')
			info_out.write('lambda_in error at index: '+str(resid1)+' to '+str(resid2)+ '\n')
			info_out.write('using matrix_fit '+ '\n')
			info_out.close()
			######## info output
		else:	
			#### calculate the marcus rate
			#lambda_line=lambda_line.replace('\t',' ').replace('     ',' ').replace('    ',' ').replace('   ',' ').replace('  ',' ').split(' ')[:]
        		delimiters=['\n','\t','      ','     ','    ','   ','  ',' ']
        		### substitute the dilimiters with one space
        		for d in delimiters:
            			lambda_line=lambda_line.replace(d,' ')
        		### split string to list and remove empty elements with the filter
        		lambda_line=filter(None, lambda_line.split(' '))
			if debug:		
				print 'lambda_in split:',lambda_line[0],lambda_line[1],lambda_line[2],lambda_line[3],lambda_line[4],lambda_line[5]
			if charge_type == 'hole':
				if lambda_in_reverse_order:
					lambda_in = float(lambda_line[4])
				else:
					lambda_in = float(lambda_line[3])
				dE_in = float(lambda_line[5])
			elif charge_type == 'electron':
				if lambda_in_reverse_order:
					lambda_in = float(lambda_line[1])
				else:
					lambda_in = float(lambda_line[0])
				dE_in = float(lambda_line[2])

	if lambda_out_method == 'otf':
		if lambda_out_line != '':
			if debug:
				print 'lambda_out line:',lambda_out_line[:]
			delimiters=['\n','\t','      ','     ','    ','   ','  ',' ']
        		### substitute the dilimiters with one space
        		for d in delimiters:
				lambda_out_line=lambda_out_line.replace(d,' ')
        		### split string to list and remove empty elements with the filter
			lambda_out_line=filter(None,lambda_out_line.split(' '))
			if debug:
				print 'split lambda_out line:',lambda_out_line[0],lambda_out_line[1],lambda_out_line[2]
			if ((lambda_out_line[0] == 'Fehler:') or (lambda_out_line.replace('    ',' ').replace('   ',' ').replace('  ',' ').split(' ')[0] == 'Fehler:')):
				### hier matrix fit einbauen
				lambda_out=0.0
				dE_out=0.0
				######## info output
				info_out=open(info_out_filename,'a')
				info_out.write('lambda_out error at index: '+str(resid1)+' to '+str(resid2)+ '\n')
				info_out.write('using fit function (not implemented)'+ '\n')
				info_out.close()
				######## info output
			else:	
				#### calculate the marcus rate
				#print output_line.split(' ')[1]
				#print lambda_line
			
				lambda_out = float(lambda_out_line[0])
				dE_out = float(lambda_out_line[1])
		else: 
			### No string lambda_out_line ==> set to zero 
			lambda_out=0.0
			dE_out=0.0
	else: 
		### No lambda_out_method selected == set to zero 
		lambda_out=0.0
		dE_out=0.0
	if (debug):
		print lambda_in, dE_in, lambda_out, dE_out, '### lambda_in, dE_in, lambda_out, dE_out'	
	return lambda_in, dE_in, lambda_out, dE_out	
	

#################################### end grab the results####################################################################################################################
#############################################################################################################################################################################



################ Start: check_mobility #######################################################################################################################################
#### function to check if the mobility is converged (mobility_conv_criterion gives the relative difference between two steps                                              ####
#### read_mobility_data_from_file = True, the data is read from the files:mobility_filename                                                                               ####
#### check_N_latest_mobility_steps: sets the number of the latest mobilities that should be checked.                                                                      ####
#### function returns a list of boolean values mobility_conv=[ mob_el, mob_lo ,mob_total ] for convergence                                                                ####
#### and the mob_list [N_Steps, t / s , mob_el, mob_lo ,mob_total ]                                                                                                       ####
#### mobility_conv, mob_list =check_mobility(mobility_filename,mob_list,mobility_conv_criterion,check_N_latest_mobility_steps,read_mobility_data_from_file,debug)         ####
def check_mobility(mobility_filename,mob_list,mobility_conv_criterion,check_N_latest_mobility_steps,read_mobility_data_from_file,debug):                                  ####
	
	####### read mobility data from file if = True in the list of arrays mob_list ######################
	if (not read_mobility_data_from_file):		
		read_mobility_data_from_file = False

	mobility_conv=[ False, False, False, False]
	#print 'Read_mobility_data_from_file: ',read_mobility_data_from_file
	if os.path.isfile(mobility_filename) and (read_mobility_data_from_file):
		print 'Reading mobility data from file: '+str(mobility_filename)
		mobility_filename_out=open(mobility_filename,'r')
		mob_list=[]
		N_mobilities=0
		while 1:
			line1 =mobility_filename_out.readline()
			if not line1:
				break
			line = line1.split()
			if line1[0] != '#':
				#print line
				mobility_arr=np.asarray(line[0:5], dtype=float)
				### liste mit np.array mit den mobilitaeten 
				mob_list.append(mobility_arr)
				#print float(line[0]),float(line[1]),float(line[2]),float(line[3]),float(line[4]),line[5]
				if (debug):
					print 'mobility data read:', mobility_arr[0], mobility_arr[1], mobility_arr[2], mobility_arr[3], mobility_arr[4]
				N_mobilities=N_mobilities+1
		if (debug):
			print 'End reading mobilities'
		### make sure that the mobility data is only read once per kMC-Calculation
		read_mobility_data_from_file = False
		mobility_filename_out.close()
	####### Ende read mobility data from file:mobility_filename if = True in the list of arrays mob_list ###################
	
	###### check mobility convergence in mob_list 
	if( not read_mobility_data_from_file):
		N_mobilities=len(mob_list)
	#print 'Start mob check B',N_mobilities,check_N_latest_mobility_steps
	if (N_mobilities > check_N_latest_mobility_steps):
		### j =0,1,2 index for the different mobilities 0= electrons, 1=holes, 2= total
		for j in range(3):
			N_below_limit=0
			### chose the last "check_N_latest_mobility_steps" steps of the mobility calculation.
			for i in range((N_mobilities-check_N_latest_mobility_steps),N_mobilities):
				if debug:
					print 'i-1 list',mob_list[i-1][:]
					print 'i list',mob_list[i][:]
					print 'rel_diff: ',abs(abs(mob_list[i-1][j+2])-abs(mob_list[i][j+2]))/abs(mob_list[i][j+2])
				rel_diff=abs(abs(mob_list[i-1][j+2])-abs(mob_list[i][j+2]))/abs(mob_list[i][j+2])
				if (rel_diff < mobility_conv_criterion[j]):
					N_below_limit=N_below_limit+1
			### check if mobility j was in the last "check_N_latest_mobility_steps" steps below the mobility_conv_criterion
			if debug:
				print 'N_below_limit:',N_below_limit
			if (N_below_limit >= check_N_latest_mobility_steps):
				mobility_conv[j]= True
				
		if debug:
			print 'N_mobilities:',N_mobilities
			print 'mobility_conv_criterion:',mobility_conv_criterion
			print 'mobility_conv:',mobility_conv
			print 'relative change rel_diff=|x_(i-1)-x_i|/|x_i| in last steps for:'
			print '1) N_steps 2) time 3) mu_el 4) mu_hole 5) mu_total'
			for i in range(N_mobilities-check_N_latest_mobility_steps,N_mobilities):
				print abs(abs(mob_list[i-1][:])-abs(mob_list[i][:]))/abs(mob_list[i][:])
		
		
		### check if all mobilities converged 
		j=0
		for i in range(len(mobility_conv)-1):
			if (mobility_conv[i]) :
				j=j+1
			if (i == (len(mobility_conv)-2)):
				if (j == (len(mobility_conv)-1)): 
					print 'mobility converged with mobility_conv_criterion: ',mobility_conv_criterion
					info_out=open(info_out_filename,'a')
					info_out.write('mobility converged with mobility_conv_criterion: ',mobility_conv_criterion + '\n')
					for i in range(len(mob_list)-1):
						info_out.write(str(mob_list[i]) + '\n')
					info_out.close()
					mobility_conv[3]= True
					mobility_arr = calc_mobility(kmc_traj_filename,kmc_out,xbox,ybox,zbox,mob_infostring+str(' mobility_converged'),k_B,T,mobility_arr,debug)
				else:
					print 'mobility is not converged'

		
	return mobility_conv,mob_list
##################End check_mobility ####################################################################

############## Start calc_mobility ######################################################################
#### function to calculate the mobility due to MSD_hole_el_Einstein (stand 12.06.17)
def calc_mobility(kmc_traj_filename,kmc_out,xbox,ybox,zbox,mob_infostring,k_B,T,mobility_arr,debug):
	###selects if msd outputfiles are created
	msd_output= False
	### file exists?
	if os.path.isfile(kmc_traj_filename):
		if (not kmc_out.closed):
			kmc_out.close()
			kmc_out=open(kmc_traj_filename,'r') #reads more data
		elif kmc_out.closed:
			#print 'geschlossenes file'
			kmc_out=open(kmc_traj_filename,'r') #reads more data
		
		
		##### Start mobility calculation #####
		##### input & output files
		if (msd_output):
			msd_out=open("msd.dat", 'w' )
			msd_el_out=open("msd_el.dat", 'w' )
			msd_lo_out=open("msd_lo.dat", 'w' )
		
		##### variables
		i=0
		n=0
		l=0
		k=0
		charge_list=[]
		old_charge_list=[]
		vectorial_charge_flow=np.asarray([0,0,0])
		number_of_holes=0
		number_of_electrons=0
		MSD=0.0
		MSD_el=0.0
		MSD_lo=0.0
		#k_B=8.6173303E-5   ### eV/K
		#T=300   ## K Temperatur
		time=0.0
		time_t0=0.0 
		vecbox=np.asarray([xbox,ybox,zbox])
		mob_infostring=' '+str(mob_infostring)
		
		### read mob_infostring
		print 'Use: '+str(kmc_traj_filename)+' '+str(xbox)+' '+str(ybox)+' '+str(zbox)+' '+str(mob_infostring)+' '+str(k_B)+' '+str(T)+' K'
		
		
		##### analyse the trajectory
		while 1:
			line1 = kmc_out.readline()
			if not line1:
				break
			##comment line will be skiped
			if (line1[0] == '#'):
				print 'Comment: ',line1.rstrip("\n")
				continue
			if i==0: 
				number_of_charges=int(line1)
				MSD_charge_k=np.zeros(shape=(number_of_charges))
			if( i==1 and n>=1):
				splitted_line=line1.split()
				time=float(splitted_line[3])
				## save time_t0 as starting time of kmc_traj as this is only written always after the second step, if the calculation did not start with time_t0=0.0
				if n==1: 
					time_t0=time
					print ('use starting time_t0: '+ str(time_t0) +' [s]')
					### Determine the number of holes an electrons in a frame
					for j in range(number_of_charges):
						if ( debug ):
							print j,old_charge_list[j][0] 
						if old_charge_list[j][0] == 'hole':
							number_of_holes=number_of_holes + 1
						elif old_charge_list[j][0] == 'electron':
							number_of_electrons=number_of_electrons + 1
					print('charges:'+str(number_of_charges)+' electrons:'+str(number_of_electrons)+' holes:'+str(number_of_holes))
			if i>=2:
				splitted_line=line1.split()
				charge_list.append(splitted_line)
			#if i>=2:
			#	splitted_line=line1.split()
			#	gridx=int(float(splitted_line[1])/boxx*subboxes)
			#	gridy=int(float(splitted_line[2])/boxy*subboxes)
			#	gridz=int(float(splitted_line[3])/boxz*subboxes)
			#	# for every charge in grid_box[x][y][z] a 0 is appended
			#	grid_box[gridx][gridy][gridz].append(0)
			if i==number_of_charges+2:
				if n!=0: #exclude the first step
					while l<number_of_charges:
						if old_charge_list[l] not in charge_list:
							while k<number_of_charges:
								if charge_list[k] not in old_charge_list:
									#use this to get output in words to check program
									#print('Atom '+str(l) +' moved from '+str(old_charge_list[l])+' to position '+str(k)+' at coords: '+str(charge_list[k]))
									vec1=np.asarray([float(startlocations[l][1]),float(startlocations[l][2]),float(startlocations[l][3])])
									try:
										vec2=np.asarray([float(charge_list[k][1]),float(charge_list[k][2]),float(charge_list[k][3])])
									except IndexError:
										print 'Error in mobility calculation'
										print 'charge_list: '+str(charge_list[k])
										exit()
									for i in range(3):
										if vec2[i]-vec1[i]<-vecbox[i]/2:
									#		print('vector '+str(i)+'	'+str(vec2[i]-vec1[i]))
											vec2[i]=vec2[i]+vecbox[i]
									#		print('corrected to '+str(vec2[i]-vec1[i]))
										elif vec2[i]-vec1[i]>vecbox[i]/2:
									#		print('minus vector '+str(i)+'	'+str(vec2[i]-vec1[i]))
											vec2[i]=vec2[i]-vecbox[i]
									#		print('corrected to '+str(vec2[i]-vec1[i]))
									##### vec1 is the old location, vec2 is the new location of the particle
									##### use this to calc the MSD
									##### note: only 1 charge moves in 1 step
									if charge_list[k][0] == 'electron':
										MSD_el=MSD_el + np.sqrt(np.dot((vec1-vec2),(vec1-vec2)))
									if charge_list[k][0] == 'hole':
										MSD_lo=MSD_lo + np.sqrt(np.dot((vec1-vec2),(vec1-vec2)))
									MSD_charge_k[k]=MSD_charge_k[k]+np.sqrt(np.dot((vec1-vec2),(vec1-vec2)))
									MSD=MSD + np.sqrt(np.dot((vec1-vec2),(vec1-vec2)))
									#vectorial_charge_flow = vectorial_charge_flow + (vec2-vec1)
								k=k+1		
						l=l+1	
				else: #first step
					startlocations=charge_list
				l=0
				i=0
				k=0
				n=n+1
				old_charge_list = charge_list
				charge_list=[]
				if n%1000==0:
					if (msd_output):
						if (not msd_out.closed):
							msd_out.write(str(time-time_t0)+'	'+str(MSD/float(number_of_charges))+'\n')
						if (not msd_el_out.closed):
							msd_el_out.write(str(time-time_t0)+'	'+str(MSD_el/float(number_of_electrons))+'\n')
						if (not msd_lo_out.closed):
							msd_lo_out.write(str(time-time_t0)+'	'+str(MSD_lo/float(number_of_holes))+'\n')
			i=i+1
		
		print('use finishing time: '+ str(time) +' [s]')
		MSD=MSD/float(number_of_charges)
		MSD_el=MSD_el/float(number_of_electrons)
		MSD_lo=MSD_lo/float(number_of_holes)
		print(str(MSD) + ' total MSD')
		print(str(MSD_el) + ' total electron MSD')
		print(str(MSD_lo) + ' total hole MSD')
		#print('found vectorial flow ' + str(vectorial_charge_flow))
		#print('mobility: '+str(10.0**(-20)*MSD/(2*3*float(time-time_t0))) +' m**2 / s')
		#print('electron mobility: '+str(10.0**(-20)*MSD_el/(2*3*float(time-time_t0))) +' m**2 / s')
		#print('hole mobility: '+str(10.0**(-20)*MSD_lo/(2*3*float(time-time_t0))) +' m**2 / s')
		
		### mobility, square displacement for individual charges, be carefull mobility is only defind as the average over N (Where N is the number of particles to be averaged)
	#	for j in range(number_of_charges):
	#		print( str(j+1)+' '+old_charge_list[j][0]+' '+str(1.0E-16*MSD_charge_k[j]/(2*3*float(time-time_t0)) *1.0/(k_B*T) ) +' cm**2 / Vs'+'   MSD:' + str(MSD_charge_k[j]) )
		
		### mobility in cm**2 /Vs
		mobility_sum=1.0E-16*MSD/(2*3*float(time-time_t0))*1.0/(k_B*T)   
		mobility_el=1.0E-16*MSD_el/(2*3*float(time-time_t0))*1.0/(k_B*T) 
		mobility_lo=1.0E-16*MSD_lo/(2*3*float(time-time_t0))*1.0/(k_B*T)
		if(debug):
			print('electron mobility: '+str(mobility_el) +' cm**2 / Vs')
			print('hole mobility: '+str(mobility_lo) +' cm**2 / Vs')
			print('mobility: '+str(mobility_sum)  +' cm**2 / Vs')		
		
		if os.path.exists(mobility_filename):
			mobility_out=open(str(mobility_filename) , 'a')
		else:
			mobility_out=open(str(mobility_filename) , 'w')
			mobility_out.write('### mobility with 1) Number of *.xyz steps: n 2) simulation time t-t0 [s] 3) mobility_el [cm**2/Vs]   4) mobility_lo [cm**2/Vs]  5) mobility_sum [cm**2/Vs]  6) traj_in *.xyz ' + '\n' )
		
		mobility_out.write(str(n)+' '+str(float(time-time_t0))+' '+str(float(mobility_el))+' '+str(float(mobility_lo))+' '+str(float(mobility_sum))+'        '+str(kmc_traj_filename) +' '+str(mob_infostring) + '\n')
		mobility_out.close()
		
		mobility_arr=np.asarray([ n, float(time-time_t0),mobility_el,mobility_lo,mobility_sum])
		if(debug):
			print 'Mobility output: '+str(n)+' '+str(float(time-time_t0))+' '+str(float(mobility_el))+' '+str(float(mobility_lo))+' '+str(float(mobility_sum))+'        '+str(kmc_traj_filename) +' '+str(mob_infostring)

		if (not kmc_out.closed):
			#print 'offenes file'
			kmc_out.close()
			kmc_out=open(kmc_traj_filename,'a') #write more data

		return mobility_arr

######################################## Ende calc_mobility ###################################
###############################################################################################










##################################### start fit functions ###################################################
############################################################################################################
def p3ht_internal_lambda_out(resid1, resid2, charge_type):
## lambda_out may be negative for small intermolecular distances - this is unphysical
	return '0 0 0 0 0 0'

## Functions need to be defined.
def lambda_in_dE_in_hole_lambda_fit(resid1,resid2):
	return 0.01, 0.0

def lambda_in_dE_in_hole_lambda_fit(resid1,resid2):
	return 0.01, 0.0


#########################################################################################
####### Start dipro_electron_matrix_fit #################################################
##### Transition matrix element |J_AB| LUMO A to LUMO B calculated via geometry coordinates and fit functions (COM_H,MA,MMA,Lin_Comb) ####
def dipro_electron_matrix_fit(resid1,resid2,frame_number,J_AB_fit_method_geometry):
	COM, COM_H, MA, MMA, theta, grep_error = get_coord_data_for_pair(resid1,resid2,frame_number)	
	#print( COM, COM_H, MA, MMA, theta, '### Geometriedaten')
	
	### Adapt names, as fits are not available for most molecules
	mol_type_1='DIPBI'  ##mol_type_1 = groList[(resid1)][0][1]
	mol_type_2='DIPBI'  ##mol_type_2 = groList[(resid2)][0][1]

	### check, if error occured before ; return 0
	if grep_error:
		j=0	
		while j < len(distList[resid1]):
			if distList[resid1*2+1][j] == resid2:
				break
			j=j+1
		COM_H = distList[resid1*2][j]
		J_AB_fit_method_geometry='COM_H'
		if ( silent_mode_off ):
			print 'use COM_H from sorted_neighbour_list ',COM_H
		grep_error= False
	

	if grep_error:
		matrix_element_lumo_lumo = 0.00000000000000001
	else:
		### Fits fuer P3MT / P3MT
		if (mol_type_1[:3] == 'THP' and mol_type_2[:3] == 'THP'): 
		### Fits fuer LUMO_A to LUMO_B 85grad fur P3HT-Ketten PM3
			if('MA' == J_AB_fit_method_geometry or 'Lin_Combi' == J_AB_fit_method_geometry ):
				## x=MA  ;   y= -2.236-0.66354*x  | y= log10(|abs(J_AB)) [eV], R=0.63
				matrix_element_lumo_lumo=10**(-2.236-0.66354*MA)
				print(' MA    PM3 fit:',matrix_element_lumo_lumo)
			elif('MMA' == J_AB_fit_method_geometry): 
				## x=MMA ;   y= -2.9808-0.11197*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_lumo_lumo=10**(-2.9808-0.11197*MMA)
				print(' MMA   PM3 fit:',matrix_element_lumo_lumo)
			elif('COM_H' == J_AB_fit_method_geometry):
				## x=COM_H ; y= -2.3523-0.14167*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_lumo_lumo=10**(-2.3523-0.14167*COM_H)
				print(' COM_H PM3 fit:',matrix_element_lumo_lumo)
			else:
				print ('Fehler: Method for J_AB_fit_method_geometry is not available, Return 0')
				matrix_element_lumo_lumo = 0.00000000000000001
	
		### Fits fuer P3MT / DIPBI
		elif((mol_type_1[:3] == 'THP' and mol_type_2[:5] == 'DIPBI') or (mol_type_1[:5] == 'DIPBI' and mol_type_2[:3] == 'P3HT')): 
		### Fits fuer LUMO_A to LUMO_B  P3MT/DIPBI PM3
			if('MA' == J_AB_fit_method_geometry or 'Lin_Combi' == J_AB_fit_method_geometry ):
				## x=MA  ;   y= -2.7577-0.82274*x  | y= log10(|abs(J_AB)) [eV], R=0.55
				matrix_element_lumo_lumo=10**(-2.7577-0.82274*MA)	
				print(' MA    PM3 fit:',matrix_element_lumo_lumo)
			elif('MMA' == J_AB_fit_method_geometry):		
				## x=MMA ;   y= -2.1555-0.38188*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_lumo_lumo=10**(-2.1555-0.38188*MMA)
				print(' MMA   PM3 fit:',matrix_element_lumo_lumo)
			elif('COM_H' == J_AB_fit_method_geometry):
				## x=COM_H ; y= -3.9572-0.057061*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_lumo_lumo=10**(-3.9572-0.057061*COM_H)
				print(' COM_H PM3 fit:',matrix_element_lumo_lumo)
			else:
				print ('Fehler: Method for J_AB_fit_method_geometry is not available, Return 0')
				matrix_element_lumo_lumo=0.00000000000000001
	
		elif((mol_type_1[:5] == 'DIPBI' and mol_type_2[:5] == 'DIPBI') ): 
		### Fits fuer LUMO_A to LUMO_B fur 3752 Paare DIPBI/DIPBI PM3
			if('MA' == J_AB_fit_method_geometry or 'Lin_Combi' == J_AB_fit_method_geometry ):
				## x=MA  ;   y= -0.57837-1.0094*x  | y= log10(|abs(J_AB)) [eV], R=0.964 (relativ guter Fit)
				matrix_element_lumo_lumo=10**(-0.57837-1.0094*MA)
				print(' MA    PM3 fit:',matrix_element_lumo_lumo)
			elif('MMA' == J_AB_fit_method_geometry): 
				## x=MMA ;   y= +0.67757-0.71548*x  | y= log10(|abs(J_AB)) [eV], R=0,836
				matrix_element_lumo_lumo=10**(0.67757-0.71548*MMA)
				print(' MMA   PM3 fit:',matrix_element_lumo_lumo)
			elif('COM_H' == J_AB_fit_method_geometry):
				## x=COM_H ; y= 0.074096-0.47174*x  | y= log10(|abs(J_AB)) [eV], R=0,695
				matrix_element_lumo_lumo=10**(0.074096-0.47174*COM_H)
				print(' COM_H PM3 fit:',matrix_element_lumo_lumo)
			else:
				print ('Fehler: Method for J_AB_fit_method_geometry is not available, Return 0')
				matrix_element_lumo_lumo=0.00000000000000001
		else:
			print ('Fehler: Selected Molecules not available, Return 0')
			return 0.00000000000000001
	
	if debug:
		print ' |J_AB| LUMO A to LUMO B Fit ',J_AB_fit_method_geometry,': ', matrix_element_lumo_lumo, 'for geometry data:',COM, COM_H, MA, MMA, theta 
	return matrix_element_lumo_lumo
####### Ende function dipro_electron_matrix_fit #########

####### Start function dipro_hole_matrix_fit ############
##### Transition matrix element |J_AB| HOMO A to HOMO B calculated via geometry coordinates and fit functions (COM_H,MA,MMA,Lin_Comb) ####
def dipro_hole_matrix_fit(resid1,resid2,frame_number,J_AB_fit_method_geometry):
	COM, COM_H, MA, MMA, theta, grep_error = get_coord_data_for_pair(resid1,resid2,frame_number)	
	#print( COM, COM_H, MA, MMA, theta, '### Geometriedaten') 

	### Adapt names, as fits are not available for most molecules
	mol_type_1='DIPBI'  ##mol_type_1 = groList[(resid1)][0][1]
	mol_type_2='DIPBI'  ##mol_type_2 = groList[(resid2)][0][1]

	### check, if error occured before ; return 0
	if grep_error:
		j=0	
		while j < len(distList[resid1]):
			if distList[resid1*2+1][j] == resid2:
				break
			j=j+1
		COM_H = distList[resid1*2][j]
		J_AB_fit_method_geometry='COM_H'
		if ( silent_mode_off ):
			print 'use COM_H from sorted_neighbour_list ',COM_H
		grep_error = False
	
	if grep_error:
		matrix_element_homo_homo = 0.00000000000000001
	else:
		### Fits fuer P3MT / P3MT
		if (mol_type_1[:3] == 'THP' and mol_type_2[:3] == 'THP'): 
		### Fits fuer HOMO_A to HOMO_B 80grad fur 4535 Paare P3MT PM3
			if('MA' == J_AB_fit_method_geometry):
				## x=MA  ;   y= -2.613-0.649*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_homo_homo=10**(-2.613-0.649*MA)
				print(' MA    PM3 fit:',matrix_element_homo_homo)
			elif('MMA' == J_AB_fit_method_geometry): 
				## x=MMA ;   y= -3.313-0.112*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_homo_homo=10**(-3.313-0.112*MMA)
				print(' MMA   PM3 fit:',matrix_element_homo_homo)
			elif('COM_H' == J_AB_fit_method_geometry):
				## x=COM_H ; y= -2.649-0.145*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_homo_homo=10**(-2.649-0.145*COM_H)
				print(' COM_H PM3 fit:',matrix_element_homo_homo)
			elif('Lin_Combi' == J_AB_fit_method_geometry):
				## mixed funciton y= log10(|abs(J_AB)) [eV] = A*MA +B*MMA+ C*COM_H +D 
				## A=-0.1083 ; B=-0.57546 ; C=7.64E-4 ; D=-1.50303
				matrix_element_homo_homo= 10**( -0.1083*MA-0.57546*MMA+7.6358E-4*COM_H-1.50303)
				print(' Mixed PM3 fit:',matrix_element_homo_homo)
	
			else:
				print ('Fehler: Method for J_AB_fit_method_geometry is not available, Return 0')
				matrix_element_homo_homo= 0.00000000000000001
	
		### Fits fuer P3MT / DIPBI
		elif((mol_type_1[:3] == 'THP' and mol_type_2[:5] == 'DIPBI') or (mol_type_1[:5] == 'DIPBI' and mol_type_2[:3] == 'P3HT')): 
		### Fits fuer HOMO_A to HOMO_B  80grad fur 1693 Paare P3MT/DIPBI PM3
			if('MA' == J_AB_fit_method_geometry):
				## x=MA  ;   y= -2.941-0.847*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_homo_homo=10**(-2.9408-0.84717*MA)	
				print(' MA    PM3 fit:',matrix_element_homo_homo)
			elif('MMA' == J_AB_fit_method_geometry):		
				## x=MMA ;   y= 2.3766-0.38643*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_homo_homo=10**(-2.3766-0.38643*MMA)
				print(' MMA   PM3 fit:',matrix_element_homo_homo)
			elif('COM_H' == J_AB_fit_method_geometry):
				## x=COM_H ; y= -4.298-0.053974*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_homo_homo=10**(-4.298-0.053974*COM_H)
				print(' COM_H PM3 fit:',matrix_element_homo_homo)
			elif('Lin_Combi' == J_AB_fit_method_geometry):
				## mixed funciton y= log10(|abs(J_AB)) [eV] = A*MA +B*MMA+ C*COM_H +D 
				## A=-0.43222 ; B=-0.16758 ; C=-0.0387 ; D=-2.2229
				matrix_element_homo_homo= 10**( -0.43222*MA-0.16758*MMA-0.0387*COM_H-2.2229)
				print(' Mixed PM3 fit:',matrix_element_homo_homo)
			else:
				print ('Fehler: Method for J_AB_fit_method_geometry is not available, Return 0')
				matrix_element_homo_homo= 0.00000000000000001
	
		elif((mol_type_1[:5] == 'DIPBI' and mol_type_2[:5] == 'DIPBI')): 
		### Fits fuer HOMO_A to HOMO_B fur 3752 Paare DIPBI/DIPBI PM3
			if('MA' == J_AB_fit_method_geometry or 'Lin_Combi' == J_AB_fit_method_geometry):
				## x=MA  ;   y= -0.43546-1.0429*x  | y= log10(|abs(J_AB)) [eV], R=0.968 (relativ guter Fit)
				matrix_element_homo_homo=10**(-0.43546-1.0429*MA)
				print(' MA    PM3 fit:',matrix_element_homo_homo)
			elif('MMA' == J_AB_fit_method_geometry):
				## x=MMA ;   y= +0.748-0.7548*x  | y= log10(|abs(J_AB)) [eV], R=0,824
				matrix_element_homo_homo=10**(0.748-0.7548*MMA)
				print(' MMA   PM3 fit:',matrix_element_homo_homo)
			elif('COM_H' == J_AB_fit_method_geometry):
				## x=COM_H ; y= 0.086734-0.7392*x  | y= log10(|abs(J_AB)) [eV]
				matrix_element_homo_homo=10**(0.086734-0.7392*COM_H)
				print(' COM_H PM3 fit:',matrix_element_homo_homo)
			else:
				print ('Fehler: Method for J_AB_fit_method_geometry is not available, Return 0')
				matrix_element_homo_homo= 0.00000000000000001

		else:	
			print ('Fehler: Selected Molecules not available, Return 0')
			return 0.00000000000000001
	if debug:
		print ' |J_AB| HOMO A to HOMO B Fit ',J_AB_fit_method_geometry,': ', matrix_element_homo_homo, 'for geometry data:',COM, COM_H, MA, MMA, theta 	
	return matrix_element_homo_homo
####### Ende function dipro_electron_matrix_fit ###############################################################################
###############################################################################################################################

###############################################################################################################################
#### Start function: get_coord_data_for_pair() in order to get geometry_data from res1_res2_COM_COM_H_MA_MMA*.dat files  ######
def get_coord_data_for_pair(resid1,resid2,frame_number):
	grep_error= False
	output_line=''	
	###### check if coord_data_for_pair is available 
	output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +'./subroutines/res1_res2_COM_COM_H_MA_MMA_theta_G'+ str(frame_number) +'.dat'),stdout=subprocess.PIPE)
	output_line = output_subscript.stdout.read()	
	if output_line == '':
		####### check if coord_data_for_pair already calculated in the reverse direction res1_res2_COM_COM_H_MA_MMA_theta_G'+ str(frame_number) +'.dat	
		output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid2)+'_'+str(resid1)+'_' + ' ' +'./subroutines/res1_res2_COM_COM_H_MA_MMA_theta_G'+ str(frame_number) +'.dat'),stdout=subprocess.PIPE)
		output_line = output_subscript.stdout.read()	
		if output_line == '':	
			###### check if coord_data_for_pair *raus.dat is available already calculated
			output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +'./subroutines/res1_res2_COM_COM_H_MA_MMA_theta_raus_G'+ str(frame_number) +'.dat'),stdout=subprocess.PIPE)
			output_line = output_subscript.stdout.read()	
			if output_line == '':
				####### check if the coord_data_for_paire  *raus.dat was already calculated in the reverse direction	
				output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid2)+'_'+str(resid1)+'_' + ' ' +'./subroutines/res1_res2_COM_COM_H_MA_MMA_theta_raus_G'+ str(frame_number) +'.dat'),stdout=subprocess.PIPE)
				output_line = output_subscript.stdout.read()	
				if output_line == '':	
					#### Return only 0.0 if no coordinates can be found
					print('Fehler: Fit failed in get_coord_data_for_pair in res1_res2_COM_COM_H_MA_MMA_theta_*/raus.dat return: 0.0 ')
					grep_error = True			
					return '0.0', '0.0', '0.0', '0.0', '0.0', grep_error # Return Error

	#print (output_line)	
	
	if output_line.split(' ')[0] == 'Fehler:' or output_line.split(' ')[1] == 'Fehler:':
		grep_error = True	
		print 'Fehler: while using grep _'+str(resid1)+'_'+str(resid2)+'_  in function get_coord_data_for_pair output_line: '+str(output_line)		
		return '0.0', '0.0', '0.0', '0.0', '0.0', grep_error # Return Error
	else:
		try:
			splitted_line=output_line.split() 
			COM=float(splitted_line[2]) 
			COM_H=float(splitted_line[3]) 
			MA=float(splitted_line[4]) 
			MMA=float(splitted_line[5])
			theta=float(splitted_line[6])
			#print str(COM), str(COM_H), str(MA), str(MMA), str(theta), '### COM, COM_H, MA, MMA [Ang], theta [grad]' 
			return COM, COM_H, MA, MMA, theta, grep_error
		except ValueError:
			print 'Fehler: ValueError_while_using_grep _'+str(resid1)+'_'+str(resid2)+'_  in function get_coord_data_for_pair. '+str(output_line)	
			grep_error = True			
			return '0.0', '0.0', '0.0', '0.0', '0.0', grep_error # Return Error
###### End function: get_coord_data_for_pair ##########################################################
#######################################################################################################



##### Skalierungsfunktion LUMO A to LUMO B #####
def scale_dipro_function_el(y_scale_method,x_scale_method,matrix_element_lumo_lumo):
	### Nutze gleiche Skalierungsfuntionen fuer lumo_lumo wie fuer homo_homo.		
	scaled_matrix_element_lumo_lumo= scale_dipro_function_lo(y_scale_method,x_scale_method,matrix_element_lumo_lumo)

	return scaled_matrix_element_lumo_lumo
#### ENDE Skalierungsfunktion LUMO A to LUMO B #########################################################################


#### Skalierungsfunktionen HOMO A to HOMO B fuer zwei ausgewaehlte methoden y_scale_method, x_scale_method #############
def scale_dipro_function_lo(y_scale_method,x_scale_method,matrix_element_homo_homo):
	scaled_matrix_element_homo_homo=[]
	if ( silent_mode_off ):
		print 'Start J_AB vor Skalierung '+str(matrix_element_homo_homo)
	if linear_scaling_J_AB:
		if y_scale_method=='CDFT' and x_scale_method=='PBE/6-311G**':
			#CDFT PBE PW	DIPRO PBE/6-311G**	0,10608	-0,0011761
			scaled_matrix_element_homo_homo=0.10608*matrix_element_homo_homo ##-0.0011761
		elif y_scale_method=='CDFT' and x_scale_method=='PM3':
			##CDFT PBE PW	PM3	0,29307	0,020483
			scaled_matrix_element_homo_homo=0.29307*matrix_element_homo_homo ##+0.020483
		elif y_scale_method=='CDFT' and x_scale_method=='DFTB':
			##CDFT PBE PW	DFTB	0,14369	0,0016371
			scaled_matrix_element_homo_homo=0.14369*matrix_element_homo_homo ##+0.0016371
		elif y_scale_method=='CDFT' and x_scale_method=='B3LYP/6-311G**':
			##P3MT	CDFT/PBE PW	B3LYP/ 6-311G**	0,094385	-0,0003627
			scaled_matrix_element_homo_homo=0.094385*matrix_element_homo_homo ##+0.0003627
		elif y_scale_method=='CDFT' and x_scale_method=='B3LYP/6-31G*':
			##P3MT	CDFT/PBE PW	B3LYP/ 6-31G*	0,087529	-0,00013053
			scaled_matrix_element_homo_homo=0.087529*matrix_element_homo_homo ##+0.00013053
		elif y_scale_method=='CDFT' and x_scale_method=='B3LYP/3-21G*':
			##P3MT	CDFT/PBE PW	B3LYP/ 3-21G*	0,089877	-0,00022794
			scaled_matrix_element_homo_homo=0.089877*matrix_element_homo_homo ##+0.00022794
		elif y_scale_method=='PBE/6-311G**' and x_scale_method=='PM3':
			## P3MT PBE/6-311G**  PM3 2.379*matrix_element_homo_homo##+0.02282
			scaled_matrix_element_homo_homo=2.379*matrix_element_homo_homo ##+0.02282
		elif y_scale_method=='PBE/6-311G**' and x_scale_method=='DFTB':
			scaled_matrix_element_homo_homo=1.3661*matrix_element_homo_homo ##+0.018968
		elif y_scale_method=='B3LYP/3-21G' and x_scale_method=='PM3':
			scaled_matrix_element_homo_homo=0.656*matrix_element_homo_homo ##-0.275		
		elif y_scale_method=='PM3' and x_scale_method=='DFTB':				
			scaled_matrix_element_homo_homo=0.97802*matrix_element_homo_homo ##-0.00114
		else:	# Wenn nicht die passenden ausgewaehlt wurden, dann gibt es keine Skalierung!
			scaled_matrix_element_homo_homo=matrix_element_homo_homo  
	else:	# Wenn nicht die passenden ausgewaehlt wurden, dann gibt es keine Skalierung!
		scaled_matrix_element_homo_homo=matrix_element_homo_homo  

	if ( silent_mode_off ):
		print 'Skaliertes J_AB am Ende '+str(scaled_matrix_element_homo_homo)
	return scaled_matrix_element_homo_homo
#### Ende Skalierungsfunktionen fuer zwei ausgewaehlte methoden y_scale_method, x_scale_method #####

################# Function to separate the DIPRO input line ##########################
def DIPRO_line_split(output_line,debug):
    ### function to separate the DIPRO inputline data, in the output_line
    ### replaces the dilimiters
    ### Usage: use_dipro_matrix_fit,S_AB_homo_homo,matrix_element_homo_homo,S_AB_lumo_lumo,matrix_element_lumo_lumo=DIPRO_line_split(output_line,debug)
    ### returns the Overlapp S_AB and Transitionmatrixelements J_AB or use_dipro_matrix_fit= False, if the convertion fail or no data is available
    use_dipro_matrix_fit = False
    if (debug):
        print 'DIPRO_line_split with output_line before splitting:',output_line.replace('\n',' ')
    ### Test is sting is empty        
    if (output_line):
        ### use these delimiters to 
        delimiters=['\n','\t','      ','     ','    ','   ','  ',' ']
        ### substitute the dilimiters with one space
        for d in delimiters:
            output_line=output_line.replace(d,' ')
        ### split'
	### split string to list and remove empty elements with the filter
        line=filter(None, output_line.split(' '))
        if(debug):
            print 'splitted line:',line[:]

        ### check if the start in the list is empty
        try:
            if (line[0] == ''):
                S_AB_homo_homo=check_nan(float(line[1]))
                matrix_element_homo_homo=check_nan(float(line[2]))
                S_AB_lumo_lumo=check_nan(float(line[3]))
                matrix_element_lumo_lumo=check_nan(float(line[4]))
            else:
                S_AB_homo_homo=check_nan(float(line[0]))
                matrix_element_homo_homo=check_nan(float(line[1]))
                S_AB_lumo_lumo=check_nan(float(line[2]))
                matrix_element_lumo_lumo=check_nan(float(line[3]))
            use_dipro_matrix_fit = False
            if (debug):
                print S_AB_homo_homo,matrix_element_homo_homo,S_AB_lumo_lumo,matrix_element_lumo_lumo, '### S_AB_homo_homo, matrix_element_homo_homo, S_AB_lumo_lumo, matrix_element_lumo_lumo'
            return use_dipro_matrix_fit,S_AB_homo_homo,matrix_element_homo_homo,S_AB_lumo_lumo,matrix_element_lumo_lumo
        except ValueError or IndexError:
            print 'Error: reading_the_DIPRO_data, replace data with use_dipro_matrix_fit.'
            use_dipro_matrix_fit = True
            return use_dipro_matrix_fit,'0.0','0.0','0.0','0.0'
    else:
        use_dipro_matrix_fit = True
        #if (debug):
        print 'Error: The DIPRO output_line is empty, replace data with use_dipro_matrix_fit.' 
        return use_dipro_matrix_fit,'0.0','0.0','0.0','0.0'
#######################################Function to separate the DIPRO input line ##################################################


############################################## Start PBDT-TS1-specific functions ########################################################################
###### Start function to convert the number of S-Atoms in a PBDT_TS chain to the index in the lambda_in and dE_in files #################################
def PBDT_TS1_S_to_index(N_Schwefel):
	### input N_Schwefel: Number of S atoms in the PBDT-TS1 chain
	### output index for lambda list in range [0,16]
	### offset index as PPDI is at position 1 in the inputfiles.
	offset_index=1 
	lambda_index=-1
	### index list index_lambda_list=[N_Schwefel = Anzahl der Schwefelatome, index_lambda_list ]
	index_lambda_list=[[0,0],[2,1],[6,2],[8,3],[10,4],[14,5],[16,6],[18,7],[22,8],[24,9],[26,10],[30,11],[32,12],[34,12],[38,13],[40,13],[42,13],[46,14],[48,14],[50,14],[54,15],[56,15],[58,15],[62,16],[64,16],[66,16]]	
	for ind in range(len(index_lambda_list[:])):
		#print ind,index_lambda_list[ind][0],index_lambda_list[i][1] 
		if (index_lambda_list[ind][0] == N_Schwefel):
			lambda_index=index_lambda_list[ind][1]

	if (lambda_index != -1 ): # lambda_index
		lambda_index=offset_index+lambda_index
	else: 
		######## info output
		### N_Schwefel does not match the index_lambda_list
		info_out=open(info_out_filename,'a')
		info_out.write('Error: Number of S-atoms in PBDT-TS1 chain does not match the lambda_index list: '+str(N_Schwefel)+' \n')
		info_out.write('exiting... '+ '\n')
		info_out.close()
		print ('Error: Number of S-atoms in PBDT-TS1 chain does not match the lambda_index list: '+str(N_Schwefel)+' \n')
		sys.exit()
		######## info output
	return lambda_index
###### End function to convert the number of S-Atoms in a PBDT_TS chain to the index in the lambda_in and dE_in files ##########################

### calculate the intramolecular data between PBDT_TS1 two subunits ##############################################
#### Intramolecular values for: matrix_element_homo_homo, dE_lo_intra, matrix_element_lumo_lumo, dE_el_intra #####
def calc_intramolecular_data_PBDT_TS1(param_list):
	if ( silent_mode_off ):
		print 'start: calc_intramolecular_data_PBDT_TS1'
	global calculation_number
	resid1=param_list[0]
	resid2=param_list[1]
	restype1 = groList[(resid1)][0][1]
	restype2 = groList[(resid2)][0][1]
	charge_type_intra=param_list[2]
	calc_intramolecular_data_new = True
	### Reset data
	matrix_element_homo_homo = 0.0
	matrix_element_lumo_lumo = 0.0
	dE_el_intra=0.0
	dE_lo_intra=0.0
	pbdt_order=''

	if (calc_intramolecular_data_new):
		### select PBDT-TS1 for intramolecular charge transfer
		if ( intramolecular_charge_transfer_on and (restype1 == '8poly') and (restype2 == '8poly') and ((resid1 == resid2+1) or (resid1+1 == resid2)) ):
			### exclude intramolecular transport if resid1 is the last element in the chain and resid2 the first element in the chain or vice versa => else DIPRO
			### (resid1=ende and resid2=start) OR (resid2=start and resid1=ende)
			if not ( ( ('CH3'==groList[(resid1)][-1][2][-3:]) and ('F'==groList[(resid2)][4][2][-1]) ) or ( ('CH3'==groList[(resid2)][-1][2][-3:]) and ('F'==groList[(resid1)][4][2][-1]) ) ): 
			
				### check AB or BA order ###
				### selects the resid2 = A, and checks if the [3] or [4] element in the list is a F-atom to identify the BA-order (select last element in string with [-1])
				if ( ('F' == str(groList[(resid2)][3][2][-1])) or ('F' == str(groList[(resid2)][4][2][-1])) ): 
					pbdt_order='BA'
				else:
					pbdt_order='AB'

				### get angle phi between subunits ###

				phi=get_angle_PBDT_TS1(resid1,resid2) 
				print pbdt_order
				### get the values for the matrix elements [J_AB_intra(phi)] and [dE_in_intra(phi)]
				if (pbdt_order == 'AB'):
					matrix_element_homo_homo=pbdt_angle_JAB_intra_list_lo_AB[int(phi*10)] 
					matrix_element_lumo_lumo=pbdt_angle_JAB_intra_list_el_AB[int(phi*10)] 
					## contains the intramolecular energy angle dependant parametrization
					dE_lo_intra=pbdt_dE_rate_list_lo_AB[int(phi*10)] 
					dE_el_intra=pbdt_dE_rate_list_el_AB[int(phi*10)] 
				elif (pbdt_order == 'BA'):
					## contains the intramolecular matrix element angle dependant parametrization
					matrix_element_homo_homo=pbdt_angle_JAB_intra_list_lo_BA[int(phi*10)] 
					matrix_element_lumo_lumo=pbdt_angle_JAB_intra_list_el_BA[int(phi*10)] 
					## contains the intramolecular energy angle dependant parametrization
					dE_lo_intra=pbdt_dE_rate_list_lo_BA[int(phi*10)] 
					dE_el_intra=pbdt_dE_rate_list_el_BA[int(phi*10)] 
			
			######## End intramolecular transfer ##########

	calculation_number[2] = calculation_number[2] + 1
	if(debug):
		print matrix_element_homo_homo, dE_lo_intra , matrix_element_lumo_lumo, dE_el_intra ,'### Data intra'
	return matrix_element_homo_homo, dE_lo_intra, matrix_element_lumo_lumo, dE_el_intra 	
########### end calculate the intramolecular rate between PBDT_TS1 two subunits ######

####### start get dihedral angle between PBDT-TS1-subunits #########################
def get_angle_PBDT_TS1(resid1,resid2):
	if(debug):
		print ('start: get_angle_PBDT_TS1')
	#stores the atom coordinates
	# increasing order resid1 < resid2 (otherwise the order is swaped, with min,max function)
	# coution, the AB order in here is the order in the gro file, not with respect o resid1 and resid2 (it may differ from the previous definition)
	#ring from where the charge starts
	mol_complex_from = groList[(min(resid1,resid2))]
	#ring where the charge goes
	mol_complex_where = groList[(max(resid1,resid2))]

	atoms_from = []
	atoms_where = []
	
	mol_type_of_from= mol_complex_from[-1][1]
	mol_type_of_where= mol_complex_where[0][1]
	pbdt_order=''

	### exclude intramolecular transport if resid1 is the last element in the chain and resid2 the first element in the chain or vice versa => else DIPRO
	### (resid1=ende and resid2=start) OR (resid2=start and resid1=ende)
	#if not ( ( ('CH3'==groList[(resid1)][-1][2][-3:]) and ('F'==groList[(resid2)][4][2][-1]) ) or ( ('CH3'==groList[(resid2)][-1][2][-3:]) and ('F'==groList[(resid1)][4][2][-1]) ) ): 


	### selects the larger resid, and checks if the [3] or [4] element in the list is a F-atom to identify the BA-order (select last element in string with [-1])
	### select BA-in the chain 
	if ('F' == str(groList[(max(resid1,resid2))][3][2][-1])): 
		pbdt_order='BA'
	else:
		pbdt_order='AB'

	if (pbdt_order == 'AB'): # Phi_index 0 1 0 1 => AB
		atom_a_ind_1=0
		atom_a_ind_2=1
		atom_b_ind_1=0 
		atom_b_ind_2=1
	elif (pbdt_order== 'BA'): #  Phi_index 3 2 0 14 => BA
		atom_a_ind_1=3
		atom_a_ind_2=2
		atom_b_ind_1=0 
		atom_b_ind_2=14	
	else:
		print 'Error: get_angle_PBDT_TS1'
		sys.exit()			

	#grab the last thiophene ring from first charge transfer complex
	for i in range(len(mol_complex_from)):
		# inverse counting
		l = (len(mol_complex_from)-1)-i
		# grab only the last thiophene ring
		if mol_type_of_from != mol_complex_from[l][1]:
			break
		atoms_from.append(mol_complex_from[l][4:7])
	#get the reversed order reversed, so it's right again
	#atoms_from = list(reversed(atoms_from))
	
	#print 'atoms_from'
	#print atoms_from

	#grab the first thiophene ring from second charge transfer complex
	for i in range(len(mol_complex_where)):
		# grab only the last thiophene ring
		if mol_type_of_where != mol_complex_where[i][1]:
			break
		atoms_where.append(mol_complex_where[i][4:7])
	
	#print 'atoms_where'
	#print atoms_where

	#cast to float
	for i in range(len(atoms_where)): 
		for j in range(3):
			atoms_where[i][j] = float(atoms_where[i][j])	

	for i in range(len(atoms_from)): 
		for j in range(3):
			atoms_from[i][j] = float(atoms_from[i][j])
	if (debug):
		print 'resid1',resid1
		print 'resid2',resid2	
		print 'mol_type_of_from',mol_type_of_from
		print 'mol_type_of_where',mol_type_of_where
		print 'pbdt_order:',pbdt_order
		print 'atom_a_ind_1:',atoms_from[atom_a_ind_1]
		print 'atom_a_ind_2:',atoms_from[atom_a_ind_2]
		print 'atom_b_ind_1:',atoms_where[atom_b_ind_1]
		print 'atom_b_ind_2:',atoms_where[atom_b_ind_2]
	#calculate the dihedral angle
	#get involved vectors
	a = np.asarray(np.asarray(atoms_from[atom_a_ind_2])-np.asarray(atoms_from[atom_a_ind_1]))
	b = np.asarray(np.asarray(atoms_where[atom_b_ind_1])-np.asarray(atoms_from[atom_a_ind_2]))
	c = np.asarray(np.asarray(atoms_where[atom_b_ind_2])-np.asarray(atoms_where[atom_b_ind_1]))
	
	#get the normal vectors of the surfaces
	n_1 = np.cross(a,b)
	n_1 = n_1 / np.linalg.norm(n_1)
	n_2 = np.cross(b,c)
	n_2 = n_2 / np.linalg.norm(n_2)

	#calculate angle
	#phi=np.arccos(np.dot(n_1,n_2))
	phi = np.arctan2(np.vdot(np.cross(n_1,n_2),b/np.linalg.norm(b)),np.vdot(n_1,n_2))
	phi = phi / (2.0*np.pi) * 360.0

	if(phi < 0.0):
		phi=phi+360.0

	
	if(debug):
		print str(phi) + ' ### phi, PBDT-TS1'
	return phi	
####### end get dihedral angle between PBDT-TS1-subunits #########################

############################################## END PBDT-TS1-specific functions ########################################################################




########### Start lambda in matrix ##################################################################################################
def lambda_in_dE_in_hole_matrix_fit(resid1,resid2):
	#anpassen!!
	#print groList[resid1]
	#print groList[resid2]
	restype1 = groList[(resid1)][0][1]
	restype2 = groList[(resid2)][0][1]
	if restype1[:3]=='THP': restype1 = 'P3MT'
	if restype2[:3]=='THP': restype2 = 'P3MT'
	length_chain_resid1=0
	length_chain_resid2=0
	c_helper=0
	if restype1 == 'P3MT':
		for c_helper in range(len(groList[resid1])):
			#count S atoms to get chain length
			length_chain_resid1 = length_chain_resid1 + groList[resid1][c_helper].count('    S')
	elif restype1 == 'DIPBI':
		#matrix element 33 contains info about DIPBI
		length_chain_resid1 = 33
	elif restype1 == 'PPDI_':
        	#matrix element 1 contains info about PPDI
        	length_chain_resid1 = 1
	elif restype1 == '8poly':
		print 'tmp:', 'length_chain_resid1',length_chain_resid1
        	#matrix element 1 contains info about PBDT-TS1
		for c_helper in range(len(groList[resid1])):
			#count S atoms to get chain length
			length_chain_resid1 = length_chain_resid1 + groList[resid1][c_helper].count('    S')
		### convert Number of S-Atoms in PBDT_TS1 to index in lambda_in-files	
        	length_chain_resid1 = PBDT_TS1_S_to_index(length_chain_resid1)  
		print 'tmp:', 'length_chain_resid1',length_chain_resid1
	elif restype1 == 'PtK2K':
        	#matrix elememt 1 contains info about PtK2K
        	length_chain_resid1 = 1
	elif restype1 == 'PtK3K':
        	#matrix elememt 2 contains info about PtK3K
        	length_chain_resid1 = 2
	elif restype1 == 'mCP__':
        	#matrix elememt 3 contains info about mCP
        	length_chain_resid1 = 3		
	elif restype1 == 'NPB__':
        	#matrix elememt 4 contains info about NPB
        	length_chain_resid1 = 4	
	elif restype1 == 'HDI__':
        	#matrix elememt 5 contains info about HDI__
        	length_chain_resid1 =5	
	elif restype1 == 'HDI_K':
        	#matrix elememt 5 contains info about HDI_K
        	length_chain_resid1 =5
	elif restype1 == 'TDI__':
        	#matrix elememt 6 contains info about TDI
        	length_chain_resid1 =6
	elif restype1 == 'TDI_K':
        	#matrix elememt 6 contains info about TDI with chain
        	length_chain_resid1 =6
	else:
		######## info output
		info_out=open(info_out_filename,'a')
		info_out.write('undefinded resid type: '+str(restype1)+' at resid: '+str(resid1)+ '\n')
		info_out.write('exiting... '+ '\n')
		info_out.close()
		sys.exit()
		######## info output

	c_helper=0	
	if restype2 == 'P3MT':
		for c_helper in range(len(groList[resid2])):
			#count S atoms to get chain length
			length_chain_resid2 = length_chain_resid2 + groList[resid2][c_helper].count('    S')
	elif restype2 == 'DIPBI':
		#matrix element 33 contains info about DIPBI
		length_chain_resid2 = 33
	elif restype2 == 'PPDI_':
        	#matrix element 1 contains info about PPDI
        	length_chain_resid2 = 1
	elif restype2 == '8poly':
		#print 'tmp:', 'length_chain_resid2',length_chain_resid2
		#print 'tmp: resid2',resid2
        	#matrix element 2 contains info about PBDT-TS1
		for c_helper in range(len(groList[resid2])):
			#count S atoms to get chain length
			length_chain_resid2 = length_chain_resid2 + groList[resid2][c_helper].count('    S')
		### convert Number of S-Atoms in PBDT_TS1 to index in lambda_in-files
		#print 'tmp:', 'length_chain_resid2',length_chain_resid2 	
        	length_chain_resid2 = PBDT_TS1_S_to_index(length_chain_resid2) 
		#print 'tmp:', 'length_chain_resid2',length_chain_resid2 
	elif restype2 == 'PtK2K':
        	#matrix element 1 contains info about PtK2K
        	length_chain_resid2 = 1
	elif restype2 == 'PtK3K':
        	#matrix element 2 contains info about PtK3K
        	length_chain_resid2 = 2
	elif restype2 == 'mCP__':
        	#matrix elememt 3 contains info about mCP
        	length_chain_resid2 = 3		
	elif restype2 == 'NPB__':
        	#matrix element 4 contains info about NPB
        	length_chain_resid2 = 4	
	elif restype2 == 'HDI__':
        	#matrix elememt 5 contains info about HDI__
        	length_chain_resid2 =5	
	elif restype2 == 'HDI_K':
        	#matrix elememt 5 contains info about HDI_K
        	length_chain_resid2 =5
	elif restype2 == 'TDI__':
        	#matrix elememt 6 contains info about TDI
        	length_chain_resid2 =6
	elif restype2 == 'TDI_K':
        	#matrix elememt 6 contains info about TDI with chain
        	length_chain_resid2 =6
	else:
		######## info output
		info_out=open(info_out_filename,'a')
		info_out.write('undefinded resid type: '+str(restype2)+' at resid: '+str(resid2)+ '\n')
		info_out.write('exiting... '+ '\n')
		info_out.close()
		sys.exit()
		######## info output
	if debug:
		print 'found a chain of length '+str(length_chain_resid1)+' at resid: '+str(resid1)
		print 'found a chain of length '+str(length_chain_resid2)+' at resid: '+str(resid2)
		print lambda_in_ho_matrix[length_chain_resid1-1][length_chain_resid2-1], ' ### lambda_in_ho_matrix'
		print dE_in_ho_matrix[length_chain_resid1-1][length_chain_resid2-1] , '    ### dE_in_ho_matrix'
	return lambda_in_ho_matrix[length_chain_resid1-1][length_chain_resid2-1], dE_in_ho_matrix[length_chain_resid1-1][length_chain_resid2-1]
#### end def lambda_in_dE_in_hole_matrix_fit


def lambda_in_dE_in_electron_matrix_fit(resid1,resid2):
	#anpassen!!
	#print groList[resid1]
	#print groList[resid2]
	restype1 = groList[(resid1)][0][1]
	restype2 = groList[(resid2)][0][1]
	if restype1[:3]=='THP': restype1 = 'P3MT'
	if restype2[:3]=='THP': restype2 = 'P3MT'
	length_chain_resid1=0
	length_chain_resid2=0
	c_helper=0
	if restype1 == 'P3MT':
		for c_helper in range(len(groList[resid1])):
			#count S atoms to get chain length
			length_chain_resid1 = length_chain_resid1 + groList[resid1][c_helper].count('    S')
	elif restype1 == 'DIPBI':
		#matrix elememt 33 contains info about DIPBI
		length_chain_resid1 = 33
	elif restype1 == 'PPDI_':
        	#matrix element 1 contains info about PPDI
        	length_chain_resid1 = 1
	elif restype1 == '8poly':
        	#matrix element 1 contains info about PBDT-TS1
		for c_helper in range(len(groList[resid1])):
			#count S atoms to get chain length
			length_chain_resid1 = length_chain_resid1 + groList[resid1][c_helper].count('    S')
		### convert Number of S-Atoms in PBDT_TS1 to index in lambda_in-files	
        	length_chain_resid1 = PBDT_TS1_S_to_index(length_chain_resid1)  
	elif restype1 == 'PtK2K':
        	#matrix elememt 1 contains info about PtK2K
        	length_chain_resid1 = 1
	elif restype1 == 'PtK3K':
        	#matrix elememt 2 contains info about PtK3K
        	length_chain_resid1 = 2
	elif restype1 == 'mCP__':
        	#matrix elememt 3 contains info about mCP
        	length_chain_resid1 = 3		
	elif restype1 == 'NPB__':
        	#matrix elememt 4 contains info about NPB
        	length_chain_resid1 = 4	
	elif restype1 == 'HDI__':
        	#matrix elememt 5 contains info about HDI__
        	length_chain_resid1 =5	
	elif restype1 == 'HDI_K':
        	#matrix elememt 5 contains info about HDI_K
        	length_chain_resid1 =5
	elif restype1 == 'TDI__':
        	#matrix elememt 6 contains info about TDI
        	length_chain_resid1 =6
	elif restype1 == 'TDI_K':
        	#matrix elememt 6 contains info about TDI with chain
        	length_chain_resid1 =6
	else:
		######## info output
		info_out=open(info_out_filename,'a')
		info_out.write('undefinded resid type: '+str(restype1)+' at resid: '+str(resid1)+ '\n')
		info_out.write('exiting... '+ '\n')
		info_out.close()
		sys.exit()
		######## info output
	c_helper=0	
	if restype2 == 'P3MT':
		for c_helper in range(len(groList[resid2])):
			#count S atoms to get chain length
			length_chain_resid2 = length_chain_resid2 + groList[resid2][c_helper].count('    S')
	elif restype2 == 'DIPBI':
		#matrix elememt 33 contains info about DIPBI
		length_chain_resid2 = 33
	elif restype2 == 'PPDI_':
        	#matrix element 1 contains info about PPDI
        	length_chain_resid2 = 1
	elif restype2 == '8poly':
        	#matrix element 2 contains info about PBDT-TS1
		for c_helper in range(len(groList[resid2])):
			#count S atoms to get chain length
			length_chain_resid2 = length_chain_resid2 + groList[resid2][c_helper].count('    S')
		### convert Number of S-Atoms in PBDT_TS1 to index in lambda_in-files	
        	length_chain_resid2 = PBDT_TS1_S_to_index(length_chain_resid2)  
	elif restype2 == 'PtK2K':
        	#matrix element 1 contains info about PtK2K
        	length_chain_resid2 = 1
	elif restype2 == 'PtK3K':
        	#matrix element 2 contains info about PtK3K
        	length_chain_resid2 = 2
	elif restype2 == 'mCP__':
        	#matrix elememt 3 contains info about mCP
        	length_chain_resid2 = 3		
	elif restype2 == 'NPB__':
        	#matrix element 4 contains info about NPB
        	length_chain_resid2 = 4	
	elif restype2 == 'HDI__':
        	#matrix elememt 5 contains info about HDI__
        	length_chain_resid2 =5	
	elif restype2 == 'HDI_K':
        	#matrix elememt 5 contains info about HDI_K
        	length_chain_resid2 =5
	elif restype2 == 'TDI__':
        	#matrix elememt 6 contains info about TDI
        	length_chain_resid2 =6
	elif restype2 == 'TDI_K':
        	#matrix elememt 6 contains info about TDI with chain
        	length_chain_resid2 =6
	else:
		######## info output
		info_out=open(info_out_filename,'a')
		info_out.write('undefinded resid type: '+str(restype2)+' at resid: '+str(resid2)+ '\n')
		info_out.write('exiting... '+ '\n')
		info_out.close()
		sys.exit()
		######## info output
	if debug:
		print 'found a chain of length '+str(length_chain_resid1)+' at resid: '+str(resid1)
		print 'found a chain of length '+str(length_chain_resid2)+' at resid: '+str(resid2)
		print lambda_in_el_matrix[length_chain_resid1-1][length_chain_resid2-1] , ' ### lambda_in_el_matrix'
		print dE_in_el_matrix[length_chain_resid1-1][length_chain_resid2-1] , '  ### dE_in_el_matrix'
	return lambda_in_el_matrix[length_chain_resid1-1][length_chain_resid2-1], dE_in_el_matrix[length_chain_resid1-1][length_chain_resid2-1]
### end def lambda_in_dE_in_electron_matrix_fit ###


########################################## fit functions ###################################################
############################################################################################################


####################################### get the marcus rate ################################################
############################################################################################################
def elec_marcus_rate(index1, index2, lambda_in, dE_in, lambda_out, dE_out):
	global calculation_number	
	#keep the box in mind
	dist = np.asarray(COM_list[index2])-np.asarray(COM_list[index1])
	for a in range(len(dist)):
		if (dist[a] > box_ang[a]/2.0): dist[a] = dist[a] - box_ang[a]
		elif (dist[a] < -box_ang[a]/2.0): dist[a] = dist[a] + box_ang[a]	
	#calculate the electric energy difference in eV	
	dE_U_ext = np.dot(dist,np.asarray(U))
	if (debug):	
		print 'potential energy difference: '+str(dE_U_ext)+' eV  < 0.1 eV'
		print 'lambda_in: ',lambda_in
		print 'lambda_out: ',lambda_out
		print 'k_B: ',k_B,' T: ',T
		print 'dE_U_ext: ',dE_U_ext
		print 'dE_in:  ',dE_in
		print 'dE_out: ',dE_out
		print 'el Marcus rate + :',np.sqrt(np.pi/((lambda_in+lambda_out)*k_B*T))/hbar*np.exp(-(dE_U_ext+dE_in+dE_out+(lambda_in+lambda_out))**2/(4*(lambda_in+lambda_out)*k_B*T))
		print 'el Marcus rate - :',np.sqrt(np.pi/((lambda_in+lambda_out)*k_B*T))/hbar*np.exp(-(dE_U_ext+dE_in+dE_out-(lambda_in+lambda_out))**2/(4*(lambda_in+lambda_out)*k_B*T))
				
	calculation_number[0] = calculation_number[0] + 1 ### count KMC_rates
	return np.sqrt(np.pi/((lambda_in+lambda_out)*k_B*T))/hbar*np.exp(-(dE_U_ext+dE_in+dE_out+(lambda_in+lambda_out))**2/(4*(lambda_in+lambda_out)*k_B*T))

## for holes because of inverse charge
def hole_marcus_rate(index1, index2, lambda_in, dE_in, lambda_out, dE_out):
	global calculation_number
	#keep the box in mind
	dist = np.asarray(COM_list[index2])-np.asarray(COM_list[index1])
	for a in range(len(dist)):
		if (dist[a] > box_ang[a]/2.0): dist[a] = dist[a] - box_ang[a]
		elif (dist[a] < -box_ang[a]/2.0): dist[a] = dist[a] + box_ang[a]
	#calculate the electric energy difference in eV		
	dE_U_ext = np.dot(dist,np.asarray(U))
	#inverse charge
	dE_U_ext = -dE_U_ext
	if (debug):
		print 'dist vector: ',dist[:]
		print '|dist_vector|: ',np.linalg.norm((dist))
		print 'U_ext: ',U[:]
		print '|U_ext|: ',np.linalg.norm(np.asarray(U))
		print 'potential energy difference: '+str(dE_U_ext)+' eV < 0.1 eV'
		print 'lambda_in: ',lambda_in
		print 'lambda_out: ',lambda_out
		print 'k_B: ',k_B,' T: ',T, 'hbar',hbar
		print 'dE_U_ext: ',dE_U_ext
		print 'dE_in: ',dE_in
		print 'dE_out: ',dE_out
		print '**2',(dE_U_ext+dE_in+dE_out-(lambda_in+lambda_out))**2, 'Nenner',4*(lambda_in+lambda_out)*k_B*T 
		print ' exp Marcus rate -: ',np.exp(-(dE_U_ext+dE_in+dE_out-(lambda_in+lambda_out))**2/(4*(lambda_in+lambda_out)*k_B*T))
		print ' exp Marcus rate +: ',np.exp(-(dE_U_ext+dE_in+dE_out+(lambda_in+lambda_out))**2/(4*(lambda_in+lambda_out)*k_B*T))
		print ' lo Marcus rate + :', np.sqrt(np.pi/((lambda_in+lambda_out)*k_B*T))/hbar*np.exp(-(dE_U_ext+dE_in+dE_out+(lambda_in+lambda_out))**2/(4*(lambda_in+lambda_out)*k_B*T))
		print ' lo Marcus rate - :', np.sqrt(np.pi/((lambda_in+lambda_out)*k_B*T))/hbar*np.exp(-(dE_U_ext+dE_in+dE_out-(lambda_in+lambda_out))**2/(4*(lambda_in+lambda_out)*k_B*T))
	calculation_number[0] = calculation_number[0] + 1 ### count KMC_rates	
	return np.sqrt(np.pi/((lambda_in+lambda_out)*k_B*T))/hbar*np.exp(-(dE_U_ext+dE_in+dE_out+(lambda_in+lambda_out))**2/(4*(lambda_in+lambda_out)*k_B*T))

####################################### get the marcus rate ################################################
############################################################################################################


##########################################build problist####################################################
############################################################################################################
###### calculates rates for electrons on the fly using the marcus rate subroutine
def build_elec_probList(index):
	global calculation_number
	global subjoblist
	elec_probList[index].append(distList[index][0])#rates
	elec_probList[index+1].append(distList[index][0])#indices
	elec_probList[index].append(0)#rates
	elec_probList[index+1].append(distList[index+1][1])#indices

	elec_matrixElementList[index].append(distList[index][0])#matrix elements
	elec_matrixElementList[index+1].append(distList[index][0])#indices
	elec_matrixElementList[index].append(0)#matrix elements
	elec_matrixElementList[index+1].append(distList[index+1][1])#indices
	
	elec_lambdaList[index].append(distList[index][0])#lambdas
	elec_lambdaList[index+1].append(distList[index][0])#indices
	elec_lambdaList[index].append(0)#lambdas
	elec_lambdaList[index+1].append(distList[index+1][1])#indices

	elec_dE_inList[index].append(distList[index][0])#energies
	elec_dE_inList[index+1].append(distList[index][0])#indices
	elec_dE_inList[index].append(0)#lambdas
	elec_dE_inList[index+1].append(distList[index+1][1])#indices

	elec_dE_out_List[index].append(distList[index][0])#energies
	elec_dE_out_List[index+1].append(distList[index][0])#indices
	elec_dE_out_List[index].append(0)#lambdas
	elec_dE_out_List[index+1].append(distList[index+1][1])#indices

	elec_lambda_out_List[index].append(distList[index][0])#energies
	elec_lambda_out_List[index+1].append(distList[index][0])#indices
	elec_lambda_out_List[index].append(0)#lambdas
	elec_lambda_out_List[index+1].append(distList[index+1][1])#indices

### here is how to read the molecule types
#	moltypeA = groList[index/2][0][1]
#	for subindex in range(len(distList[index]))[2:]:
#		moltypeB = groList[int(distList[index+1][subindex])][0][1]
###
	##### use old values for matrix elements if possible
	try:
		for l in range(len(distList[index]))[2:]:
			indexA = index
			subindexB = l
			resid1 = groList[indexA/2][0][0]
			resid2 = groList[int(distList[indexA+1][subindexB])][0][0]
			matrix_elem = elec_matrixElementList[index][l]
			if lambda_in_method == 'otf':
				lambda_in = elec_lambdaList[index][l]
				dE_in = elec_dE_inList[index][l]
			elif lambda_in_method == 'gaussian':
				mu, sigma = lambda_in_dE_arr[1][:] # 0.22, 0.03 mu, signa [eV]
				lambda_in = np.random.normal(mu, sigma)
				#eV
				mu, sigma = lambda_in_dE_arr[3][:] #0, 1
				dE_in = np.random.normal(mu, sigma) 
			elif lambda_in_method == 'static':
				lambda_in = lambda_in_dE_arr[1][0]
				dE_in= lambda_in_dE_arr[3][0]
			else:
				print 'Error: lambda_in method not defined! possibilities are: static, gaussian, otf, otf_oniom'
				print 'exiting'
				sys.exit()
			if lambda_out_method == 'otf':
				lambda_out = elec_lambda_out_List[index][l]
				dE_out = elec_dE_out_List[index][l]
			else:
				lambda_out = 0.0
				dE_out = 0.0
				
			marcusrate = np.abs(matrix_elem)**2 * elec_marcus_rate(resid1,resid2,lambda_in,dE_in,lambda_out,dE_out)
			if ( silent_mode_off ):
				print 'electron marcusrate with J_AB element', marcusrate,matrix_elem
				print  '_____________________________________________________________________________________________'
			elec_probList[index].append(marcusrate)

	##### if no old matrix elements are available, calculate them
	except IndexError:
	#### hier schleife zur submittierung
		for l in range(len(distList[index])):
			if l>1:	
				#check what kind of molecules are processed
				indexA = index
				subindexB = l		
				mol_type_1= groList[indexA/2][0][1]
				mol_type_2=groList[int(distList[indexA+1][subindexB])][0][1]
				resid1 = groList[indexA/2][0][0]
				resid2 = groList[int(distList[indexA+1][subindexB])][0][0]	
				####### for LUMO no fit is specified -> using HOMO data ######
				####### for LUMO no fit is specified -> using HOMO data ######	

				#check if the charge is transferring intramolecular and is not transferring from THP1A to THP32
				if ( intramolecular_charge_transfer_on and (mol_type_1[:3] == 'THP' and mol_type_2[:3] == 'THP') and (resid1 == resid2 + 1 or resid1 + 1 == resid2) and not ( (groList[(resid1)][-1][1] == 'THP32' and groList[(resid2)][0][1] == 'THP1A') or (groList[(resid2)][-1][1] == 'THP32' and groList[(resid1)][0][1] == 'THP1A')) ):
					#calc_intramolecular_rate_P3HT([resid1,resid2,'electron'])  
					if ( silent_mode_off ):
						print 'using fit for intramolecular electron transport'
				#check if the charge is transferring intramolecular and is not transferring from PBDT-TS1 to PBDT-TS1
				elif ( intramolecular_charge_transfer_on and (mol_type_1 == '8poly') and (mol_type_2 == '8poly') and ((resid1 == resid2+1) or (resid1+1 == resid2)) ): 
					### exclude intramolecular transport if resid1 is the last element in the chain and resid2 the first element in the chain or vice versa => else DIPRO
					### (resid1=ende and resid2=start) OR (resid2=start and resid1=ende)
					if not ( ( ('CH3'==groList[(resid1)][-1][2][-3:]) and ('F'==groList[(resid2)][4][2][-1]) ) or ( ('CH3'==groList[(resid2)][-1][2][-3:]) and ('F'==groList[(resid1)][4][2][-1]) ) ): 						
						#calc_intramolecular_data_PBDT_TS1([resid1,resid2,'electron'])
						if ( silent_mode_off ):
							print 'using fit for intramolecular electron transport for PBDT-TS1'
				else:
					###### check if rate was already calculated
					output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +str(DIPRO_J_AB_datafile)),stdout=subprocess.PIPE)
					output_line = output_subscript.stdout.read()	
					if output_line == '':
						####### check if the rate was already calculated in the reverse direction	
						output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid2)+'_'+str(resid1)+'_' + ' ' +str(DIPRO_J_AB_datafile)),stdout=subprocess.PIPE)
						output_line = output_subscript.stdout.read()	
						if output_line == '':
							if ( silent_mode_off ):	
								print 'submitting dipro for indices: '+str(resid1)+' '+str(resid2)
							DIPRO_sub([index,l,'el',calculation_number,[True]])
						else:	
							dipro_daten_output = open(str(DIPRO_J_AB_datafile), 'a')
							format_list = output_line.split()
							# use _%temp%_ to make swapping of indices possible
							dipro_daten_output.write(output_line.replace('_'+str(resid1)+'_','_%temp%_').replace('_'+str(resid2)+'_','_'+str(resid1)+'_').replace('_%temp%_','_'+str(resid2)+'_'))
							if ( silent_mode_off ):
								print 'using rate for indices: '+str(resid1)+' '+str(resid2) + ' from old rate from ' +str(resid2)+' '+str(resid1)
								print output_line.replace('_'+str(resid1)+'_','_%temp%_').replace('_'+str(resid2)+'_','_'+str(resid1)+'_').replace('_%temp%_','_'+str(resid2)+'_') , '   ### output_line.replace sub '		
							dipro_daten_output.close()		
						#######
					else:
						if ( silent_mode_off ):
							print 'rate for resid '+str(resid1)+' and resid '+str(resid2)+' already calculated'
				elec_probList[index+1].append(distList[index+1][l])#indices
				elec_matrixElementList[index+1].append(distList[index+1][l])#indices
				elec_lambdaList[index+1].append(distList[index+1][l])#indices
				elec_dE_inList[index+1].append(distList[index+1][l])#indices
				elec_lambda_out_List[index+1].append(distList[index+1][l])#indices
				elec_dE_out_List[index+1].append(distList[index+1][l])#indices
	
		#### grep the results
		#### calculate the marcus rate, denpendant on the DIPRO results

		for l in range(len(distList[index]))[2:]:
			indexA = index
			subindexB = l
			resid1 = groList[indexA/2][0][0]
			resid2 = groList[int(distList[indexA+1][subindexB])][0][0]
			### submit jobs in internal queuing system, if the subjoblist is not empty ###
			if sub_internal_queue and subjoblist:
				process_threads_with_queue(subjoblist,sub_one_calc_at_a_time,number_of_parallel_threads)
				subjoblist=[] 

			matrix_elem, lambda_in, dE_in, lambda_out, dE_out = elec_get_results_from_dat(index,l)
			if ( silent_mode_off ):
				print'electron elec_get_results_from_dat:',matrix_elem, lambda_in, dE_in, lambda_out, dE_out 
			marcusrate = np.abs(matrix_elem)**2 * elec_marcus_rate(resid1,resid2,lambda_in, dE_in,lambda_out,dE_out)
			if ( silent_mode_off ):
				print '%s'%"electron marcusrate with J_AB element: ",'%8.3E'%marcusrate,'%8.3E'%matrix_elem
				print  '_____________________________________________________________________________________________'
			elec_lambdaList[index].append(lambda_in)
			elec_dE_inList[index].append(dE_in)
			elec_matrixElementList[index].append(matrix_elem)
			elec_probList[index].append(marcusrate)
			elec_lambda_out_List[index].append(lambda_out)
			elec_dE_out_List[index].append(dE_out)



###### calculates rates for the holes on the fly using the marcus rate subroutine
def build_hole_probList(index):
	global calculation_number
	global subjoblist
	hole_probList[index].append(distList[index][0])#rates
	hole_probList[index+1].append(distList[index][0])#indices
	hole_probList[index].append(0)#rates
	hole_probList[index+1].append(distList[index+1][1])#indices

	hole_matrixElementList[index].append(distList[index][0])#matrix elements
	hole_matrixElementList[index+1].append(distList[index][0])#indices
	hole_matrixElementList[index].append(0)#matrix elements
	hole_matrixElementList[index+1].append(distList[index+1][1])#indices
	
	hole_lambdaList[index].append(distList[index][0])#lambdas
	hole_lambdaList[index+1].append(distList[index][0])#indices
	hole_lambdaList[index].append(0)#lambdas
	hole_lambdaList[index+1].append(distList[index+1][1])#indices

	hole_dE_inList[index].append(distList[index][0])#energies
	hole_dE_inList[index+1].append(distList[index][0])#indices
	hole_dE_inList[index].append(0)#lambdas
	hole_dE_inList[index+1].append(distList[index+1][1])#indices


	hole_dE_out_List[index].append(distList[index][0])#energies
	hole_dE_out_List[index+1].append(distList[index][0])#indices
	hole_dE_out_List[index].append(0)#lambdas
	hole_dE_out_List[index+1].append(distList[index+1][1])#indices

	hole_lambda_out_List[index].append(distList[index][0])#energies
	hole_lambda_out_List[index+1].append(distList[index][0])#indices
	hole_lambda_out_List[index].append(0)#lambdas
	hole_lambda_out_List[index+1].append(distList[index+1][1])#indices
### here is how to read the molecule types
#	moltypeA = groList[index/2][0][1]
#	for subindex in range(len(distList[index]))[2:]:
#		moltypeB = groList[int(distList[index+1][subindex])][0][1]
###
	##### use old values for matrix elements if possible
	try:
		for l in range(len(distList[index]))[2:]:
			indexA = index
			subindexB = l	
			resid1 = groList[indexA/2][0][0]
			resid2 = groList[int(distList[indexA+1][subindexB])][0][0]
			matrix_elem = hole_matrixElementList[index][l]
			if lambda_in_method == 'otf':
				lambda_in = hole_lambdaList[index][l]
				dE_in = hole_dE_inList[index][l]
			elif lambda_in_method == 'gaussian':
				mu, sigma = lambda_in_dE_arr[0][:]  #0.22, 0.03
				lambda_in = np.random.normal(mu, sigma)
				#eV
				mu, sigma = lambda_in_dE_arr[2][:] # 0, 1
				dE_in = np.random.normal(mu, sigma) 
			elif lambda_in_method == 'static':
				lambda_in = lambda_in_dE_arr[0][0]  #0.22
				dE_in= lambda_in_dE_arr[2][0]
			else:
				print 'Error: lambda_in method not defined! possibilities are: static, gaussian, otf, otf_oniom'
				print 'exiting'
				sys.exit()
			if lambda_out_method == 'otf':
				lambda_out = hole_lambda_out_List[index][l]
				dE_out = hole_dE_out_List[index][l]
			else:
				lambda_out = 0.0
				dE_out = 0.0
			marcusrate = np.abs(matrix_elem)**2 * hole_marcus_rate(resid1,resid2,lambda_in, dE_in,lambda_out,dE_out)
			if ( silent_mode_off ):
				print '%s'%"hole marcusrate with J_AB element: ",'%8.3E'%marcusrate,'%8.3E'%matrix_elem
			hole_probList[index].append(marcusrate)

	##### if no old matrix elements are available, calculate them
	except IndexError:
		#### hier schleife zur submittierung
		for l in range(len(distList[index])):
			if l>1:	
				#check what kind of molecules are processed
				indexA = index
				subindexB = l
				mol_type_1= groList[indexA/2][0][1]
				mol_type_2=groList[int(distList[indexA+1][subindexB])][0][1]
				resid1 = groList[indexA/2][0][0]
				resid2 = groList[int(distList[indexA+1][subindexB])][0][0]	
				#check if the charge is transferring intramolecular and is not transferring from THP1A to THP32
				if ( intramolecular_charge_transfer_on and (mol_type_1[:3] == 'THP' and mol_type_2[:3] == 'THP') and (resid1 == resid2 + 1 or resid1 + 1 == resid2) and not ( (groList[(resid1)][-1][1] == 'THP32' and groList[(resid2)][0][1] == 'THP1A') or (groList[(resid2)][-1][1] == 'THP32' and groList[(resid1)][0][1] == 'THP1A')) ):
					#calc_intramolecular_rate_P3HT([resid1,resid2,'hole'])
					if ( silent_mode_off ):
						print 'using fit for intramolecular hole transport for P3MT (no_submission)',resid1,resid2	
				#check if the charge is transferring intramolecular and is not transferring from PBDT-TS1 to PBDT-TS1
				elif ( intramolecular_charge_transfer_on and (mol_type_1 == '8poly') and (mol_type_2 == '8poly') and ((resid1 == resid2+1) or (resid1+1 == resid2)) ): 
					### exclude intramolecular transport if resid1 is the last element in the chain and resid2 the first element in the chain or vice versa => else DIPRO
					### (resid1=ende and resid2=start) OR (resid2=start and resid1=ende)
					if not ( ( ('CH3'==groList[(resid1)][-1][2][-3:]) and ('F'==groList[(resid2)][4][2][-1]) ) or ( ('CH3'==groList[(resid2)][-1][2][-3:]) and ('F'==groList[(resid1)][4][2][-1]) ) ): 
						calc_intramolecular_data_PBDT_TS1([resid1,resid2,'hole']) 
						
						if ( silent_mode_off ):
							print 'using fit for intramolecular hole transport for PBDT-TS1 (no_submission)',resid1,resid2	
								
				else:
					###### check if rate was already calculated
					output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +str(DIPRO_J_AB_datafile)),stdout=subprocess.PIPE)
					output_line = output_subscript.stdout.read()	
					if output_line == '':
						####### check if the rate was already calculated in the reverse direction	
						output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid2)+'_'+str(resid1)+'_' + ' ' +str(DIPRO_J_AB_datafile)),stdout=subprocess.PIPE)
						output_line = output_subscript.stdout.read()	
						if output_line == '':
							if ( silent_mode_off ):	
								print 'submitting dipro for indices: '+str(resid1)+' '+str(resid2)
							DIPRO_sub([index,l,'lo',calculation_number,[True]])
						else:	
							dipro_daten_output = open(str(DIPRO_J_AB_datafile), 'a')
							format_list = output_line.split()
							# use _%temp%_ to make swapping of indices possible
							dipro_daten_output.write(output_line.replace('_'+str(resid1)+'_','_%temp%_').replace('_'+str(resid2)+'_','_'+str(resid1)+'_').replace('_%temp%_','_'+str(resid2)+'_'))
							if ( silent_mode_off ):
								print 'using rate for indices: '+str(resid1)+' '+str(resid2) + ' from old rate from ' +str(resid2)+' '+str(resid1)
								print output_line.replace('_'+str(resid1)+'_','_%temp%_').replace('_'+str(resid2)+'_','_'+str(resid1)+'_').replace('_%temp%_','_'+str(resid2)+'_') +'   ### output_line.replace sub '
							dipro_daten_output.close()			
					#######		
					else:
						if ( silent_mode_off ):
							print 'rate for resid '+str(resid1)+' and resid '+str(resid2)+' already calculated'
			
				hole_probList[index+1].append(distList[index+1][l])#indices
				hole_matrixElementList[index+1].append(distList[index+1][l])#indices
				hole_lambdaList[index+1].append(distList[index+1][l])#indices
				hole_dE_inList[index+1].append(distList[index+1][l])#indices
				hole_lambda_out_List[index+1].append(distList[index+1][l])#indices
				hole_dE_out_List[index+1].append(distList[index+1][l])#indices
		
		#### grep the results
		#### calculate the marcus rate, denpendant on the DIPRO results
	
		for l in range(len(distList[index]))[2:]:
			indexA = index
			subindexB = l
			resid1 = groList[indexA/2][0][0]
			resid2 = groList[int(distList[indexA+1][subindexB])][0][0]
			### submit jobs in internal queuing system, if the subjoblist is not empty ###
			if sub_internal_queue and subjoblist:
				process_threads_with_queue(subjoblist,sub_one_calc_at_a_time,number_of_parallel_threads)
				subjoblist=[] 
			matrix_elem, lambda_in, dE_in, lambda_out, dE_out = hole_get_results_from_dat(index,l)
			if ( silent_mode_off ):
				print 'hole_get_results_from_dat output:',matrix_elem, lambda_in, dE_in, lambda_out, dE_out
			marcusrate = np.abs(matrix_elem)**2 * hole_marcus_rate(resid1,resid2,lambda_in, dE_in,lambda_out,dE_out)
			if ( silent_mode_off ):			
				print '%s'%"hole marcusrate with J_AB element: ",'%10.5E'%marcusrate,'%10.5E'%matrix_elem
				print  '_____________________________________________________________________________________________'
			hole_lambdaList[index].append(lambda_in)
			hole_matrixElementList[index].append(matrix_elem)
			hole_dE_inList[index].append(dE_in)
			hole_probList[index].append(marcusrate)
			hole_lambda_out_List[index].append(lambda_out)
			hole_dE_out_List[index].append(dE_out)
	
##########################################build problist####################################################
############################################################################################################

################################### here the rate evaluation part begins####################################
################################### the indices and .gro coordinates are given	############################
################################### in here you can "safely" mess around :)	############################

###### calculates the marcus rate between molecule "indexA" and neighbouring mol "subindexB"
###### groList[indexA/2] returns the .gro of molecule with indexA!
###### groList[distList[indexA+1][subindexB]] returns the .gro of molecule with subindexB

### calculate the intramolecular rate between thiophene rings 
def calc_intramolecular_rate_P3HT(param_list):
	if ( silent_mode_off ):
		print 'start calc_intramolecular_rate_P3HT'
	global calculation_number
	resid1=param_list[0]
	resid2=param_list[1]
	charge_type_intra=param_list[2]
	calc_intramolecular_data_new = False
	## Reset data
	matrix_element_homo_homo = 0.0
	matrix_element_lumo_lumo = 0.0
	dE_el_intra=0.0
	dE_lo_intra=0.0
	### check if data has already been calculated in DIPRO file
	#print 'grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +str(DIPRO_J_AB_datafile)
	output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +str(DIPRO_J_AB_datafile)),stdout=subprocess.PIPE)
	output_line = output_subscript.stdout.read()
	#print str(output_line.split(' ')[:]) + '### start outputline'
	if output_line == '':
		####### check if the rate was already calculated in the reverse direction       
		output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid2)+'_'+str(resid1)+'_' + ' ' +str(DIPRO_J_AB_datafile)),stdout=subprocess.PIPE)
		output_line = output_subscript.stdout.read()
		if output_line == '':
			calc_intramolecular_data_new = True
		else:  ### to grep resids 
			if ( silent_mode_off ):
				print 'intramolecular data in file for '+ str(resid2) +' and '+str(resid1)
	else: ### to grep resids
		if ( silent_mode_off ):
			print 'intramolecular data in file for '+ str(resid1) +' and '+str(resid2)            
            
        #### Funktion fuer Matrixelement aus Fit vom Abstand z.B.

	###print str(output_line.split('  ')[:]) +' ### JAB: vor split'
	if output_line == '':    
		calc_intramolecular_data_new = True
	elif output_line.split(' ')[0] == 'Fehler:':
			calc_intramolecular_data_new = True
			#matrix_element_homo_homo = dipro_hole_matrix_fit(resid1,resid2,frame_number,J_AB_fit_method_geometry)
 			#matrix_element_lumo_lumo = dipro_electron_matrix_fit(resid1,resid2,frame_number,J_AB_fit_method_geometry)
			######## info output
			info_out=open(info_out_filename,'a')
			info_out.write('Intramolecular error at index: '+str(resid1)+' to '+str(resid2)+ '\n')
			info_out.write('using fit function '+ '\n')
			info_out.close()
			######## info output
	elif output_line.split(' ')[2] == 'Das_Paar_wurde_fuer_DIPRO_aussortiert_MA_>_15_Ang_':
			calc_intramolecular_data_new = True
			#matrix_element_homo_homo = dipro_hole_matrix_fit(resid1,resid2,frame_number,J_AB_fit_method_geometry)
			#matrix_element_lumo_lumo = dipro_electron_matrix_fit(resid1,resid2,frame_number,J_AB_fit_method_geometry)
			######## info output
			info_out=open(info_out_filename,'a')
			info_out.write('distance too far at index: '+str(resid1)+' to '+str(resid2)+ '\n')
			info_out.write('using fit function '+ '\n')
			info_out.close()
			######## info output
	else:
		#### get matrix elements 
		try:
			### get matrix_element_homo_homo = float(output_line.split('  ')[2])
			### get matrix_element_lumo_lumo = float(output_line.split('  ')[4])
			use_dipro_matrix_fit,S_AB_homo_homo,matrix_element_homo_homo,S_AB_lumo_lumo,matrix_element_lumo_lumo=DIPRO_line_split(output_line,debug)
			if (use_dipro_matrix_fit):
				print 'Error: while_reading_Intramolecular_DIPRO_data: calc_intramolecular_data_new = True'
				calc_intramolecular_data_new = True

		except ValueError:
			calc_intramolecular_data_new = True
			print "Error: Intramolecular output_line is not a float", output_line.split('  ')[2] ,output_line.split('  ')[4]
			print "Check: DIPRO outputfile for ",resid1," and ",resid2
			print output_line , '### output_line nach ValueError'
			#matrix_element_lumo_lumo = dipro_electron_matrix_fit(resid1,resid2,frame_number,J_AB_fit_method_geometry)  #Ausname, verwende Fit
	if(debug):
		print str(matrix_element_homo_homo) +' ' + str(matrix_element_lumo_lumo) +' ### intra JAB grep'

	### check if data has already been calculated in lambda_in file
	output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' subroutines/lambda_in/results_lambda_in_G'+ str(frame_number) +'.dat '),stdout=subprocess.PIPE)
	output_line_lambda_in=output_subscript.stdout.read()
	if output_line_lambda_in== '':
		####### check if the rate was already calculated in the reverse direction       
		output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid2)+'_'+str(resid1)+'_' +' '+' subroutines/lambda_in/results_lambda_in_G'+ str(frame_number) +'.dat '),stdout=subprocess.PIPE)
		output_line_lambda_in= output_subscript.stdout.read()
		if output_line_lambda_in == '':
			calc_intramolecular_data_new = True

	if ( silent_mode_off ):
		print output_line_lambda_in.split(' ')[:]
    
	if output_line_lambda_in == '':
			calc_intramolecular_data_new = True    
	elif output_line_lambda_in.split(' ')[0] == 'Fehler:':
			calc_intramolecular_data_new = True
			info_out=open(info_out_filename,'a')
			info_out.write('Intramolecular error while reading dE_intra at index: '+str(resid1)+' to '+str(resid2)+ '\n')
			info_out.write('calculate Intramolecular data again '+ '\n')
			info_out.close()
	else:
		### Read dE_el/lo_intra from file
		try: 
			dE_el_intra=float(output_line_lambda_in.split(' ')[2])
			dE_lo_intra=float(output_line_lambda_in.split(' ')[5])
		except ValueError:
			calc_intramolecular_data_new = True
			print "Error: Intramolecular output_line not a float", output_line_lambda_in.split('  ')[2] ,output_line_lambda_in.split('  ')[5]
			print "Check: results_lambda_in outputfile "
			print output_line_lambda_in, '### output_line nach ValueError' 	
	if(debug):  
		print dE_el_intra,dE_lo_intra, '### dE_el_intra,dE_lo_intra'

	if calc_intramolecular_data_new:                
		#### Intramolecular transfer ####
		if ( silent_mode_off ):
			print 'calculate intramolecular data for indices: '+str(resid1)+' '+str(resid2)
		# check on which side of the p3ht chain the transfer occurs
		if resid1 == resid2 -1:
			# for THP1A and THP32 different atom counting has to be used
				if groList[(resid1)][-1][1] == 'THP1A':
					phi = get_angle_thiophene(resid1,resid2,6,5,0,5)
				elif groList[(resid2)][0][1] == 'THP32':
					phi = get_angle_thiophene(resid1,resid2,5,4,0,6)
				else:
					phi = get_angle_thiophene(resid1,resid2,5,4,0,5)
				# check on which side of the p3ht chain the transfer occurs
		elif resid2 == resid1 -1:
			# for THP1A and THP32 different atom counting has to be used
			if groList[(resid2)][-1][1] == 'THP1A':
				phi = get_angle_thiophene(resid2,resid1,6,5,0,5)
			elif groList[(resid1)][0][1] == 'THP32':
				phi = get_angle_thiophene(resid2,resid1,5,4,0,6)
			else:
				phi = get_angle_thiophene(resid2,resid1,5,4,0,5)
                
#	J = subprocess.Popen(shlex.split('grep -F ' + ' ' +str(round(float(phi),1))+' ' + 'data/spline_interp_2mere' ),stdout=subprocess.PIPE)
#	if int(phi)==float(phi):
#		J = subprocess.Popen(shlex.split('grep -F ' + ' ' +str(int(phi))+' ' + 'data/spline_interp_2mere' ),stdout=subprocess.PIPE)
#	output_line = J.stdout.read()
#	matrix_element_homo_homo = float(output_line.split('  ')[1])
		if intramolecular_method_el == 'cosfit':
		### use intramolecular electron fit / preliminary version 
			if ((phi > 90) and (phi < 270)): # kleineres mittleres maximum / energies in eV
				matrix_element_lumo_lumo= 0.42*abs(np.cos(phi*np.pi/180.0))+0.28
				### use fit for site energy difference dE			
				dE_el_intra = -0.65*p3ht_dE_rate_list_lo[int(phi*10)]
			else:    ### vorne und hinten			
				matrix_element_lumo_lumo= 0.65*abs(np.cos(phi*np.pi/180.0))+0.28
				### use fit for site energy difference dE			
				dE_el_intra = -0.65*p3ht_dE_rate_list_lo[int(phi*10)]
		elif intramolecular_method_el == 'hole': # use hole data
				matrix_element_lumo_lumo = p3ht_angle_JAB_intra_list_lo[int(phi*10)]
				dE_el_intra = p3ht_dE_rate_list_lo[int(phi*10)]
	
		elif intramolecular_method_el == 'electron': #use elecron data from file
		                    matrix_element_lumo_lumo = p3ht_angle_JAB_intra_list_el[int(phi*10)]
		                    dE_el_intra = p3ht_dE_rate_list_el[int(phi*10)]
		
		else:  
		### default id intramolecular_method_el is not selected
			matrix_element_lumo_lumo=0.0
			dE_el_intra=0.0
		
		##### intramolecular hole transport
		#intramolecular hole transport with CDFT data
		matrix_element_homo_homo = p3ht_angle_JAB_intra_list_lo[int(phi*10)]
		dE_lo_intra = p3ht_dE_rate_list_lo[int(phi*10)]
		## ??? Hier fehlt noch die 0.0, falls kein intramolekularer transport ausgewaehlt wird

		datenauswertung = open(str(DIPRO_J_AB_datafile), 'a')
		datenauswertung.write('  0.0  '+str(matrix_element_homo_homo)+'  0.0  '+str(matrix_element_lumo_lumo) +'  Intr_P3MT_P3MT_'+str(resid1)+'_'+str(resid2)+'_CDFT_PBE_G'+ str(frame_number) +'_N'+str(calculation_number[2])+'\n')
		datenauswertung.close()
		

		lambdadE = open('subroutines/lambda_in/results_lambda_in_G'+ str(frame_number) +'.dat', 'a')
		lambdadE.write('0.0 0.0 '+str(dE_el_intra)+' 0.0 0.0 '+str(dE_lo_intra)+' 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 0.0 Intr_P3MT_P3MT_'+str(resid1)+'_'+str(resid2)+'_CDFT_PBE_G'+ str(frame_number) +'_N'+str(calculation_number[2])+'\n')
		lambdadE.close()
	######## End intramolecular transfer ##########

	calculation_number[2] = calculation_number[2] + 1
	if(debug):
		print matrix_element_homo_homo, dE_lo_intra , matrix_element_lumo_lumo, dE_el_intra ,'### Data intra'
	return matrix_element_homo_homo, dE_lo_intra , matrix_element_lumo_lumo, dE_el_intra 	
	######## End intramolecular transfer ##########

#gets resid's and atomic coordinate numbers (e.g. which atom is in the thiophene ring P3HT/P3MT) and returns the angle betweeen the rings
def get_angle_thiophene(resid1,resid2,atom_a_ind_1,atom_a_ind_2,atom_b_ind_1,atom_b_ind_2):
	if(debug):
		print ('start: get_angle_thiophene')
	#stores the atom coordinates
	#ring from where the charge starts
	mol_complex_from = groList[(resid1)]
	#ring where the charge goes
	mol_complex_where = groList[(resid2)]
	atoms_from = []
	atoms_where = []
	
	mol_type_of_from= mol_complex_from[-1][1]
	mol_type_of_where= mol_complex_where[0][1]
	
#	print resid1
#	print resid2		
#	print mol_type_of_from
#	print mol_type_of_where

	#grab the last thiophene ring from first charge transfer complex
	for i in range(len(mol_complex_from)):
		#inverse counting
		l = (len(mol_complex_from)-1)-i
		# grab only the last thiophene ring
		if mol_type_of_from != mol_complex_from[l][1]:
			break
		atoms_from.append(mol_complex_from[l][4:7])
	#get the reversed order reversed, so it's right again
	atoms_from = list(reversed(atoms_from))

	#grab the first thiophene ring from second charge transfer complex
	for i in range(len(mol_complex_where)):
		# grab only the last thiophene ring
		if mol_type_of_where != mol_complex_where[i][1]:
			break
		atoms_where.append(mol_complex_where[i][4:7])

	#cast to float
	for i in range(len(atoms_where)): 
		for j in range(3):
			atoms_where[i][j] = float(atoms_where[i][j])	

	for i in range(len(atoms_from)): 
		for j in range(3):
			atoms_from[i][j] = float(atoms_from[i][j])

	#calculate the dihedral angle
	#get involved vectors
	a = np.asarray(np.asarray(atoms_from[atom_a_ind_2])-np.asarray(atoms_from[atom_a_ind_1]))
	b = np.asarray(np.asarray(atoms_where[atom_b_ind_1])-np.asarray(atoms_from[atom_a_ind_2]))
	c = np.asarray(np.asarray(atoms_where[atom_b_ind_2])-np.asarray(atoms_where[atom_b_ind_1]))
	
	#get the normal vectors of the surfaces
	n_1 = np.cross(a,b)
	n_1 = n_1 / np.linalg.norm(n_1)
	n_2 = np.cross(b,c)
	n_2 = n_2 / np.linalg.norm(n_2)

	#calculate angle
	#phi=np.arccos(np.dot(n_1,n_2))
	phi = np.arctan2(np.vdot(np.cross(n_1,n_2),b/np.linalg.norm(b)),np.vdot(n_1,n_2))
	phi = phi / (2.0*np.pi) * 360.0
	if(phi < 0.0):
		phi=phi+360.0

	if(debug):
		print str(phi) + ' ### phi'
	return phi		
		
### subroutine for running the aufruf.out (DIPRO) subscript
def DIPRO_sub(param_list): 
	global calculation_number
	global calculation_number_All

	indexA = param_list[0]
	subindexB = param_list[1]
	charge_type= param_list[2]
	if calc_complete_list:
		#select_DIPRO=[False,True,False,False,False]
		select_submission_type=[False,True,False,False,False]
	else:
		calculation_number = param_list[3]
		# select the type of calculation which should be submitted:
		# select_submission_type[0-4] mit, All = 0 DIPRO = 1, Intramolecular =2, lambda_in = 3, lambda_out = 4  
		select_submission_type = param_list[4]
	
		if select_submission_type[0]:
			select_submission_type=np.full((5), True, dtype=bool)  

	#### get the resid's and the path for the subroutines
	resid1 = groList[indexA/2][0][0]
	resid2 = groList[int(distList[indexA+1][subindexB])][0][0]

	subpath = os.getcwd()+'/subroutines'
	if (debug):	
		print 'debug mode: no submission for:',resid1,resid2
	if not (debug):
		#calculate the matrix element
		restype1 = groList[(resid1)][0][1]
		restype2 = groList[(resid2)][0][1]

		#check if the charge is transferring intramolecular and is not transferring from THP1A to THP32
		if select_submission_type[2] and intramolecular_charge_transfer_on and ((restype1[:3] == 'THP' and restype2[:3] == 'THP') and (resid1 == resid2 + 1 or resid1 + 1 == resid2) and not ( (groList[(resid1)][-1][1] == 'THP32' and groList[(resid2)][0][1] == 'THP1A') or (groList[(resid2)][-1][1] == 'THP32' and groList[(resid1)][0][1] == 'THP1A')) ):
			if charge_type == 'lo':			
				calc_intramolecular_rate_P3HT([resid1,resid2,'hole'])
			elif charge_type == 'el':
				calc_intramolecular_rate_P3HT([resid1,resid2,'electron'])
			if ( silent_mode_off ):				
				print 'using fit for intramolecular transport: '+str(charge_type)
		elif select_submission_type[1]:
		#if the charge is not transferring intramolecular use the DIPRO method
			if restype1[:3]=='THP': restype1 = 'P3MT'
			if restype2[:3]=='THP': restype2 = 'P3MT'
			if ( silent_mode_off ):
				print 'versuche dipro methode zu starten: '
			diproaufruf = str('./aufruf.out DIPRO ' + '../'+str(sys.argv[3]) + ' ' + str(resid1) +' '+str(restype1)+ ' ' + str(resid2) +' '+str(restype2)+ ' '+str(calculation_method)+' ' + str(frame_number) +' '+ str(calculation_number[1]) +" '"+str(DIPRO_programm)+"' "+' " '+str(g09_DIPRO_method_line)+ ' "' ) # assign a running calc number	
			
			if ( silent_mode_off ):			
				print diproaufruf, '### diproaufruf'
			if(sub_internal_queue):
				subjoblist.extend([diproaufruf])				
			elif (sub_old_style):
				### modified for threading
				thread = threading.Thread(name='submission_dipro_job',target = submit_dipro_job,args = (diproaufruf,'Thread-1',time_count_max))
				thread.start()

				#### start tobias subscript
				### modified for threading
				#test1 =	subprocess.Popen(shlex.split(diproaufruf), cwd=str(subpath) ,stdout=subprocess.PIPE)			
				if sub_one_calc_at_a_time:
					if ( silent_mode_off ):			
						print 'wait till process finishes'
					wait_for_active_threads(number_of_parallel_dipro_threads)
					thread.join()
					wait_for_active_threads(number_of_parallel_dipro_threads)
			
			#if sub_one_calc_at_a_time:
			#	if ( silent_mode_off ):			
			#		print 'wait till process finishes'
			#	thread.join()
			calculation_number_All = calculation_number_All+1
			calculation_number[1] = calculation_number[1] + 1

		#calculate the lambdas
		if select_submission_type[3] and lambda_in_method == 'otf':
			if ( silent_mode_off ):
				print 'versuche lambda_in methode zu starten: '
			lambdaaufruf = str('./aufruf.out lambda_in ' + '../'+str(sys.argv[3]) + ' ' + str(resid1) +' '+str(restype1)+ ' ' + str(resid2) +' '+str(restype2)+ ' ' +str(calculation_method_lambda_in)+' ' + str(frame_number) +' '+ str(calculation_number[3]) +' '+ str('true') + ' "UFF(QEq)" ')# assign a running calc number		
			if ( silent_mode_off ):			
				print lambdaaufruf +' ### lambda_in_methode'
			if(sub_internal_queue):
				subjoblist.extend([lambdaaufruf])				
			elif (sub_old_style):			
			#### start tobias subscript
				test1 =	subprocess.Popen(shlex.split(lambdaaufruf), cwd=str(subpath) ,stdout=subprocess.PIPE)
				calculation_number[3] = calculation_number[3] + 1
				#print test1.stdout.read()
#				test1.wait() #wait for the process to finish
				if sub_one_calc_at_a_time:
					if ( silent_mode_off ):			
						print 'wait till process finishes'
					test1_status = test1.wait()

		#submission routine for lambda_in using oniom & neighbours
		elif (select_submission_type[3] and lambda_in_method == 'otf_oniom'):
			lambda_in_neighbours_list1=distList[resid1*2+1]
			lambda_in_neighbours_list2=distList[resid2*2+1]
			### merge lists and dont use double arguments
			merged_dict_lambda_in_oniom = dict([(int(x),1) for x in lambda_in_neighbours_list1+lambda_in_neighbours_list2])
			merged_list_lambda_in_oniom = merged_dict_lambda_in_oniom.keys()
			# remove the resids from their own neighbour list
			while resid1 in merged_list_lambda_in_oniom:
            			merged_list_lambda_in_oniom.remove(resid1)
			while resid2 in merged_list_lambda_in_oniom:
            			merged_list_lambda_in_oniom.remove(resid2)
			print 'versuche lambda_in_oniom methode zu starten: '
			lambdaaufruf_oniom = str('./aufruf.out lambda_in_oniom ' + '../'+str(sys.argv[3]) + ' ' + str(resid1) +' '+str(restype1)+ ' ' + str(resid2) +' '+str(restype2)+ ' Oniom_UFF ' + str(frame_number) +' '+ str(calculation_number[4]) +' '+ str('true') + ' " '+str(oniom_method)+' " PBE0_6-31G#_CHelpG '+str(charge_type) +' '+str(len(merged_list_lambda_in_oniom))+' '+str(merged_list_lambda_in_oniom[:]).replace(',','').replace(']','').replace('[','') + ' &')# assign a running calc number	
			if ( silent_mode_off ):	
				print lambdaaufruf_oniom +'### lambda_in_oniom'
			if(sub_internal_queue):
				subjoblist.extend([lambdaaufruf_oniom])				
			elif (sub_old_style):
				#### start tobias subscript
				with open('./lambda_in_oniom_calculation_output.log', "w") as outfile:
					test1 =	subprocess.call(shlex.split(lambdaaufruf_oniom), cwd=str(subpath), stdout=outfile)
					calculation_number[4] = calculation_number[4] + 1
					#print test1.stdout.read()
					#test1.wait() #wait for the process to finish
					if sub_one_calc_at_a_time:
						if ( silent_mode_off ):			
							print 'wait till process finishes'
						test1_status = test1.wait()

		if select_submission_type[4] and lambda_out_method == 'otf':
			if charge_type == 'lo':
				lambda_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +'./subroutines/results_lambda_out_lo_G'+ str(frame_number) +'.dat'),stdout=subprocess.PIPE)
			elif charge_type == 'el':
				lambda_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +'./subroutines/results_lambda_out_el_G'+ str(frame_number) +'.dat'),stdout=subprocess.PIPE)
			lambda_out_line = lambda_subscript.stdout.read()	
			if lambda_out_line == '':
				lambda_out_neighbours_list1=lambda_out_neighbourlist[resid1*2+1]
				lambda_out_neighbours_list2=lambda_out_neighbourlist[resid2*2+1]
				### merge lists and dont use double arguments
				merged_dict = dict([(x,1) for x in lambda_out_neighbours_list1+lambda_out_neighbours_list2])
				merged_list = merged_dict.keys()
				while resid1 in merged_list:
            				merged_list.remove(resid1)
				while resid2 in merged_list:
            				merged_list.remove(resid2)
				if ( silent_mode_off ):
					print 'versuche lambda_out methode zu starten: '
				#check wegen benachbarten p3mt
				#if not (resid1 == resid2 -1 or resid2 == resid1 -1 and groList[(resid1)][-1][1][0:3] == 'THP' and groList[(resid2)][-1][1][0:3] == 'THP'):
				lambdaaufruf = str('./aufruf.out lambda_out ' + '../'+str(sys.argv[3]) + ' ' + str(resid1) +' '+str(restype1)+ ' ' + str(resid2) +' '+str(restype2)+  ' lambda_out_PBE0_6-31G# ' + str(frame_number) +' '+ str(calculation_number[5]) +' '+ str('true') + ' "UFF(QEq)" PBE0_6-31G#_CHelpG '+str(charge_type) +' '+str(r_cut)+' '+str(len(merged_list))+' '+str(merged_list[:]).replace(',','').replace(']','').replace('[','') +' &')# assign a running calc number
				if ( silent_mode_off ):
					print lambdaaufruf, ' ### lambdaaufruf'
				if(sub_internal_queue):
					subjoblist.extend([lambdaaufruf])				
				elif (sub_old_style): 
					#### start tobias subscript
					#test1 =	subprocess.Popen(shlex.split(lambdaaufruf), cwd=str(subpath) ,stdout=subprocess.PIPE)
					with open('./subroutines/lambda_out_logs/lambda_out_calculation_N'+str(calculation_number[5])+'_output.log', "w") as outfile:
						test2 =	subprocess.call(shlex.split(lambdaaufruf), cwd=str(subpath), stdout=outfile)
						calculation_number[5] = calculation_number[5] + 1
					#print test1.stdout.read()
					#test1.wait() #wait for the process to finish
						if sub_one_calc_at_a_time:
							if (silent_mode_off):			
								print 'wait till process finishes'
							test2_status = test2.wait()

			
	####

	##calculation_number = calculation_number + 1

# hier ausgabe der matrixelemente in datei zur analyse
# verschiedene abstandsmasse
########################################### end of rate evalution part	####################################
############################################################################################################


###########################################################################################################
###########  Start: use subprocesses with threading and queuing in python #################################
###########################################################################################################
### kill subprocess in after timeout ###
def kill(p):
	try:		
		print 'Error: process killed!!!'
		print 'PID:',p.pid
		#kill_child_processes(p.pid,signal.SIGTERM)
		#os.killpg(os.getpgid(p.pid), signal.SIGTERM)
		get_pid_and_kill('dftb+',time_count_max)
		p.kill()
	except OSError:
		pass # ignore
### end kill ###


### checks if a process: processname is listed in the top-list for all processes,
### gets the pid, and if the time_count_max is exeeded, the process is 
def get_pid_and_kill(name,time_count_max):
	for processname in [name,'dftb+','l508.exe','l502.exe']:
		print 'tmp: processname,time_count_max',processname,time_count_max
		output=[]
		input_string='top -bn1 '
		test1=subprocess.Popen(shlex.split(input_string) ,stdout=subprocess.PIPE, stderr=subprocess.STDOUT,bufsize=1)  # should be zero if accomplished
		with test1.stdout:
			for line in iter(test1.stdout.readline, b''):
				if ( processname in line):
					print line,
					output.append(shlex.split(line))
					pid=int(output[-1][0])
					print 'tmp pid:',pid
					# check if a job with the processname is in the top list
					if check_pid(pid):
						print 'tmp pid:',pid
						time_running=output[-1][10].replace(".",":")
						#convert time to seconds
						time_in_sec=sum(x * int(t) for x, t in zip([ 60, 1, 0.01], time_running.split(":")))
						if (silent_mode_off):
							print 'processname: ',processname
							print 'tmp top line: ',output[-1][:]
							print 'pid exists',pid
							print 'time_in_sec: ',time_in_sec,time_count_max
						if ( time_in_sec > time_count_max):
							print 'Killed process with pid: '+str(pid)+' and '+str(processname)
							os.kill(pid, signal.SIGTERM) #or signal.SIGKILL
							#os.killpg(os.getpgid(pid), signal.SIGTERM)
 
### end get_pid_and_kill ####

### check process pid #########
def check_pid(pid):        
	""" Check For the existence of a unix pid. """
	try:
		os.kill(pid, 0)
	except OSError:
		return False
	else:
		return True
### end check process pid #########


### kill children using modules: signal, psutil##########################


def kill_child_processes(parent_pid, sig=signal.SIGTERM):
	try:
		parent = psutil.Process(parent_pid)
	except psutil.NoSuchProcess:
		return
	children = parent.children(recursive=True)
	for process in children:
		process.send_signal(sig)
		print 'Killed child process with pid:',process.pid
	
### kill children using modules: signal, psutil #####


### check_nan(number) ; checks if a value is not a number NaN and returns the value or zero ################
def check_nan(number):
	if np.isnan(number):
		print 'Error: Number is NaN and replaced by zero!: '+str(number)
		return 0.0
	else:
		return number
### end chech_nan ########################################################################################

############ myThread ################################
class myThread (threading.Thread):
	def __init__(self, threadID, name, q):
		threading.Thread.__init__(self)
		self.threadID = threadID
		self.name = name
		self.q = q
		self.daemon = True
		self.kill_received = False
	def run(self):
		print "Starting " + self.name
		process_data(self.name, self.q,self.kill_received)
		print "Exiting " + self.name
### end class myThread #############################

###### process_data in queuing system ##############
def process_data(threadName, q, kill_received):
	while (not exitFlag) and (not kill_received) :
		queueLock.acquire()
		if (not workQueue.empty()) and (not kill_received):
			try:
				data = q.get()
				queueLock.release()
				print 'tmp: kill_received:',kill_received
				print "%s processing %s" % (threadName, data)
				input_string=data
				#if debug:
				#	print 'process_data: ',input_string,time_count_max
				### Here the processes are called ##
				#if ('DIPRO' in input_string): # looks for a string in the input_string ; beg - This is the starting index, by default its 0
				path = os.getcwd()+'/subroutines'
				submit_dipro_job(input_string,path,threadName,time_count_max)
				q.task_done()
				#else:
					#pass
			except KeyboardInterrupt:
				# Ctrl-C handling and send kill to stop queue
				print 'Ctrl-C handling to stop queue in threading'
				kill_received= True
		else:
			queueLock.release()
		time.sleep(1)
####### end process_data ###


def process_threads_with_queue(taskList,sub_one_calc_at_a_time,number_of_parallel_threads):
	
	if taskList:
		nameList = taskList
	else:
		print 'Error: List of tasks in threading is empty, in process_threads_with_queue!'
		return
	if (silent_mode_off):
		print 'start using parallel threads'
	global exitFlag
	global queueLock 
	global workQueue
	exitFlag = 0
	queueLock = threading.Lock()
	workQueue = Queue.Queue((len(nameList)+1))

	threads = []
	threadID = 1
	### make list for the number of threads used in queuing 
	threadList=[]
	if (sub_one_calc_at_a_time):
		threadList = ["Thread-1"]
	else:
		for i_thread in range(number_of_parallel_threads):
			threadList.append(  "Thread-"+str(i_thread+1) )
	if (silent_mode_off):
		print 'List of threads used: ',threadList
	
	
	# Create new threads
	for tName in threadList:
		thread = myThread(threadID, tName, workQueue)
		thread.start()
		threads.append(thread)
		threadID += 1
	
	# Fill the queue
	queueLock.acquire()
	for word in nameList:
		workQueue.put(word)
	queueLock.release()
	
	# Wait for queue to empty
	while not workQueue.empty():
		pass
	
	# Notify threads it's time to exit
	exitFlag = 1
	
	# Wait for all threads to complete
	try:
		for t in threads:
			t.join()
	except KeyboardInterrupt:
		# Ctrl-C handling and send kill to threads
		print "Sending kill to threads..."
		exitFlag = 1
            	for t in threads:
			t.kill_received = True
	print "Exiting Main Thread"
### process_threads_with_queue 

###########  end use subprocesses with threading and queuing system in python ###################
#################################################################################################



########################################### submit a dipro job #############################################
############################################################################################################
def submit_dipro_job(input_string,path,threadName,time_count_max):
		if ( silent_mode_off ):	
			print 'submit dipro job'
			print 'tmp: time_count_max:',time_count_max
		### check if external user requests a soft exit with an 'EXIT'-file
		check_soft_exit()
		try:
			#test1 =subprocess.Popen(shlex.split(input_string), cwd=str(path) ,stdout=subprocess.PIPE, stderr=subprocess.STDOUT)
			test1=subprocess.Popen(shlex.split(input_string), cwd=str(path) ,stdout=subprocess.PIPE, stderr=subprocess.STDOUT,bufsize=1)  # should be zero if accomplished
			print 'tmp: test1 id:',test1.pid		
			time1=Timer(time_count_max+10, kill, [test1])
			time1.start()
			with test1.stdout:
				for line in iter(test1.stdout.readline, b''):
					if (silent_mode_off):
						print threadName+str(':'),line,
					elif ('Fehler' in line):
						print threadName+str(':'),line,
					elif ('Error' in line):
						print threadName+str(':'),line,

			return_code=test1.wait() # wait for the subprocess to exit
			time1.cancel()
		except OSError:
			print 'OSError: for '+str(input_string)
			#if return_code:
				#raise subprocess.CalledProcessError(return_code, input_string)
		#if (int(threading.active_count()) > int(number_of_parallel_threads)):
### submit_dipro_job ###
########################################### end of submit dipro ############################################
############################################################################################################

############################# runs the VSSM method to calc which charge jumps ##############################
############################################################################################################
def VSSM(index,charge_type):
	intramolecular = False
	double_index=2*index
	try:	
		if charge_type == 'electron':
			test = elec_probList[double_index][1]
		elif charge_type == 'hole':
			test = hole_probList[double_index][1]
		else:
			######## info output
			info_out=open(info_out_filename,'a')
			info_out.write('undefined charge type! '+str(charge_type)+ '\n')
			info_out.write('exiting... '+ '\n')
			info_out.close()
			sys.exit()
			######## info output
	except IndexError:
		if charge_type == 'electron':
			build_elec_probList(double_index)
		elif charge_type == 'hole':
			build_hole_probList(double_index)
	if charge_type == 'electron':
		l=len(elec_probList[double_index])-3
	elif charge_type == 'hole':
		l=len(hole_probList[double_index])-3
	r_2 = np.random.random()
	jumped =False
	jump_to=-2
	while l>=0:
		i=0
		w_kl=0
		#here the MC step occurs, e.g. the interval is split (0,1] and
		#a random number is chosen to determine jump
		# see supporting information (15)	if charge_type == 'electron':

    	#def jump_probability(index, sub_index, charge_type):
	#	return elec_probList[double_index][sub_index+2]
	#if charge_type == 'hole':
	#	return hole_probList[double_index][sub_index+2]

		if charge_type == 'electron':
			while (i <= l):
				w_kl = w_kl + elec_probList[double_index][i+2]
				i=i+1
		else:
			while (i <= l):
				w_kl = w_kl + hole_probList[double_index][i+2]
				if debug:
					print 'tmp: w_kl:',w_kl,' hole_probList[double_index][i+2]:',hole_probList[double_index][i+2],'  from resid:',index,' subindex i+2:',i+2, ' to resid: ', int(distList[2*index+1][i+2])
				i=i+1
			
	#	while i <= l:
	#		w_kl = w_kl + jump_probability(index,i,charge_type)
	#		i=i+1
		#print str((1.0/total_jump_probability(index))*w_kl)+ ' <= ' + str(r_2)
		if charge_type == 'electron':	
			if (elec_total_sum_probList[index] == -1): 
				tot_jump_prob = total_jump_probability(index,charge_type)
			else:
				tot_jump_prob = float(elec_total_sum_probList[index])
		else:
			if (hole_total_sum_probList[index] == -1): 
				tot_jump_prob = total_jump_probability(index,charge_type)
				if debug:
					print 'tmp: hole total jump prob:',tot_jump_prob
			else:
				tot_jump_prob = float(hole_total_sum_probList[index])
		if r_2 <= (1.0/tot_jump_prob)*w_kl:
			jump_to = l
			jumped=True
			if debug:
				print 'tmp: w_kl:',w_kl,' tot_jump_prob:',tot_jump_prob,'  (1.0/tot_jump_prob)*w_kl:',(1.0/tot_jump_prob)*w_kl
		l=l-1
	#### return if the charge is transferring intramolecular
	if print_only_intermolecular:
		### checks if the jump occured intramolecular
		## index where the charge jumps
		index_to_jump_to = jump(index,jump_to)
		#check what kind of molecules are processed
		indexA = index
		subindexB = l
		mol_type_1= groList[indexA/2][0][1]
		mol_type_2=groList[int(distList[indexA+1][subindexB])][0][1]		
		resid1 = groList[indexA/2][0][0]
		resid2 = groList[int(distList[indexA+1][subindexB])][0][0]
		
        	if (intramolecular_charge_transfer_on and (mol_type_1[:3] == 'THP' and mol_type_2[:3] == 'THP') and (resid1 == resid2 + 1 or resid1 + 1 == resid2) and not ( (groList[(resid1)][-1][1] == 'THP32' and groList[(resid2)][0][1] == 'THP1A') or (groList[(resid2)][-1][1] == 'THP32' and groList[(resid1)][0][1] == 'THP1A')) ):
			intramolecular = True
	return jump_to, jumped, intramolecular
############################################################################################################
############################################################################################################

######################### returns the index of (index, subindex) -> index where to jump ####################
############################################################################################################
def jump(index_from, index_where):
	try:
		return int(distList[2*index_from+1][index_where+2])
	except IndexError:
		######## info output
		info_out=open(info_out_filename,'a')
		info_out.write('Index error in neighbour list at line: '+str(2*index_from+1)+' to subindex '+str(index_where+2)+ '\n')
		info_out.write('exiting... '+ '\n')
		info_out.close()
		sys.exit()
		######## info output

########################################### Start calculation of mobility and current if kmc_traj_filename gets too big#############################################################
###  Check if the trajectory file gets too big to handle, if size > max_kmc_traj_filesize a new file is constructed and the mobility and current are calculated
def check_if_kmc_traj_filename_is_too_big(kmc_traj_filename,max_kmc_traj_filesize,counter_kmc_traj_steps,xbox,ybox,zbox,frame_number,step_count):
	global kmc_out
	##print "Check vor Start kmc_traj_filename"	
	if os.path.isfile(kmc_traj_filename):
		##print "Step1 vor Start kmc_traj_filename is file =true ",kmc_traj_filename
		kmc_traj_filesize =os.path.getsize(kmc_traj_filename)
		if ( silent_mode_off ):
			print kmc_traj_filesize,  max_kmc_traj_filesize		
		if abs(kmc_traj_filesize) > abs(max_kmc_traj_filesize):
			print str(kmc_traj_filename)+' filesize: '+str(kmc_traj_filesize)+' byte'

			### check ob current_calculation_hole_el is possible to calculate
			if os.path.isfile(str(script_path)+'/current_calculation_hole_el'):
					#try:
						#print 'use: current_calculation_hole_el'
						### Alter stiel###
						#Bashcommand=' current_file=current_calculation_hole_el_G'+str(frame_number)+'_V'+str(counter_kmc_traj_steps)+'.dat ;  echo "'+str(step_count)+' frame  timestep: '+str(sim_time)+' " >> ${current_file} ; '+str(script_path)+'/current_calculation_hole_el '+str(kmc_traj_filename)+' '+str(xbox)+' '+str(ybox)+' '+str(zbox)+'  " |U_exc|= '+str(np.linalg.norm(U))+' U_ext= '+str(U)+' "  >> ${current_file} '
						#try:
						#	print 'Use: '+str(Bashcommand)
						#	output = subprocess.check_output(['/bin/bash','-c', Bashcommand])
						
            				#except IndexError:
					#	print 'Error: in current_calculation_hole_el maybe the traj*.xyz file is corrupted'

					### alter Stiel
					try:
						print 'use: current_calculation_hole_el'
						Bashcommand=str(script_path)+'/current_calculation_hole_el '+str(kmc_traj_filename)+' '+str(xbox)+' '+str(ybox)+' '+str(zbox)+' "|U_exc|= '+str(np.linalg.norm(U))+' U_ext= '+str(U)+'" '
						print Bashcommand
						current_filename='current_calculation_hole_el_G'+str(frame_number)+'_V'+str(counter_kmc_traj_steps)+'.dat'
						current_file = open(current_filename,'w')
						current_file.write(str(step_count)+' frame  timestep: '+str(sim_time)+'\n')
						current_file.close
						current_file = open(current_filename,'a')
						cu = subprocess.Popen(Bashcommand, shell=True,stdout=current_file, stderr=subprocess.PIPE)
						cu.wait()
						stdout, sub_stderr = cu.communicate()
						if sub_stderr:
							print 'Error: ./current_calculation_hole_el_was_not_executed_properly.'
							print sub_stderr
							if (debug):
								print 'File output:'
								with open(current_filename,'r') as file:
									output = file.read()
									print(output)
						else:
							print 'Normal Termination of current_calculation_hole_el.'
					except IndexError:
						print 'Error: in current_calculation_hole_el: maybe the traj*.xyz file is corrupted'
					#except subprocess.CalledProcessError, ex:
						print 'Error in current_calculation_hole_el: maybe the traj*.xyz file is corrupted'
						print ex.cmd
						print ex.message
						print ex.returncode
						print ex.output

			### check if MSD_hole_el_Einstein is possible to calculate  #########################################
			if os.path.isfile(str(script_path)+'/MSD_hole_el_Einstein'):
				### Alter stiel###
				#try:
				#	print 'use: MSD_hole_el_Einstein'
				#	Bashcommand='MSD_file=MSD_hole_el_Einstein_G'+str(frame_number)+'_V'+str(counter_kmc_traj_steps)+'.dat ; echo "'+str(step_count)+' frame  timestep: '+str(sim_time)+' " >> ${MSD_file} ; '+str(script_path)+'/MSD_hole_el_Einstein '+str(kmc_traj_filename)+' '+str(xbox)+' '+str(ybox)+' '+str(zbox)+' " |U_exc|= '+str(np.linalg.norm(U))+' U_ext= '+str(U)+' "  >> ${MSD_file} '
				#	print 'Use: '+str(Bashcommand)					
				#	output = subprocess.check_output(['/bin/bash','-c', Bashcommand])
				#	
            			#except IndexError:
				#	print 'Error: in MSD_hole_el_Einstein: maybe the traj*.xyz file is corrupted'
				try:
						print 'use: MSD_hole_el_Einstein'
						Bashcommand=str(script_path)+'/MSD_hole_el_Einstein '+str(kmc_traj_filename)+' '+str(xbox)+' '+str(ybox)+' '+str(zbox)+' "|U_exc|= '+str(np.linalg.norm(U))+' U_ext= '+str(U)+'" '
						print Bashcommand
						MSD_filename='MSD_hole_el_Einstein_G'+str(frame_number)+'_V'+str(counter_kmc_traj_steps)+'.dat'
						MSD_file = open(MSD_filename,'w')
						MSD_file.write(str(step_count)+' frame  timestep: '+str(sim_time)+'\n')
						MSD_file.close
						MSD_file = open(MSD_filename,'a')
						p = subprocess.Popen(Bashcommand, shell=True,stdout=MSD_file, stderr=subprocess.PIPE)
						p.wait()
						stdout, sub_stderr = p.communicate()
						if sub_stderr:
							print 'Error: ./MSD_hole_el_Einstein_was_not_executed_properly.'
							print sub_stderr
							if (debug):
								print 'File output:'
								with open(MSD_filename,'r') as file:
									output = file.read()
									print(output)
						else:
							print 'Normal Termination of MSD_hole_el_Einstein.'
				except IndexError:
						print 'Error: in MSD_hole_el_Einstein: maybe the traj*.xyz file is corrupted'
				#except subprocess.CalledProcessError, ex:
						print 'Error in MSD_hole_el_Einstein: maybe the traj*.xyz file is corrupted'
						print ex.cmd
						print ex.message
						print ex.returncode
						print ex.output


			### close old kmc_out (kmc_traj_filename)			
			kmc_out.close()            
			### number and rename kmc_traj_filename
			if '_V'+str(counter_kmc_traj_steps)+'.xyz' in kmc_traj_filename:
				counter_kmc_traj_steps=counter_kmc_traj_steps+1
				kmc_traj_filename=kmc_traj_filename.split('_V')[0]+'_V'+str(counter_kmc_traj_steps)+'.xyz'
			else:
				counter_kmc_traj_steps=counter_kmc_traj_steps+1
				kmc_traj_filename=kmc_traj_filename[:-4]+'_V'+str(counter_kmc_traj_steps)+'.xyz'
			### 
			kmc_out=open(kmc_traj_filename,'w') # erases data
			#kmc_out.write(str(len(occupied_list))+'\n')
			#kmc_out.write(str(step_count+2)+' frame '+ ' timestep '+str(sim_time)+'\n')
			print 'New kmc_trajectory_filename:',kmc_traj_filename
	return kmc_traj_filename,  counter_kmc_traj_steps
	#############################END calculation if kmc_traj_filename gets too big ############################################################################
	#######################################################################################################################################################	


#################################################################################################################################################
#### function to check, if the current Resids were visited before, so you do not write to many data in the kmc_traj_file.xyz ####################
#### latest_occupied_lists contains afterwards the inital occupied_list ###
def check_resids_were_visited(occupied_list,latest_occupied_lists):
	N_Elements_occ=len(occupied_list) 
	N_steps_stored=len(latest_occupied_lists[0])
	sites_were_visited= False
	if N_steps_stored < 5:
		print ' Error: in function check_resids_were_visited: latest_occupied_lists is to short, can not check last changes!'
		return False

	## Check, if Resids in occupied_list were visited before (last N_steps_stored) ( how often is occupied_list in latest_occupied_lists)
	have_been_at_same_resids_in_last_steps=0
	for i in range(0,N_steps_stored):
		count_same_elements=0
		for j in range(0,N_Elements_occ):
			if latest_occupied_lists[j][i] == occupied_list[j]:
				count_same_elements=count_same_elements+1
		if (count_same_elements == N_Elements_occ):       
				have_been_at_same_resids_in_last_steps=have_been_at_same_resids_in_last_steps+1

	#print ' Same Resids in N_Steps:',have_been_at_same_resids_in_last_steps
	if have_been_at_same_resids_in_last_steps > 1:
		### check if visited neighbours are the same latest_occupied_lists[0]=latest_occupied_lists[2]=latest_occupied_lists[4]
		count_same_elements=0
		for j in range(0,N_Elements_occ):
			if ( latest_occupied_lists[j][0] == latest_occupied_lists[j][2] ) and ( latest_occupied_lists[j][0] == latest_occupied_lists[j][4] ):
				count_same_elements=count_same_elements+1
		if count_same_elements==N_Elements_occ:
			## check if last [1] und [3] resids are like occupied_list
			count_same_elements=0
			for j in range(0,N_Elements_occ):
				if ( latest_occupied_lists[j][1] == occupied_list[j] ) and ( latest_occupied_lists[j][3] == occupied_list[j] ):
					count_same_elements=count_same_elements+1
			### site was visited 
			if (count_same_elements==N_Elements_occ): 
				sites_were_visited= True
              
	### Tasche die Reihenfolge order
	#print 'Swap data from i to i+1 in latest_occupied_lists'
	for i in range(N_steps_stored-1,0,-1):
		for j in range(0,N_Elements_occ):
			latest_occupied_lists[j][i]=latest_occupied_lists[j][i-1]
    
	## Uebergabe der Resids an die Elemente im zum ersten(jetzigen) Zeitpunkt
	for i in range(0,N_Elements_occ):
		latest_occupied_lists[i][0]=occupied_list[i]
    
	#print 'sites_were_visited? ' +str(sites_were_visited)+' '+str(latest_occupied_lists[0][N_steps_stored-1])+' '+str(latest_occupied_lists[1][N_steps_stored-1])
	### check if sufficient steps were calculated 
	if (latest_occupied_lists[0][N_steps_stored-1]==0) and ( latest_occupied_lists[1][N_steps_stored-1] == 0):
		return False
        
	if sites_were_visited:
		return True
	else:
		return False
##### End function check_resids_were_visited #########################################################################################################
#####################################################################################################################################################

########################################## end of functions ################################################
############################################################################################################
############################################################################################################


### check if external user requests a soft exit with an 'EXIT'-file
check_soft_exit()

######################## routine for building a complete list for all indices ##############################
############################################################################################################
if calc_complete_list == True:
	for a_count in range(start_index_for_complete_list_calculation,end_index_for_complete_list_calculation):
		b_count = 0
		### check if external user requests a soft exit with an 'EXIT'-file
		check_soft_exit()
		for b_count in range(len(distList[a_count*2]))[2:]:
			#DIPRO_sub([a_count*2,b_count,'el'])
			#DIPRO_sub([a_count*2,b_count,'lo'])
			calc_DIPRO_pair= True
			resid1 = groList[a_count][0][0]
			resid2 = groList[int(distList[2*a_count+1][b_count])][0][0]
			print 'Resids:',resid1,resid2
			#	subpath = os.getcwd()+'/subroutines'
			output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid1)+'_'+str(resid2)+'_' + ' ' +str(DIPRO_J_AB_datafile)),stdout=subprocess.PIPE)
			output_line = output_subscript.stdout.read()	
			#	check if the rate was already calculated in the opposite direction
			if output_line == '':
				output_subscript = subprocess.Popen(shlex.split('grep ' + '_' +str(resid2)+'_'+str(resid1)+'_' + ' ' +str(DIPRO_J_AB_datafile)),stdout=subprocess.PIPE)
				output_line = output_subscript.stdout.read()
			###print 'tmp output_line:',output_line[:]
			### Test is sting is empty        
			if (output_line != ''):
					### use these delimiters to 
					delimiters=['\n','\t','      ','     ','    ','   ','  ',' ']
					### substitute the dilimiters with one space
					for d in delimiters:
						output_line=output_line.replace(d,' ')
					### split'
					### split string to list and remove empty elements with the filter
					line=filter(None, output_line.split(' '))
					if(debug):
						print 'splitted line:',line[:]
					k=0
					for s in line[0:4]: 
						if (is_number(s)):
							k=k+1
					if (k > 3):
							calc_DIPRO_pair = False
					if (debug):
						print 'k_check: ',k,' calc_DIPRO_pair:',calc_DIPRO_pair
			### end check if pair was already calculated.
			
			### check and exclude intramolecular charge transfer |J_AB|, as DIPRO can not be applied.
			if calc_DIPRO_pair and (not intramolecular_charge_transfer_on):
				if ((resid1 == resid2+1) or (resid2 == resid1+1)):
						mol_type_1= groList[a_count][0][1]
						mol_type_2=groList[int(distList[2*a_count+1][b_count])][0][1]
						if (debug):
							print "Check intramolecular pair: ",resid1,resid2,mol_type_1,mol_type_2,calc_DIPRO_pair
						if (mol_type_1[:3] == 'THP' and mol_type_2[:3] == 'THP') or (mol_type_1[:2] == 'PH' and mol_type_2[:2] == 'PH'):
							if ( not ( (( mol_type_1[:5] == 'THP32' and mol_type_2[:5] == 'THP1A')) or ( mol_type_2[:5] == 'THP32' and mol_type_1[:5] == 'THP1A')) ):
								calc_DIPRO_pair = False
								print "Exclude intramolecular pair: ",resid1,resid2,mol_type_1,mol_type_2,calc_DIPRO_pair
			
			if (not calc_DIPRO_pair):
				print "DIPRO data for pair already exists:",resid1,resid2
				continue 
			
			if (sub_internal_queue):
				DIPRO_sub([a_count*2,b_count,'el',calculation_number_All])
				print 'tmp: subjoblist:',b_count,'list',subjoblist
			elif (sub_old_style):
                        	thread = threading.Thread(target = DIPRO_sub,args = ([a_count*2,b_count,'el',calculation_number_All],))
				#calculation_number[6] = calculation_number[6]+1
				calculation_number_All = calculation_number_All+1
				thread.start()
		
				#append all threads to a list
				thread.start()
				if threading.active_count >= number_of_parallel_dipro_threads+1:
					while threading.active_count() != 1:
						print 'still waiting for threads to finish'
						print str(threading.active_count()) + ' threads still running'
						print str(threading.enumerate()) + ' threads still running'
						time.sleep(3)
				#thread = threading.Thread(target = DIPRO_sub,args = ([a_count*2,b_count,'lo',calculation_number[6],True],))
				#calculation_number[6] = calculation_number[6]+1
				#append all threads to a list
				#thread.start()
				#if threading.active_count >= number_of_parallel_dipro_threads+1:
				#	while threading.active_count() != 1:
				#		print 'still waiting for threads to finish'
				#		print str(threading.active_count()) + ' threads still running'
				#		print str(threading.enumerate()) + ' threads still running'
				#		time.sleep(1)
		### calc b_count list with internal queue
		if (debug):
			print 'tmp: subjoblist:',subjoblist
			print 'tmp: number_of_parallel_threads:',number_of_parallel_threads		
		if sub_internal_queue and subjoblist:
				process_threads_with_queue(subjoblist,sub_one_calc_at_a_time,number_of_parallel_threads)
				subjoblist=[] 				
		if (sub_old_style):
			while threading.active_count() != 1:
				print 'still waiting for threads to finish'
				print str(threading.active_count()) + ' threads still running'
				print str(threading.enumerate()) + ' threads still running'
				time.sleep(1)
		if (sub_old_style):
			if (threading.active_count == 1) and (delete_debug_data == True):
				#clean up 
				cleanup =subprocess.Popen(shlex.split('rm -r ./subroutines/DIPRO/Dim_* ',stdout=subprocess.PIPE))
				cleanup =subprocess.Popen(shlex.split('rm -r ./subroutines/lambda_out_logs/* ',stdout=subprocess.PIPE))
				cleanup =subprocess.Popen(shlex.split('rm -r ./subroutines/xyz_q_Dateien/xyz* ',stdout=subprocess.PIPE))
				cleanup =subprocess.Popen(shlex.split('rm ./subroutines/xyz_q_Dateien/* ',stdout=subprocess.PIPE))
				cleanup =subprocess.Popen(shlex.split('rm ./subroutines/xyz_q_Dateien/lambda_out_xyz_q_pairs/* ',stdout=subprocess.PIPE))
		
		
			#b_count = 0
			#for b_count in range(len(distList[a_count*2]))[2:]:
			#	elec_get_results_from_dat(a_count*2,b_count)
			#	hole_get_results_from_dat(a_count*2,b_count)
############################################################################################################
############################################################################################################

#string objects for buffered output
kmc_traj_out_list=[]
N_charges=len(occupied_list)
startlocations = occupied_list
MSD_el=0.0
MSD_lo=0.0
MSD=0.0
mobility_sum=0.0
mobility_lo=0.0
mobility_el=0.0
msd_output=True
msd_out=open("msd.dat", 'a' )
msd_el_out=open("msd_el.dat", 'a' )
msd_lo_out=open("msd_lo.dat", 'a' )
msd_out.write(str(sim_time)+'  new mobilities  '+str(starting_time[4:19])+'\n')
msd_el_out.write(str(sim_time)+'  new mobilities  '+str(starting_time[4:19]) +'\n')
msd_lo_out.write(str(sim_time)+'  new mobilities  '+str(starting_time[4:19]) +'\n')
msd_out.close()
msd_el_out.close()
msd_lo_out.close()


######## open & generate the trajectory file
if (not calc_complete_list):
	kmc_run =True
else:
	kmc_run =False
	#kmc_out=open(kmc_traj_filename,'w')#erases data

	#write file header
	#kmc_out.write(str(len(occupied_list))+'\n')
	#kmc_out.write('1 frame '+'\n')
	#kmc_traj_out_list.append(str(N_charges))
	#kmc_traj_out_list.append('1 frame ')
########


######################################### start the KMC algorithm ##########################################
############################################################################################################

if ( not calc_complete_list ):
	print 'Start kMC-Simulation ...'
	if ( not silent_mode_off ):
		print 'Using silent_mode with reduced kMC-Output.' 

# if charge carries want to be added during the simulation, this needs to be called inside the while kmc_run loop
range_len_occ_list=range(N_charges)

#while step_count <= number_of_steps and calc_complete_list== False:
while 1:
	if not kmc_run:
		break
	if (sim_time <= t_kmc_max) and (counter_kmc_traj_steps <= max_kmc_traj_step) and  (step_count <= number_of_steps) and (calc_complete_list== False) and (not mobility_conv[3]):
		kmc_run = True
	else:
		kmc_run = False
	
	# checks if an intramolecular jump occured
	intramolecular = False
	#store the starting time to see if a long calculation is 
	#runtime_start = float(time.strftime('%s'))
	while jumped==False:
		r_1 = np.random.random()
		if step_count == 0:
			for i in range_len_occ_list:
				occ_list_i = occupied_list[i]
				charge_list_i = charge_type_list[i]
				#if i!= removed:
				if charge_list_i == 'electron':	
					if (elec_total_sum_probList[occ_list_i] == -1): 
						tot_jump_prob = total_jump_probability(occ_list_i,charge_list_i)
					else:
						tot_jump_prob = float(elec_total_sum_probList[occ_list_i])
				else:
					if (hole_total_sum_probList[occ_list_i] == -1): 
						tot_jump_prob = total_jump_probability(occ_list_i,charge_list_i)
					else:
						tot_jump_prob = float(hole_total_sum_probList[occ_list_i])

				#tau_i[i]=sim_time-1.0/(total_jump_probability(occupied_list[i],charge_type_list[i]))*np.log(r_1)
				tau_i[i]=sim_time-1.0/(tot_jump_prob)*np.log(r_1)

#		min_tau=np.argmin([x for i, x in enumerate(tau_i) if i != removed])
		min_tau=np.argmin(tau_i)
		#VSSM determines where the charge goes
		jump_to, jumped, intramolecular = VSSM(occupied_list[min_tau],charge_type_list[min_tau])
		#dont allow 2 charges in 1 place
		while jump(occupied_list[min_tau],jump_to) in occupied_list:
			jump_to, jumped, intramolecular = VSSM(occupied_list[min_tau],charge_type_list[min_tau])
		if jumped==True:
			sim_time = tau_i[min_tau]
			if debug:
				print 'sim_time:',sim_time

	## let the jump occur
	old_occ_list_min_tau = startlocations[min_tau]
	occupied_list[min_tau] = jump(occupied_list[min_tau],jump_to)
	r_1 = np.random.random()
	occ_list_min_tau = occupied_list[min_tau]
	charge_type_min_tau = charge_type_list[min_tau]
	#calculate the distance
	print 'tmp:occ_list_min_tau:',occ_list_min_tau,min_tau,jump_to,occupied_list[min_tau],charge_type_list[min_tau]
	dist = np.asarray(COM_list[old_occ_list_min_tau])-np.asarray(COM_list[occ_list_min_tau])
	for a in range(len(dist)):
		if (dist[a] > box_ang[a]/2.0): dist[a] = dist[a] - box_ang[a]
		elif (dist[a] < -box_ang[a]/2.0): dist[a] = dist[a] + box_ang[a]
	##### use this to calc the MSD
	dr_travelled[min_tau] =dr_travelled[min_tau] + dist
	net_displacement_total = net_displacement_total + dist
	moved_distance = np.sqrt(np.dot(dist,dist))
	if charge_type_min_tau == 'electron':
		net_displacement_el = net_displacement_el + dist
		MSD_el=MSD_el + moved_distance
	elif charge_type_min_tau == 'hole':
		net_displacement_lo = net_displacement_lo + dist
		MSD_lo=MSD_lo + moved_distance
	#MSD_charge_k[k]=MSD_charge_k[k]+np.sqrt(np.dot(dist,dist))
	MSD=MSD  + moved_distance
	#vectorial_charge_flow = vectorial_charge_flow + (vec2-vec1)

	if charge_type_min_tau == 'electron':	
		if (elec_total_sum_probList[occ_list_min_tau] == -1): 
			tot_jump_prob = total_jump_probability(occ_list_min_tau,charge_type_min_tau)
		else:
			tot_jump_prob = float(elec_total_sum_probList[occ_list_min_tau])
	else:
		if (hole_total_sum_probList[occ_list_min_tau] == -1): 
			tot_jump_prob = total_jump_probability(occ_list_min_tau,charge_type_min_tau)
		else:
			tot_jump_prob = float(hole_total_sum_probList[occ_list_min_tau])
	tau_i[min_tau]=sim_time-1.0/(tot_jump_prob)*np.log(r_1)
	#print occupied_list
	if (intramolecular == False or (not print_only_intermolecular) or (not kmc_run)):
		### Check if resids were visted; latest_occupied_lists contains afterwards the inital occupied_list!  
		#if check_resids_were_visited(occupied_list,latest_occupied_lists) and (kmc_run):
		#	pass # do nothing
		#else:
		if 1==1:
			if ((sim_time < t_kmc_max) and (kmc_run)):
				#kmc_out.write(str(len(occupied_list))+'\n')
				#kmc_out.write(str(step_count+2)+' frame '+ ' timestep '+str(sim_time)+'\n')
				kmc_traj_out_list.append(str(N_charges))
				kmc_traj_out_list.append(' '.join([str(step_count+1),'frame', 'timestep',str(sim_time)]))
			### print occuped_list to traj_*.xyz ###		
			k=0
			for k in range_len_occ_list:
				kmc_traj_out_list.append(' '.join([str(charge_type_list[k]) , str('	'.join(map(str, COM_list[occupied_list[k]]))),'#Resid:' , str(occupied_list[k]) ]))
				#kmc_out.write(str(charge_type_list[k])+'	'+str('	'.join(map(str, COM_list[occupied_list[k]])))+' #Resid: ' + str(occupied_list[k]) + '\n')
				
			if (((step_count%(buffered_mobility_out_steps)==0) and step_count!=0) or (not kmc_run)): 
				#### check otf mobility convergence !!!
				#	if ((step_count > minimum_N_kMC_steps_to_check_mobility) or (not kmc_run)):
				#		### calculate the mobility of the current kmc_traj*.xyz 
				#		mobility_arr = calc_mobility(kmc_traj_filename,kmc_out,xbox,ybox,zbox,mob_infostring,k_B,T,mobility_arr,debug)
				#		### check the mobility convergence
				#		mobility_conv, mob_list =check_mobility(mobility_filename,mob_list,mobility_conv_criterion,check_N_latest_mobility_steps,read_mobility_data_from_file,debug)
				#		if (kmc_out.closed):
				#			kmc_out=open(kmc_traj_filename,'a')
				if (mobilitymode == 'FEM'): # Fieldeffectmobility 
					if (msd_output):
						for i_charge in range_len_occ_list:
							velocity_charges[i_charge]= np.asarray(dr_travelled[i_charge][:])/float(sim_time)
							for i_coord in range(3):
								if (fieldfactors[i_coord] != 0 ):
									mobility_charges[i_charge][i_coord]=np.dot(velocity_charges[i_charge][i_coord],fieldfactors[i_coord])		#### modify!!! np arrays do not work like this!!!!!!
									if debug:
										print 'charge: ',i_charge,occupied_list[i_charge]
										print 'fieldfactors[i_coord]:',fieldfactors[:]
										print 'dr_travelled: ',dr_travelled[i_charge][:]
										print 'velocity_charges[i_charge]',velocity_charges[i_charge]
										print 'scalar_product:',np.dot(velocity_charges[i_charge],fieldfactors[:])									
										print 'FEM mu:',mobility_charges[i_charge],' cm**2 / Vs '



						msd_out=open("msd.dat", 'a' )
						msd_el_out=open("msd_el.dat", 'a' )
						msd_lo_out=open("msd_lo.dat", 'a' )
						net_mobility_old=net_mobility_total
						mobility_sum=1.0E-16*MSD/(2*3*sim_time)*1.0/(k_B*T)   *1.0/N_charges 
						if( N_el != 0):
							mobility_el=1.0E-16*MSD_el/(2*3*sim_time)*1.0/(k_B*T) *1.0/N_el
						else:
							mobility_el=0.0E0
						if(N_lo != 0):
							mobility_lo=1.0E-16*MSD_lo/(2*3*sim_time)*1.0/(k_B*T)*1.0/N_lo
						else:
							mobility_lo=0.0E0


						if U[0] != 0:
							net_mobility_total[0]=1.0E-16*net_displacement_total[0] / (sim_time * U[0])
							net_mobility_el[0]=1.0E-16*net_displacement_el[0] / (sim_time * U[0]) 
							net_mobility_lo[0]=1.0E-16*net_displacement_lo[0] / (sim_time * U[0]) 
						if U[1] != 0:
							net_mobility_total[1]=1.0E-16*net_displacement_total[1] / (sim_time * U[1])
							net_mobility_el[1]=1.0E-16*net_displacement_el[1] / (sim_time * U[1]) 
							net_mobility_lo[1]=1.0E-16*net_displacement_lo[1] / (sim_time * U[1]) 
						if U[2] != 0:
							net_mobility_total[2]=1.0E-16*net_displacement_total[2] / (sim_time * U[2])
							net_mobility_el[2]=1.0E-16*net_displacement_el[2] / (sim_time * U[2]) 
							net_mobility_lo[2]=1.0E-16*net_displacement_lo[2] / (sim_time * U[2]) 

						net_mobility_total=net_mobility_total/N_charges
						if( N_el != 0):
							net_mobility_el[:]=net_mobility_el[:]/N_el
							msd_el_out.write(str(sim_time)+'	'+str(MSD_el)+ '   '+str(mobility_el)+'   '+str(net_mobility_el[0])+'   '+str(net_mobility_el[1])+'   '+str(net_mobility_el[2]) +'\n')
						else:
							net_mobility_el[:]=0.0E0*net_mobility_el[:]
						if( N_lo != 0):
							net_mobility_lo=net_mobility_lo/N_lo
							msd_lo_out.write(str(sim_time)+'	'+str(MSD_lo)+ '   '+str(mobility_lo)+'   '+str(net_mobility_lo[0])+'   '+str(net_mobility_lo[1])+'   '+str(net_mobility_lo[2]) +'\n')
						else:
							net_mobility_lo[:]=0.0E0*net_mobility_lo[:]

						msd_out.write(str(sim_time)+'	'+str(MSD)+ '   '+str(mobility_sum)+'   '+str(net_mobility_total[0])+'   '+str(net_mobility_total[1])+'   '+str(net_mobility_total[2]) +'\n')

						msd_out.close()
						msd_el_out.close()
						msd_lo_out.close()
						if debug:
							print 'mobility_sum: ',mobility_sum
							print 'mobility_el: ',mobility_el
							print 'mobility_lo: ',mobility_lo
							print 'net_mobility_total:',net_mobility_total[:]
							print 'net_mobility_el:',net_mobility_el[:]
							print 'net_mobility_lo:',net_mobility_lo[:]

				elif (mobilitymode =='Einstein'):
					mob_old = mobility_sum
					mobility_sum=1.0E-16*MSD/(2*3*sim_time)*1.0/(k_B*T)*1.0/N_charges
					if( N_el != 0):   
						mobility_el=1.0E-16*MSD_el/(2*3*sim_time)*1.0/(k_B*T)*1.0/N_el 
					else:
						mobility_el=0.0
					if( N_lo != 0):
						mobility_lo=1.0E-16*MSD_lo/(2*3*sim_time)*1.0/(k_B*T)*1.0/N_lo
					else:
						mobility_lo=0.0

					if mob_old < mobility_sum*(1+mobility_conv_crit) and mob_old > mobility_sum*(1-mobility_conv_crit):
						print 'mobility converged after '+str(step_count)
						mobility_conv[3]=True
				### check_if_kmc_traj_filename_is_too_big in function ## check every 1.0E5 steps
				kmc_traj_filename, counter_kmc_traj_steps = check_if_kmc_traj_filename_is_too_big(kmc_traj_filename,max_kmc_traj_filesize,counter_kmc_traj_steps,xbox,ybox,zbox,frame_number,step_count)
				### check if external user requests a soft exit with an 'EXIT'-file
				check_soft_exit()
				
		#	if ((sim_time < t_kmc_max) and (kmc_run)):
		#		#kmc_out.write(str(len(occupied_list))+'\n')
		#		#kmc_out.write(str(step_count+2)+' frame '+ ' timestep '+str(sim_time)+'\n')
		#		kmc_traj_out_list.append(str(N_charges))
		#		kmc_traj_out_list.append(' '.join([str(step_count+2),'frame', 'timestep',str(sim_time)]))
	

	if (step_count%buffered_traj_out_steps==0 and step_count!=0):
		kmc_out=open(kmc_traj_filename,'a')
		kmc_out.write('\n'.join(kmc_traj_out_list))
		kmc_out.write('\n')
		kmc_traj_out_list = []
	#print occupied_list
	jumped=False
	
	if (step_count%buffered_mobility_out_steps==0 and step_count!=0):
		if (msd_output):
			if (mobilitymode == 'FEM'): # Fieldeffectmobility
						for i_charge in range_len_occ_list:
							velocity_charges[i_charge]= np.asarray(dr_travelled[i_charge][:])/float(sim_time)
							for i_coord in range(3):
								if (fieldfactors[i_coord] != 0 ):
									print 'charge:',i_charge,occupied_list[i_charge]
									print 'fieldfactors[i_coord]:',fieldfactors[:]
									print 'dr_travelled:',dr_travelled[i_charge][:]
									print 'velocity_charges[i_charge]',velocity_charges[i_charge]
									print 'scalar_product:',np.dot(velocity_charges[i_charge],fieldfactors[:])
									mobility_charges[i_charge][i_coord]=np.dot(velocity_charges[i_charge][i_coord],fieldfactors[i_coord])		#### modify!!! np arrays do not work like this!!!!!!
									print 'FEM mu:',mobility_charges[i_charge],' cm**2 / Vs '
 
						msd_out=open("msd.dat", 'a' )
						msd_el_out=open("msd_el.dat", 'a' )
						msd_lo_out=open("msd_lo.dat", 'a' )
						net_mobility_old=net_mobility_total
						mobility_sum=1.0E-16*MSD/(2*3*sim_time)*1.0/(k_B*T)   *1.0/N_charges
						if( N_el != 0): 
							mobility_el=1.0E-16*MSD_el/(2*3*sim_time)*1.0/(k_B*T) *1.0/N_el
						else:
							mobility_el=0.0

						if( N_lo != 0):
							mobility_lo=1.0E-16*MSD_lo/(2*3*sim_time)*1.0/(k_B*T)*1.0/N_lo
						else:
							mobility_lo=0.0

						if U[0] != 0:
							net_mobility_total[0]=1.0E-16*net_displacement_total[0] / (sim_time * U[0])
							net_mobility_el[0]=1.0E-16*net_displacement_el[0] / (sim_time * U[0]) 
							net_mobility_lo[0]=1.0E-16*net_displacement_lo[0] / (sim_time * U[0]) 
						if U[1] != 0:
							net_mobility_total[1]=1.0E-16*net_displacement_total[1] / (sim_time * U[1])
							net_mobility_el[1]=1.0E-16*net_displacement_el[1] / (sim_time * U[1]) 
							net_mobility_lo[1]=1.0E-16*net_displacement_lo[1] / (sim_time * U[1]) 
						if U[2] != 0:
							net_mobility_total[2]=1.0E-16*net_displacement_total[2] / (sim_time * U[2])
							print 'tmp net_mobility_el[:]',net_mobility_el[:],net_mobility_el[0],net_mobility_el[1],net_mobility_el[2]
							print 'net_mobility_el: ',net_mobility_el[:]
							print 'net_displacement_el: ',net_displacement_el[:] 
							print 'sim_time: ',sim_time
							print 'U:',U[:]
							net_mobility_el[2]=1.0E-16*net_displacement_el[2] / (sim_time * U[2]) 
							net_mobility_lo[2]=1.0E-16*net_displacement_lo[2] / (sim_time * U[2]) 

						net_mobility_total=net_mobility_total/N_charges
						if( N_el != 0): 
							net_mobility_el[:]=net_mobility_el[:]/N_el
						if( N_lo != 0): 
							net_mobility_lo[:]=net_mobility_lo[:]/N_lo

						msd_out.write(str(sim_time)+'	'+str(MSD)+ '   '+str(mobility_sum)+'   '+str(net_mobility_total[0])+'   '+str(net_mobility_total[1])+'   '+str(net_mobility_total[2]) +'\n')
						msd_el_out.write(str(sim_time)+'	'+str(MSD_el)+ '   '+str(mobility_el)+'   '+str(net_mobility_el[0])+'   '+str(net_mobility_el[1])+'   '+str(net_mobility_el[2]) +'\n')
						msd_lo_out.write(str(sim_time)+'	'+str(MSD_lo)+ '   '+str(mobility_lo)+'   '+str(net_mobility_lo[0])+'   '+str(net_mobility_lo[1])+'   '+str(net_mobility_lo[2]) +'\n')

						msd_out.close()
						msd_el_out.close()
						msd_lo_out.close()

			elif (mobilitymode =='Einstein'):
				msd_out=open("msd.dat", 'a' )
				msd_el_out=open("msd_el.dat", 'a' )
				msd_lo_out=open("msd_lo.dat", 'a' )
				mobility_sum=1.0E-16*MSD/(2*3*sim_time)*1.0/(k_B*T)   *1.0/N_charges
				if( N_el != 0):
					mobility_el=1.0E-16*MSD_el/(2*3*sim_time)*1.0/(k_B*T) *1.0/N_el
				else:
					mobility_el=0.0
				if( N_lo != 0):
					mobility_lo=1.0E-16*MSD_lo/(2*3*sim_time)*1.0/(k_B*T)*1.0/N_lo
				else:
					mobility_lo=0.0
				msd_out.write(str(sim_time)+'	'+str(MSD)+ '   '+str(mobility_sum) +'\n')
				msd_el_out.write(str(sim_time)+'	'+str(MSD_el)+ '   '+str(mobility_el) +'\n')
				msd_lo_out.write(str(sim_time)+'	'+str(MSD_lo)+ '   '+str(mobility_lo) +'\n')
			

	## count the steps and print probs every 10%
	step_count = step_count+1
	#if step_count%(number_of_steps/10)==0:
	if step_count%(kmc_print_intervall)==0 or (not kmc_run):
		print(str((1+percent)*10)+'% done')
		######## info output
		info_out=open(info_out_filename,'a')
		info_out.write(str((1+percent)*10)+'% done'+ '\n')
		info_out.close()
		######## info output
		percent=percent+1

	#if the calculation takes longer than 60 secs for 1 step or ~10% of the calc are done write out the data
	#if (float(time.strftime('%s'))-runtime_start) > 60 or step_count%(number_of_steps/10)==0:
	#if (float(time.strftime('%s'))-runtime_start) > 60 or step_count%(kmc_print_intervall)==0 or (not kmc_run):
	if step_count%(kmc_print_intervall)==0 or (not kmc_run):
		########
		#write the probList to a file for later checkup
	
		elec_probList_out=open(elec_prob_out_filename,'w')
		elec_matrixElementList_out = open(elec_matrix_out_filename,'w')
		hole_probList_out=open(hole_prob_out_filename,'w')
		hole_matrixElementList_out = open(hole_matrix_out_filename,'w')
		elec_lambda_in_out = open(elec_lambda_in_out_filename,'w')
		hole_lambda_in_out = open(hole_lambda_in_out_filename,'w')
		elec_dE_in_out = open(elec_dE_in_out_filename,'w')
		hole_dE_in_out = open(hole_dE_in_out_filename,'w')
		elec_dE_out_out = open(elec_dE_out_out_filename,'w')
		hole_dE_out_out = open(hole_dE_out_out_filename,'w')
		elec_lambda_out_out = open(elec_lambda_out_out_filename,'w')
		hole_lambda_out_out = open(hole_lambda_out_out_filename,'w')
		
	
		for item in elec_probList:
			elec_probList_out.write(str('	'.join(map(str, item)))+'\n')
		for item in elec_matrixElementList:
			elec_matrixElementList_out.write(str('	'.join(map(str, item)))+'\n')
		for item in hole_probList:
			hole_probList_out.write(str('	'.join(map(str, item)))+'\n')
		for item in hole_matrixElementList:
			hole_matrixElementList_out.write(str('	'.join(map(str, item)))+'\n')
		for item in elec_lambdaList:
			elec_lambda_in_out.write(str('	'.join(map(str, item)))+'\n')
		for item in hole_lambdaList:
			hole_lambda_in_out.write(str('	'.join(map(str, item)))+'\n')
		for item in elec_dE_inList:
			elec_dE_in_out.write(str('	'.join(map(str, item)))+'\n')
		for item in hole_dE_inList:
			hole_dE_in_out.write(str('	'.join(map(str, item)))+'\n')
		for item in elec_dE_out_List:
			elec_dE_out_out.write(str('	'.join(map(str, item)))+'\n')
		for item in hole_dE_out_List:
			hole_dE_out_out.write(str('	'.join(map(str, item)))+'\n')
		for item in elec_lambda_out_List:
			elec_lambda_out_out.write(str('	'.join(map(str, item)))+'\n')
		for item in hole_lambda_out_List:
			hole_lambda_out_out.write(str('	'.join(map(str, item)))+'\n')

		######## copy the data evaluation file for later checkup
		test1 =	subprocess.Popen(shlex.split('cp ./subroutines/lambda_in/results_lambda_in_G'+ str(frame_number) +'.dat '+str(NGeo_path)+'results_lambda_in_G'+ str(frame_number) +'_'+ str(starting_time[4:19].replace(" ","_")) +'.dat'))
		test1 =	subprocess.Popen(shlex.split('cp ' + str(DIPRO_J_AB_datafile) +' '+str(NGeo_path)+ str(DIPRO_J_AB_datafile[:-4])+'_'+ str(starting_time[4:19].replace(" ","_").replace(":","-")) +'.dat'))
		########

		elec_probList_out.close()
		hole_probList_out.close()
		elec_matrixElementList_out.close()
		hole_matrixElementList_out.close()
		elec_lambda_in_out.close()
		hole_lambda_in_out.close()
		elec_dE_in_out.close()
		hole_dE_in_out.close()
		#  probList_out.write("%s\n" % item)
		########

######################################### end of kmc algorithm #############################################
############################################################################################################

if ( not calc_complete_list ):
	######## copy the data evaluation file for later checkup
	test1 =	subprocess.Popen(shlex.split('cp ./subroutines/lambda_in/results_lambda_in_G'+ str(frame_number) +'.dat '+str(NGeo_path)+'results_lambda_in_G'+ str(frame_number) +'_' + str(starting_time[4:19].replace(" ","_").replace(":","-")) +'.dat'))
	test1 =	subprocess.Popen(shlex.split('cp ' + str(DIPRO_J_AB_datafile) +' '+str(NGeo_path)+ str(DIPRO_J_AB_datafile[:-4])+'_' + str(starting_time[4:19].replace(" ","_").replace(":","-")) +'.dat'))
	########


	######## info output
	info_out=open(info_out_filename,'a')
	info_out.write( '\n' + 'Simulation finished. ' +str(step_count-1)+' steps simulated '+'\n')
	info_out.write( 'number_charges: '+ str( len(occupied_list) ) + '\n')
	info_out.write( 'last_occupied_list: '+ str(' '.join(map( str, occupied_list))) + '\n')
	info_out.write( 'charge_type_list: '+ str(' '.join(map( str, charge_type_list))) + '\n')
	info_out.write( 'last_tau_i: '+ str(' '.join(map( str, tau_i))) + '\n')
	info_out.write( 'step_count: '+str(step_count) + '\n')
	info_out.write( 'MSD_all: '+str(MSD) + '\n')
	info_out.write( 'MSD_el: '+str(MSD_el) + '\n')
	info_out.write( 'MSD_lo: '+str(MSD_lo) + '\n')
	info_out.write( 'simulated_time_s: '+str(sim_time)+ ' s \n')
	form_sim_time='%.0e' % (sim_time)
	info_out.write( 'formated_simulated_time_s: '+str(form_sim_time)+ ' s \n')
	info_out.write( 'geo_step: '+str(frame_number)+ ' \n')

	k=0 
	for k in range(len(occupied_list)):
			info_out.write(str(charge_type_list[k])+'	'+str('	'.join(map(str, COM_list[occupied_list[k]])))+' #Resid: ' + str(occupied_list[k]) + '\n')
	info_out.write('finishing_time: '+time.strftime('%c')+ '\n')
	info_out.write('Normal termination of kMC calculation ' + '\n')
	info_out.close()
	######## info output

########

	###write the probList to a file for later checkup
	
	elec_probList_out=open(elec_prob_out_filename,'w')
	#elec_matrixElementList_out = open(matrix_out_filename,'w')
	hole_probList_out=open(hole_prob_out_filename,'w')
	#hole_matrixElementList_out = open(hole_matrix_out_filename,'w')
	#elec_lambda_in_out = open(lambda_in_out_filename,'w')
	#hole_lambda_in_out = open(hole_lambda_in_out_filename,'w')
	#elec_dE_in_out = open(dE_in_out_filename,'w')
	#hole_dE_in_out = open(hole_dE_in_out_filename,'w')
	#elec_dE_out_out = open(dE_out_out_filename,'w')
	#hole_dE_out_out = open(hole_dE_out_out_filename,'w')
	#elec_lambda_out_out = open(lambda_out_out_filename,'w')
	#hole_lambda_out_out = open(hole_lambda_out_out_filename,'w')

	for item in elec_probList:
		elec_probList_out.write(str('	'.join(map(str, item)))+'\n')
	#for item in elec_matrixElementList:
	#	elec_matrixElementList_out.write(str('	'.join(map(str, item)))+'\n')
	for item in hole_probList:
		hole_probList_out.write(str('	'.join(map(str, item)))+'\n')
	#for item in hole_matrixElementList:
	#	hole_matrixElementList_out.write(str('	'.join(map(str, item)))+'\n')
	#for item in elec_lambdaList:
	#	elec_lambda_in_out.write(str('	'.join(map(str, item)))+'\n')
	#for item in hole_lambdaList:
	#	hole_lambda_in_out.write(str('	'.join(map(str, item)))+'\n')
	#for item in elec_dE_inList:
	#	elec_dE_in_out.write(str('	'.join(map(str, item)))+'\n')
	#for item in hole_dE_inList:
	#	hole_dE_in_out.write(str('	'.join(map(str, item)))+'\n')
	#for item in elec_dE_out_List:
	#	elec_dE_out_out.write(str('	'.join(map(str, item)))+'\n')
	#for item in hole_dE_out_List:
	#	hole_dE_out_out.write(str('	'.join(map(str, item)))+'\n')
	#for item in elec_lambda_out_List:
	#	elec_lambda_out_out.write(str('	'.join(map(str, item)))+'\n')
	#for item in hole_lambda_out_List:
	#	hole_lambda_out_out.write(str('	'.join(map(str, item)))+'\n')
	#
	#
	elec_probList_out.close()
	#elec_matrixElementList_out.close()
	hole_probList_out.close()
	#hole_matrixElementList_out.close()
	#elec_lambda_in_out.close()
	#hole_lambda_in_out.close()
	#elec_dE_in_out.close()
	#hole_dE_in_out.close()
	#elec_dE_out_out.close()
	#hole_dE_out_out.close()
	#elec_lambda_out_out.close()
	#hole_lambda_out_out.close()
	
	#elec_probList_out.write("%s\n" % item)
	########

	#print elec_probList
	#print('done')
	#kmc_out.close()
	########



