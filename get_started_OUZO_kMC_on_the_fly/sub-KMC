#!/bin/bash

 if [ $# -eq 0 ]; then
    echo "Usage: $0 <Basisordner> \" ./kmc_multigeo_V1 kMC_startline \"  [delete_dibug_data=True/False] [Auswertung_kMC_ok=True/False]  [Pfad_jim_skripts] \"[waitfor_jobid]"
    echo " "
    echo "Bsp: $0 <Basisordner>  \" ./kmc_multigeo_V1 sim_data_12N/sorted_neighbours_23_06.ngh sim_data_12N/no_box_02_08.xyz sim_data_12N/indexed_23_06.gro False sim_data_12N/sorted_lambda_neighbours_23_06.ngh \"  True True \"~/transfer/kMC_Rechnungen/multi_geo/skripte/\" "  
    exit 1
 fi

 if [ ! -d "$1" ]; then
    echo "directory $1 doesn't exist!"
    exit 1
 fi

# if [ ! -d "./lambda_out/" ]; then
#    echo "directory ./lambda_out/ doesn't exist!"
#    exit 1
# fi

 JOB=${1%/}
 NAM=${1%/}
# LAMBDA_OUT_EL=${2}
# LAMBDA_OUT_LO=${3}
 KEY=" "   ##".ssh/stahs" ## old keys
 delete_dibug_data='True' ## Delete Debug-data like DIPRO, lambda_in_log, xyz_q files
 Auswertung_kMC_ok='False'
 Pfad_jim_skripts='/home/t/t_koch08/transfer/kMC_Rechnungen/multi_geo/skripte'
 DEPEND="#" 


  if [ $# -ge 2 ]; then   ## Einlesen des Starts des KMC-Programmes mit einer Rechnung oder standard
	kMC_startline=${2}
  else 
  	kMC_startline="./kmc_multigeo_V1 sim_data_12N/sorted_neighbours_23_06.ngh sim_data_12N/no_box_02_08.xyz sim_data_12N/indexed_23_06.gro False sim_data_12N/sorted_lambda_neighbours_23_06.ngh"  
  fi


 if [ $# -ge 3 ]; then
    	delete_dibug_data=${3}
 else
        delete_dibug_data='True'
 fi

 if [ $# -ge 4 ]; then ## Nutze Skripte zur KMC auswertung wenn Auswertung_kMC_ok=True
    	Auswertung_kMC_ok=${4}
 else
        Auswertung_kMC_ok='False'
 fi

 if [ $# -ge 5 ]; then
    	 Pfad_jim_skripts=${5}
 else
	 Pfad_jim_skripts='/home/t/t_koch08/transfer/kMC_Rechnungen/multi_geo/skripte'
 fi

 if [ $# -ge 6 ]; then
      DEPEND="#PBS -W depend=afterany:$6 "
 fi
 

 CURDIR=`pwd`
 

if [ "${Auswertung_kMC_ok}" == "True" ] ; then ## Kopiere Auswertungsskripte in den Job-Ordner
	for datei in boxsize current_calculation_hole_el MSD_hole_el_Einstein  traj_timestep Nachbereitung_kmc.sh ; do
        if [ -e "${JOB}/${datei}" ] ; then ## Existiert Datei im JOB-Ordner?
                echo "Skript in ${JOB} vorhanden: $datei"
        else
                if [ -e "${Pfad_jim_skripts}/${datei}" ] ; then
                    echo "Skript in ${Pfad_jim_skripts} vorhanden: $datei"
                    cp ${Pfad_jim_skripts}/${datei}  ${CURDIR}/${JOB}/ 
                else
                    echo "Fehler: Die Datei ${datei} exitiert nicht im Pfad ${Pfad_jim_skripts}, keine Auswertung im Anschluss an kMC Rechnng moeglich"
                    Auswertung_kMC_ok='False'
                fi # Existiert Datei in Pfad
        fi # Existiert Datei in Ordner
	done 
fi # Auswertung = True


 
 #MEM=`cat $1 | grep -i %mem | cut -f2 -d"="`
 #[ -e "$MEM" ] && MEM=1GB
 #echo MEM = $MEM

 #PPN=`cat $1 | grep -i %nproc | cut -f2 -d"="`
 #[ -e "$PPN" ] && PPN=1
 PPN=8
 echo PPN = $PPN

#PRE=$(pwd | sed s/${USER}/,/ | cut -d',' -f1,1)

#echo $PRE

echo " Starte kMC mit:  ${kMC_startline} "


 qsub -V << EOF
#!/bin/bash
#PBS -l nodes=1:ppn=${PPN}
#PBS -l walltime=180:00:00:00
##PBS -l mem=${MEM}
#PBS -q moria
#PBS -N ${NAM}
#PBS -e ${HOME}/QSUBIO
#PBS -o ${HOME}/QSUBIO
##PBS -m e
${DEPEND}
#

#shorten host name
S_HOST=\${PBS_O_HOST%.uni-muenster.de}

# activate verbose shell
 set -vx

# ! need to use scp/ssh via gondor !
# create temporary input/output directory
 TMPINOUT="queue_inout/KMC.\${PBS_JOBID}"
 ssh gondor mkdir -p \${TMPINOUT}

# create SCRATCH directory
 SCRATCH="/scratch/KMC.\${PBS_JOBID}"
 mkdir -p \${SCRATCH}


 echo "Starting ${JOB} from ${CURDIR} on \${PARENT}"




# run JOB in SCRATCH directory on PARENT
 cd \${SCRATCH}
 #touch _START_


# fetch input data 
#cp -p ${CURDIR}/${JOB}/ .

 ssh gondor " scp -pr \${S_HOST}:${CURDIR}/${JOB}/ \${TMPINOUT}"
# ssh gondor " scp -pr \${S_HOST}:${CURDIR}/partial_charges \${TMPINOUT}"
# ssh gondor " scp -pr \${S_HOST}:${CURDIR}/lambda_out_und_dE_out_aus_xyz_q_file \${TMPINOUT}"
# ssh gondor " scp -pr \${S_HOST}:${CURDIR}/aufruf.out \${TMPINOUT}"

 scp -pr gondor:\${TMPINOUT}/* .
if [[ "${HOSTNAME}" == *"balrog"* ]] || [[ "${HOSTNAME}" == *"kankra"* ]]  ; then
	# set GAUSSIAN environment
	#  rev. D01 @gondor
   		export g09root=/opt/intel
   		export GAUSS_EXEDIR=/opt/intel/g09   
   		export PATH=/opt/intel/g09:$PATH

		# set INTEL environment
		#currently @gondor
   		export LD_LIBRARY_PATH=/opt/intel/lib/intel64:/opt/intel/mkl/lib/intel64
 		## python path fuer balrog/kankra
		export PYTHONPATH='/opt/vmd-1.9.3-python_framework/vmd-1.9.3/python':/opt/files/dftb+/dftbplus-17.1.x86_64-linux/lib/python2.7/site-packages
fi 
############ now on moria
# run the kmc algorithm
cd ${JOB}
${kMC_startline}


### Nachbereitung kMC
if [ "${Auswertung_kMC_ok}" == "True" ]; then
	./Nachbereitung_kmc.sh ${JOB} 1.0E-12 \$( ls kmc_info* | tail -1 ) "."   " \$( ./boxsize | head -1 ) "
else # Nachbereitung kMC
	echo "Keine Nachbereitung der kMC Rechnung mit Analyseprogrammen." 
fi # Nachbereitung kMC 

#### Ende Nachbereitung kMC Daten mit Analyseprogrammen

if [ "${delete_dibug_data}" == 'True' ]; then
	rm -r subroutines/DIPRO/Dim_*N*
	rm -r subroutines/xyz_q_Dateien/xyz_q*N*
	rm -r subroutines/xyz_q_Dateien/lambda_out_xyz_q_pairs/All_xyz_q*.xyz
	rm -r subroutines/xyz_q_Dateien/lambda_out_xyz_q_pairs/xyz_q*.xyz
	rm -r subroutines/lambda_out_logs/lambda_out*.log
fi

############
 #wechsle in Basisordner
 #cd ${JOB}/
# mkdir xyz_q_Dateien
# mkdir xyz_q_Dateien/lambda_out_xyz_q_pairs
# cp ./${JOB}/input_file_lambda_out .
# chmod 755 input_file_lambda_out
# ./input_file_lambda_out
# touch ${LAMBDA_OUT_LO}
# touch ${LAMBDA_OUT_EL}
# lines_file_1=\$( wc -l ${LAMBDA_OUT_LO} ); lines_file_1=\${lines_file_1% *}
# lines_file_2=\$( wc -l ${LAMBDA_OUT_EL} ); lines_file_2=\${lines_file_2% *}
# lines_input_file=\$( wc -l input_file_lambda_out ); lines_input_file=\${lines_input_file% *}

 # waiting for the processes startet by the "lines_input_file" to finish
 # while [ \$(( \${lines_file_1} + \${lines_file_2} )) -lt \${lines_input_file} ]
 # do
 #     sleep 3
 #     lines_file_1=\$( wc -l ${LAMBDA_OUT_LO} ); lines_file_1=\${lines_file_1% *}
 #     lines_file_2=\$( wc -l ${LAMBDA_OUT_EL} ); lines_file_2=\${lines_file_2% *}
 # done 

#file_EL=\$( cat ${LAMBDA_OUT_EL} )
#file_LO=\$( cat ${LAMBDA_OUT_LO} )
 
# put output data & clean up
 scp -pr \${SCRATCH}/* gondor:\${TMPINOUT}
 ssh gondor " scp -pr \${TMPINOUT}/* \${S_HOST}:${CURDIR}/"
# ssh gondor " scp -pr \${TMPINOUT}/${LAMBDA_OUT_EL} \${S_HOST}:${CURDIR}/lambda_out/${JOB}/"
# ssh gondor " scp -pr \${TMPINOUT}/${LAMBDA_OUT_LO} \${S_HOST}:${CURDIR}/lambda_out/${JOB}/"
# ssh gondor " ssh  \${S_HOST} \"cat ${CURDIR}/lambda_out/${JOB}/${LAMBDA_OUT_EL} >> ${CURDIR}/${LAMBDA_OUT_EL} \" "
# ssh gondor " ssh  \${S_HOST} \"cat ${CURDIR}/lambda_out/${JOB}/${LAMBDA_OUT_LO} >> ${CURDIR}/${LAMBDA_OUT_LO} \" "

if [ "${delete_dibug_data}" == 'True' ]; then
    rm -r   \${SCRATCH}/*
    rmdir \${SCRATCH}
fi


# retrieve PBS output
 scp -p /var/spool/torque/spool/\${PBS_JOBID}.OU gondor:\${TMPINOUT}
 scp -p /var/spool/torque/spool/\${PBS_JOBID}.ER gondor:\${TMPINOUT}

 ssh  gondor " scp  \${TMPINOUT}/\${PBS_JOBID}.OU \${S_HOST}:${CURDIR}/${JOB}/ "
 ssh  gondor " scp  \${TMPINOUT}/\${PBS_JOBID}.ER \${S_HOST}:${CURDIR}/${JOB}/ "

 ssh gondor " rm -r \${TMPINOUT}/* "
 ssh gondor " rmdir \${TMPINOUT} "


EOF
